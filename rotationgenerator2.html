<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RotationOps</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><circle cx='32' cy='32' r='30' fill='%230f172a'/><path d='M20 14 A20 20 0 0 1 50 26' fill='none' stroke='%231f6feb' stroke-width='5' stroke-linecap='round'/><polygon points='50,20 56,28 46,28' fill='%231f6feb'/><path d='M44 50 A20 20 0 0 1 14 38' fill='none' stroke='%2322c55e' stroke-width='5' stroke-linecap='round'/><polygon points='14,44 8,36 18,36' fill='%2322c55e'/></svg>" />
<style>
  :root {
    --bg:#0b0f16; --panel:#111826; --panel2:#0f1622; --line:#2a3446; --text:#e6edf7;
    --muted:#a8b3c7; --btn:#1f6feb; --btn2:#233047; --danger:#d94848;
    --chip:#1a2436;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: radial-gradient(1200px 800px at 30% 10%, #172234 0%, var(--bg) 55%);
    color:var(--text);
  }
  .wrap{max-width:1500px; margin:10px auto; padding:0 10px;}
  h1{margin:0; font-size:26px; letter-spacing:.2px; font-weight:800;}
  .topbar{display:flex; gap:8px; align-items:center; padding:8px 10px; border:1px solid var(--line);
    background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    border-radius:8px;
  }
  select, input[type="text"], input[type="date"]{
    background:var(--panel2); border:1px solid var(--line); color:var(--text);
    border-radius:8px; padding:8px 10px; outline:none; min-width: 120px; font-size:13px;
  }
  label{color:var(--muted); font-size:12px; margin-right:6px}
  .btn{background:var(--btn); color:white; border:none; padding:8px 12px; border-radius:8px;
    cursor:pointer; font-weight:700; font-size:13px; box-shadow: 0 6px 18px rgba(31,111,235,.22);
  }
  .btn.secondary{background:var(--btn2); box-shadow:none; border:1px solid var(--line);}
  .btn.danger{background:transparent; color:#ffb4b4; border:1px solid rgba(217,72,72,.6);}
  .btn:active{transform:translateY(1px)}

  .btn-copy-block:hover{background:rgba(255,255,255,.06); border-color:rgba(255,255,255,.18);}
  .btn-copy-block:active{transform:translateY(1px);}

  .layout{display:flex; flex-direction:column; gap:8px; margin-top:8px}
  .subgrid{display:grid; grid-template-columns: 1fr 1fr; gap:8px}
  @media (max-width: 980px){
    .subgrid{grid-template-columns: 1fr}
  }
  .card{background:rgba(255,255,255,.03); border:1px solid var(--line); border-radius:8px; padding:8px;}
  .card h2{margin:0 0 8px; font-size:14px; color:var(--muted); font-weight:700; letter-spacing:.25px}
  .small{font-size:11px; color:var(--muted);}

  .vac-form{display:grid; grid-template-columns: 1fr; gap:8px}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .row .grow{flex:1}
  .list{margin-top:8px; border-top:1px solid var(--line); padding-top:8px; max-height:180px; overflow:auto}
  .pill{display:flex; justify-content:space-between; align-items:center; gap:8px;
    padding:6px 8px; border:1px solid var(--line); border-radius:8px; background:var(--chip);
    margin-bottom:6px; font-size:12px;
  }
  .pill .meta{color:var(--muted); font-size:11px}
  .pill button{background:transparent; border:1px solid var(--line); color:var(--text); border-radius:6px; padding:4px 7px; cursor:pointer; font-size:11px;}

  .tabs{display:flex; gap:6px; border-bottom:1px solid var(--line); padding-bottom:8px; margin-bottom:8px}
  .tab{padding:7px 10px; border:1px solid var(--line); border-radius:8px; cursor:pointer; background:var(--panel2); color:var(--muted); font-weight:650; font-size:12px;}
  .tab.active{background:rgba(31,111,235,.18); color:var(--text); border-color: rgba(31,111,235,.5);}

  table{width:auto; border-collapse:collapse; overflow:hidden;}
  th, td{padding:3px 4px; border:1px solid var(--line); text-align:center; font-size:11px}
  th{background:rgba(255,255,255,.04); color:var(--muted); font-weight:800}

  /* Day/night shift divider — 5th child = first night column (CHANNEL + 3 day blocks + 1) */
  #dayTableWrap td:nth-child(5),
  #dayTableWrap th:nth-child(5){border-left:4px solid rgba(255,255,255,.4);}
  body.light #dayTableWrap td:nth-child(5),
  body.light #dayTableWrap th:nth-child(5){border-left:4px solid rgba(0,0,0,.3);}

  .assign-cell{border-radius:8px; padding:6px 10px; display:inline-block; min-width:110px; font-size:11px; font-weight:700; border:1px solid rgba(255,255,255,.14); text-align:center; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  .assign-cell.violation{outline:2px solid #f59e0b; outline-offset:1px; box-shadow: 0 0 6px rgba(245,158,11,.5);}
  .needed-badge{background:#dc2626!important; border:2px solid #fca5a5!important; color:#fff!important; font-weight:900!important; font-size:12px!important; letter-spacing:1px; animation:needPulse 1.2s ease-in-out infinite; text-shadow:0 1px 4px rgba(0,0,0,.5);}
  @keyframes needPulse{0%,100%{box-shadow:0 0 4px rgba(220,38,38,.4);} 50%{box-shadow:0 0 14px rgba(220,38,38,.8), 0 0 24px rgba(220,38,38,.3);}}
  @keyframes tipSlideUp{from{opacity:0; transform:translateX(-50%) translateY(20px);} to{opacity:1; transform:translateX(-50%) translateY(0);}}
  .clickable-assign{cursor:pointer; transition: transform 0.1s, box-shadow 0.1s;}
  .clickable-assign:hover{transform:scale(1.03); box-shadow: 0 2px 6px rgba(0,0,0,0.3);}
  .clickable-needed{cursor:pointer; transition: transform 0.1s, box-shadow 0.1s;}
  .clickable-needed:hover{transform:scale(1.05); box-shadow: 0 2px 8px rgba(220,38,38,0.4);}
  .clickable-absent{cursor:pointer; transition: transform 0.1s, box-shadow 0.1s;}
  .clickable-absent:hover{transform:scale(1.05); box-shadow: 0 2px 8px rgba(248,113,113,0.4);}

  .actions{display:flex; gap:8px; margin-top:10px; flex-wrap:wrap}

  .two-col{display:grid; grid-template-columns: 1fr; gap:12px;}
  .stats{display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-top:12px}
  .stats .card{padding:12px}

  .toast{position:fixed; left:18px; right:18px; bottom:18px; background:#101826; border:1px solid rgba(255,255,255,.15);
    border-radius:14px; padding:12px 14px; display:none; max-width:1220px; margin:0 auto; color:#ffd6d6;}
  .toast code{color:#ffe2a8}

  .week-grid{display:grid; grid-template-columns: 110px repeat(7, 1fr); gap:6px; align-items:stretch;}
  .week-head{font-size:12px; color:var(--muted); padding:6px 8px;}
  .week-channel{font-weight:800; color:var(--muted); padding:8px;}
  .wkcell{border:1px solid var(--line); border-radius:10px; padding:8px; background:rgba(255,255,255,.02);}
  .dots{display:flex; gap:6px; flex-wrap:wrap}
  .dot{width:10px; height:10px; border-radius:999px; border:1px solid rgba(255,255,255,.2);}
  .badge{display:inline-block; padding:2px 7px; border-radius:999px; border:1px solid rgba(217,72,72,.55); color:#ffb4b4; font-size:11px; margin-left:8px;}

  .month-grid{display:grid; grid-template-columns: repeat(7, 1fr); gap:8px;}
  .mcell{border:1px solid var(--line); border-radius:12px; background:rgba(255,255,255,.02); padding:8px; min-height:86px; cursor:pointer;}
  .mdate{display:flex; justify-content:space-between; align-items:center; color:var(--muted); font-size:12px; margin-bottom:6px}
  .mblocks{display:flex; flex-wrap:wrap; gap:6px}
  .mblock{font-size:10px; padding:3px 6px; border-radius:999px; border:1px solid rgba(255,255,255,.15); color:var(--muted);}
  .mblock.bad{border-color: rgba(217,72,72,.65); color:#ffb4b4;}

  .ctlist{display:flex; flex-direction:column; gap:4px; align-items:center;}
  .ctitem{padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:rgba(220,220,230,.15); color:rgba(255,255,255,.7); font-size:11px; font-weight:700; line-height:1.2; min-width:110px; text-align:center; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  .ctitem.repeat{border-color: rgba(217,72,72,.9); box-shadow: 0 0 0 2px rgba(217,72,72,.45), 0 10px 26px rgba(217,72,72,.18);}

  /* Sync pill styles */
  .sync-pill{display:inline-flex; align-items:center; gap:5px; padding:4px 10px; border-radius:999px; font-size:11px; font-weight:600; border:1px solid var(--line); background:var(--chip); margin-left:auto;}
  .sync-pill.synced{border-color:rgba(52,211,153,.40); background:rgba(52,211,153,.10); color:#d7ffe9;}
  .sync-pill.error{border-color:rgba(251,113,133,.45); background:rgba(251,113,133,.10); color:#ffd5dd;}
  .sync-pill.syncing{border-color:rgba(74,163,255,.45); background:rgba(74,163,255,.10); color:#a5d4ff; animation:syncPulse 1s ease-in-out infinite;}
  @keyframes syncPulse{0%,100%{opacity:1}50%{opacity:.5}}

  /* Theme toggle */
  #btnDayPrev:hover, #btnDayNext:hover{background:rgba(255,255,255,.08); border-color:var(--text);}
  #btnDayPrev:active, #btnDayNext:active{transform:translateY(1px);}
  body.light #btnDayPrev:hover, body.light #btnDayNext:hover{background:rgba(0,0,0,.06);}
  .theme-toggle{background:transparent; border:1px solid var(--line); border-radius:8px; padding:6px 10px; cursor:pointer; color:var(--muted); font-size:12px; display:flex; align-items:center; gap:5px;}
  .theme-toggle:hover{background:rgba(255,255,255,.05); color:var(--text);}
  body.light{--bg:#f5f7fa; --panel:#ffffff; --panel2:#f0f2f5; --line:#d1d5db; --text:#1f2937; --muted:#6b7280; --chip:#e5e7eb;}
  body.light .wrap{background:transparent;}
  body.light{background:linear-gradient(180deg, #e8ecf3 0%, #f5f7fa 100%);}
  body.light .card{background:rgba(0,0,0,.02); border-color:var(--line);}
  body.light .topbar{background:linear-gradient(180deg, rgba(0,0,0,.02), rgba(0,0,0,.01));}
  body.light select, body.light input[type="text"], body.light input[type="date"]{background:#fff; border-color:var(--line); color:var(--text);}
  body.light .tab{background:#fff; color:var(--muted);}
  body.light .tab.active{background:rgba(31,111,235,.12); color:#1f6feb;}
  body.light th{background:rgba(0,0,0,.04);}
  body.light .assign-cell{border-color:rgba(0,0,0,.12);}
  body.light .pill{background:#fff; border-color:var(--line);}
  body.light .toast{background:#fff; border-color:var(--line); color:#b91c1c;}
  body.light .how-it-works-box{background:rgba(0,0,0,.04)!important; border-color:rgba(0,0,0,.12)!important; color:#374151!important;}
  body.light .stat-card{background:rgba(0,0,0,.03); border-color:rgba(0,0,0,.08);}
  body.light .stats-panel{background:rgba(0,0,0,.02);}
  body.light .sticky-col{background:rgba(255,255,255,.98)!important;}
  /* Light mode: darken all text for visibility */
  body.light .assign-cell{color:#1f2937!important;}
  body.light .ctitem{background:rgba(180,180,190,.2)!important; color:#374151!important; border-color:rgba(0,0,0,.12)!important;}
  body.light .ctitem.repeat{border-color:rgba(217,72,72,.9)!important;}
  body.light .cellbtn.ct, body.light .assign-cell.ct{background:rgba(180,180,190,.2)!important; color:#374151!important; border-color:rgba(0,0,0,.12)!important;}
  body.light td b{color:#1f2937;}
  body.light .needed-badge{color:#fff!important;}
  /* Stats panel */
  .stats-panel{display:grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap:8px; padding:10px; background:rgba(255,255,255,.02); border:1px solid var(--line); border-radius:8px; margin-top:8px;}
  .stat-card{text-align:center; padding:10px; background:rgba(255,255,255,.03); border-radius:6px; border:1px solid rgba(255,255,255,.08);}
  .stat-value{font-size:24px; font-weight:800; color:#4aa3ff;}
  .stat-label{font-size:10px; color:var(--muted); text-transform:uppercase; margin-top:4px;}
  .stat-card.good .stat-value{color:#22c55e;}
  .stat-card.warn .stat-value{color:#f59e0b;}
  .stat-card.bad .stat-value{color:#ef4444;}

  /* Employee management modal */
  .modal-overlay{position:fixed; inset:0; background:rgba(0,0,0,.7); display:none; align-items:center; justify-content:center; z-index:1000;}
  .modal-overlay.show{display:flex;}
  .modal-content{background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:20px; max-width:600px; width:90%; max-height:80vh; overflow:auto;}
  .modal-header{display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;}
  .modal-header h3{margin:0; font-size:16px;}
  .modal-close{background:transparent; border:none; color:var(--muted); font-size:20px; cursor:pointer; padding:5px;}
  .emp-list{max-height:300px; overflow:auto; border:1px solid var(--line); border-radius:8px;}
  .emp-row{display:flex; justify-content:space-between; align-items:center; padding:8px 12px; border-bottom:1px solid var(--line); font-size:12px;}
  .emp-row:last-child{border-bottom:none;}
  .emp-row:hover{background:rgba(255,255,255,.03);}
  .emp-row .emp-info{display:flex; gap:12px; align-items:center;}
  .emp-row .emp-name{font-weight:700; min-width:100px;}
  .emp-row .emp-pos{color:var(--muted); font-size:11px;}
  .emp-row .emp-days{color:var(--muted); font-size:10px;}
  .emp-add-form{display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:15px; padding-top:15px; border-top:1px solid var(--line);}
  .emp-add-form input, .emp-add-form select{padding:8px; font-size:12px;}

  /* Swap history */
  .history-list{max-height:200px; overflow:auto; font-size:11px;}
  .history-item{padding:6px 8px; border-bottom:1px solid var(--line); display:flex; gap:8px; align-items:center;}
  .history-item:last-child{border-bottom:none;}
  .history-time{color:var(--muted); font-size:10px; min-width:70px;}
  .history-action{flex:1;}

  /* Mobile styles */
  @media (max-width: 768px) {
    .wrap{padding:0 5px;}
    h1{font-size:18px !important;}
    .topbar{flex-wrap:wrap; padding:6px;}
    .topbar .row{flex:1; min-width:100px;}
    .tabs{flex-wrap:wrap;}
    .tab{padding:5px 8px; font-size:11px;}
    .sync-pill{font-size:10px; padding:3px 8px;}
    .theme-toggle{padding:4px 8px; font-size:11px;}
    .assign-cell{min-width:80px; padding:4px 6px; font-size:10px;}
    .stats-panel{grid-template-columns: repeat(2, 1fr);}
    .stat-value{font-size:18px;}
    .modal-content{padding:15px; max-width:95%;}
    table{font-size:10px;}
    th, td{padding:2px 3px;}
    .btn{padding:6px 10px; font-size:12px;}
    .header-controls{flex-wrap:wrap; gap:6px !important;}
  }
  @media (max-width: 480px) {
    .topbar{flex-direction:column; align-items:stretch;}
    .topbar .row{width:100%;}
    .stats-panel{grid-template-columns: 1fr 1fr;}
    .assign-cell{min-width:60px; font-size:9px;}
    .emp-add-form{grid-template-columns: 1fr;}
  }
  .matrix-wrap{max-height:520px; overflow:auto; border-radius:12px;}
  .matrix-wrap table{min-width:980px;}
  .sticky-head thead th{position:sticky; top:0; z-index:2;}
  .sticky-col{position:sticky; left:0; z-index:3; background:rgba(15,22,34,.98);}

  .wknames{margin-top:8px; display:grid; gap:4px; font-size:11px; line-height:1.15}
  .wkline{display:flex; justify-content:space-between; gap:8px; white-space:nowrap; overflow:hidden}
  .wkline .lbl{color:var(--muted); flex:0 0 auto}
  .wkline .nm{color:var(--text); flex:1 1 auto; overflow:hidden; text-overflow:ellipsis}


  .scroll-x{overflow-x:auto; width:100%; padding-bottom:6px}
  .wide-table th{white-space:nowrap}
  .wide-table td{min-width:70px; vertical-align:top}
  .wide-table .subhead{font-size:10px; color:var(--muted); font-weight:800; text-transform:none}
  .wide-table .dayhead{font-size:11px; color:var(--muted); font-weight:900; text-align:center}
  .wide-table .assign-cell{width:70px; min-width:70px; padding:4px 5px; font-size:10px; min-height:19px}

  .mroster-scroll{overflow-x:auto; width:100%; padding-bottom:8px}
  table.mroster-table{border-collapse:separate; border-spacing:0; width:max-content; min-width:100%}
  .mroster-table th,.mroster-table td{border:1px solid rgba(255,255,255,.08); padding:6px 6px}
  .mroster-table th{background:rgba(12,14,20,.92); position:sticky; top:0; z-index:4; white-space:nowrap}
  .mroster-table th.sticky-left{left:0; z-index:6}
  .mroster-table td.sticky-left{position:sticky; left:0; z-index:3; background:rgba(12,14,20,.98); white-space:nowrap}
  .cellbtn{display:inline-flex; align-items:center; justify-content:center; width:70px; min-height:38px; padding:8px 5px; border-radius:10px; border:1px solid rgba(255,255,255,.10); font-weight:900; font-size:11px; cursor:default; user-select:none}
  .cellbtn.off{background:rgba(255,255,255,.05); color:rgba(255,255,255,.55)}

/* CT buttons styling override */
.cellbtn.ct,
.assign-cell.ct {
  background: rgba(220,220,230,.15) !important;
  color: rgba(255,255,255,.7) !important;
  border-color: rgba(220,220,230,.25) !important;
  box-shadow: none !important;
}

/* Search highlight styles */
.search-match {
  outline: 3px solid #22c55e !important;
  outline-offset: 2px;
  box-shadow: 0 0 12px rgba(34, 197, 94, 0.5) !important;
}
.search-dim {
  opacity: 0.25;
}
.search-active .assign-cell:not(.search-match) {
  opacity: 0.25;
}

/* Print styles */
@media print {
  body {
    background: white !important;
    color: black !important;
    font-size: 10px !important;
  }
  .wrap {
    max-width: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
  }
  .topbar, .tabs, .actions, .btn, .card:has(h2:contains("Excluded")),
  .card:has(h2:contains("Trainees")), .card:has(h2:contains("Add New")),
  .subgrid, .toast, #monthSearch {
    display: none !important;
  }
  .card {
    border: 1px solid #ccc !important;
    background: white !important;
    page-break-inside: avoid;
    margin-bottom: 10px !important;
  }
  table {
    border: 1px solid #333 !important;
    font-size: 9px !important;
  }
  th, td {
    border: 1px solid #666 !important;
    padding: 4px !important;
    color: black !important;
  }
  th {
    background: #eee !important;
  }
  .assign-cell {
    border: 1px solid #333 !important;
    color: black !important;
    padding: 2px 4px !important;
    font-size: 8px !important;
  }
  .cellbtn {
    border: 1px solid #333 !important;
    color: black !important;
    background: #f5f5f5 !important;
  }
  .cellbtn.off {
    background: #ddd !important;
  }
  h1 {
    font-size: 16px !important;
    margin-bottom: 5px !important;
  }
  h2 {
    font-size: 12px !important;
  }
  .small {
    font-size: 8px !important;
  }
  /* Show current tab content */
  #tab_day, #tab_week, #tab_month, #tab_mroster {
    display: block !important;
  }
  #tab_day:not(.print-active),
  #tab_week:not(.print-active),
  #tab_month:not(.print-active),
  #tab_mroster:not(.print-active) {
    display: none !important;
  }
}

@keyframes spinArrows{
  0%{transform:rotate(0deg)}
  100%{transform:rotate(360deg)}
}
@keyframes logoPulse{
  0%,100%{opacity:.8}
  50%{opacity:1}
}
.rotation-logo{
  animation:logoPulse 3s ease-in-out infinite;
}
.rotation-logo .arrows{
  transform-origin:32px 32px;
  animation:spinArrows 4s linear infinite;
}

/* Login overlay */
#loginOverlay{
  position:fixed; inset:0; background:var(--bg); z-index:100000;
  display:flex; align-items:center; justify-content:center;
}
#loginOverlay.hidden{ display:none; }
.login-box{
  background:var(--panel); border:1px solid var(--line); border-radius:16px;
  padding:32px 40px; width:100%; max-width:360px; box-shadow:0 8px 32px rgba(0,0,0,.3);
}
.login-box h2{ margin:0 0 8px; font-size:24px; text-align:center; color:var(--text); }
.login-box .subtitle{ text-align:center; color:var(--muted); font-size:13px; margin-bottom:24px; }
.login-box label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
.login-box input[type="email"],
.login-box input[type="password"]{
  width:100%; padding:12px 14px; border-radius:10px; border:1px solid var(--line);
  background:var(--panel2); color:var(--text); font-size:14px; margin-bottom:16px; outline:none; box-sizing:border-box;
}
.login-box input:focus{ border-color:var(--btn); box-shadow:0 0 0 3px rgba(31,111,235,.15); }
.login-box .btn-login{
  width:100%; padding:12px; border-radius:10px; border:none; background:var(--btn);
  color:#fff; font-size:14px; font-weight:700; cursor:pointer; margin-top:8px;
}
.login-box .btn-login:hover{ background:#3b8fd9; }
.login-box .btn-login:disabled{ opacity:.6; cursor:not-allowed; }
.login-box .login-error{
  background:rgba(255,95,95,.12); border:1px solid rgba(255,95,95,.3); color:#ff6b6b;
  padding:10px 12px; border-radius:8px; font-size:13px; margin-bottom:16px; display:none;
}
.login-box .login-error.show{ display:block; }
#userInfo{ display:flex; align-items:center; gap:10px; font-size:12px; color:var(--muted); }
#userInfo .user-email{ color:var(--text); font-weight:600; }
#btnLogout{
  padding:4px 10px; border-radius:6px; border:1px solid var(--line); background:transparent;
  color:var(--muted); font-size:11px; cursor:pointer;
}
#btnLogout:hover{ background:rgba(255,255,255,.06); }

</style>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
<script>
  // Firebase configuration (same as CommandOps)
  const firebaseConfig = {
    apiKey: "AIzaSyA6KELmSyotefK0zhahQZ0-mbYur8_nTsg",
    authDomain: "commandops-93846.firebaseapp.com",
    databaseURL: "https://commandops-93846-default-rtdb.firebaseio.com",
    projectId: "commandops-93846",
    storageBucket: "commandops-93846.firebasestorage.app",
    messagingSenderId: "262613721964",
    appId: "1:262613721964:web:478a694d357234e3be4949"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
  const auth = firebase.auth();

  // Auth state – resolved once onAuthStateChanged fires with a user
  let authResolve;
  let authReady = new Promise(r => { authResolve = r; });

  auth.onAuthStateChanged((user) => {
    const overlay = document.getElementById('loginOverlay');
    const userInfo = document.getElementById('userInfo');
    const userEmail = document.getElementById('userEmail');

    if (user) {
      if (overlay) overlay.classList.add('hidden');
      if (userInfo) userInfo.style.display = 'flex';
      if (userEmail) userEmail.textContent = user.email;
      authResolve();
    } else {
      if (overlay) overlay.classList.remove('hidden');
      if (userInfo) userInfo.style.display = 'none';
      if (userEmail) userEmail.textContent = '';
    }
  });

  // Login form handler
  document.addEventListener('DOMContentLoaded', () => {
    const loginForm = document.getElementById('loginForm');
    const loginError = document.getElementById('loginError');
    const btnLogin = document.getElementById('btnLogin');
    const btnLogout = document.getElementById('btnLogout');

    if (loginForm) loginForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;

      loginError.classList.remove('show');
      btnLogin.disabled = true;
      btnLogin.textContent = 'Signing in...';

      try {
        await auth.signInWithEmailAndPassword(email, password);
      } catch (err) {
        let msg = 'Sign in failed';
        if (err.code === 'auth/user-not-found') msg = 'No account found with this email';
        else if (err.code === 'auth/wrong-password') msg = 'Incorrect password';
        else if (err.code === 'auth/invalid-email') msg = 'Invalid email address';
        else if (err.code === 'auth/too-many-requests') msg = 'Too many attempts. Try again later.';
        else if (err.code === 'auth/invalid-credential') msg = 'Invalid email or password';
        loginError.textContent = msg;
        loginError.classList.add('show');
      }

      btnLogin.disabled = false;
      btnLogin.textContent = 'Sign In';
    });

    if (btnLogout) btnLogout.addEventListener('click', () => {
      auth.signOut();
    });
  });

  // ===== Firebase Sync Functions =====
  let autoSaveTimer = null;
  let realtimeUnsubscribe = null;
  let lastSavedAt = null;
  let isSyncing = false;
  let initialLoadDone = false; // blocks onSnapshot until first load completes

  function setSyncStatus(status, state = null) {
    const pill = document.getElementById("syncPill");
    if (!pill) return;
    pill.textContent = "SYNC: " + status.toUpperCase();
    pill.classList.remove("synced", "error", "syncing");
    if (state === "good") pill.classList.add("synced");
    else if (state === "bad") pill.classList.add("error");
    else if (state === "pending") pill.classList.add("syncing");
  }

  async function saveRotationToFirebase() {
    await authReady;
    if (!auth.currentUser) { console.error("SAVE: No auth user"); return false; }

    const plan = JSON.parse(localStorage.getItem("rotation_plan_v2") || "null");
    const vac = JSON.parse(localStorage.getItem("rotation_vac_ranges_v2") || "[]");
    const training = JSON.parse(localStorage.getItem("rotation_training_v2") || "[]");

    if (!plan || !plan.meta) { console.error("SAVE: No plan or plan.meta"); return false; }

    const docId = `rotation_${plan.meta.year}_${plan.meta.monthIndex}`;
    console.log("SAVE: Writing to docId:", docId);
    try {
      // Use set WITHOUT merge to fully replace the document
      await db.collection('rotation_plans').doc(docId).set({
        plan: plan,
        vacations: vac,
        trainers: training,
        savedAt: new Date().toISOString()
      });
      console.log("SAVE: SUCCESS for", docId);

      // Verify the write by reading it back from the server
      const verify = await db.collection('rotation_plans').doc(docId).get({ source: 'server' });
      if (!verify.exists) {
        console.error("SAVE: Verification FAILED — doc not found after save");
        return false;
      }
      console.log("SAVE: Verified on server ✓", docId);
      return true;
    } catch (err) {
      console.error("SAVE: Firebase error:", err);
      return false;
    }
  }

  async function loadRotationFromFirebase(year, monthIndex) {
    await authReady;
    if (!auth.currentUser) return false;

    const docId = `rotation_${year}_${monthIndex}`;
    console.log("LOAD: Reading docId:", docId);
    try {
      // Force read from server, not local cache
      const doc = await db.collection('rotation_plans').doc(docId).get({ source: 'server' });
      if (doc.exists) {
        const data = doc.data();
        console.log("LOAD: Got doc, savedAt:", data.savedAt);
        if (data.plan) localStorage.setItem("rotation_plan_v2", JSON.stringify(data.plan));
        if (data.vacations) localStorage.setItem("rotation_vac_ranges_v2", JSON.stringify(data.vacations));
        if (data.trainers) localStorage.setItem("rotation_training_v2", JSON.stringify(data.trainers));
        return true;
      }
      console.log("LOAD: Doc does not exist for", docId);
    } catch (err) {
      console.warn("LOAD: Firebase error (trying cache fallback):", err);
      // If server read fails (offline), try cache
      try {
        const doc = await db.collection('rotation_plans').doc(docId).get({ source: 'cache' });
        if (doc.exists) {
          const data = doc.data();
          if (data.plan) localStorage.setItem("rotation_plan_v2", JSON.stringify(data.plan));
          if (data.vacations) localStorage.setItem("rotation_vac_ranges_v2", JSON.stringify(data.vacations));
          if (data.trainers) localStorage.setItem("rotation_training_v2", JSON.stringify(data.trainers));
          return true;
        }
      } catch (_) {}
    }
    return false;
  }

  function scheduleAutoSave() {
    if (!initialLoadDone) return; // Don't auto-save during page load
    if (autoSaveTimer) clearTimeout(autoSaveTimer);
    setSyncStatus("PENDING...", "pending");

    autoSaveTimer = setTimeout(async () => {
      setSyncStatus("SAVING...", "pending");
      isSyncing = true;
      const ok = await saveRotationToFirebase();
      isSyncing = false;

      if (ok) {
        lastSavedAt = Date.now();
        setSyncStatus("SYNCED", "good");
      } else {
        setSyncStatus("FAILED", "bad");
      }
    }, 1500);
  }

  async function startRealtimeSync(year, monthIndex) {
    await authReady;
    if (!auth.currentUser) return;
    if (realtimeUnsubscribe) realtimeUnsubscribe();

    const docId = `rotation_${year}_${monthIndex}`;
    realtimeUnsubscribe = db.collection('rotation_plans').doc(docId).onSnapshot((doc) => {
      if (!doc.exists) return;
      if (!initialLoadDone) { console.log("REALTIME: SKIPPED (initial load not done)"); return; }
      if (isSyncing) return;
      if (lastSavedAt && (Date.now() - lastSavedAt) < 2000) return;

      const data = doc.data();
      if (!data) return;

      console.log("REALTIME: update received for", docId, "savedAt:", data.savedAt, "fromCache:", doc.metadata.fromCache);
      // Skip cached snapshots — only trust server data
      if (doc.metadata.fromCache) {
        console.log("REALTIME: SKIPPED (from cache, not server)");
        return;
      }

      // Skip if this is the same data we already have (prevents circular save loop)
      const currentPlan = JSON.parse(localStorage.getItem("rotation_plan_v2") || "null");
      if (currentPlan && currentPlan.meta && data.plan && data.plan.meta
          && JSON.stringify(currentPlan.meta) === JSON.stringify(data.plan.meta)
          && data.savedAt === (currentPlan._savedAt || "")) {
        console.log("REALTIME: SKIPPED (same data already loaded)");
        setSyncStatus("LIVE", "good");
        return;
      }

      setSyncStatus("UPDATING...", "pending");

      // Tag the plan with savedAt so we can detect duplicates
      if (data.plan) {
        data.plan._savedAt = data.savedAt;
        localStorage.setItem("rotation_plan_v2", JSON.stringify(data.plan));
      }
      if (data.vacations) localStorage.setItem("rotation_vac_ranges_v2", JSON.stringify(data.vacations));
      if (data.trainers) localStorage.setItem("rotation_training_v2", JSON.stringify(data.trainers));

      // Refresh views
      const dayKey = document.getElementById("dayPick")?.value;
      if (dayKey && typeof renderDay === "function") {
        renderDay(dayKey);
        renderWeek(dayKey);
      }
      if (typeof renderMonth === "function") renderMonth(year, monthIndex);

      setSyncStatus("LIVE", "good");
    }, (err) => {
      console.error("Realtime sync error:", err);
      setSyncStatus("ERROR", "bad");
    });
  }

  // Hook into localStorage to auto-save on changes
  const originalSetItem = localStorage.setItem;
  localStorage.setItem = function(key, value) {
    originalSetItem.call(this, key, value);
    if (key.startsWith("rotation_") && key !== "rotation_ui_v2") {
      scheduleAutoSave();
    }
  };
</script>
</head>
<body>

<!-- Login Overlay -->
<div id="loginOverlay">
  <div class="login-box">
    <h2>RotationOps</h2>
    <p class="subtitle">Sign in to continue</p>
    <div id="loginError" class="login-error"></div>
    <form id="loginForm">
      <label>Email</label>
      <input type="email" id="loginEmail" placeholder="you@example.com" required autocomplete="email"/>
      <label>Password</label>
      <input type="password" id="loginPassword" placeholder="Enter password" required autocomplete="current-password"/>
      <button type="submit" class="btn-login" id="btnLogin">Sign In</button>
    </form>
  </div>
</div>

  <div class="wrap">
    <div style="display:flex;align-items:center;gap:6px;margin-bottom:10px;" class="header-controls">
      <span id="channelFlash" style="font-size:18px;font-weight:900;color:#4aa3ff;width:38px;text-align:center;font-family:system-ui;letter-spacing:1px;display:inline-block;perspective:100px;overflow:hidden;height:24px;line-height:24px;">
        <span id="channelInner" style="display:inline-block;width:38px;text-align:center;"></span>
      </span>
      <h1 style="font-size:22px;margin:0;font-weight:800;">RotationOps</h1>
      <span id="syncPill" class="sync-pill">SYNC: OFFLINE</span>
      <button id="btnThemeToggle" class="theme-toggle" title="Toggle theme">
        <span id="themeIcon">☀️</span> <span id="themeLabel">LIGHT</span>
      </button>
      <button id="btnSwapHistory" class="btn secondary" style="font-size:11px; padding:6px 10px;">HISTORY</button>
      <div style="position:relative; display:inline-block;">
        <button id="btnFairnessStats" class="btn secondary" style="font-size:11px; padding:6px 10px;">HOW IT WORKS</button>
        <div id="fairnessPopup" style="display:none; position:absolute; top:calc(100% + 6px); right:0; z-index:999; width:560px; max-height:75vh; overflow-y:auto; background:var(--panel); border:1px solid var(--line); border-radius:10px; padding:16px; box-shadow:0 8px 30px rgba(0,0,0,.4);">
          <div id="fairnessPopupContent"></div>
        </div>
      </div>
      <div style="position:relative; display:inline-block;">
        <button id="btnChannelTotals" class="btn secondary" style="font-size:11px; padding:6px 10px;">CHANNEL TOTALS</button>
        <div id="channelTotalsPopup" style="display:none; position:absolute; top:calc(100% + 6px); right:0; z-index:999; width:560px; max-height:75vh; overflow-y:auto; background:var(--panel); border:1px solid var(--line); border-radius:10px; padding:16px; box-shadow:0 8px 30px rgba(0,0,0,.4);">
          <div id="channelTotalsPopupContent"></div>
        </div>
      </div>
      <button id="btnExportTotals" class="btn secondary" style="font-size:11px; padding:6px 10px;">EXPORT TOTALS</button>
      <button id="btnExportCSV" class="btn secondary" style="font-size:11px; padding:6px 10px; background:#16A34A; color:#fff;">EXPORT EXCEL</button>
      <button id="btnExportMonthCSV" class="btn secondary" style="font-size:11px; padding:6px 10px; background:#0EA5E9; color:#fff;">EXPORT CSV</button>
      <div id="userInfo" style="margin-left:auto;display:none;">
        <span class="user-email" id="userEmail"></span>
        <button id="btnLogout" type="button">Sign Out</button>
      </div>
    </div>

    <div class="topbar">
      <div class="row">
        <label for="monthSel">Month:</label>
        <select id="monthSel"></select>
      </div>
      <div class="row">
        <label for="yearSel">Year:</label>
        <select id="yearSel"></select>
      </div>
      <button class="btn" id="btnRandomizeA">Option A</button>
      <button class="btn" id="btnRandomizeB" style="background:#22c55e; box-shadow:0 6px 18px rgba(34,197,94,.22);">Option B</button>
    </div>

    <div class="layout">
      <div class="card">
        <input id="dayPick" type="date" style="display:none;" />
        <div style="display:flex; align-items:center; gap:12px;">
          <div style="display:flex; align-items:center; gap:6px;">
            <h2 style="margin:0; white-space:nowrap;">Day Assignments –</h2>
            <button id="btnDayPrev" style="background:none; border:1px solid var(--line); border-radius:6px; padding:4px 8px; cursor:pointer; color:var(--text); font-size:14px; line-height:1;">&#9664;</button>
            <span id="dayTitle" style="font-size:14px; font-weight:800; color:var(--text); white-space:nowrap; min-width:130px; text-align:center;"></span>
            <button id="btnDayNext" style="background:none; border:1px solid var(--line); border-radius:6px; padding:4px 8px; cursor:pointer; color:var(--text); font-size:14px; line-height:1;">&#9654;</button>
          </div>
        </div>

        <div class="tabs" style="margin-top:12px; align-items:center;">
          <div class="tab active" data-tab="day">Day</div>
          <div class="tab" data-tab="week">Week</div>
          <div class="tab" data-tab="month">Month</div>
          <div class="tab" data-tab="mroster">Roster</div>
          <div id="violationStats" style="display:none; margin-left:12px; padding:6px 10px; background:rgba(239,68,68,0.15); border:1px solid rgba(239,68,68,0.4); border-radius:8px; font-size:11px; align-items:center;">
            <span style="font-weight:700;">VIOLATIONS:</span> <span id="violationCount">0</span> <span style="color:#888;">(<span id="violationPeople">0</span>)</span><span id="violationBest" style="margin-left:6px; color:#22c55e; display:none;">BEST!</span>
          </div>
          <div class="tab" data-tab="exceptions" style="margin-left:auto;">Monthly Exceptions</div>
        </div>

        <div id="tab_day">
          <div id="dayTableWrap"></div>

        </div>

        
        <div id="tab_mroster" style="display:none">
  <div class="card" style="padding:12px; margin-bottom:12px">
    <h2 style="margin:0 0 8px">Day Shift – Roster</h2>
    <div id="mRosterWrapDay"></div>
  </div>

  <div class="card" style="padding:12px">
    <h2 style="margin:0 0 8px">Night Shift – Roster</h2>
    <div id="mRosterWrapNight"></div>
  </div>
</div>

<div id="tab_week" style="display:none">
          <div style="margin-bottom:8px;">
            <input id="weekSearch" type="text" placeholder="SEARCH EMPLOYEE..." style="min-width:200px;" />
          </div>
          <div id="weekWrap"></div>
        </div>

        <div id="tab_month" style="display:none">
          <div class="row" style="margin-bottom:10px; gap:12px; align-items:center;">
            <input id="monthSearch" type="text" placeholder="SEARCH EMPLOYEE..." style="min-width:200px;" />
          </div>
          <div id="monthWrap"></div>
        </div>

        <div id="tab_exceptions" style="display:none">
          <div id="exceptionsWrap"></div>
        </div>

        </div>


<div class="toast" id="toast"></div>

<!-- Swap tip bubble -->
<div id="swapTip" style="display:none; position:fixed; bottom:70px; left:50%; transform:translateX(-50%); background:rgba(31,111,235,.92); color:#fff; padding:12px 20px; border-radius:12px; font-size:13px; font-weight:600; z-index:999; box-shadow:0 8px 30px rgba(0,0,0,.4); cursor:pointer; text-align:center; max-width:400px; animation:tipSlideUp .4s ease-out;">
  Click any name to swap assignments
  <div style="font-size:10px; font-weight:400; margin-top:4px; opacity:.8;">tap to dismiss</div>
</div>

<!-- Swap Assignment Modal -->
<div id="callOffModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:9999; align-items:center; justify-content:center;">
  <div style="background:var(--bg); border:1px solid var(--border); border-radius:8px; padding:20px; min-width:320px; max-width:420px;">
    <h3 style="margin:0 0 15px;" id="callOffModalTitle">SWAP ASSIGNMENT</h3>
    <p id="callOffModalInfo" style="margin:0 0 15px; font-size:14px;"></p>
    <div style="margin-bottom:15px;">
      <label style="font-size:12px; font-weight:700; display:block; margin-bottom:6px;">SWAP WITH:</label>
      <select id="swapSelect" style="width:100%; padding:8px; font-size:13px; border-radius:6px; border:1px solid var(--line); background:var(--panel2); color:var(--text);"></select>
    </div>
    <div id="moveToSection" style="display:none; margin-bottom:15px;">
      <label style="font-size:12px; font-weight:700; display:block; margin-bottom:6px;">MOVE TO:</label>
      <select id="moveToSelect" style="width:100%; padding:8px; font-size:13px; border-radius:6px; border:1px solid var(--line); background:var(--panel2); color:var(--text);"></select>
    </div>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <button class="btn" id="btnModalSwap">SWAP</button>
      <button class="btn danger" id="btnMarkAbsent">MARK ABSENT</button>
      <button class="btn" id="btnMoveTo" style="background:#8b5cf6; display:none;">MOVE</button>
      <button class="btn secondary" id="btnModalCancel">CANCEL</button>
    </div>
    <div id="callOffModalResult" style="margin-top:15px; font-size:13px;"></div>
  </div>
</div>

<!-- Assign to Empty Slot Modal -->
<div id="assignSlotModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:9999; align-items:center; justify-content:center;">
  <div style="background:var(--bg); border:1px solid var(--border); border-radius:8px; padding:20px; min-width:320px; max-width:420px;">
    <h3 style="margin:0 0 15px;" id="assignSlotModalTitle">ASSIGN TO SLOT</h3>
    <p id="assignSlotModalInfo" style="margin:0 0 15px; font-size:14px;"></p>
    <div style="margin-bottom:15px;">
      <label style="font-size:12px; font-weight:700; display:block; margin-bottom:6px;">ASSIGN FROM CT:</label>
      <select id="assignSlotSelect" style="width:100%; padding:8px; font-size:13px; border-radius:6px; border:1px solid var(--line); background:var(--panel2); color:var(--text);"></select>
    </div>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <button class="btn" id="btnAssignSlot">ASSIGN</button>
      <button class="btn secondary" id="btnAssignSlotCancel">CANCEL</button>
    </div>
  </div>
</div>


<!-- Swap History Modal -->
<div id="historyModal" class="modal-overlay">
  <div class="modal-content">
    <div class="modal-header">
      <h3>SWAP HISTORY</h3>
      <button class="modal-close" id="btnCloseHistoryModal">&times;</button>
    </div>
    <div class="history-list" id="historyList">
      <div style="color:var(--muted); text-align:center; padding:20px;">NO SWAPS RECORDED YET</div>
    </div>
    <div style="margin-top:15px; display:flex; gap:10px;">
      <button class="btn danger" id="btnClearHistory">CLEAR HISTORY</button>
    </div>
  </div>
</div>

<script>


// --- Guard: ensure blocksWorkedForSchedule exists (prevents undefined if any earlier script aborts) ---
if (typeof window.blocksWorkedForSchedule !== "function") {
  window.parseShiftToBlocks = window.parseShiftToBlocks || function(shiftStr){
    const ss = String(shiftStr||"").trim().toUpperCase();
    if (!ss || ss==="OFF") return new Set();
    if (ss==="6A-6P") return new Set(["0600-1000","1000-1400","1400-1800"]);
    if (ss==="6P-6A") return new Set(["1800-2200","2200-0200","0200-0600"]);
    if (ss==="6A-2P") return new Set(["0600-1000","1000-1400"]);
    if (ss==="10A-6P") return new Set(["1000-1400","1400-1800"]);
    if (ss==="2P-10P") return new Set(["1400-1800","1800-2200"]);
    if (ss==="6P-2A") return new Set(["1800-2200","2200-0200"]);
    if (ss==="10P-6A") return new Set(["2200-0200","0200-0600"]);
    if (ss==="2A-10A") return new Set(["0200-0600","0600-1000"]);
    try { return new Set((window.BLOCKS||[]).map(b=>b.key)); } catch(e) { return new Set(); }
  };
  window.blocksWorkedForSchedule = function(scheduleStr, shiftFilter){
    const worked = window.parseShiftToBlocks(scheduleStr);
    const allowed = new Set((shiftFilter==="DAY") ? ["0600-1000","1000-1400","1400-1800"]
                      : (shiftFilter==="NIGHT") ? ["1800-2200","2200-0200","0200-0600"]
                      : ((window.BLOCKS||[]).map(b=>b.key)));
    const out = new Set();
    for (const k of worked) if (allowed.has(k)) out.add(k);
    return out;
  };
}
// Also expose as local name if needed
const blocksWorkedForSchedule = window.blocksWorkedForSchedule;

// CT fairness globals (rebuilt each month)
let ctCapBase = 0;
let ctCapByName = new Map();

/** DATA — loaded from Firestore employees collection */
let BASE = [];

/** Derive DaysOff string from schedule (e.g. "Sat/Sun") */
function deriveDaysOff(emp) {
  const days = ["SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"];
  const labels = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
  const off = [];
  for (let i = 0; i < days.length; i++) {
    const v = String(emp[days[i]] || "").trim().toUpperCase();
    if (!v || v === "OFF") off.push(labels[i]);
  }
  return off.join("/") || "";
}

/** Load DISPATCHER employees from Firestore and populate BASE */
async function loadEmployeesFromFirestore() {
  await authReady;
  if (!auth.currentUser) return false;
  try {
    const snap = await db.collection('employees').get();
    BASE = snap.docs.map(doc => {
      const r = doc.data();
      const pos = String(r.POSITION ?? r.Position ?? "").toUpperCase();
      const emp = {
        Employee: (r.Employee || doc.id).toString().trim().toUpperCase(),
        Seniority: Number(r.SENIORITY ?? r.Seniority ?? 0),
        Position: pos,
        Present: "YES",
        MONDAY: r.MONDAY ?? "OFF",
        TUESDAY: r.TUESDAY ?? "OFF",
        WEDNESDAY: r.WEDNESDAY ?? "OFF",
        THURSDAY: r.THURSDAY ?? "OFF",
        FRIDAY: r.FRIDAY ?? "OFF",
        SATURDAY: r.SATURDAY ?? "OFF",
        SUNDAY: r.SUNDAY ?? "OFF"
      };
      emp.DaysOff = deriveDaysOff(emp);
      return emp;
    }).filter(r => r.Employee && r.Position === "DISPATCHER");
    console.log("Loaded " + BASE.length + " dispatchers from Firestore");
    return true;
  } catch (err) {
    console.error("Failed to load employees from Firestore:", err);
    return false;
  }
}


const CHANNELS = ["North","East","South","West","Northwest","Central","DC1","DC2","Relief 1","Relief 2"];
// 7th channel only active on Fri/Sat nights (2200-0300)
const SEVENTH_CHANNEL = "7th";
const SEVENTH_BLOCKS = new Set(["2200-0200","0200-0600"]); // Block(s) where 7th channel is active

// --- Special Detail (SD) settings ---
// Only these names may ever be assigned SD.
const SD_ELIGIBLE = new Set(["RAMIREZ","FOWLERL","GROUNDS","GUIDRY","BROWNC","MARZAHN","CLEMENT"]);

// Tracking + scoring maps (reinitialized each time a plan is built)
let sdWeekHours = new Map();          // weekKey -> Map(name -> SD hours)
let overflowScoreByDay = new Map();   // YYYY-MM-DD -> total overflow score for that day
let overflowMaxByWeek = new Map();    // weekKey -> max overflow score in that week
const BLOCKS = [
  {key:"0600-1000", label:"6 AM — 10 AM", start:6, end:10},
  {key:"1000-1400", label:"10 AM — 2 PM", start:10, end:14},
  {key:"1400-1800", label:"2 PM — 6 PM", start:14, end:18},
  {key:"1800-2200", label:"6 PM — 10 PM", start:18, end:22},
  {key:"2200-0200", label:"10 PM — 2 AM", start:22, end:26},
  {key:"0200-0600", label:"2 AM — 6 AM", start:26, end:30},
];


function parseShiftToBlocks(shiftStr) {
  const s = String(shiftStr||"").trim().toUpperCase();
  if (!s || s === "OFF") return new Set();
  if (s === "6A-6P") return new Set(["0600-1000","1000-1400","1400-1800"]);
  if (s === "6P-6A") return new Set(["1800-2200","2200-0200","0200-0600"]);
  if (s === "6A-2P") return new Set(["0600-1000","1000-1400"]);
  if (s === "10A-6P") return new Set(["1000-1400","1400-1800"]);
  if (s === "2P-10P") return new Set(["1400-1800","1800-2200"]);
  if (s === "6P-2A") return new Set(["1800-2200","2200-0200"]);
  if (s === "10P-6A") return new Set(["2200-0200","0200-0600"]);
  if (s === "2A-10A") return new Set(["0200-0600","0600-1000"]);
  return new Set(BLOCKS.map(b=>b.key));
}

function blocksWorkedForScheduleCanonical(scheduleStr, shiftFilter) {
  const worked = parseShiftToBlocks(scheduleStr);
  const allowed = new Set((shiftFilter==="DAY") ? ["0600-1000","1000-1400","1400-1800"]
                    : (shiftFilter==="NIGHT") ? ["1800-2200","2200-0200","0200-0600"]
                    : BLOCKS.map(b=>b.key));
  const out = new Set();
  for (const k of worked) if (allowed.has(k)) out.add(k);
  return out;
}
// Preferred name used across the app
// Backward-compatible name used in some views
// Shift code -> hours (used for scheduled-hours reporting)
const SHIFT_HOURS = {
  "6A-2P": 8, "6A-6P": 12,
  "10A-6P": 8, "10A-10P": 12,
  "2P-10P": 8,
  "6P-2A": 8, "6P-6A": 12,
  "10P-6A": 8,
  "OFF": 0, "": 0
};

function scheduledWeeklyHoursByName(name) {
  const nm = String(name || "").trim().toUpperCase();
  if (!nm) return 0;
  const base = normalizeBase();
  const row = base.find(r => String(r.Employee||"").trim().toUpperCase() === nm);
  if (!row) return 0;
  let tot = 0;
  const days = ["SATURDAY","SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY"];
  for (const d of days) {
    const v = String(row[d] || "").trim().toUpperCase();
    tot += (SHIFT_HOURS[v] ?? 0);
  }
  return tot;
}
const STORAGE = {
  plan: "rotation_plan_v2",
  vac: "rotation_vac_ranges_v2",
  hires: "rotation_new_hires_v2",
  training: "rotation_training_v2",
  ui: "rotation_ui_v2",
  employees: "rotation_employees_v2",
  swapHistory: "rotation_swap_history_v2",
  theme: "rotation_theme_v2"
};

function showToast(msg) {
  const t = document.getElementById("toast");
  t.style.display = "block";
  t.innerHTML = msg;
  clearTimeout(showToast._tm);
  showToast._tm = setTimeout(()=>t.style.display="none", 9000);
}
function safeParseJSON(str, fallback) { try { return JSON.parse(str); } catch(e) { return fallback; } }
function loadJSON(key, fallback) {
  const raw = localStorage.getItem(key);
  if (!raw) return fallback;
  const val = safeParseJSON(raw, null);
  if (val === null || val === undefined) { localStorage.removeItem(key); return fallback; }
  return val;
}
function saveJSON(key, value) { localStorage.setItem(key, JSON.stringify(value)); }
function pad2(n) { return String(n).padStart(2,"0"); }
function ymd(d) { return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }
function parseYMD(s) {
  if (!s) return null;
  const [y,m,d] = s.split("-").map(Number);
  if (!y||!m||!d) return null;
  return new Date(y, m-1, d, 12,0,0,0);
}
function dayName(d) { return ["SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"][d.getDay()]; }

function weekKeyFromDate(dateObj) {
  // Week starts on Saturday
  const d = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate(), 12,0,0,0);
  const dow = d.getDay(); // 0 Sun ... 6 Sat
  const offsetToSat = (dow - 6 + 7) % 7;
  const start = new Date(d.getFullYear(), d.getMonth(), d.getDate() - offsetToSat, 12,0,0,0);
  return ymd(start); // key by week start date
}
function monthName(i) { return ["January","February","March","April","May","June","July","August","September","October","November","December"][i]; }
function escapeHtml(s) { return String(s).replace(/[&<>"']/g, m => ({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"}[m])); }

function normalizeBase() {
  const b = Array.isArray(BASE) ? BASE : [];
  return b.filter(x => {
    const p = String(x.Present || "").trim().toUpperCase();
    return (p === "YES" || p === "Y" || p === "TRUE" || p === "1");
  });
}
function getNewHires() {
  const hires = loadJSON(STORAGE.hires, []);
  return Array.isArray(hires) ? hires : [];
}
function getVacRanges() {
  const v = loadJSON(STORAGE.vac, []);
  return Array.isArray(v) ? v : [];
}
function getTrainerRanges() {
  const t = loadJSON(STORAGE.training, []);
  if (!Array.isArray(t)) return [];
  // Support old format (plain strings) and new format (objects with name, from, to)
  return t.map(item => {
    if (typeof item === 'string') return { name: item.trim().toUpperCase(), from: '', to: '' };
    return { name: String(item.name||'').trim().toUpperCase(), from: item.from||'', to: item.to||'' };
  }).filter(r => r.name);
}
function getTrainees() {
  // Returns just the names for backward compatibility
  return getTrainerRanges().map(r => r.name);
}
function isTrainee(name, dayKey) {
  const ranges = getTrainerRanges();
  const nm = String(name || "").trim().toUpperCase();
  const dateObj = dayKey ? parseYMD(dayKey) : null;
  const dt = dateObj ? dateObj.getTime() : null;
  return ranges.some(r => {
    if (!r || !r.name) return false;
    if (r.name.toUpperCase() !== nm) return false;
    // If no dates specified, always applies
    if (!r.from && !r.to) return true;
    if (!dt) return true;
    const fromT = r.from ? new Date(r.from + "T00:00:00").getTime() : -Infinity;
    const toT = r.to ? new Date(r.to + "T23:59:59").getTime() : Infinity;
    return dt >= fromT && dt <= toT;
  });
}
function isExcluded(name, dateObj) {
  const ranges = getVacRanges();
  const nm = String(name||"").trim().toUpperCase();
  const dt = dateObj ? dateObj.getTime() : null;
  return ranges.some(r => {
    if (!r || !r.name) return false;
    if (String(r.name).trim().toUpperCase() !== nm) return false;
    if (!r.from && !r.to) return true; // month-wide
    const f = r.from ? parseYMD(r.from) : null;
    const t = r.to ? parseYMD(r.to) : null;
    const ft = f ? f.getTime() : -Infinity;
    const tt = t ? t.getTime() : Infinity;
    return dt !== null && dt >= ft && dt <= tt;
  });
}

function buildDispatcherPoolForDate(dateObj) {
  const base = normalizeBase();
  const hires = getNewHires().map(n => String(n).trim()).filter(Boolean);
  const dispatchers = base.filter(r => String(r.Position||"").toUpperCase()==="DISPATCHER")
    .map(r => ({ name: String(r.Employee||"").trim(), seniority: Number(r.Seniority||0), sched: r }))
    .filter(r => r.name);

  const hireObjs = hires
    .filter(n => dispatchers.every(d => d.name.toUpperCase() !== n.toUpperCase()))
    .map(n => ({ name:n, seniority:0, sched:null, isHire:true }));

  return dispatchers.concat(hireObjs).filter(d => !isExcluded(d.name, dateObj));
}

function worksBlock(disp, dateObj, block) {
  if (disp.isHire && !disp.sched) return false; // new hires must be scheduled before being assigned
  const sched = disp.sched || {};
  const dn = dayName(dateObj);
  const val = String(sched[dn] || "").toUpperCase().trim();
  if (!val || val==="OFF") return false;
  const map = {
    "6A-2P":[6,14],
    "6A-6P":[6,18],
    "10A-6P":[10,18],
    "10A-10P":[10,22],
    "2P-10P":[14,22],
    "6P-2A":[18,26],
    "6P-6A":[18,30],
    "10P-6A":[22,30],
  };
  const rng = map[val];
  if (!rng) return false;
  const [s,e] = rng;
  return (block.start >= s && block.end <= e);
}

function is12HrShift(disp, dateObj) {
  if (disp.isHire && !disp.sched) return false;
  const sched = disp.sched || {};
  const dn = dayName(dateObj);
  const val = String(sched[dn] || "").toUpperCase().trim();
  return val === "6A-6P" || val === "10A-10P" || val === "6P-6A";
}

function shuffle(arr) {
  const a = arr.slice();
  for (let i=a.length-1; i>0; i--) {
    const j = Math.floor(Math.random()*(i+1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function loadPlan() {
  const p = loadJSON(STORAGE.plan, null);
  return (p && typeof p==="object") ? p : null;
}
function savePlan(p) { saveJSON(STORAGE.plan, p); }

function buildEmptyPlan(year, monthIndex) {
  // reset per-month helper maps
  overflowScoreByDay = new Map();
  overflowMaxByWeek = new Map();
  sdWeekHours = new Map();

  const plan = { meta: {year, monthIndex, created: Date.now()}, days: {} };
  const daysInMonth = new Date(year, monthIndex+1, 0).getDate();

  // CT cap pre-scan totals
  let totalCTSlotsMonth = 0;
  let workedBlocksByName = new Map();

  // --- Pre-pass: compute where CT overflow is highest (per day, per week) ---
  for (let day=1; day<=daysInMonth; day++) {
    const dateObj = new Date(year, monthIndex, day, 12,0,0,0);
    const dayKey = ymd(dateObj);
    const wk = weekKeyFromDate(dateObj);
    const poolAll = buildDispatcherPoolForDate(dateObj);
    let score = 0;
    for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
      const available = poolAll.filter(d => worksBlock(d, dateObj, b));
      const overflowSlots = Math.max(0, available.length - 10);
      score += overflowSlots;
      totalCTSlotsMonth += overflowSlots;
      for (const d of available) workedBlocksByName.set(d.name, (workedBlocksByName.get(d.name)||0) + 1);
    }
    overflowScoreByDay.set(dayKey, score);
    const prevMax = overflowMaxByWeek.get(wk) || 0;
    if (score > prevMax) overflowMaxByWeek.set(wk, score);
  }

  // --- Compute hard monthly CT caps (as even as possible) ---
  const activeNames = Array.from(workedBlocksByName.keys());
  const activeCount = Math.max(1, activeNames.length);
  // CT hard cap (fixed)
  ctCapBase = 10;
  ctCapByName = new Map(activeNames.map(n => [n, ctCapBase]));

  for (let day=1; day<=daysInMonth; day++) {
    const d = new Date(year, monthIndex, day, 12,0,0,0);
    const key = ymd(d);
    plan.days[key] = {};
    for (const b of BLOCKS) plan.days[key][b.key] = { assignments:{}, sd:[], ct:[], filled:0, needed:10 };
  }
  return plan;
}

function randomizeMonth(year, monthIndex) {
  const plan = buildEmptyPlan(year, monthIndex);

  // Track last channel (prevents immediate back-to-back repeats)
  const lastAssign = new Map();
  function forbiddenBackToBack(prev, next) {
    // DC1/DC2 never back-to-back
    if ((prev==="DC1" && next==="DC2") || (prev==="DC2" && next==="DC1")) return true;
    // R1, R2, CT never back-to-back in any order
    const ctrSet = new Set(["RELIEF 1","RELIEF 2","CT","R1","R2"]);
    const pU = String(prev||"").toUpperCase();
    const nU = String(next||"").toUpperCase();
    if (ctrSet.has(pU) && ctrSet.has(nU)) return true;
    return false;
  }


  // Track per-person channel cycle (prevents repeating a channel until they've hit all 10)
  // name -> Set(channels used in current cycle)
  const channelCycle = new Map();

  // Light balancing helper (keeps total assignments per person more even)
  const channelCounts = new Map();

  // CT fairness tracking (per month + per week + back-to-back exception)
  const ctWeekCounts = new Map();   // weekKey -> Map(name -> ctCountThisWeek)
  const ctMonthCounts = new Map();  // name -> ctCountThisMonth
  const lastCTAt = new Map();       // name -> {dayKey, blockIdx} for back-to-back rule

  // Violation fairness: track violations per person (max 1 per person if possible)
  const violationCount = new Map();  // name -> number of violations this month
  function hasViolation(name) { return (violationCount.get(String(name).toUpperCase()) || 0) > 0; }
  function addViolation(name) {
    const n = String(name).toUpperCase();
    violationCount.set(n, (violationCount.get(n) || 0) + 1);
  }

  // Track people assigned R1/R2 who work next block - they get GUARANTEED channel priority
  // This prevents Relief->CT violations when Pass 4 must fill R1/R2 with someone working next block
  const mustGetChannelNextBlock = new Set(); // names that MUST get a channel (not CT) next block

  // ctCapByName is global (rebuilt in buildEmptyPlan)
  const ctOverCapUsedByWeek = new Map(); // weekKey -> Set(names who used 1 over-cap allowance)
  const lastCTGlobalIdx = new Map();     // name -> global block index of last CT (for back-to-back rule)

  const daysInMonth = new Date(year, monthIndex+1, 0).getDate();

  // ========== SD PRE-ASSIGNMENT (32 hrs/WEEK = 8 blocks/WEEK per person) ==========
  // Pre-assign SD to SD-eligible employees before filling channels
  // Each SD person gets 32 hrs (8 blocks) of SD per WEEK, rest goes to channels.
  // Track: sdPreAssigned[weekKey][dayKey][blockKey] = [names assigned to SD]
  const sdPreAssigned = new Map(); // weekKey -> Map(dayKey -> Map(blockKey -> [names]))
  const sdRemainingBlocks = new Map(); // weekKey -> Map(name -> remaining channel blocks to fill)

  // Group days by week and find days with most dispatchers for SD priority
  const weekDays = new Map(); // weekKey -> [{dayKey, dateObj, dispatcherCount}]
  for (let day=1; day<=daysInMonth; day++) {
    const dateObj = new Date(year, monthIndex, day, 12,0,0,0);
    const dayKey = ymd(dateObj);
    const wk = weekKeyFromDate(dateObj);
    if (!weekDays.has(wk)) weekDays.set(wk, []);

    // Count total dispatcher availability for this day
    const poolAll = buildDispatcherPoolForDate(dateObj);
    let totalAvail = 0;
    for (const b of BLOCKS) {
      const available = poolAll.filter(d => worksBlock(d, dateObj, b));
      totalAvail += available.length;
    }
    weekDays.get(wk).push({dayKey, dateObj, dispatcherCount: totalAvail});
  }

  // Monthly SD cap: 32 blocks (128 hrs) per month — ensures totals stay at 32
  const SD_MONTHLY_CAP = 32;
  const sdMonthlyCount = new Map(); // name -> total SD blocks this month
  for (const sdName of SD_ELIGIBLE) sdMonthlyCount.set(sdName, 0);

  // For each week, pre-assign SD (8 blocks = 32 hrs per FULL WEEK, pro-rated for partial weeks)
  for (const [wk, days] of weekDays.entries()) {
    // Sort days by dispatcher count descending (prioritize days with most dispatchers)
    days.sort((a, b) => b.dispatcherCount - a.dispatcherCount);

    sdPreAssigned.set(wk, new Map());
    sdRemainingBlocks.set(wk, new Map());
    const sdMap = sdPreAssigned.get(wk);

    // Pro-rate SD cap for partial weeks:
    // A full week (7 days, ~5 working days) = 8 blocks cap
    // Partial weeks get proportional cap based on actual days in this month-week
    const daysInThisWeek = days.length;
    // Full week has ~5 working days (Mon-Fri from Sat-Fri week). Scale 8 blocks by ratio.
    // Use 5 as the baseline for a full working week
    const sdWeeklyCap = Math.min(8, Math.round(8 * daysInThisWeek / 5));

    // Track blocks assigned per SD employee this week
    const sdBlocksThisWeek = new Map(); // name -> blocks assigned this week

    // For each SD-eligible employee, initialize to 0
    for (const sdName of SD_ELIGIBLE) {
      sdBlocksThisWeek.set(sdName, 0);
      sdRemainingBlocks.get(wk).set(sdName, 0); // will calculate after
    }

    // Distribute SD assignments across the week
    for (const {dayKey, dateObj} of days) {
      if (!sdMap.has(dayKey)) sdMap.set(dayKey, new Map());
      const dayMap = sdMap.get(dayKey);

      const poolAll = buildDispatcherPoolForDate(dateObj);

      for (const b of BLOCKS) {
        if (!dayMap.has(b.key)) dayMap.set(b.key, []);

        // Find SD-eligible people working this block who haven't hit weekly or monthly cap
        for (const sdName of SD_ELIGIBLE) {
          const weeklyBlocks = sdBlocksThisWeek.get(sdName) || 0;
          if (weeklyBlocks >= sdWeeklyCap) continue; // CAP: pro-rated per week
          const monthlyBlocks = sdMonthlyCount.get(sdName) || 0;
          if (monthlyBlocks >= SD_MONTHLY_CAP) continue; // HARD CAP: 32 blocks per month

          // Check if this person works this block
          const disp = poolAll.find(d => String(d.name).toUpperCase() === sdName);
          if (!disp) continue;
          if (!worksBlock(disp, dateObj, b)) continue;

          // Assign to SD
          dayMap.get(b.key).push(sdName);
          sdBlocksThisWeek.set(sdName, weeklyBlocks + 1);
          sdMonthlyCount.set(sdName, monthlyBlocks + 1);
        }
      }
    }

    // Calculate remaining channel blocks for each SD employee
    // (Total scheduled blocks - SD blocks = remaining for channels)
    for (const sdName of SD_ELIGIBLE) {
      let totalScheduledBlocks = 0;
      for (const {dayKey, dateObj} of days) {
        const poolAll = buildDispatcherPoolForDate(dateObj);
        const disp = poolAll.find(d => String(d.name).toUpperCase() === sdName);
        if (!disp) continue;
        for (const b of BLOCKS) {
          if (worksBlock(disp, dateObj, b)) totalScheduledBlocks++;
        }
      }
      const sdBlocks = sdBlocksThisWeek.get(sdName) || 0;
      const remainingBlocks = Math.max(0, totalScheduledBlocks - sdBlocks);
      sdRemainingBlocks.get(wk).set(sdName, remainingBlocks);
    }
  }
  // ========== END SD PRE-ASSIGNMENT ==========

// Weekly quota targets (after SD):
// - 24 hrs (6 blocks) from N/E/S/W/C/NW
// - 8 hrs (2 blocks) from CT or R1/R2
// - 8 hrs (2 blocks) from DC1/DC2
const PRIMARY_SET = new Set(["NORTH","EAST","SOUTH","WEST","CENTRAL","NORTHWEST"]);
const DC_SET = new Set(["DC1","DC2"]);
const CTR_SET = new Set(["CT","R1","R2"]);

// wk -> Map(name -> {primary:int, ctr:int, dc:int})
const weekNeeds = new Map();
function getNeeds(wkKey, name){
  if (!weekNeeds.has(wkKey)) weekNeeds.set(wkKey, new Map());
  const m = weekNeeds.get(wkKey);
  if (!m.has(name)) m.set(name, {primary:6, ctr:2, dc:2}); // default 40hr week (10 blocks)
  return m.get(name);
}

// Keep channel chunks up to 8 hours (2 blocks) when possible
const sameChanStreak = new Map(); // name -> {ch, len}
// Hard constraint: never more than 8 hours (2 blocks) in CT/R1/R2 bucket back-to-back
const ctrStreakLen = new Map(); // name -> consecutive blocks in {CT,R1,R2}

function updateStreaks(name, assignedChannel){
  // same channel streak
  const prev = sameChanStreak.get(name);
  if (prev && prev.ch === assignedChannel) sameChanStreak.set(name, {ch: assignedChannel, len: Math.min(2, prev.len+1)});
  else sameChanStreak.set(name, {ch: assignedChannel, len: 1});

  // CT-bucket streak
  if (CTR_SET.has(assignedChannel)) ctrStreakLen.set(name, (ctrStreakLen.get(name)||0)+1);
  else ctrStreakLen.set(name, 0);
}



  // Track which channels each person has already worked TODAY (to prevent same channel twice in same day)
  const dayChannelsWorked = new Map(); // dayKey -> Map(name -> Set of channels)

  for (let day=1; day<=daysInMonth; day++) {
    const dateObj = new Date(year, monthIndex, day, 12,0,0,0);
    const dayKey = ymd(dateObj);
        const wk = weekKeyFromDate(dateObj);
    if (!ctWeekCounts.has(wk)) ctWeekCounts.set(wk, new Map());

    // Initialize daily channel tracking for this day
    if (!dayChannelsWorked.has(dayKey)) dayChannelsWorked.set(dayKey, new Map());
    const todayChannels = dayChannelsWorked.get(dayKey); // Map(name -> Set of channels)

const poolAll = buildDispatcherPoolForDate(dateObj);

    for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
      const available = poolAll.filter(d => worksBlock(d, dateObj, b));
      const shuffled = shuffle(available);

      // Balance: prefer people with fewer total assignments so far
      // HIGHEST PRIORITY: People who were just on CT/R1/R2 must get a channel to avoid back-to-back
      shuffled.sort((a,b2)=>{
        // ABSOLUTE PRIORITY: People marked as must-get-channel (from Pass 4 R1/R2 assignment)
        const aMustGet = mustGetChannelNextBlock.has(a.name);
        const bMustGet = mustGetChannelNextBlock.has(b2.name);
        if (aMustGet && !bMustGet) return -1; // a goes first (GUARANTEED)
        if (bMustGet && !aMustGet) return 1;  // b goes first (GUARANTEED)

        // Check if either person was just on CT/R1/R2 (needs priority for channel)
        const lastA = lastAssign.get(a.name);
        const lastB = lastAssign.get(b2.name);
        const ctrNames = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
        const aWasOnCTR = lastA && ctrNames.has(String(lastA).toUpperCase());
        const bWasOnCTR = lastB && ctrNames.has(String(lastB).toUpperCase());

        // SECOND: People who were just on CT/R1/R2 get top priority for channels
        if (aWasOnCTR && !bWasOnCTR) return -1; // a goes first
        if (bWasOnCTR && !aWasOnCTR) return 1;  // b goes first

        const ma = channelCounts.get(a.name) || new Map();
        const mb = channelCounts.get(b2.name) || new Map();
        const ta = Array.from(ma.values()).reduce((s,v)=>s+v,0);
        const tb = Array.from(mb.values()).reduce((s,v)=>s+v,0);

        // CT fairness: if someone has already been sent to CT more often, pull them onto a channel first
        const wmap = ctWeekCounts.get(wk) || new Map();
        const cwa = wmap.get(a.name) || 0;
        const cwb = wmap.get(b2.name) || 0;

        const cma = ctMonthCounts.get(a.name) || 0;
        const cmb = ctMonthCounts.get(b2.name) || 0;

        // Priority order:
        // 1) Higher CT this week gets channel priority (reduces repeat CT in the same week)
        // 2) Higher CT this month gets channel priority (evens CT across the month)
        // 3) Then balance total channel work so one person doesn't do everything
        if (cwa !== cwb) return cwb - cwa;
        if (cma !== cmb) return cmb - cma;
        if (ta !== tb) return ta - tb;
        return 0;
      });

      const assignments = {};
      const usedNames = new Set();

      // ========== ADD PRE-ASSIGNED SD TO THIS BLOCK ==========
      // Get pre-assigned SD for this block and add to usedNames
      const sdForBlock = [];
      const wkSdMap = sdPreAssigned.get(wk);
      if (wkSdMap && wkSdMap.has(dayKey)) {
        const dayMap = wkSdMap.get(dayKey);
        if (dayMap && dayMap.has(b.key)) {
          for (const sdName of dayMap.get(b.key)) {
            sdForBlock.push(sdName);
            usedNames.add(sdName); // Exclude from channel assignment this block
          }
        }
      }
      // ========== END PRE-ASSIGNED SD ==========

      // Check if an SD employee still has remaining channel blocks to fill
      // If so, prioritize them for primary channels (N,E,S,W,NW,C) and one DC
      const sdRemainingMap = sdRemainingBlocks.get(wk) || new Map();
      function isSDEmployeeNeedingChannel(name) {
        const nm = String(name).toUpperCase();
        return SD_ELIGIBLE.has(nm) && (sdRemainingMap.get(nm) || 0) > 0 && !usedNames.has(nm);
      }

      // Training restriction: trainees can only be assigned to E, S, W, C
      const TRAINEE_ALLOWED_CHANNELS = new Set(["EAST","SOUTH","WEST","CENTRAL"]);
      function canTraineeWork(candName, channelUpper) {
        if (!isTrainee(candName, dayKey)) return true; // Non-trainees can work any channel
        return TRAINEE_ALLOWED_CHANNELS.has(channelUpper);
      }

      for (const ch of CHANNELS) {
  let pick = null;
  const CH = String(ch).toUpperCase();

  // Determine which quota bucket this channel satisfies
  const bucket = DC_SET.has(CH) ? "dc" : (PRIMARY_SET.has(CH) ? "primary" : (CTR_SET.has(CH) ? "ctr" : "primary"));

  // Compute average assignment count for this channel across all dispatchers
  let chAvgCount = 0;
  if (channelCounts.size > 0) {
    let sum = 0, cnt = 0;
    for (const [nm, m] of channelCounts) {
      sum += (m.get(ch) || 0);
      cnt++;
    }
    chAvgCount = cnt > 0 ? sum / cnt : 0;
  }

  function candScore(cand){
    const needs = getNeeds(wk, cand.name);
    const needVal = needs[bucket] || 0;

    const last = lastAssign.get(cand.name);
    const lastUpper = last ? String(last).toUpperCase() : "";
    const streak = sameChanStreak.get(cand.name);
    const sameBonus = (last && lastUpper===CH && streak && streak.len < 2) ? 50 : 0;

    const m = channelCounts.get(cand.name) || new Map();
    const total = Array.from(m.values()).reduce((s,v)=>s+v,0);

    // CRITICAL: People who were just on CTR (CT, R1, R2) MUST get a non-CTR channel
    // Give them massive priority so they always win
    let ctrPriorityBonus = 0;
    const wasCTR = lastUpper === "CT" || lastUpper === "RELIEF 1" || lastUpper === "RELIEF 2" || lastUpper === "R1" || lastUpper === "R2";
    if (wasCTR) {
      // They were on CTR - they NEED a non-CTR channel now
      if (CH !== "RELIEF 1" && CH !== "RELIEF 2") {
        ctrPriorityBonus = 5000; // Massive bonus for non-R1/R2 channels
      }
    }

    // Also check if they had CTR today - they shouldn't get R1/R2 or go to CT
    const candDayChans = todayChannels.get(cand.name);
    const hadCTRToday = candDayChans && (candDayChans.has("CT") || candDayChans.has("RELIEF 1") || candDayChans.has("RELIEF 2"));
    if (hadCTRToday && CH !== "RELIEF 1" && CH !== "RELIEF 2") {
      ctrPriorityBonus += 3000; // Additional bonus if they already had CTR today
    }

    // SD employee priority: give big bonus for primary channels (N,E,S,W,NW,C) and DC1/DC2
    // Their remaining 8 hrs should go to these channels
    let sdBonus = 0;
    if (isSDEmployeeNeedingChannel(cand.name)) {
      if (PRIMARY_SET.has(CH) || DC_SET.has(CH)) {
        sdBonus = 200; // High priority for SD employees to get primary/DC channels
      } else {
        sdBonus = -100; // Discourage R1/R2 for SD employees
      }
    }

    // R1/R2 penalty: If assigning R1 or R2, heavily penalize people who work the next block
    // This prevents R1/R2 -> CT violations
    let r1r2Penalty = 0;
    if (CH === "RELIEF 1" || CH === "RELIEF 2") {
      const nextBlockIdx = bi + 1;
      if (nextBlockIdx < BLOCKS.length) {
        // Check if this person works the next block today
        if (worksBlock(cand, dateObj, BLOCKS[nextBlockIdx])) {
          r1r2Penalty = -500; // Heavy penalty - prefer someone whose shift ends
        }
      }
      // Also check if they work the first block of the next day
      if (bi === BLOCKS.length - 1) {
        const nextDay = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate() + 1, 12, 0, 0, 0);
        if (worksBlock(cand, nextDay, BLOCKS[0])) {
          r1r2Penalty = -500; // Heavy penalty for cross-day continuation
        }
      }
    }

    // CT/Relief inverse balance: high CT → prefer Relief, high Relief → prefer CT
    // Combined CT+R total should be balanced, so if one is high the other should be low
    let ctReliefInverseBonus = 0;
    const myCT = ctMonthCounts.get(cand.name) || 0;
    const myRelief = (m.get("Relief 1") || 0) + (m.get("Relief 2") || 0);
    // Compute averages
    let avgCT = 0, avgRelief = 0, pCount = 0;
    for (const [nm, cnt] of ctMonthCounts) { avgCT += cnt; pCount++; }
    if (pCount > 0) avgCT /= pCount;
    if (channelCounts.size > 0) {
      let rSum = 0;
      for (const [, cm] of channelCounts) rSum += (cm.get("Relief 1") || 0) + (cm.get("Relief 2") || 0);
      avgRelief = rSum / channelCounts.size;
    }
    if (CH === "RELIEF 1" || CH === "RELIEF 2") {
      // Assigning Relief: bonus if person has high CT (they need more Relief to compensate)
      if (myCT > avgCT) ctReliefInverseBonus = (myCT - avgCT) * 120;
      // Penalty if person already has high Relief
      if (myRelief > avgRelief) ctReliefInverseBonus -= (myRelief - avgRelief) * 120;
    }

    // Channel balance: quadratic penalty for being above average, linear bonus for below
    // This strongly discourages piling up on one channel (1 above = -150, 2 above = -600, 3 above = -1350)
    const myChCount = (channelCounts.get(cand.name) || new Map()).get(ch) || 0;
    const chDelta = myChCount - chAvgCount;
    const chBalancePenalty = chDelta > 0
      ? -(chDelta * chDelta * 150)   // quadratic penalty — escalates fast
      : (Math.abs(chDelta) * 50);    // linear bonus — gently attracts under-assigned channels

    // Minimum floor bonus: strongly prefer channels where person has < 2 assignments
    // Massive bonus at 0 to avoid anyone ending up with only 1 of a channel
    let minFloorBonus = 0;
    if (PRIMARY_SET.has(CH) && myChCount < 2) {
      minFloorBonus = (2 - myChCount) * 500; // +1000 at 0, +500 at 1
    } else if (PRIMARY_SET.has(CH) && myChCount < 3) {
      minFloorBonus = 200; // gentle bonus to reach 3
    }

    // Big push to satisfy weekly quotas, then prefer 8-hour chunks, then keep totals even
    return (needVal*100) + sameBonus + sdBonus + r1r2Penalty + ctrPriorityBonus + chBalancePenalty + minFloorBonus + ctReliefInverseBonus - (total*0.25);
  }

  // Helper: check if candidate works next block (for R1/R2 restriction)
  function worksNextBlock(cand) {
    const nextBlockIdx = bi + 1;
    if (nextBlockIdx < BLOCKS.length) {
      if (worksBlock(cand, dateObj, BLOCKS[nextBlockIdx])) return true;
    }
    if (bi === BLOCKS.length - 1) {
      const nextDay = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate() + 1, 12, 0, 0, 0);
      if (worksBlock(cand, nextDay, BLOCKS[0])) return true;
    }
    return false;
  }

  // Pass 1: STRICT – quota-driven + no immediate repeat + respect channel cycle + respect CT-bucket streak rule
  let best = null, bestScore = -1e9;
  for (const cand of shuffled) {
    if (usedNames.has(cand.name)) continue;

    // Training restriction: trainees can only work E, S, W, C
    if (!canTraineeWork(cand.name, CH)) continue;

    // R1/R2 restriction: In Pass 1, skip people who work next block
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;

    // Same-day channel restriction: don't assign same channel twice in one day
    const candDayChannels = todayChannels.get(cand.name);
    if (candDayChannels && candDayChannels.has(CH)) continue;

    // init/roll cycle
    if (!channelCycle.has(cand.name)) channelCycle.set(cand.name, new Set());
    const cyc = channelCycle.get(cand.name);
    if (cyc.size >= CHANNELS.length) cyc.clear();

    const last = lastAssign.get(cand.name);
    if (last && (String(last).toUpperCase() === CH || forbiddenBackToBack(String(last).toUpperCase(), CH))) continue;
    if (cyc.has(ch)) continue;

    // Hard rule: never more than 2 consecutive blocks in CT/R1/R2 bucket
    if (bucket === "ctr" && (ctrStreakLen.get(cand.name)||0) >= 2) continue;

    const sc = candScore(cand);
    if (sc > bestScore) { bestScore=sc; best=cand; }
  }
  pick = best;

  // Pass 2: RELAX cycle (if staffing is too tight) – still enforce CT-bucket streak
  if (!pick) {
    best = null; bestScore = -1e9;
    for (const cand of shuffled) {
      if (usedNames.has(cand.name)) continue;

      // Training restriction: trainees can only work E, S, W, C
      if (!canTraineeWork(cand.name, CH)) continue;

      // R1/R2 restriction: In Pass 2, still skip people who work next block
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;

      // Same-day channel restriction: don't assign same channel twice in one day
      const candDayChannels = todayChannels.get(cand.name);
      if (candDayChannels && candDayChannels.has(CH)) continue;

      const last = lastAssign.get(cand.name);
      if (last && (String(last).toUpperCase() === CH || forbiddenBackToBack(String(last).toUpperCase(), CH))) continue;

      if (bucket === "ctr" && (ctrStreakLen.get(cand.name)||0) >= 2) continue;

      const sc = candScore(cand) - 15; // slight penalty vs strict
      if (sc > bestScore) { bestScore=sc; best=cand; }
    }
    pick = best;
  }

  // Pass 3: LAST RESORT – any available person (still enforce CT-bucket streak)
  if (!pick) {
    for (const cand of shuffled) {
      if (usedNames.has(cand.name)) continue;
      // Training restriction: trainees can only work E, S, W, C
      if (!canTraineeWork(cand.name, CH)) continue;
      // R1/R2 restriction: CRITICAL - still skip people who work next block even in Pass 3
      // This prevents Relief->CT back-to-back violations
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;
      // Same-day channel restriction: don't assign same channel twice in one day
      const candDayChannels = todayChannels.get(cand.name);
      if (candDayChannels && candDayChannels.has(CH)) continue;
      // Check forbiddenBackToBack even in Pass 3
      const last = lastAssign.get(cand.name);
      if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) continue;
      if (bucket === "ctr" && (ctrStreakLen.get(cand.name)||0) >= 2) continue;
      pick = cand; break;
    }
  }

  // If no pick found, skip this channel but continue with others
  // (Especially important for R1/R2 which may be skipped to prevent violations)
  if (!pick) continue;

  assignments[ch] = pick.name;
  usedNames.add(pick.name);
  lastAssign.set(pick.name, ch);

  // Track channel worked today (to prevent same channel twice in one day)
  if (!todayChannels.has(pick.name)) todayChannels.set(pick.name, new Set());
  todayChannels.get(pick.name).add(CH);

  // update cycle tracking
  if (!channelCycle.has(pick.name)) channelCycle.set(pick.name, new Set());
  const cyc = channelCycle.get(pick.name);
  if (cyc.size >= CHANNELS.length) cyc.clear();
  cyc.add(ch);

  // decrement weekly need if still owed
  const nd = getNeeds(wk, pick.name);
  if (nd[bucket] > 0) nd[bucket] -= 1;

  // update streaks
  updateStreaks(pick.name, String(ch).toUpperCase());

  // update balancing counts
  if (!channelCounts.has(pick.name)) channelCounts.set(pick.name, new Map());
  const m = channelCounts.get(pick.name);
  m.set(ch, (m.get(ch)||0)+1);

  // Track SD employee channel usage (decrement remaining blocks)
  const pickUpper = String(pick.name).toUpperCase();
  if (SD_ELIGIBLE.has(pickUpper) && sdRemainingMap.has(pickUpper)) {
    const rem = sdRemainingMap.get(pickUpper) || 0;
    if (rem > 0) sdRemainingMap.set(pickUpper, rem - 1);
  }

  // Remove from must-get-channel list (they got their channel)
  mustGetChannelNextBlock.delete(pick.name);

  // If R1/R2 assigned and they work next block, they MUST get a channel next block
  // (This applies to Pass 1-3 as well, not just Pass 4)
  if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(pick)) {
    mustGetChannelNextBlock.add(pick.name);
  }
}

// ========== PASS 4: FILL ANY EMPTY CHANNELS ==========
// Multiple sub-passes with decreasing strictness to minimize violations
for (const ch of CHANNELS) {
  if (assignments[ch]) continue; // Already filled

  const CH = String(ch).toUpperCase();
  let pick = null;

  // Pass 4a: All checks - ideal candidate
  for (const cand of shuffled) {
    if (usedNames.has(cand.name)) continue;
    if (!canTraineeWork(cand.name, CH)) continue;
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;
    const last = lastAssign.get(cand.name);
    if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) continue;
    const candDayChannels = todayChannels.get(cand.name);
    if (candDayChannels && candDayChannels.has(CH)) continue;
    pick = cand;
    break;
  }

  // Pass 4b: Skip worksNextBlock, keep forbiddenBackToBack and same-day
  // For R1/R2, prefer people without violations (they'll likely get a Relief->CT violation)
  if (!pick) {
    const candidates4b = shuffled.filter(cand => {
      if (usedNames.has(cand.name)) return false;
      if (!canTraineeWork(cand.name, CH)) return false;
      const last = lastAssign.get(cand.name);
      if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) return false;
      const candDayChannels = todayChannels.get(cand.name);
      if (candDayChannels && candDayChannels.has(CH)) return false;
      return true;
    });
    // Sort: people without violations first (for R1/R2 that may cause violation)
    if ((CH === "RELIEF 1" || CH === "RELIEF 2")) {
      candidates4b.sort((a, b) => (violationCount.get(a.name.toUpperCase())||0) - (violationCount.get(b.name.toUpperCase())||0));
    }
    if (candidates4b.length > 0) pick = candidates4b[0];
  }

  // Pass 4c: Skip worksNextBlock and same-day, KEEP forbiddenBackToBack (most important)
  if (!pick) {
    const candidates4c = shuffled.filter(cand => {
      if (usedNames.has(cand.name)) return false;
      if (!canTraineeWork(cand.name, CH)) return false;
      const last = lastAssign.get(cand.name);
      if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) return false;
      return true;
    });
    // Sort: people without violations first
    if ((CH === "RELIEF 1" || CH === "RELIEF 2")) {
      candidates4c.sort((a, b) => (violationCount.get(a.name.toUpperCase())||0) - (violationCount.get(b.name.toUpperCase())||0));
    }
    if (candidates4c.length > 0) pick = candidates4c[0];
  }

  // Pass 4d: Last resort - anyone available (channel MUST be filled)
  // Even here, prefer people without violations
  if (!pick) {
    const candidates4d = shuffled.filter(cand => {
      if (usedNames.has(cand.name)) return false;
      if (!canTraineeWork(cand.name, CH)) return false;
      return true;
    });
    candidates4d.sort((a, b) => (violationCount.get(a.name.toUpperCase())||0) - (violationCount.get(b.name.toUpperCase())||0));
    if (candidates4d.length > 0) pick = candidates4d[0];
  }

  if (pick) {
    assignments[ch] = pick.name;
    usedNames.add(pick.name);
    lastAssign.set(pick.name, ch);

    if (!todayChannels.has(pick.name)) todayChannels.set(pick.name, new Set());
    todayChannels.get(pick.name).add(CH);

    if (!channelCycle.has(pick.name)) channelCycle.set(pick.name, new Set());
    channelCycle.get(pick.name).add(ch);

    if (!channelCounts.has(pick.name)) channelCounts.set(pick.name, new Map());
    const m = channelCounts.get(pick.name);
    m.set(ch, (m.get(ch)||0)+1);

    updateStreaks(pick.name, CH);

    // Remove from must-get-channel list if they were in it (they got a channel now)
    mustGetChannelNextBlock.delete(pick.name);

    // If R1/R2 assigned to someone who works next block, they MUST get a channel next block
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(pick)) {
      mustGetChannelNextBlock.add(pick.name);
    }
  }
}
// ========== END PASS 4 ==========

const filled = Object.keys(assignments).length;

      // ========== 7TH CHANNEL (Fri/Sat nights 2200-0300) ==========
      // On Friday (day 5) and Saturday (day 6), add an additional "7th" dispatcher channel
      const dayOfWeek = dateObj.getDay(); // 0=Sun, 5=Fri, 6=Sat
      const isFriOrSat = (dayOfWeek === 5 || dayOfWeek === 6);
      const is7thBlock = SEVENTH_BLOCKS.has(b.key);

      if (isFriOrSat && is7thBlock && filled >= 10) {
        // Find someone for 7th channel from remaining available
        const remaining7th = shuffled.filter(c => !usedNames.has(c.name) && !isTrainee(c.name, dayKey));

        // Sort by fewest total assignments (fairness)
        remaining7th.sort((a,b2)=>{
          const ma = channelCounts.get(a.name) || new Map();
          const mb = channelCounts.get(b2.name) || new Map();
          const ta = Array.from(ma.values()).reduce((s,v)=>s+v,0);
          const tb = Array.from(mb.values()).reduce((s,v)=>s+v,0);
          return ta - tb;
        });

        if (remaining7th.length > 0) {
          const pick7 = remaining7th[0];
          assignments[SEVENTH_CHANNEL] = pick7.name;
          usedNames.add(pick7.name);
          lastAssign.set(pick7.name, SEVENTH_CHANNEL);

          // Track 7th channel worked today (to prevent same channel twice in one day)
          if (!todayChannels.has(pick7.name)) todayChannels.set(pick7.name, new Set());
          todayChannels.get(pick7.name).add("7TH");

          // Update balancing counts for 7th
          if (!channelCounts.has(pick7.name)) channelCounts.set(pick7.name, new Map());
          const m7 = channelCounts.get(pick7.name);
          m7.set(SEVENTH_CHANNEL, (m7.get(SEVENTH_CHANNEL)||0)+1);
        }
      }
      // ========== END 7TH CHANNEL ==========

      // SD (Special Detail): Use pre-assigned SD from earlier calculation
      // SD is now assigned FIRST (32 hrs mandatory/week) before channels are filled
      const sd = sdForBlock.slice(); // Copy pre-assigned SD for this block

      // CT overflow: show as a vertical list later; CT does NOT count as a channel in cycle tracking
      const ct = [];


if (available.length > 10) {
  // CT overflow with HARD monthly caps:
  // - We try to keep CT split as evenly as possible across the month.
  // - If CT is unavoidable after caps are hit, we allow a controlled "repeat":
  //     * MAX once per week per person
  //     * MUST be back-to-back (consecutive 4-hr blocks)
    const wmap = ctWeekCounts.get(wk) || new Map();
  const globalIdx = (day-1) * BLOCKS.length + bi;

  function capFor(name){
    // HARD CAP: nobody can be assigned to CT more than 10 times per month
    return 10;
  }
  function canTakeChannel(name, ch){
    const last = lastAssign.get(name);
    if (last && (last === ch || forbiddenBackToBack(last, ch))) return false;
    // Also check daily same-channel restriction
    const candDayChannels = todayChannels.get(name);
    const chUpper = String(ch).toUpperCase();
    if (candDayChannels && candDayChannels.has(chUpper)) return false;
    return true;
  }
  function atOrOverCap(name){
    return (ctMonthCounts.get(name) || 0) >= capFor(name);
  }

  // CRITICAL: First, ensure anyone in mustGetChannelNextBlock gets a channel (to avoid Relief->CT)
  // These people were on R1/R2 last block and MUST get a channel now
  let remaining = shuffled.filter(c => !usedNames.has(c.name));

  const mustGetPeople = remaining.filter(c => mustGetChannelNextBlock.has(c.name));
  for (const cand of mustGetPeople) {
    // Try to swap them into any channel
    for (const ch of CHANNELS) {
      const cur = assignments[ch];
      if (!cur) continue; // Empty channel - shouldn't happen but skip
      if (!canTakeChannel(cand.name, ch)) continue;

      // Check if current holder can go to CT (not on CTR recently)
      const holderLast = lastAssign.get(cur);
      const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
      const ctrSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
      if (ctrSet.has(holderLastUpper)) continue; // Holder can't go to CT
      if (mustGetChannelNextBlock.has(cur)) continue; // Holder also needs a channel

      // Swap: cand gets channel, cur goes to CT pool
      assignments[ch] = cand.name;
      usedNames.add(cand.name);
      usedNames.delete(cur);
      lastAssign.set(cand.name, ch);

      const chUpper = String(ch).toUpperCase();
      if (!todayChannels.has(cand.name)) todayChannels.set(cand.name, new Set());
      todayChannels.get(cand.name).add(chUpper);

      if (!channelCounts.has(cand.name)) channelCounts.set(cand.name, new Map());
      channelCounts.get(cand.name).set(ch, (channelCounts.get(cand.name).get(ch)||0)+1);

      mustGetChannelNextBlock.delete(cand.name); // They got their channel
      break;
    }
    remaining = shuffled.filter(c => !usedNames.has(c.name));
  }

  // If someone is capped, try to swap them into a channel (so they don't land in CT),
  // pushing a non-capped person into overflow instead.
  remaining = shuffled.filter(c => !usedNames.has(c.name));

  const cappedNow = remaining.filter(c => atOrOverCap(c.name));
  for (const cand of cappedNow) {
    let swapped = false;

    for (const ch of CHANNELS) {
      const cur = assignments[ch];
      if (!cur) continue;

      // only swap out someone who is NOT capped
      if (atOrOverCap(cur)) continue;
      if (!canTakeChannel(cand.name, ch)) continue;

      // swap
      assignments[ch] = cand.name;
      usedNames.add(cand.name);
      usedNames.delete(cur);

      // keep lastAssign consistent for cand
      lastAssign.set(cand.name, ch);

      // Track swapped-in channel worked today
      const swapCH = String(ch).toUpperCase();
      if (!todayChannels.has(cand.name)) todayChannels.set(cand.name, new Set());
      todayChannels.get(cand.name).add(swapCH);

      // update balancing counts for cand
      if (!channelCounts.has(cand.name)) channelCounts.set(cand.name, new Map());
      const mm = channelCounts.get(cand.name);
      mm.set(ch, (mm.get(ch) || 0) + 1);

      swapped = true;
      break;
    }

    if (swapped) {
      remaining = shuffled.filter(c => !usedNames.has(c.name));
    }
  }

  // Now assign CT STRICTLY under the hard cap.
  // Weekly soft cap: prefer people with fewer CT this week (spread across month)
  const CT_WEEKLY_SOFT_CAP = 3; // Soft cap: try to limit CT to 3 per person per week
  remaining = shuffled.filter(c => !usedNames.has(c.name));

  // Sort priority: under weekly soft cap > under monthly cap > lowest CT counts
  // Also factor in Relief count: high Relief people should get CT priority (inverse balance)
  remaining.sort((a,b2)=>{
    const ca = ctMonthCounts.get(a.name)||0;
    const cb = ctMonthCounts.get(b2.name)||0;
    const oa = ca >= capFor(a.name);
    const ob = cb >= capFor(b2.name);

    // Weekly CT counts for spreading across month
    const wca = wmap.get(a.name)||0;
    const wcb = wmap.get(b2.name)||0;
    const woa = wca >= CT_WEEKLY_SOFT_CAP;
    const wob = wcb >= CT_WEEKLY_SOFT_CAP;

    // Priority: under monthly cap first
    if (oa !== ob) return oa ? 1 : -1;
    // Then prefer under weekly soft cap (spread CT across weeks)
    if (woa !== wob) return woa ? 1 : -1;

    // CT/Relief inverse balance: prefer people with high Relief for CT (and vice versa)
    const mA = channelCounts.get(a.name) || new Map();
    const mB = channelCounts.get(b2.name) || new Map();
    const rA = (mA.get("Relief 1") || 0) + (mA.get("Relief 2") || 0);
    const rB = (mB.get("Relief 1") || 0) + (mB.get("Relief 2") || 0);
    // Combined CT+R score: lower combined total = higher priority for CT
    // But also: high R relative to CT means they should get CT to balance
    const balA = ca - rA; // positive = more CT than R, negative = more R than CT
    const balB = cb - rB;
    // Prefer person with more Relief relative to CT (negative balance = needs more CT)
    if (balA !== balB) return balA - balB; // lower balance (more R, less CT) goes first

    // Then prefer lowest weekly CT (spread within week)
    if (wca !== wcb) return wca - wcb;
    // Then prefer lowest monthly CT
    if (ca !== cb) return ca - cb;
    return 0;
  });

  for (const cand of remaining) {
    const name = cand.name;
    // Training restriction: trainees should not be assigned to CT
    if (isTrainee(name, dayKey)) { continue; }

    // 12hr shift restriction: max 1 CT per day for 12-hour shift employees
    if (is12HrShift(cand, dateObj)) {
      const candDayCh = todayChannels.get(name);
      if (candDayCh && candDayCh.has("CT")) continue;
    }

    // STRICT: R1, R2, CT should NEVER be back-to-back in any order
    const lastCh = lastAssign.get(name);
    if (lastCh) {
      const lastUpper = String(lastCh).toUpperCase();
      if (lastUpper === "CT" || lastUpper === "RELIEF 1" || lastUpper === "RELIEF 2" || lastUpper === "R1" || lastUpper === "R2") {
        continue; // Skip - they were just on R1/R2/CT
      }
    }

    // STRICT: CT/R1/R2 should NOT repeat in the same day in any combination
    const candDayChannels = todayChannels.get(name);
    if (candDayChannels) {
      if (candDayChannels.has("CT") || candDayChannels.has("RELIEF 1") || candDayChannels.has("RELIEF 2")) {
        continue; // Skip - they already had CT/R1/R2 today
      }
    }

    const needs = getNeeds(wk, name);
    // Weekly mix rule: CT counts toward the CT/R1/R2 bucket (2 blocks / 8 hrs target)
    if ((needs.ctr || 0) <= 0) { continue; }

    const cur = ctMonthCounts.get(name) || 0;
    const cap = capFor(name);

    if (cur >= cap) {
      continue;
    }

    // Soft weekly cap: skip if over soft cap AND others are available
    const weekCt = wmap.get(name)||0;
    const othersUnderWeeklyCap = remaining.some(c =>
      c.name !== name &&
      !ct.includes(c.name) &&
      (wmap.get(c.name)||0) < CT_WEEKLY_SOFT_CAP &&
      (ctMonthCounts.get(c.name)||0) < capFor(c.name)
    );
    if (weekCt >= CT_WEEKLY_SOFT_CAP && othersUnderWeeklyCap) {
      continue; // Skip this person, let someone else take CT
    }

    ct.push(name);
    // decrement weekly CT/R bucket need
    if ((needs.ctr||0) > 0) needs.ctr -= 1;
    updateStreaks(name, "CT");
    lastAssign.set(name, "CT"); // Track CT assignment for back-to-back prevention

    // Track CT in daily channels to prevent same-day repeat
    if (!todayChannels.has(name)) todayChannels.set(name, new Set());
    todayChannels.get(name).add("CT");

    wmap.set(name, (wmap.get(name) || 0) + 1);
    ctMonthCounts.set(name, cur + 1);
    lastCTAt.set(name, {dayKey, blockIdx: bi});
    lastCTGlobalIdx.set(name, globalIdx);
  }

  ctWeekCounts.set(wk, wmap);
}

// SAFETY NET: Anyone who is available but wasn't assigned to a channel or CT
// For people who were on CT/R1/R2, we MUST get them a channel to avoid back-to-back
const unassigned = available.filter(d => !usedNames.has(d.name));
const ctrNames = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);

for (const u of unassigned) {
  if (ct.includes(u.name)) continue;

  const lastCh = lastAssign.get(u.name);
  const lastUpper = lastCh ? String(lastCh).toUpperCase() : "";
  const wasOnCTR = ctrNames.has(lastUpper);

  // Also check if they had any CTR today (not just last block)
  const uDayChans = todayChannels.get(u.name);
  const hadCTRToday = uDayChans && (uDayChans.has("CT") || uDayChans.has("RELIEF 1") || uDayChans.has("RELIEF 2"));

  if (wasOnCTR || hadCTRToday) {
    // They were on CT/R1/R2 - MUST get a channel, not CT
    // Try to find an empty channel first
    let foundChannel = false;
    for (const ch of CHANNELS) {
      if (assignments[ch]) continue; // Already filled
      const chUpper = String(ch).toUpperCase();
      if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue; // Can't do R1/R2
      // Check daily same-channel restriction
      const uDayChannels = todayChannels.get(u.name);
      if (uDayChannels && uDayChannels.has(chUpper)) continue;
      if (!forbiddenBackToBack(lastUpper, chUpper)) {
        assignments[ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, ch);
        // Track channel worked today
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(chUpper);
        foundChannel = true;
        break;
      }
    }

    // If no empty channel, SWAP with someone who CAN go to CT (prefer no violations)
    if (!foundChannel) {
      const swapCands1 = [];
      for (const ch of CHANNELS) {
        const currentHolder = assignments[ch];
        if (!currentHolder) continue;
        const chUpper = String(ch).toUpperCase();
        if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue;
        if (forbiddenBackToBack(lastUpper, chUpper)) continue;
        const uDayChannels = todayChannels.get(u.name);
        if (uDayChannels && uDayChannels.has(chUpper)) continue;

        const holderLast = lastAssign.get(currentHolder);
        const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
        const holderWasOnCTR = ctrNames.has(holderLastUpper);
        const holderDayChannels = todayChannels.get(currentHolder);
        const holderHadCTToday = holderDayChannels && holderDayChannels.has("CT");
        const holderCTCount = ctMonthCounts.get(currentHolder) || 0;
        const holderAtCap = holderCTCount >= 10;

        if (!holderWasOnCTR && !holderHadCTToday && !holderAtCap) {
          const holderViol = violationCount.get(currentHolder.toUpperCase()) || 0;
          swapCands1.push({ ch, chUpper, currentHolder, holderCTCount, holderViol });
        }
      }
      // Sort: no violations first, then lowest CT
      swapCands1.sort((a, b) => {
        if (a.holderViol !== b.holderViol) return a.holderViol - b.holderViol;
        return a.holderCTCount - b.holderCTCount;
      });
      if (swapCands1.length > 0) {
        const best = swapCands1[0];
        assignments[best.ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, best.ch);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(best.chUpper);

        ct.push(best.currentHolder);
        lastAssign.set(best.currentHolder, "CT");
        updateStreaks(best.currentHolder, "CT");
        if (!todayChannels.has(best.currentHolder)) todayChannels.set(best.currentHolder, new Set());
        todayChannels.get(best.currentHolder).add("CT");
        ctMonthCounts.set(best.currentHolder, best.holderCTCount + 1);
        const wkMap = ctWeekCounts.get(wk) || new Map();
        wkMap.set(best.currentHolder, (wkMap.get(best.currentHolder) || 0) + 1);
        ctWeekCounts.set(wk, wkMap);

        foundChannel = true;
      }
    }

    // If still no channel, try harder to swap - find ANY channel holder who can go to CT (prefer no violations)
    if (!foundChannel) {
      const swapCands2 = [];
      for (const ch of CHANNELS) {
        const currentHolder = assignments[ch];
        if (!currentHolder) continue;
        const chUpper = String(ch).toUpperCase();
        if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue;
        if (forbiddenBackToBack(lastUpper, chUpper)) continue;
        const uDayChannels = todayChannels.get(u.name);
        if (uDayChannels && uDayChannels.has(chUpper)) continue;

        const holderLast = lastAssign.get(currentHolder);
        const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
        const holderWasOnCTR = ctrNames.has(holderLastUpper);
        const holderDayChannels = todayChannels.get(currentHolder);
        const holderHadCTRToday = holderDayChannels && (holderDayChannels.has("CT") || holderDayChannels.has("RELIEF 1") || holderDayChannels.has("RELIEF 2"));
        const holderCTCount2 = ctMonthCounts.get(currentHolder) || 0;
        const holderAtCap2 = holderCTCount2 >= 10;

        if (!holderWasOnCTR && !holderHadCTRToday && !holderAtCap2) {
          const holderViol = violationCount.get(currentHolder.toUpperCase()) || 0;
          swapCands2.push({ ch, chUpper, currentHolder, holderCTCount2, holderViol });
        }
      }
      // Sort: no violations first, then lowest CT
      swapCands2.sort((a, b) => {
        if (a.holderViol !== b.holderViol) return a.holderViol - b.holderViol;
        return a.holderCTCount2 - b.holderCTCount2;
      });
      if (swapCands2.length > 0) {
        const best = swapCands2[0];
        assignments[best.ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, best.ch);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(best.chUpper);

        ct.push(best.currentHolder);
        lastAssign.set(best.currentHolder, "CT");
        updateStreaks(best.currentHolder, "CT");
        if (!todayChannels.has(best.currentHolder)) todayChannels.set(best.currentHolder, new Set());
        todayChannels.get(best.currentHolder).add("CT");
        ctMonthCounts.set(best.currentHolder, best.holderCTCount2 + 1);
        const wkMap2 = ctWeekCounts.get(wk) || new Map();
        wkMap2.set(best.currentHolder, (wkMap2.get(best.currentHolder) || 0) + 1);
        ctWeekCounts.set(wk, wkMap2);

        foundChannel = true;
      }
    }

    // THIRD ATTEMPT: Allow swapping with someone OVER cap (uneven CT is better than violation)
    // Sort by CT count to prefer swapping with lowest CT person even if over cap
    if (!foundChannel) {
      const swapCandidates = [];
      for (const ch of CHANNELS) {
        const currentHolder = assignments[ch];
        if (!currentHolder) continue;
        const chUpper = String(ch).toUpperCase();
        if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue;
        if (forbiddenBackToBack(lastUpper, chUpper)) continue;
        const uDayChannels = todayChannels.get(u.name);
        if (uDayChannels && uDayChannels.has(chUpper)) continue;

        const holderLast = lastAssign.get(currentHolder);
        const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
        const holderWasOnCTR = ctrNames.has(holderLastUpper);
        const holderDayChannels = todayChannels.get(currentHolder);
        const holderHadCTRToday = holderDayChannels && (holderDayChannels.has("CT") || holderDayChannels.has("RELIEF 1") || holderDayChannels.has("RELIEF 2"));

        // Allow over-cap, but skip if they were on CTR or had CTR today (would cause violation)
        if (!holderWasOnCTR && !holderHadCTRToday) {
          const holderCT = ctMonthCounts.get(currentHolder) || 0;
          swapCandidates.push({ ch, chUpper, currentHolder, holderCT });
        }
      }

      // Sort by: 1) no violations first, 2) lowest CT count
      swapCandidates.sort((a, b) => {
        const aViol = violationCount.get(a.currentHolder.toUpperCase()) || 0;
        const bViol = violationCount.get(b.currentHolder.toUpperCase()) || 0;
        if (aViol !== bViol) return aViol - bViol; // Prefer no violations
        return a.holderCT - b.holderCT;
      });

      if (swapCandidates.length > 0) {
        const best = swapCandidates[0];
        assignments[best.ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, best.ch);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(best.chUpper);

        ct.push(best.currentHolder);
        lastAssign.set(best.currentHolder, "CT");
        updateStreaks(best.currentHolder, "CT");
        if (!todayChannels.has(best.currentHolder)) todayChannels.set(best.currentHolder, new Set());
        todayChannels.get(best.currentHolder).add("CT");
        ctMonthCounts.set(best.currentHolder, best.holderCT + 1);
        const wkMap3 = ctWeekCounts.get(wk) || new Map();
        wkMap3.set(best.currentHolder, (wkMap3.get(best.currentHolder) || 0) + 1);
        ctWeekCounts.set(wk, wkMap3);

        foundChannel = true;
      }
    }

    // Last resort: if still no channel, assign CT (violation is unavoidable)
    if (!foundChannel) {
      ct.push(u.name);
      lastAssign.set(u.name, "CT");
      updateStreaks(u.name, "CT");
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add("CT");
      // UPDATE CT COUNTS
      ctMonthCounts.set(u.name, (ctMonthCounts.get(u.name) || 0) + 1);
      const wkMapLR = ctWeekCounts.get(wk) || new Map();
      wkMapLR.set(u.name, (wkMapLR.get(u.name) || 0) + 1);
      ctWeekCounts.set(wk, wkMapLR);
      // TRACK VIOLATION (Relief->CT back-to-back)
      addViolation(u.name);
    }
  } else {
    // They weren't on CT/R1/R2 - check if they already had any CTR today
    const uDayChannels = todayChannels.get(u.name);
    const uHadCTRToday = uDayChannels && (uDayChannels.has("CT") || uDayChannels.has("RELIEF 1") || uDayChannels.has("RELIEF 2"));
    // Also check if they're at or over monthly CT cap
    const uCTCount = ctMonthCounts.get(u.name) || 0;
    if (!uHadCTRToday && uCTCount < 10) {
      ct.push(u.name);
      lastAssign.set(u.name, "CT");
      updateStreaks(u.name, "CT");
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add("CT");
      // UPDATE CT COUNTS
      ctMonthCounts.set(u.name, uCTCount + 1);
      const wkMapElse = ctWeekCounts.get(wk) || new Map();
      wkMapElse.set(u.name, (wkMapElse.get(u.name) || 0) + 1);
      ctWeekCounts.set(wk, wkMapElse);
    }
    // If they already had CTR today or at cap, force CT anyway — unassigned is never acceptable
    if (!ct.includes(u.name) && !usedNames.has(u.name)) {
      ct.push(u.name);
      lastAssign.set(u.name, "CT");
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add("CT");
      ctMonthCounts.set(u.name, (ctMonthCounts.get(u.name) || 0) + 1);
      const wkMapForce = ctWeekCounts.get(wk) || new Map();
      wkMapForce.set(u.name, (wkMapForce.get(u.name) || 0) + 1);
      ctWeekCounts.set(wk, wkMapForce);
    }
  }
}

// FINAL SWEEP: Catch anyone still not assigned (trainees, edge cases) — force to CT
const finalUnassigned = available.filter(d => !usedNames.has(d.name) && !ct.includes(d.name) && !sd.includes(d.name));
for (const u of finalUnassigned) {
  // 12hr shift: max 1 CT per day — skip if already had CT today
  if (is12HrShift(u, dateObj)) {
    const uDayCh = todayChannels.get(u.name);
    if (uDayCh && uDayCh.has("CT")) continue;
  }
  ct.push(u.name);
  lastAssign.set(u.name, "CT");
  if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
  todayChannels.get(u.name).add("CT");
  ctMonthCounts.set(u.name, (ctMonthCounts.get(u.name) || 0) + 1);
  const wkMapFinal = ctWeekCounts.get(wk) || new Map();
  wkMapFinal.set(u.name, (wkMapFinal.get(u.name) || 0) + 1);
  ctWeekCounts.set(wk, wkMapFinal);
}

      plan.days[dayKey][b.key] = { assignments, sd, ct, filled, needed: 10 };
    }
  }

  // ========== POST-PROCESSING: CHANNEL REBALANCING PASS ==========
  // Scan for per-channel imbalances and swap assignments to even them out.
  // Goal: every person should have a roughly equal count of each primary channel.
  const _ctrChSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2","DC1","DC2"]);
  // Only rebalance primary channels (N,S,E,W,NW,C)
  const rebalanceChannels = CHANNELS.filter(ch => !_ctrChSet.has(ch.toUpperCase()));

  // Build per-person channel counts from the final plan
  const finalCounts = new Map(); // name -> Map(channel -> count)
  const allAssignments = []; // [{dayKey, blockKey, channel, name}]
  {

    for (let day = 1; day <= daysInMonth; day++) {
      const dObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
      const dk = ymd(dObj);
      const dayData = plan.days[dk];
      if (!dayData) continue;
      for (const bk of BLOCKS) {
        const bd = dayData[bk.key];
        if (!bd || !bd.assignments) continue;
        for (const [ch, nm] of Object.entries(bd.assignments)) {
          if (!nm) continue;
          if (!finalCounts.has(nm)) finalCounts.set(nm, new Map());
          finalCounts.get(nm).set(ch, (finalCounts.get(nm).get(ch)||0) + 1);
          allAssignments.push({dayKey: dk, blockKey: bk.key, channel: ch, name: nm});
        }
      }
    }

    // Helper: get all channels a person works on a given day (for same-day-twice check)
    function _rebalDayChannels(personName, dayKey, excludeBlockKey) {
      const chs = new Set();
      const dayData = plan.days[dayKey];
      if (!dayData) return chs;
      for (const bk of BLOCKS) {
        if (bk.key === excludeBlockKey) continue;
        const bd = dayData[bk.key];
        if (!bd) continue;
        for (const [ch, nm] of Object.entries(bd.assignments || {})) {
          if (nm && String(nm).toUpperCase() === String(personName).toUpperCase()) chs.add(ch.toUpperCase());
        }
      }
      return chs;
    }

    // Run up to 10 rebalancing rounds
    for (let round = 0; round < 10; round++) {
      let swapped = false;
      const people = Array.from(finalCounts.keys());

      // Build swap candidates: pairs where one person has more of a channel than the other
      const swapCandidates = [];
      for (let i = 0; i < people.length; i++) {
        for (let j = i+1; j < people.length; j++) {
          const a = people[i], b = people[j];
          const ma = finalCounts.get(a), mb = finalCounts.get(b);
          for (const ch of rebalanceChannels) {
            const ca = ma.get(ch)||0, cb = mb.get(ch)||0;
            const diff = Math.abs(ca - cb);
            if (diff >= 2) {
              swapCandidates.push({a, b, ch, ca, cb, diff});
            }
          }
        }
      }
      // Sort by biggest imbalance first
      swapCandidates.sort((x,y) => y.diff - x.diff);

      for (const {a, b, ch, ca, cb} of swapCandidates) {
        // Determine who has more and who has less
        const over = ca > cb ? a : b;
        const under = ca > cb ? b : a;

        // Find a block where 'over' is on 'ch' and 'under' is on a different primary channel
        for (const entry of allAssignments) {
          if (entry.name !== over || entry.channel !== ch) continue;
          const dk = entry.dayKey, bk = entry.blockKey;
          const bd = plan.days[dk] && plan.days[dk][bk];
          if (!bd || !bd.assignments) continue;

          // Find what 'under' is assigned to in this same block
          let underCh = null;
          for (const [c2, nm2] of Object.entries(bd.assignments)) {
            if (nm2 === under) { underCh = c2; break; }
          }
          if (!underCh) continue; // 'under' doesn't work this block
          if (_ctrChSet.has(underCh.toUpperCase())) continue; // Don't swap CTR/DC channels
          if (underCh === ch) continue; // Same channel, no point

          // Re-check current counts to ensure swap still helps
          const overCounts = finalCounts.get(over);
          const underCounts = finalCounts.get(under);
          const overOnCh = overCounts.get(ch)||0;
          const underOnCh = underCounts.get(ch)||0;
          const overOnUnderCh = overCounts.get(underCh)||0;
          const underOnUnderCh = underCounts.get(underCh)||0;

          // Only swap if it reduces the spread for both channels
          if (overOnCh - underOnCh < 2) continue; // No longer imbalanced enough
          if (underOnUnderCh - overOnUnderCh < -1) continue; // Would create reverse imbalance

          // Safety: check same-channel-twice-in-day for both parties
          const overOtherChs = _rebalDayChannels(over, dk, bk);
          if (overOtherChs.has(underCh.toUpperCase())) continue; // 'over' already has underCh elsewhere today

          const underOtherChs = _rebalDayChannels(under, dk, bk);
          if (underOtherChs.has(ch.toUpperCase())) continue; // 'under' already has ch elsewhere today

          // Perform the swap
          bd.assignments[ch] = under;
          bd.assignments[underCh] = over;

          // Update finalCounts
          overCounts.set(ch, (overCounts.get(ch)||0) - 1);
          overCounts.set(underCh, (overCounts.get(underCh)||0) + 1);
          underCounts.set(ch, (underCounts.get(ch)||0) + 1);
          underCounts.set(underCh, (underCounts.get(underCh)||0) - 1);

          // Update allAssignments entries
          entry.name = under;
          for (const e2 of allAssignments) {
            if (e2.dayKey === dk && e2.blockKey === bk && e2.name === under && e2.channel === underCh) {
              e2.name = over;
              break;
            }
          }

          swapped = true;
          break; // Move to next imbalance pair
        }
      }
      if (!swapped) break; // No more swaps possible
    }

    // --- Phase 2: Fine-tuning pass (diff >= 1, both parties must move toward average) ---
    // Compute per-channel averages across all people
    const chAvgs = new Map();
    for (const ch of rebalanceChannels) {
      let sum = 0, cnt = 0;
      for (const [nm, m] of finalCounts) {
        sum += (m.get(ch) || 0);
        cnt++;
      }
      chAvgs.set(ch, cnt > 0 ? sum / cnt : 0);
    }

    for (let round = 0; round < 10; round++) {
      let swapped = false;
      const people = Array.from(finalCounts.keys());

      const fineCandidates = [];
      for (let i = 0; i < people.length; i++) {
        for (let j = i + 1; j < people.length; j++) {
          const a = people[i], b = people[j];
          const ma = finalCounts.get(a), mb = finalCounts.get(b);
          for (const ch of rebalanceChannels) {
            const ca = ma.get(ch) || 0, cb = mb.get(ch) || 0;
            const avg = chAvgs.get(ch) || 0;
            // One must be above avg and the other below (or at) avg, with diff >= 1
            if (ca > cb && ca > avg && cb < avg) {
              fineCandidates.push({ over: a, under: b, ch, overCount: ca, underCount: cb, diff: ca - cb });
            } else if (cb > ca && cb > avg && ca < avg) {
              fineCandidates.push({ over: b, under: a, ch, overCount: cb, underCount: ca, diff: cb - ca });
            }
          }
        }
      }
      // Sort by biggest gap first
      fineCandidates.sort((a, b) => b.diff - a.diff);

      for (const { over, under, ch } of fineCandidates) {
        const overCounts = finalCounts.get(over);
        const underCounts = finalCounts.get(under);
        const overOnCh = overCounts.get(ch) || 0;
        const underOnCh = underCounts.get(ch) || 0;
        const avg = chAvgs.get(ch) || 0;
        if (overOnCh <= avg || underOnCh >= avg) continue; // No longer straddles average

        for (const entry of allAssignments) {
          if (entry.name !== over || entry.channel !== ch) continue;
          const dk = entry.dayKey, bk = entry.blockKey;
          const bd = plan.days[dk] && plan.days[dk][bk];
          if (!bd || !bd.assignments) continue;

          let underCh = null;
          for (const [c2, nm2] of Object.entries(bd.assignments)) {
            if (nm2 === under) { underCh = c2; break; }
          }
          if (!underCh) continue;
          if (_ctrChSet.has(underCh.toUpperCase())) continue;
          if (underCh === ch) continue;

          // Verify both channels improve: over loses ch (good), under gains ch (good),
          // but also check the swap channel doesn't create a worse imbalance
          const overOnUnderCh = overCounts.get(underCh) || 0;
          const underOnUnderCh = underCounts.get(underCh) || 0;
          const underChAvg = chAvgs.get(underCh) || 0;
          // Don't swap if it would push 'under' further above average on underCh
          // or push 'over' further above average on underCh
          if (overOnUnderCh + 1 > underChAvg + 1.5) continue;
          if (underOnUnderCh - 1 < underChAvg - 1.5) continue;

          // Same-day-channel-twice safety
          const overOtherChs = _rebalDayChannels(over, dk, bk);
          if (overOtherChs.has(underCh.toUpperCase())) continue;
          const underOtherChs = _rebalDayChannels(under, dk, bk);
          if (underOtherChs.has(ch.toUpperCase())) continue;

          // Perform the swap
          bd.assignments[ch] = under;
          bd.assignments[underCh] = over;

          overCounts.set(ch, (overCounts.get(ch) || 0) - 1);
          overCounts.set(underCh, (overCounts.get(underCh) || 0) + 1);
          underCounts.set(ch, (underCounts.get(ch) || 0) + 1);
          underCounts.set(underCh, (underCounts.get(underCh) || 0) - 1);

          entry.name = under;
          for (const e2 of allAssignments) {
            if (e2.dayKey === dk && e2.blockKey === bk && e2.name === under && e2.channel === underCh) {
              e2.name = over;
              break;
            }
          }

          swapped = true;
          break;
        }
      }
      if (!swapped) break;
    }

    // --- Phase 3: Minimum floor enforcement (no one should have only 0 or 1 of any primary channel) ---
    const HARD_FLOOR = 2; // absolute minimum per channel

    // Build a lookup: for each person, which blocks do they appear in?
    const personBlocks = new Map(); // name -> [{dayKey, blockKey, channel}]
    for (const entry of allAssignments) {
      if (!personBlocks.has(entry.name)) personBlocks.set(entry.name, []);
      personBlocks.get(entry.name).push(entry);
    }

    for (let round = 0; round < 30; round++) {
      let swapped = false;
      const people = Array.from(finalCounts.keys());

      // Find people below the floor on any primary channel
      const deficits = [];
      for (const person of people) {
        const m = finalCounts.get(person);
        let totalPrimary = 0;
        for (const ch of rebalanceChannels) totalPrimary += (m.get(ch) || 0);
        // Skip people who don't have enough total primary blocks to meet floor across all channels
        // (e.g. SD people with only ~8 blocks can't have 2 of each of 6 channels = 12 needed)
        if (totalPrimary < HARD_FLOOR * rebalanceChannels.length) continue;

        for (const ch of rebalanceChannels) {
          const cnt = m.get(ch) || 0;
          if (cnt < HARD_FLOOR) {
            deficits.push({ person, ch, count: cnt, deficit: HARD_FLOOR - cnt });
          }
        }
      }
      if (deficits.length === 0) break;
      deficits.sort((a, b) => b.deficit - a.deficit); // worst deficits first

      for (const { person: under, ch } of deficits) {
        const underCounts = finalCounts.get(under);
        if ((underCounts.get(ch) || 0) >= HARD_FLOOR) continue;

        // Scan blocks where 'under' works — find a block-mate who has 'ch' and can donate
        const underBlocks = personBlocks.get(under) || [];
        let didSwap = false;

        for (const uEntry of underBlocks) {
          if (_ctrChSet.has(uEntry.channel.toUpperCase())) continue;
          if (uEntry.channel === ch) continue;

          const dk = uEntry.dayKey, bk = uEntry.blockKey;
          const bd = plan.days[dk] && plan.days[dk][bk];
          if (!bd || !bd.assignments) continue;

          if (bd.assignments[uEntry.channel] !== under) continue;

          const donor = bd.assignments[ch];
          if (!donor || donor === under) continue;

          const donorCounts = finalCounts.get(donor);
          if (!donorCounts) continue;
          // Donor must have at least 3 of this channel (keeps them at 2+ after giving one)
          if ((donorCounts.get(ch) || 0) < 3) continue;

          const underCh = uEntry.channel;

          // Under must keep at least 2 of the channel they're giving up
          if ((underCounts.get(underCh) || 0) < 3) continue;

          // Don't push donor too far above avg on the channel they receive
          const donorOnUnderCh = donorCounts.get(underCh) || 0;
          const ucAvg = chAvgs.get(underCh) || 0;
          if (donorOnUnderCh + 1 > ucAvg + 3) continue;

          // Same-day-channel-twice safety
          const donorOtherChs = _rebalDayChannels(donor, dk, bk);
          if (donorOtherChs.has(underCh.toUpperCase())) continue;
          const underOtherChs = _rebalDayChannels(under, dk, bk);
          if (underOtherChs.has(ch.toUpperCase())) continue;

          bd.assignments[ch] = under;
          bd.assignments[underCh] = donor;

          donorCounts.set(ch, (donorCounts.get(ch) || 0) - 1);
          donorCounts.set(underCh, (donorCounts.get(underCh) || 0) + 1);
          underCounts.set(ch, (underCounts.get(ch) || 0) + 1);
          underCounts.set(underCh, (underCounts.get(underCh) || 0) - 1);

          uEntry.channel = ch;
          for (const e2 of allAssignments) {
            if (e2.dayKey === dk && e2.blockKey === bk && e2.name === donor && e2.channel === ch) {
              e2.channel = underCh;
              break;
            }
          }

          swapped = true;
          didSwap = true;
          break;
        }
      }
      if (!swapped) break;
    }

    // --- Phase 4: Emergency floor — aggressively fix anyone still at 0 or 1 ---
    // Relaxes constraints: donor only needs > 2, under can give up down to 2
    for (let round = 0; round < 30; round++) {
      let swapped = false;
      const people = Array.from(finalCounts.keys());

      const deficits = [];
      for (const person of people) {
        const m = finalCounts.get(person);
        let totalPrimary = 0;
        for (const ch of rebalanceChannels) totalPrimary += (m.get(ch) || 0);
        if (totalPrimary < HARD_FLOOR * rebalanceChannels.length) continue;

        for (const ch of rebalanceChannels) {
          const cnt = m.get(ch) || 0;
          if (cnt < HARD_FLOOR) {
            deficits.push({ person, ch, count: cnt, deficit: HARD_FLOOR - cnt });
          }
        }
      }
      if (deficits.length === 0) break;
      deficits.sort((a, b) => b.deficit - a.deficit);

      for (const { person: under, ch } of deficits) {
        const underCounts = finalCounts.get(under);
        if ((underCounts.get(ch) || 0) >= HARD_FLOOR) continue;

        const underBlocks = personBlocks.get(under) || [];
        let didSwap = false;

        for (const uEntry of underBlocks) {
          if (_ctrChSet.has(uEntry.channel.toUpperCase())) continue;
          if (uEntry.channel === ch) continue;

          const dk = uEntry.dayKey, bk = uEntry.blockKey;
          const bd = plan.days[dk] && plan.days[dk][bk];
          if (!bd || !bd.assignments) continue;
          if (bd.assignments[uEntry.channel] !== under) continue;

          const donor = bd.assignments[ch];
          if (!donor || donor === under) continue;

          const donorCounts = finalCounts.get(donor);
          if (!donorCounts) continue;
          // Relaxed: donor just needs > 2 (keeps them at 2 after giving)
          if ((donorCounts.get(ch) || 0) <= 2) continue;

          const underCh = uEntry.channel;
          // Relaxed: under just needs > 1 (keeps them at 1 after giving — not ideal but fixes a 0)
          if ((underCounts.get(underCh) || 0) <= 1) continue;

          // Same-day-channel-twice safety
          const donorOtherChs = _rebalDayChannels(donor, dk, bk);
          if (donorOtherChs.has(underCh.toUpperCase())) continue;
          const underOtherChs = _rebalDayChannels(under, dk, bk);
          if (underOtherChs.has(ch.toUpperCase())) continue;

          bd.assignments[ch] = under;
          bd.assignments[underCh] = donor;

          donorCounts.set(ch, (donorCounts.get(ch) || 0) - 1);
          donorCounts.set(underCh, (donorCounts.get(underCh) || 0) + 1);
          underCounts.set(ch, (underCounts.get(ch) || 0) + 1);
          underCounts.set(underCh, (underCounts.get(underCh) || 0) - 1);

          uEntry.channel = ch;
          for (const e2 of allAssignments) {
            if (e2.dayKey === dk && e2.blockKey === bk && e2.name === donor && e2.channel === ch) {
              e2.channel = underCh;
              break;
            }
          }

          swapped = true;
          didSwap = true;
          break;
        }
      }
      if (!swapped) break;
    }
  }
  // ========== END CHANNEL REBALANCING PASS ==========

  // ========== PER-SHIFT AGGRESSIVE BALANCING (Day, Night, Split) ==========
  // Generic function that balances primary channels for a group of people.
  // Called once for each shift group so all shifts get equal treatment.
  {
    const DAY_BLK_SET = new Set(["0600-1000","1000-1400","1400-1800"]);
    const ctrExclude = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2","DC1","DC2"]);

    // Classify everyone into shift groups
    const personShiftType = new Map(); // name -> {day, night}
    for (const entry of allAssignments) {
      if (!personShiftType.has(entry.name)) personShiftType.set(entry.name, { day: false, night: false });
      const s = personShiftType.get(entry.name);
      if (DAY_BLK_SET.has(entry.blockKey)) s.day = true; else s.night = true;
    }
    const dayOnlyPeople = new Set(), nightOnlyPeople = new Set(), splitPeople = new Set();
    for (const [name, s] of personShiftType) {
      if (SD_ELIGIBLE.has(name.toUpperCase())) continue; // SD people handled separately
      if (s.day && s.night) splitPeople.add(name);
      else if (s.day) dayOnlyPeople.add(name);
      else nightOnlyPeople.add(name);
    }

    // Helper: day channels for a person on a given day excluding one block
    function _shiftDayChannels(personName, dayKey, excludeBlockKey) {
      const chs = new Set();
      const dayData = plan.days[dayKey];
      if (!dayData) return chs;
      for (const bk of BLOCKS) {
        if (bk.key === excludeBlockKey) continue;
        const bd = dayData[bk.key];
        if (!bd) continue;
        for (const [ch, nm] of Object.entries(bd.assignments || {})) {
          if (nm === personName) chs.add(ch.toUpperCase());
        }
      }
      return chs;
    }

    function _balanceShiftGroup(groupName, groupPeople) {
      if (groupPeople.size < 2) return;

      // Rebuild counts for this group
      const grpCounts = new Map(); // name -> Map(channel -> count)
      const grpAssignments = []; // only assignments from this group
      for (const entry of allAssignments) {
        if (!groupPeople.has(entry.name)) continue;
        if (!grpCounts.has(entry.name)) grpCounts.set(entry.name, new Map());
        grpCounts.get(entry.name).set(entry.channel, (grpCounts.get(entry.name).get(entry.channel) || 0) + 1);
        grpAssignments.push(entry);
      }

      const grpPrimary = rebalanceChannels; // N,E,S,W,NW,C
      const grpAvgs = new Map();

      // Helper: perform a swap, updating grpCounts + finalCounts + grpAssignments
      function _grpSwap(personA, chA, personB, chB, dk, bk, bd, entryToUpdate) {
        bd.assignments[chA] = personB;
        bd.assignments[chB] = personA;
        const cA = grpCounts.get(personA), cB = grpCounts.get(personB);
        cA.set(chA, (cA.get(chA) || 0) - 1); cA.set(chB, (cA.get(chB) || 0) + 1);
        cB.set(chB, (cB.get(chB) || 0) - 1); cB.set(chA, (cB.get(chA) || 0) + 1);
        const fA = finalCounts.get(personA), fB = finalCounts.get(personB);
        if (fA) { fA.set(chA, (fA.get(chA) || 0) - 1); fA.set(chB, (fA.get(chB) || 0) + 1); }
        if (fB) { fB.set(chB, (fB.get(chB) || 0) - 1); fB.set(chA, (fB.get(chA) || 0) + 1); }
        if (entryToUpdate) entryToUpdate.channel = chB;
        for (const e2 of grpAssignments) {
          if (e2.dayKey === dk && e2.blockKey === bk && e2.name === personB && e2.channel === chB) {
            e2.channel = chA; break;
          }
        }
      }

      const GRP_FLOOR = 2;
      const GRP_CEIL = 4;

      // 6 passes: pairwise(strict/relaxed), ceiling(strict), floor(strict), ceiling(relaxed), floor(relaxed)
      for (let pass = 0; pass < 6; pass++) {
        const minDiff = pass === 0 ? 3 : 2;

        for (let round = 0; round < 80; round++) {
          let swapped = false;

          // Recompute averages each round
          for (const ch of grpPrimary) {
            let sum = 0;
            for (const [, m] of grpCounts) sum += (m.get(ch) || 0);
            grpAvgs.set(ch, sum / groupPeople.size);
          }

          if (pass <= 1) {
            // --- Pairwise balancing ---
            const candidates = [];
            const people = Array.from(groupPeople);
            for (let i = 0; i < people.length; i++) {
              for (let j = i + 1; j < people.length; j++) {
                const a = people[i], b = people[j];
                const ma = grpCounts.get(a), mb = grpCounts.get(b);
                for (const ch of grpPrimary) {
                  const ca = (ma.get(ch) || 0), cb = (mb.get(ch) || 0);
                  const diff = Math.abs(ca - cb);
                  if (diff >= minDiff) {
                    const over = ca > cb ? a : b, under = ca > cb ? b : a;
                    candidates.push({ over, under, ch, diff });
                  }
                }
              }
            }
            candidates.sort((a, b) => b.diff - a.diff);

            for (const { over, under, ch } of candidates) {
              const overC = grpCounts.get(over), underC = grpCounts.get(under);
              if ((overC.get(ch) || 0) - (underC.get(ch) || 0) < minDiff) continue;

              for (const entry of grpAssignments) {
                if (entry.name !== over || entry.channel !== ch) continue;
                const dk = entry.dayKey, bk = entry.blockKey;
                const bd = plan.days[dk] && plan.days[dk][bk];
                if (!bd || !bd.assignments || bd.assignments[ch] !== over) continue;

                let underCh = null;
                for (const [c2, nm2] of Object.entries(bd.assignments)) {
                  if (nm2 === under) { underCh = c2; break; }
                }
                if (!underCh || ctrExclude.has(underCh.toUpperCase()) || underCh === ch) continue;
                if ((underC.get(underCh) || 0) <= 2) continue;
                if ((overC.get(ch) || 0) <= 2) continue;

                const overDayChs = _shiftDayChannels(over, dk, bk);
                if (overDayChs.has(underCh.toUpperCase())) continue;
                const underDayChs = _shiftDayChannels(under, dk, bk);
                if (underDayChs.has(ch.toUpperCase())) continue;

                _grpSwap(over, ch, under, underCh, dk, bk, bd, entry);
                swapped = true;
                break;
              }
            }

          } else if (pass === 2 || pass === 4) {
            // --- Ceiling enforcement: bring anyone > GRP_CEIL down ---
            // pass 4: relaxed — donor can go to 2, skip avg check
            const ceilRelaxed = pass === 4;
            for (const person of groupPeople) {
              const pc = grpCounts.get(person);
              for (const ch of grpPrimary) {
                if ((pc.get(ch) || 0) <= GRP_CEIL) continue;

                let didSwap = false;
                for (const entry of grpAssignments) {
                  if (entry.name !== person || entry.channel !== ch) continue;
                  const dk = entry.dayKey, bk = entry.blockKey;
                  const bd = plan.days[dk] && plan.days[dk][bk];
                  if (!bd || !bd.assignments || bd.assignments[ch] !== person) continue;

                  for (const [c2, nm2] of Object.entries(bd.assignments)) {
                    if (!nm2 || nm2 === person || c2 === ch) continue;
                    if (ctrExclude.has(c2.toUpperCase())) continue;
                    if (!groupPeople.has(nm2)) continue;

                    const otherC = grpCounts.get(nm2);
                    const personOnC2 = pc.get(c2) || 0;
                    if (!ceilRelaxed) {
                      const avgC2 = grpAvgs.get(c2) || 0;
                      if (personOnC2 >= avgC2) continue;
                    }
                    if ((otherC.get(c2) || 0) <= (ceilRelaxed ? 1 : 2)) continue;

                    const pDayChs = _shiftDayChannels(person, dk, bk);
                    if (pDayChs.has(c2.toUpperCase())) continue;
                    const oDayChs = _shiftDayChannels(nm2, dk, bk);
                    if (oDayChs.has(ch.toUpperCase())) continue;

                    _grpSwap(person, ch, nm2, c2, dk, bk, bd, entry);
                    swapped = true;
                    didSwap = true;
                    break;
                  }
                  if (didSwap) break;
                }
              }
            }

          } else {
            // --- Floor enforcement (pass 3 strict, pass 5 relaxed) ---
            const floorRelaxed = pass === 5;
            for (const under of groupPeople) {
              const underC = grpCounts.get(under);
              for (const ch of grpPrimary) {
                if ((underC.get(ch) || 0) >= GRP_FLOOR) continue;

                for (const uEntry of grpAssignments) {
                  if (uEntry.name !== under) continue;
                  if (ctrExclude.has(uEntry.channel.toUpperCase())) continue;
                  if (uEntry.channel === ch) continue;

                  const dk = uEntry.dayKey, bk = uEntry.blockKey;
                  const bd = plan.days[dk] && plan.days[dk][bk];
                  if (!bd || !bd.assignments || bd.assignments[uEntry.channel] !== under) continue;

                  const donor = bd.assignments[ch];
                  if (!donor || !groupPeople.has(donor)) continue;
                  const donorC = grpCounts.get(donor);
                  if ((donorC.get(ch) || 0) <= (floorRelaxed ? 1 : 2)) continue;

                  const underCh = uEntry.channel;
                  if ((underC.get(underCh) || 0) <= (floorRelaxed ? 0 : 1)) continue;

                  const donorDayChs = _shiftDayChannels(donor, dk, bk);
                  if (donorDayChs.has(underCh.toUpperCase())) continue;
                  const underDayChs = _shiftDayChannels(under, dk, bk);
                  if (underDayChs.has(ch.toUpperCase())) continue;

                  _grpSwap(under, uEntry.channel, donor, ch, dk, bk, bd, uEntry);
                  swapped = true;
                  break;
                }
              }
            }
          }

          if (!swapped) break;
        }
      }

      // ========= EXTREME OUTLIER PASS: target anyone > 6 on any primary channel =========
      const EXTREME_CEIL = 5;
      const extremeSkip = new Set(); // track unfixable (person|ch) pairs
      for (let eRound = 0; eRound < 200; eRound++) {
        // Recompute averages
        for (const ch of grpPrimary) {
          let sum = 0;
          for (const [, m] of grpCounts) sum += (m.get(ch) || 0);
          grpAvgs.set(ch, sum / groupPeople.size);
        }

        // Find the single worst outlier not already skipped
        let worstPerson = null, worstCh = null, worstCount = 0;
        for (const person of groupPeople) {
          const pc = grpCounts.get(person);
          for (const ch of grpPrimary) {
            const count = pc.get(ch) || 0;
            if (count > EXTREME_CEIL && count > worstCount && !extremeSkip.has(person + "|" + ch)) {
              worstCount = count; worstPerson = person; worstCh = ch;
            }
          }
        }
        if (!worstPerson) break; // all outliers fixed or skipped

        // Try every block where worstPerson is on worstCh
        let fixed = false;
        for (const entry of grpAssignments) {
          if (entry.name !== worstPerson || entry.channel !== worstCh) continue;
          const dk = entry.dayKey, bk = entry.blockKey;
          const bd = plan.days[dk] && plan.days[dk][bk];
          if (!bd || !bd.assignments || bd.assignments[worstCh] !== worstPerson) continue;

          // Find best swap partner — scored by how much the swap improves balance
          let bestPartner = null, bestPartnerCh = null, bestScore = -Infinity;
          for (const [c2, nm2] of Object.entries(bd.assignments)) {
            if (!nm2 || nm2 === worstPerson || c2 === worstCh) continue;
            if (ctrExclude.has(c2.toUpperCase())) continue;
            if (!groupPeople.has(nm2)) continue;
            const pC = grpCounts.get(nm2);
            if ((pC.get(c2) || 0) <= 1) continue; // partner keeps at least 1
            // Same-day check
            const wpDayChs = _shiftDayChannels(worstPerson, dk, bk);
            if (wpDayChs.has(c2.toUpperCase())) continue;
            const pDayChs = _shiftDayChannels(nm2, dk, bk);
            if (pDayChs.has(worstCh.toUpperCase())) continue;
            // Score: prefer partners below avg on worstCh and above avg on c2
            const score = ((grpAvgs.get(worstCh) || 0) - (pC.get(worstCh) || 0))
                        + ((pC.get(c2) || 0) - (grpAvgs.get(c2) || 0));
            if (score > bestScore) {
              bestScore = score; bestPartner = nm2; bestPartnerCh = c2;
            }
          }
          if (bestPartner) {
            _grpSwap(worstPerson, worstCh, bestPartner, bestPartnerCh, dk, bk, bd, entry);
            fixed = true;
            break;
          }
        }
        if (!fixed) {
          extremeSkip.add(worstPerson + "|" + worstCh); // skip this one, try next outlier
        }
      }

    }

    // Run for all three shift groups
    _balanceShiftGroup("DAY", dayOnlyPeople);
    _balanceShiftGroup("NIGHT", nightOnlyPeople);
    _balanceShiftGroup("SPLIT", splitPeople);
  }
  // ========== END PER-SHIFT BALANCING ==========

  // ========== SD PEOPLE: USE THEIR FEW CHANNEL BLOCKS TO MAXIMIZE BALANCE ==========
  // SD-eligible people only get ~2 channel blocks per week. Reassign those blocks
  // to whichever primary channel is most underrepresented globally.
  {
    const sdPrimaryChannels = rebalanceChannels; // N,E,S,W,NW,C
    const sdCtrExclude = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2","DC1","DC2"]);

    // Collect SD people's channel assignments
    const sdChAssignments = []; // [{dayKey, blockKey, channel, name}]
    for (const entry of allAssignments) {
      if (!SD_ELIGIBLE.has(entry.name.toUpperCase())) continue;
      if (sdCtrExclude.has(entry.channel.toUpperCase())) continue;
      sdChAssignments.push(entry);
    }

    if (sdChAssignments.length > 0) {
      // Helper: compute global average count per primary channel (across ALL people)
      function _globalChAvg(ch) {
        let sum = 0, cnt = 0;
        for (const [, m] of finalCounts) { sum += (m.get(ch) || 0); cnt++; }
        return cnt > 0 ? sum / cnt : 0;
      }

      // Helper: find which primary channel has the biggest deficit globally
      // (lowest count relative to average)
      function _mostNeededChannel(excludeChannels) {
        let bestCh = null, bestDeficit = -Infinity;
        for (const ch of sdPrimaryChannels) {
          if (excludeChannels && excludeChannels.has(ch.toUpperCase())) continue;
          const avg = _globalChAvg(ch);
          // Sum up how much everyone is below average on this channel
          let totalDeficit = 0;
          for (const [, m] of finalCounts) {
            const c = m.get(ch) || 0;
            if (c < avg) totalDeficit += (avg - c);
          }
          if (totalDeficit > bestDeficit) { bestDeficit = totalDeficit; bestCh = ch; }
        }
        return bestCh;
      }

      // Helper: day channels for person (for same-day-twice safety)
      function _sdDayChannels(personName, dayKey, excludeBlockKey) {
        const chs = new Set();
        const dayData = plan.days[dayKey];
        if (!dayData) return chs;
        for (const bk of BLOCKS) {
          if (bk.key === excludeBlockKey) continue;
          const bd = dayData[bk.key];
          if (!bd) continue;
          for (const [ch, nm] of Object.entries(bd.assignments || {})) {
            if (nm && String(nm).toUpperCase() === String(personName).toUpperCase()) chs.add(ch.toUpperCase());
          }
        }
        return chs;
      }

      // For each SD person's channel assignment, try to swap it to the most-needed channel
      for (let round = 0; round < 5; round++) {
        let swapped = false;

        for (const entry of sdChAssignments) {
          const dk = entry.dayKey, bk = entry.blockKey;
          const bd = plan.days[dk] && plan.days[dk][bk];
          if (!bd || !bd.assignments) continue;
          const sdName = entry.name;
          const currentCh = entry.channel;

          // Skip if this assignment no longer matches the plan (already swapped)
          if (bd.assignments[currentCh] !== sdName) continue;

          // Find the most-needed channel globally
          const sdDayChs = _sdDayChannels(sdName, dk, bk);
          const needCh = _mostNeededChannel(sdDayChs); // exclude channels SD person already has today
          if (!needCh || needCh === currentCh) continue;

          // Check if someone else in this block has the needed channel and can swap
          const otherName = bd.assignments[needCh];
          if (!otherName) continue;
          if (SD_ELIGIBLE.has(String(otherName).toUpperCase())) continue; // don't swap between SD people

          // Safety: other person can't already have currentCh today
          const otherDayChs = _sdDayChannels(otherName, dk, bk);
          if (otherDayChs.has(currentCh.toUpperCase())) continue;

          // Safety: SD person can't already have needCh today (already excluded above)
          // Safety: don't drop other person's count of needCh below 2
          const otherCounts = finalCounts.get(otherName);
          if (otherCounts && (otherCounts.get(needCh) || 0) <= 2) continue;

          // Perform the swap
          bd.assignments[currentCh] = otherName;
          bd.assignments[needCh] = sdName;

          // Update finalCounts
          const sdCounts = finalCounts.get(sdName);
          if (sdCounts) {
            sdCounts.set(currentCh, (sdCounts.get(currentCh) || 0) - 1);
            sdCounts.set(needCh, (sdCounts.get(needCh) || 0) + 1);
          }
          if (otherCounts) {
            otherCounts.set(needCh, (otherCounts.get(needCh) || 0) - 1);
            otherCounts.set(currentCh, (otherCounts.get(currentCh) || 0) + 1);
          }

          // Update allAssignments tracking
          entry.channel = needCh;
          for (const e2 of allAssignments) {
            if (e2.dayKey === dk && e2.blockKey === bk && e2.name === otherName && e2.channel === needCh) {
              e2.channel = currentCh;
              break;
            }
          }

          swapped = true;
        }
        if (!swapped) break;
      }
    }
  }
  // ========== END SD BALANCING ==========

  // ========== GROUPED CHANNEL BALANCING PASS (R1/R2 and DC1/DC2) ==========
  // R1 & R2 are functionally identical, as are DC1 & DC2.
  // Balance the combined total of each group across all dispatchers.
  {
    const ctrUpper = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
    const dcUpper = new Set(["DC1","DC2"]);

    // Helper: get all channels a person is assigned on a given day
    function _personDayChannels(personName, dayKey) {
      const channels = new Set();
      const dayData = plan.days[dayKey];
      if (!dayData) return channels;
      for (const bk of BLOCKS) {
        const bd = dayData[bk.key];
        if (!bd) continue;
        for (const [ch, nm] of Object.entries(bd.assignments || {})) {
          if (nm && String(nm).toUpperCase() === String(personName).toUpperCase()) channels.add(ch.toUpperCase());
        }
        for (const nm of (bd.ct || [])) {
          if (String(nm).toUpperCase() === String(personName).toUpperCase()) channels.add("CT");
        }
      }
      return channels;
    }

    // Helper: check if swapping would create a back-to-back violation for a person
    // Covers both CTR back-to-back and DC1/DC2 back-to-back
    function _wouldCauseBackToBack(personName, dayKey, blockKey, newChannel) {
      const chUpper = String(newChannel).toUpperCase();
      const dayData = plan.days[dayKey];
      if (!dayData) return false;
      const bIdx = BLOCKS.findIndex(b => b.key === blockKey);
      if (bIdx < 0) return false;

      function _checkAdjacentBlock(adjBd) {
        if (!adjBd) return false;
        for (const [ch, nm] of Object.entries(adjBd.assignments || {})) {
          if (!nm || String(nm).toUpperCase() !== String(personName).toUpperCase()) continue;
          const adjUpper = ch.toUpperCase();
          // CTR back-to-back
          if (ctrUpper.has(chUpper) && ctrUpper.has(adjUpper)) return true;
          // DC1/DC2 back-to-back
          if (dcUpper.has(chUpper) && dcUpper.has(adjUpper)) return true;
        }
        for (const nm of (adjBd.ct || [])) {
          if (String(nm).toUpperCase() !== String(personName).toUpperCase()) continue;
          if (ctrUpper.has(chUpper)) return true;
        }
        return false;
      }

      if (bIdx > 0 && _checkAdjacentBlock(dayData[BLOCKS[bIdx - 1].key])) return true;
      if (bIdx < BLOCKS.length - 1 && _checkAdjacentBlock(dayData[BLOCKS[bIdx + 1].key])) return true;
      return false;
    }

    // Generic balancing function for a channel group
    function _balanceGroup(groupChannels, noSwapWith) {
      // Build per-person combined counts and index group assignments
      const grpCounts = new Map(); // name -> combined count
      const grpAssignments = []; // [{dayKey, blockKey, channel, name}]
      const allNames = new Set();

      for (let day = 1; day <= daysInMonth; day++) {
        const dObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
        const dk = ymd(dObj);
        const dayData = plan.days[dk];
        if (!dayData) continue;
        for (const bk of BLOCKS) {
          const bd = dayData[bk.key];
          if (!bd || !bd.assignments) continue;
          for (const [ch, nm] of Object.entries(bd.assignments)) {
            if (!nm) continue;
            allNames.add(nm);
            if (groupChannels.has(ch)) {
              grpCounts.set(nm, (grpCounts.get(nm) || 0) + 1);
              grpAssignments.push({ dayKey: dk, blockKey: bk.key, channel: ch, name: nm });
            }
          }
        }
      }

      // Initialize people with 0 group assignments
      for (const nm of allNames) {
        if (!grpCounts.has(nm)) grpCounts.set(nm, 0);
      }

      // Run up to 5 rebalancing rounds
      for (let round = 0; round < 5; round++) {
        let swappedAny = false;
        const people = Array.from(grpCounts.keys());
        if (people.length < 2) break;

        // Find over/under pairs sorted by biggest gap
        const pairs = [];
        for (let i = 0; i < people.length; i++) {
          for (let j = i + 1; j < people.length; j++) {
            const ca = grpCounts.get(people[i]) || 0;
            const cb = grpCounts.get(people[j]) || 0;
            const diff = Math.abs(ca - cb);
            if (diff >= 2) {
              pairs.push({ over: ca > cb ? people[i] : people[j], under: ca > cb ? people[j] : people[i], diff });
            }
          }
        }
        pairs.sort((a, b) => b.diff - a.diff);

        for (const { over, under } of pairs) {
          const overCount = grpCounts.get(over) || 0;
          const underCount = grpCounts.get(under) || 0;
          if (overCount - underCount < 2) continue;

          for (const gEntry of grpAssignments) {
            if (gEntry.name !== over) continue;
            const dk = gEntry.dayKey, bk = gEntry.blockKey;
            const bd = plan.days[dk] && plan.days[dk][bk];
            if (!bd || !bd.assignments) continue;

            // Verify 'over' is still on this channel
            if (bd.assignments[gEntry.channel] !== over) continue;

            // Find what 'under' is assigned to in this same block
            let underCh = null;
            for (const [c2, nm2] of Object.entries(bd.assignments)) {
              if (nm2 === under) { underCh = c2; break; }
            }
            if (!underCh) continue;
            if (groupChannels.has(underCh)) continue; // Both in same group — no point
            if (noSwapWith.has(underCh.toUpperCase())) continue; // Don't swap with excluded channels

            // Check same-channel-twice-in-day for 'under' getting the group channel
            const underDayCh = _personDayChannels(under, dk);
            if (underDayCh.has(gEntry.channel.toUpperCase())) continue;

            // Check same-channel-twice for 'over' getting underCh
            const overDayCh = _personDayChannels(over, dk);
            overDayCh.delete(gEntry.channel.toUpperCase());
            if (overDayCh.has(underCh.toUpperCase())) continue;

            // Check back-to-back for both parties
            if (_wouldCauseBackToBack(under, dk, bk, gEntry.channel)) continue;
            if (_wouldCauseBackToBack(over, dk, bk, underCh)) continue;

            // Perform the swap
            bd.assignments[gEntry.channel] = under;
            bd.assignments[underCh] = over;

            grpCounts.set(over, (grpCounts.get(over) || 0) - 1);
            grpCounts.set(under, (grpCounts.get(under) || 0) + 1);
            gEntry.name = under;

            swappedAny = true;
            break;
          }
        }

        if (!swappedAny) break;
      }
    }

    // Balance R1/R2 combined — don't swap with CT or DC channels
    _balanceGroup(new Set(["Relief 1","Relief 2"]), new Set(["CT","RELIEF 1","RELIEF 2","R1","R2","DC1","DC2"]));

    // Balance DC1/DC2 combined — don't swap with CT or R channels
    _balanceGroup(new Set(["DC1","DC2"]), new Set(["CT","RELIEF 1","RELIEF 2","R1","R2","DC1","DC2"]));
  }
  // ========== END GROUPED CHANNEL BALANCING PASS ==========

  // ========== CT BALANCING PASS ==========
  // Runs AFTER grouped channel balancing so back-to-back checks see final R1/R2 positions
  {
    const DAY_BLK_SET2 = new Set(["0600-1000","1000-1400","1400-1800"]);
    const ctrAdj = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);

    // Reclassify people into shift groups
    const pShift2 = new Map();
    for (const entry of allAssignments) {
      if (!pShift2.has(entry.name)) pShift2.set(entry.name, { day: false, night: false });
      const s = pShift2.get(entry.name);
      if (DAY_BLK_SET2.has(entry.blockKey)) s.day = true; else s.night = true;
    }
    const dayPpl2 = new Set(), nightPpl2 = new Set(), splitPpl2 = new Set();
    for (const [name, s] of pShift2) {
      if (SD_ELIGIBLE.has(name.toUpperCase())) continue;
      if (s.day && s.night) splitPpl2.add(name);
      else if (s.day) dayPpl2.add(name);
      else nightPpl2.add(name);
    }

    function _balanceCT(groupPeople) {
      if (groupPeople.size < 2) return;

      // Count CT per person and collect CT entries
      const ctCounts = new Map();
      for (const name of groupPeople) ctCounts.set(name, 0);
      const ctEntries = [];
      for (let day = 1; day <= daysInMonth; day++) {
        const dObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
        const dk = ymd(dObj);
        const dayData = plan.days[dk];
        if (!dayData) continue;
        for (const bk of BLOCKS) {
          const bd = dayData[bk.key];
          if (!bd || !bd.ct) continue;
          for (let ci = 0; ci < bd.ct.length; ci++) {
            const nm = bd.ct[ci];
            if (groupPeople.has(nm)) {
              ctCounts.set(nm, (ctCounts.get(nm) || 0) + 1);
              ctEntries.push({ dayKey: dk, blockKey: bk.key, ctIndex: ci, name: nm });
            }
          }
        }
      }

      const avgCT = [...ctCounts.values()].reduce((a, b) => a + b, 0) / groupPeople.size;
      const ceilCT = Math.ceil(avgCT);
      const floorCT = Math.floor(avgCT);

      // Two passes: tight thresholds then wide thresholds, both with back-to-back safety
      for (let ctPass = 0; ctPass < 2; ctPass++) {
        const overThresh = ctPass === 0 ? ceilCT : floorCT;
        const underThresh = ctPass === 0 ? floorCT : ceilCT;

        for (let round = 0; round < 80; round++) {
          let swapped = false;
          ctEntries.sort((a, b) => (ctCounts.get(b.name) || 0) - (ctCounts.get(a.name) || 0));

          for (const entry of ctEntries) {
            const overName = entry.name;
            const overCT = ctCounts.get(overName) || 0;
            if (overCT <= overThresh) continue;

            const dk = entry.dayKey, bk = entry.blockKey;
            const bd = plan.days[dk] && plan.days[dk][bk];
            if (!bd || !bd.ct) continue;
            if (bd.ct[entry.ctIndex] !== overName) continue;

            // Skip CT-only people (no channel assignment)
            let overHasChannel = false;
            for (const [, anm] of Object.entries(bd.assignments || {})) {
              if (anm === overName) { overHasChannel = true; break; }
            }
            if (!overHasChannel) continue;

            // Find under-CT person with back-to-back safety
            let bestUnder = null, bestUnderCT = Infinity;
            const bIdx = BLOCKS.findIndex(b => b.key === bk);
            for (const [ch, nm] of Object.entries(bd.assignments || {})) {
              if (!nm || nm === overName || !groupPeople.has(nm)) continue;
              if (bd.ct.includes(nm)) continue;
              const uCT = ctCounts.get(nm) || 0;
              if (uCT >= underThresh) continue;

              // Back-to-back check against FINAL R1/R2 positions
              let btbConflict = false;
              for (const adjOff of [-1, 1]) {
                const adjIdx = bIdx + adjOff;
                if (adjIdx < 0 || adjIdx >= BLOCKS.length) continue;
                const adjBd = plan.days[dk] && plan.days[dk][BLOCKS[adjIdx].key];
                if (!adjBd) continue;
                for (const [ach, anm] of Object.entries(adjBd.assignments || {})) {
                  if (anm === nm && ctrAdj.has(ach.toUpperCase())) { btbConflict = true; break; }
                }
                if (!btbConflict && adjBd.ct) {
                  for (const cnm of adjBd.ct) {
                    if (cnm === nm) { btbConflict = true; break; }
                  }
                }
                if (btbConflict) break;
              }
              if (btbConflict) continue;

              if (uCT < bestUnderCT) { bestUnderCT = uCT; bestUnder = nm; }
            }

            if (bestUnder) {
              bd.ct[entry.ctIndex] = bestUnder;
              ctCounts.set(overName, overCT - 1);
              ctCounts.set(bestUnder, bestUnderCT + 1);
              entry.name = bestUnder;
              swapped = true;
            }
          }

          if (!swapped) break;
        }
      }
    }

    _balanceCT(dayPpl2);
    _balanceCT(nightPpl2);
    _balanceCT(splitPpl2);
  }
  // ========== END CT BALANCING ==========

  // ========== VIOLATION REPAIR PASS ==========
  const ctrSet2 = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
  const MAX_REPAIR_ROUNDS = 3;

  // Helper: scan all violations for the current plan state
  function _scanViolations() {
    const vFound = new Map(); // name -> count
    const vList = []; // detailed list for repair

    for (let day = 1; day <= daysInMonth; day++) {
      const dateObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
      const dk = ymd(dateObj);
      const dayData = plan.days[dk];
      if (!dayData) continue;

      const personAssignments = new Map(); // name -> [{blockIdx, channel, blockKey}]

      for (let bi = 0; bi < BLOCKS.length; bi++) {
        const b = BLOCKS[bi];
        const blockData = dayData[b.key];
        if (!blockData) continue;

        for (const [ch, name] of Object.entries(blockData.assignments || {})) {
          if (!name) continue;
          const nameUpper = String(name).toUpperCase();
          if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
          personAssignments.get(nameUpper).push({ blockIdx: bi, channel: ch.toUpperCase(), blockKey: b.key, origChannel: ch, origName: String(name) });
        }
        for (const name of (blockData.ct || [])) {
          const nameUpper = String(name).toUpperCase();
          if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
          personAssignments.get(nameUpper).push({ blockIdx: bi, channel: "CT", blockKey: b.key, origChannel: "CT", isCt: true, origName: String(name) });
        }
      }

      for (const [name, assignments] of personAssignments) {
        assignments.sort((a, b) => a.blockIdx - b.blockIdx);
        const dayChannels = new Map();

        for (let i = 0; i < assignments.length; i++) {
          const curr = assignments[i];
          const chUpper = curr.channel;

          // Same channel twice in day (except SD)
          if (dayChannels.has(chUpper) && chUpper !== "SD") {
            vFound.set(name, (vFound.get(name) || 0) + 1);
            vList.push({ name, origName: curr.origName, dayKey: dk, blockKey: curr.blockKey, channel: curr.origChannel, type: "same-channel", blockIdx: curr.blockIdx, isCt: !!curr.isCt });
          }
          dayChannels.set(chUpper, (dayChannels.get(chUpper) || 0) + 1);

          // CTR back-to-back
          if (i > 0) {
            const prev = assignments[i - 1];
            if (curr.blockIdx === prev.blockIdx + 1 && ctrSet2.has(chUpper) && ctrSet2.has(prev.channel)) {
              vFound.set(name, (vFound.get(name) || 0) + 1);
              vList.push({ name, origName: curr.origName, dayKey: dk, blockKey: curr.blockKey, channel: curr.origChannel, type: "ctr-back-to-back", blockIdx: curr.blockIdx, isCt: !!curr.isCt });
            }
          }
        }
      }
    }

    let total = 0;
    for (const c of vFound.values()) total += c;
    return { vFound, vList, total };
  }

  // Helper: check if a person has a violation in a specific block/day after a hypothetical swap
  function _wouldCreateViolation(personName, dayKey, blockIdx, newChannel) {
    const nameUpper = String(personName).toUpperCase();
    const chUpper = String(newChannel).toUpperCase();
    const dayData = plan.days[dayKey];
    if (!dayData) return false;

    // Gather this person's assignments for the day (excluding the block being swapped)
    const otherAssignments = [];
    for (let bi = 0; bi < BLOCKS.length; bi++) {
      if (bi === blockIdx) continue;
      const b = BLOCKS[bi];
      const bd = dayData[b.key];
      if (!bd) continue;
      for (const [ch, nm] of Object.entries(bd.assignments || {})) {
        if (nm && String(nm).toUpperCase() === nameUpper) {
          otherAssignments.push({ blockIdx: bi, channel: ch.toUpperCase() });
        }
      }
      for (const nm of (bd.ct || [])) {
        if (String(nm).toUpperCase() === nameUpper) {
          otherAssignments.push({ blockIdx: bi, channel: "CT" });
        }
      }
    }

    // Add the proposed new assignment
    otherAssignments.push({ blockIdx, channel: chUpper });
    otherAssignments.sort((a, b) => a.blockIdx - b.blockIdx);

    // Check same-channel-twice
    const chCounts = new Map();
    for (const a of otherAssignments) {
      if (a.channel !== "SD") {
        if (chCounts.has(a.channel)) return true;
        chCounts.set(a.channel, 1);
      }
    }

    // Check CTR back-to-back
    for (let i = 1; i < otherAssignments.length; i++) {
      const curr = otherAssignments[i];
      const prev = otherAssignments[i - 1];
      if (curr.blockIdx === prev.blockIdx + 1 && ctrSet2.has(curr.channel) && ctrSet2.has(prev.channel)) {
        return true;
      }
    }
    return false;
  }

  for (let repairRound = 0; repairRound < MAX_REPAIR_ROUNDS; repairRound++) {
    const scan = _scanViolations();
    if (scan.total === 0) break; // No violations — done!

    let repairsThisRound = 0;

    for (const v of scan.vList) {
      const dayData = plan.days[v.dayKey];
      if (!dayData) continue;
      const blockData = dayData[v.blockKey];
      if (!blockData) continue;

      if (v.isCt) continue; // Skip CT array entries — harder to swap safely

      const offenderNameUpper = v.name; // uppercase for comparisons
      const offenderOrigName = v.origName; // original case for plan writes
      const offenderChannel = v.channel;

      // Verify offender is still on this channel (earlier repair may have moved them)
      if (String(blockData.assignments?.[offenderChannel] || "").toUpperCase() !== offenderNameUpper) continue;

      // Find someone else in the same block on a different, non-conflicting channel to swap with
      const candidates = Object.entries(blockData.assignments || {}).filter(([ch, nm]) => {
        if (!nm) return false;
        if (ch === offenderChannel) return false; // same channel
        if (String(nm).toUpperCase() === offenderNameUpper) return false; // same person
        return true;
      });

      let swapped = false;
      for (const [candChannel, candName] of candidates) {
        // Would the swap create a violation for the candidate?
        if (_wouldCreateViolation(candName, v.dayKey, v.blockIdx, offenderChannel)) continue;
        // Would the swap create a violation for the offender?
        if (_wouldCreateViolation(offenderOrigName, v.dayKey, v.blockIdx, candChannel)) continue;

        // Perform the swap
        blockData.assignments[offenderChannel] = candName;
        blockData.assignments[candChannel] = offenderOrigName;
        repairsThisRound++;
        swapped = true;
        break;
      }
    }

    if (repairsThisRound === 0) break; // No more repairs possible
  }

  // Final violation count after repairs
  const finalScan = _scanViolations();

  savePlan(plan);

  // Compute max primary channel count and max CT count for non-SD people (quality metrics)
  let _maxPrimCount = 0;
  const _primUpper = new Set(rebalanceChannels.map(ch => ch.toUpperCase()));
  for (const [name, m] of finalCounts) {
    if (SD_ELIGIBLE.has(name.toUpperCase())) continue;
    for (const [ch, count] of m) {
      if (_primUpper.has(ch.toUpperCase()) && count > _maxPrimCount) _maxPrimCount = count;
    }
  }

  // Max CT count across all non-SD people
  let _maxCTCount = 0;
  const _ctMap = new Map();
  for (const dk of Object.keys(plan.days)) {
    const dayData = plan.days[dk];
    for (const bk of BLOCKS) {
      const bd = dayData[bk.key];
      if (!bd || !bd.ct) continue;
      for (const nm of bd.ct) {
        if (SD_ELIGIBLE.has(String(nm).toUpperCase())) continue;
        _ctMap.set(nm, (_ctMap.get(nm) || 0) + 1);
      }
    }
  }
  for (const [, count] of _ctMap) {
    if (count > _maxCTCount) _maxCTCount = count;
  }

  // Store violation stats for display
  window.lastRandomizeStats = {
    totalViolations: finalScan.total,
    uniquePeopleWithViolations: finalScan.vFound.size,
    violationsByPerson: Object.fromEntries(finalScan.vFound),
    maxPrimaryCount: _maxPrimCount,
    maxCTCount: _maxCTCount
  };

  return plan;
}

// ========== OPTION B RANDOMIZER (SD = 8 blocks/month, simpler distribution) ==========
function randomizeMonthB(year, monthIndex) {
  const plan = buildEmptyPlan(year, monthIndex);

  // Track last channel (prevents immediate back-to-back repeats)
  const lastAssign = new Map();
  function forbiddenBackToBack(prev, next) {
    // DC1/DC2 never back-to-back
    if ((prev==="DC1" && next==="DC2") || (prev==="DC2" && next==="DC1")) return true;
    // R1, R2, CT never back-to-back in any order
    const ctrSet = new Set(["RELIEF 1","RELIEF 2","CT","R1","R2"]);
    const pU = String(prev||"").toUpperCase();
    const nU = String(next||"").toUpperCase();
    if (ctrSet.has(pU) && ctrSet.has(nU)) return true;
    return false;
  }


  // Track per-person channel cycle (prevents repeating a channel until they've hit all 10)
  // name -> Set(channels used in current cycle)
  const channelCycle = new Map();

  // Light balancing helper (keeps total assignments per person more even)
  const channelCounts = new Map();

  // CT fairness tracking (per month + per week + back-to-back exception)
  const ctWeekCounts = new Map();   // weekKey -> Map(name -> ctCountThisWeek)
  const ctMonthCounts = new Map();  // name -> ctCountThisMonth
  const lastCTAt = new Map();       // name -> {dayKey, blockIdx} for back-to-back rule

  // Violation fairness: track violations per person (max 1 per person if possible)
  const violationCount = new Map();  // name -> number of violations this month
  function hasViolation(name) { return (violationCount.get(String(name).toUpperCase()) || 0) > 0; }
  function addViolation(name) {
    const n = String(name).toUpperCase();
    violationCount.set(n, (violationCount.get(n) || 0) + 1);
  }

  // Track people assigned R1/R2 who work next block - they get GUARANTEED channel priority
  // This prevents Relief->CT violations when Pass 4 must fill R1/R2 with someone working next block
  const mustGetChannelNextBlock = new Set(); // names that MUST get a channel (not CT) next block

  // ctCapByName is global (rebuilt in buildEmptyPlan)
  const ctOverCapUsedByWeek = new Map(); // weekKey -> Set(names who used 1 over-cap allowance)
  const lastCTGlobalIdx = new Map();     // name -> global block index of last CT (for back-to-back rule)

  const daysInMonth = new Date(year, monthIndex+1, 0).getDate();

  // ========== SD PRE-ASSIGNMENT (32 hrs/WEEK = 8 blocks/WEEK per person) ==========
  // Pre-assign SD to SD-eligible employees before filling channels
  // Each SD person gets 32 hrs (8 blocks) of SD per WEEK, rest goes to channels.
  // Track: sdPreAssigned[weekKey][dayKey][blockKey] = [names assigned to SD]
  const sdPreAssigned = new Map(); // weekKey -> Map(dayKey -> Map(blockKey -> [names]))
  const sdRemainingBlocks = new Map(); // weekKey -> Map(name -> remaining channel blocks to fill)

  // Group days by week and find days with most dispatchers for SD priority
  const weekDays = new Map(); // weekKey -> [{dayKey, dateObj, dispatcherCount}]
  for (let day=1; day<=daysInMonth; day++) {
    const dateObj = new Date(year, monthIndex, day, 12,0,0,0);
    const dayKey = ymd(dateObj);
    const wk = weekKeyFromDate(dateObj);
    if (!weekDays.has(wk)) weekDays.set(wk, []);

    // Count total dispatcher availability for this day
    const poolAll = buildDispatcherPoolForDate(dateObj);
    let totalAvail = 0;
    for (const b of BLOCKS) {
      const available = poolAll.filter(d => worksBlock(d, dateObj, b));
      totalAvail += available.length;
    }
    weekDays.get(wk).push({dayKey, dateObj, dispatcherCount: totalAvail});
  }

  // Monthly SD cap: 32 blocks (128 hrs) per month — ensures totals stay at 32
  const SD_MONTHLY_CAP = 32;
  const sdMonthlyCount = new Map(); // name -> total SD blocks this month
  for (const sdName of SD_ELIGIBLE) sdMonthlyCount.set(sdName, 0);

  // For each week, pre-assign SD (8 blocks = 32 hrs per FULL WEEK, pro-rated for partial weeks)
  for (const [wk, days] of weekDays.entries()) {
    // Sort days by dispatcher count descending (prioritize days with most dispatchers)
    days.sort((a, b) => b.dispatcherCount - a.dispatcherCount);

    sdPreAssigned.set(wk, new Map());
    sdRemainingBlocks.set(wk, new Map());
    const sdMap = sdPreAssigned.get(wk);

    // Pro-rate SD cap for partial weeks:
    // A full week (7 days, ~5 working days) = 8 blocks cap
    // Partial weeks get proportional cap based on actual days in this month-week
    const daysInThisWeek = days.length;
    // Full week has ~5 working days (Mon-Fri from Sat-Fri week). Scale 8 blocks by ratio.
    // Use 5 as the baseline for a full working week
    const sdWeeklyCap = Math.min(8, Math.round(8 * daysInThisWeek / 5));

    // Track blocks assigned per SD employee this week
    const sdBlocksThisWeek = new Map(); // name -> blocks assigned this week

    // For each SD-eligible employee, initialize to 0
    for (const sdName of SD_ELIGIBLE) {
      sdBlocksThisWeek.set(sdName, 0);
      sdRemainingBlocks.get(wk).set(sdName, 0); // will calculate after
    }

    // Distribute SD assignments across the week
    for (const {dayKey, dateObj} of days) {
      if (!sdMap.has(dayKey)) sdMap.set(dayKey, new Map());
      const dayMap = sdMap.get(dayKey);

      const poolAll = buildDispatcherPoolForDate(dateObj);

      for (const b of BLOCKS) {
        if (!dayMap.has(b.key)) dayMap.set(b.key, []);

        // Find SD-eligible people working this block who haven't hit weekly or monthly cap
        for (const sdName of SD_ELIGIBLE) {
          const weeklyBlocks = sdBlocksThisWeek.get(sdName) || 0;
          if (weeklyBlocks >= sdWeeklyCap) continue; // CAP: pro-rated per week
          const monthlyBlocks = sdMonthlyCount.get(sdName) || 0;
          if (monthlyBlocks >= SD_MONTHLY_CAP) continue; // HARD CAP: 32 blocks per month

          // Check if this person works this block
          const disp = poolAll.find(d => String(d.name).toUpperCase() === sdName);
          if (!disp) continue;
          if (!worksBlock(disp, dateObj, b)) continue;

          // Assign to SD
          dayMap.get(b.key).push(sdName);
          sdBlocksThisWeek.set(sdName, weeklyBlocks + 1);
          sdMonthlyCount.set(sdName, monthlyBlocks + 1);
        }
      }
    }

    // Calculate remaining channel blocks for each SD employee
    // (Total scheduled blocks - SD blocks = remaining for channels)
    for (const sdName of SD_ELIGIBLE) {
      let totalScheduledBlocks = 0;
      for (const {dayKey, dateObj} of days) {
        const poolAll = buildDispatcherPoolForDate(dateObj);
        const disp = poolAll.find(d => String(d.name).toUpperCase() === sdName);
        if (!disp) continue;
        for (const b of BLOCKS) {
          if (worksBlock(disp, dateObj, b)) totalScheduledBlocks++;
        }
      }
      const sdBlocks = sdBlocksThisWeek.get(sdName) || 0;
      const remainingBlocks = Math.max(0, totalScheduledBlocks - sdBlocks);
      sdRemainingBlocks.get(wk).set(sdName, remainingBlocks);
    }
  }
  // ========== END SD PRE-ASSIGNMENT ==========

// Weekly quota targets (after SD):
// - 24 hrs (6 blocks) from N/E/S/W/C/NW
// - 8 hrs (2 blocks) from CT or R1/R2
// - 8 hrs (2 blocks) from DC1/DC2
const PRIMARY_SET = new Set(["NORTH","EAST","SOUTH","WEST","CENTRAL","NORTHWEST"]);
const DC_SET = new Set(["DC1","DC2"]);
const CTR_SET = new Set(["CT","R1","R2"]);

// wk -> Map(name -> {primary:int, ctr:int, dc:int})
const weekNeeds = new Map();
function getNeeds(wkKey, name){
  if (!weekNeeds.has(wkKey)) weekNeeds.set(wkKey, new Map());
  const m = weekNeeds.get(wkKey);
  if (!m.has(name)) m.set(name, {primary:6, ctr:2, dc:2}); // default 40hr week (10 blocks)
  return m.get(name);
}

// Keep channel chunks up to 8 hours (2 blocks) when possible
const sameChanStreak = new Map(); // name -> {ch, len}
// Hard constraint: never more than 8 hours (2 blocks) in CT/R1/R2 bucket back-to-back
const ctrStreakLen = new Map(); // name -> consecutive blocks in {CT,R1,R2}

function updateStreaks(name, assignedChannel){
  // same channel streak
  const prev = sameChanStreak.get(name);
  if (prev && prev.ch === assignedChannel) sameChanStreak.set(name, {ch: assignedChannel, len: Math.min(2, prev.len+1)});
  else sameChanStreak.set(name, {ch: assignedChannel, len: 1});

  // CT-bucket streak
  if (CTR_SET.has(assignedChannel)) ctrStreakLen.set(name, (ctrStreakLen.get(name)||0)+1);
  else ctrStreakLen.set(name, 0);
}



  // Track which channels each person has already worked TODAY (to prevent same channel twice in same day)
  const dayChannelsWorked = new Map(); // dayKey -> Map(name -> Set of channels)

  for (let day=1; day<=daysInMonth; day++) {
    const dateObj = new Date(year, monthIndex, day, 12,0,0,0);
    const dayKey = ymd(dateObj);
        const wk = weekKeyFromDate(dateObj);
    if (!ctWeekCounts.has(wk)) ctWeekCounts.set(wk, new Map());

    // Initialize daily channel tracking for this day
    if (!dayChannelsWorked.has(dayKey)) dayChannelsWorked.set(dayKey, new Map());
    const todayChannels = dayChannelsWorked.get(dayKey); // Map(name -> Set of channels)

const poolAll = buildDispatcherPoolForDate(dateObj);

    for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
      const available = poolAll.filter(d => worksBlock(d, dateObj, b));
      const shuffled = shuffle(available);

      // Balance: prefer people with fewer total assignments so far
      // HIGHEST PRIORITY: People who were just on CT/R1/R2 must get a channel to avoid back-to-back
      shuffled.sort((a,b2)=>{
        // ABSOLUTE PRIORITY: People marked as must-get-channel (from Pass 4 R1/R2 assignment)
        const aMustGet = mustGetChannelNextBlock.has(a.name);
        const bMustGet = mustGetChannelNextBlock.has(b2.name);
        if (aMustGet && !bMustGet) return -1; // a goes first (GUARANTEED)
        if (bMustGet && !aMustGet) return 1;  // b goes first (GUARANTEED)

        // Check if either person was just on CT/R1/R2 (needs priority for channel)
        const lastA = lastAssign.get(a.name);
        const lastB = lastAssign.get(b2.name);
        const ctrNames = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
        const aWasOnCTR = lastA && ctrNames.has(String(lastA).toUpperCase());
        const bWasOnCTR = lastB && ctrNames.has(String(lastB).toUpperCase());

        // SECOND: People who were just on CT/R1/R2 get top priority for channels
        if (aWasOnCTR && !bWasOnCTR) return -1; // a goes first
        if (bWasOnCTR && !aWasOnCTR) return 1;  // b goes first

        const ma = channelCounts.get(a.name) || new Map();
        const mb = channelCounts.get(b2.name) || new Map();
        const ta = Array.from(ma.values()).reduce((s,v)=>s+v,0);
        const tb = Array.from(mb.values()).reduce((s,v)=>s+v,0);

        // CT fairness: if someone has already been sent to CT more often, pull them onto a channel first
        const wmap = ctWeekCounts.get(wk) || new Map();
        const cwa = wmap.get(a.name) || 0;
        const cwb = wmap.get(b2.name) || 0;

        const cma = ctMonthCounts.get(a.name) || 0;
        const cmb = ctMonthCounts.get(b2.name) || 0;

        // Priority order:
        // 1) Higher CT this week gets channel priority (reduces repeat CT in the same week)
        // 2) Higher CT this month gets channel priority (evens CT across the month)
        // 3) Then balance total channel work so one person doesn't do everything
        if (cwa !== cwb) return cwb - cwa;
        if (cma !== cmb) return cmb - cma;
        if (ta !== tb) return ta - tb;
        return 0;
      });

      const assignments = {};
      const usedNames = new Set();

      // ========== ADD PRE-ASSIGNED SD TO THIS BLOCK ==========
      // Get pre-assigned SD for this block and add to usedNames
      const sdForBlock = [];
      const wkSdMap = sdPreAssigned.get(wk);
      if (wkSdMap && wkSdMap.has(dayKey)) {
        const dayMap = wkSdMap.get(dayKey);
        if (dayMap && dayMap.has(b.key)) {
          for (const sdName of dayMap.get(b.key)) {
            sdForBlock.push(sdName);
            usedNames.add(sdName); // Exclude from channel assignment this block
          }
        }
      }
      // ========== END PRE-ASSIGNED SD ==========

      // Check if an SD employee still has remaining channel blocks to fill
      // If so, prioritize them for primary channels (N,E,S,W,NW,C) and one DC
      const sdRemainingMap = sdRemainingBlocks.get(wk) || new Map();
      function isSDEmployeeNeedingChannel(name) {
        const nm = String(name).toUpperCase();
        return SD_ELIGIBLE.has(nm) && (sdRemainingMap.get(nm) || 0) > 0 && !usedNames.has(nm);
      }

      // Training restriction: trainees can only be assigned to E, S, W, C
      const TRAINEE_ALLOWED_CHANNELS = new Set(["EAST","SOUTH","WEST","CENTRAL"]);
      function canTraineeWork(candName, channelUpper) {
        if (!isTrainee(candName, dayKey)) return true; // Non-trainees can work any channel
        return TRAINEE_ALLOWED_CHANNELS.has(channelUpper);
      }

      for (const ch of CHANNELS) {
  let pick = null;
  const CH = String(ch).toUpperCase();

  // Determine which quota bucket this channel satisfies
  const bucket = DC_SET.has(CH) ? "dc" : (PRIMARY_SET.has(CH) ? "primary" : (CTR_SET.has(CH) ? "ctr" : "primary"));

  function candScore(cand){
    const needs = getNeeds(wk, cand.name);
    const needVal = needs[bucket] || 0;

    const last = lastAssign.get(cand.name);
    const lastUpper = last ? String(last).toUpperCase() : "";
    const streak = sameChanStreak.get(cand.name);
    const sameBonus = (last && lastUpper===CH && streak && streak.len < 2) ? 50 : 0;

    const m = channelCounts.get(cand.name) || new Map();
    const total = Array.from(m.values()).reduce((s,v)=>s+v,0);

    // CRITICAL: People who were just on CTR (CT, R1, R2) MUST get a non-CTR channel
    // Give them massive priority so they always win
    let ctrPriorityBonus = 0;
    const wasCTR = lastUpper === "CT" || lastUpper === "RELIEF 1" || lastUpper === "RELIEF 2" || lastUpper === "R1" || lastUpper === "R2";
    if (wasCTR) {
      // They were on CTR - they NEED a non-CTR channel now
      if (CH !== "RELIEF 1" && CH !== "RELIEF 2") {
        ctrPriorityBonus = 5000; // Massive bonus for non-R1/R2 channels
      }
    }

    // Also check if they had CTR today - they shouldn't get R1/R2 or go to CT
    const candDayChans = todayChannels.get(cand.name);
    const hadCTRToday = candDayChans && (candDayChans.has("CT") || candDayChans.has("RELIEF 1") || candDayChans.has("RELIEF 2"));
    if (hadCTRToday && CH !== "RELIEF 1" && CH !== "RELIEF 2") {
      ctrPriorityBonus += 3000; // Additional bonus if they already had CTR today
    }

    // SD employee priority: give big bonus for primary channels (N,E,S,W,NW,C) and DC1/DC2
    // Their remaining 8 hrs should go to these channels
    let sdBonus = 0;
    if (isSDEmployeeNeedingChannel(cand.name)) {
      if (PRIMARY_SET.has(CH) || DC_SET.has(CH)) {
        sdBonus = 200; // High priority for SD employees to get primary/DC channels
      } else {
        sdBonus = -100; // Discourage R1/R2 for SD employees
      }
    }

    // R1/R2 penalty: If assigning R1 or R2, heavily penalize people who work the next block
    // This prevents R1/R2 -> CT violations
    let r1r2Penalty = 0;
    if (CH === "RELIEF 1" || CH === "RELIEF 2") {
      const nextBlockIdx = bi + 1;
      if (nextBlockIdx < BLOCKS.length) {
        // Check if this person works the next block today
        if (worksBlock(cand, dateObj, BLOCKS[nextBlockIdx])) {
          r1r2Penalty = -500; // Heavy penalty - prefer someone whose shift ends
        }
      }
      // Also check if they work the first block of the next day
      if (bi === BLOCKS.length - 1) {
        const nextDay = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate() + 1, 12, 0, 0, 0);
        if (worksBlock(cand, nextDay, BLOCKS[0])) {
          r1r2Penalty = -500; // Heavy penalty for cross-day continuation
        }
      }
    }

    // Big push to satisfy weekly quotas, then prefer 8-hour chunks, then keep totals even
    return (needVal*100) + sameBonus + sdBonus + r1r2Penalty + ctrPriorityBonus - (total*0.25);
  }

  // Helper: check if candidate works next block (for R1/R2 restriction)
  function worksNextBlock(cand) {
    const nextBlockIdx = bi + 1;
    if (nextBlockIdx < BLOCKS.length) {
      if (worksBlock(cand, dateObj, BLOCKS[nextBlockIdx])) return true;
    }
    if (bi === BLOCKS.length - 1) {
      const nextDay = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate() + 1, 12, 0, 0, 0);
      if (worksBlock(cand, nextDay, BLOCKS[0])) return true;
    }
    return false;
  }

  // Pass 1: STRICT – quota-driven + no immediate repeat + respect channel cycle + respect CT-bucket streak rule
  let best = null, bestScore = -1e9;
  for (const cand of shuffled) {
    if (usedNames.has(cand.name)) continue;

    // Training restriction: trainees can only work E, S, W, C
    if (!canTraineeWork(cand.name, CH)) continue;

    // R1/R2 restriction: In Pass 1, skip people who work next block
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;

    // Same-day channel restriction: don't assign same channel twice in one day
    const candDayChannels = todayChannels.get(cand.name);
    if (candDayChannels && candDayChannels.has(CH)) continue;

    // init/roll cycle
    if (!channelCycle.has(cand.name)) channelCycle.set(cand.name, new Set());
    const cyc = channelCycle.get(cand.name);
    if (cyc.size >= CHANNELS.length) cyc.clear();

    const last = lastAssign.get(cand.name);
    if (last && (String(last).toUpperCase() === CH || forbiddenBackToBack(String(last).toUpperCase(), CH))) continue;
    if (cyc.has(ch)) continue;

    // Hard rule: never more than 2 consecutive blocks in CT/R1/R2 bucket
    if (bucket === "ctr" && (ctrStreakLen.get(cand.name)||0) >= 2) continue;

    const sc = candScore(cand);
    if (sc > bestScore) { bestScore=sc; best=cand; }
  }
  pick = best;

  // Pass 2: RELAX cycle (if staffing is too tight) – still enforce CT-bucket streak
  if (!pick) {
    best = null; bestScore = -1e9;
    for (const cand of shuffled) {
      if (usedNames.has(cand.name)) continue;

      // Training restriction: trainees can only work E, S, W, C
      if (!canTraineeWork(cand.name, CH)) continue;

      // R1/R2 restriction: In Pass 2, still skip people who work next block
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;

      // Same-day channel restriction: don't assign same channel twice in one day
      const candDayChannels = todayChannels.get(cand.name);
      if (candDayChannels && candDayChannels.has(CH)) continue;

      const last = lastAssign.get(cand.name);
      if (last && (String(last).toUpperCase() === CH || forbiddenBackToBack(String(last).toUpperCase(), CH))) continue;

      if (bucket === "ctr" && (ctrStreakLen.get(cand.name)||0) >= 2) continue;

      const sc = candScore(cand) - 15; // slight penalty vs strict
      if (sc > bestScore) { bestScore=sc; best=cand; }
    }
    pick = best;
  }

  // Pass 3: LAST RESORT – any available person (still enforce CT-bucket streak)
  if (!pick) {
    for (const cand of shuffled) {
      if (usedNames.has(cand.name)) continue;
      // Training restriction: trainees can only work E, S, W, C
      if (!canTraineeWork(cand.name, CH)) continue;
      // R1/R2 restriction: CRITICAL - still skip people who work next block even in Pass 3
      // This prevents Relief->CT back-to-back violations
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;
      // Same-day channel restriction: don't assign same channel twice in one day
      const candDayChannels = todayChannels.get(cand.name);
      if (candDayChannels && candDayChannels.has(CH)) continue;
      // Check forbiddenBackToBack even in Pass 3
      const last = lastAssign.get(cand.name);
      if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) continue;
      if (bucket === "ctr" && (ctrStreakLen.get(cand.name)||0) >= 2) continue;
      pick = cand; break;
    }
  }

  // If no pick found, skip this channel but continue with others
  // (Especially important for R1/R2 which may be skipped to prevent violations)
  if (!pick) continue;

  assignments[ch] = pick.name;
  usedNames.add(pick.name);
  lastAssign.set(pick.name, ch);

  // Track channel worked today (to prevent same channel twice in one day)
  if (!todayChannels.has(pick.name)) todayChannels.set(pick.name, new Set());
  todayChannels.get(pick.name).add(CH);

  // update cycle tracking
  if (!channelCycle.has(pick.name)) channelCycle.set(pick.name, new Set());
  const cyc = channelCycle.get(pick.name);
  if (cyc.size >= CHANNELS.length) cyc.clear();
  cyc.add(ch);

  // decrement weekly need if still owed
  const nd = getNeeds(wk, pick.name);
  if (nd[bucket] > 0) nd[bucket] -= 1;

  // update streaks
  updateStreaks(pick.name, String(ch).toUpperCase());

  // update balancing counts
  if (!channelCounts.has(pick.name)) channelCounts.set(pick.name, new Map());
  const m = channelCounts.get(pick.name);
  m.set(ch, (m.get(ch)||0)+1);

  // Track SD employee channel usage (decrement remaining blocks)
  const pickUpper = String(pick.name).toUpperCase();
  if (SD_ELIGIBLE.has(pickUpper) && sdRemainingMap.has(pickUpper)) {
    const rem = sdRemainingMap.get(pickUpper) || 0;
    if (rem > 0) sdRemainingMap.set(pickUpper, rem - 1);
  }

  // Remove from must-get-channel list (they got their channel)
  mustGetChannelNextBlock.delete(pick.name);

  // If R1/R2 assigned and they work next block, they MUST get a channel next block
  // (This applies to Pass 1-3 as well, not just Pass 4)
  if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(pick)) {
    mustGetChannelNextBlock.add(pick.name);
  }
}

// ========== PASS 4: FILL ANY EMPTY CHANNELS ==========
// Multiple sub-passes with decreasing strictness to minimize violations
for (const ch of CHANNELS) {
  if (assignments[ch]) continue; // Already filled

  const CH = String(ch).toUpperCase();
  let pick = null;

  // Pass 4a: All checks - ideal candidate
  for (const cand of shuffled) {
    if (usedNames.has(cand.name)) continue;
    if (!canTraineeWork(cand.name, CH)) continue;
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;
    const last = lastAssign.get(cand.name);
    if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) continue;
    const candDayChannels = todayChannels.get(cand.name);
    if (candDayChannels && candDayChannels.has(CH)) continue;
    pick = cand;
    break;
  }

  // Pass 4b: Skip worksNextBlock, keep forbiddenBackToBack and same-day
  // For R1/R2, prefer people without violations (they'll likely get a Relief->CT violation)
  if (!pick) {
    const candidates4b = shuffled.filter(cand => {
      if (usedNames.has(cand.name)) return false;
      if (!canTraineeWork(cand.name, CH)) return false;
      const last = lastAssign.get(cand.name);
      if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) return false;
      const candDayChannels = todayChannels.get(cand.name);
      if (candDayChannels && candDayChannels.has(CH)) return false;
      return true;
    });
    // Sort: people without violations first (for R1/R2 that may cause violation)
    if ((CH === "RELIEF 1" || CH === "RELIEF 2")) {
      candidates4b.sort((a, b) => (violationCount.get(a.name.toUpperCase())||0) - (violationCount.get(b.name.toUpperCase())||0));
    }
    if (candidates4b.length > 0) pick = candidates4b[0];
  }

  // Pass 4c: Skip worksNextBlock and same-day, KEEP forbiddenBackToBack (most important)
  if (!pick) {
    const candidates4c = shuffled.filter(cand => {
      if (usedNames.has(cand.name)) return false;
      if (!canTraineeWork(cand.name, CH)) return false;
      const last = lastAssign.get(cand.name);
      if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) return false;
      return true;
    });
    // Sort: people without violations first
    if ((CH === "RELIEF 1" || CH === "RELIEF 2")) {
      candidates4c.sort((a, b) => (violationCount.get(a.name.toUpperCase())||0) - (violationCount.get(b.name.toUpperCase())||0));
    }
    if (candidates4c.length > 0) pick = candidates4c[0];
  }

  // Pass 4d: Last resort - anyone available (channel MUST be filled)
  // Even here, prefer people without violations
  if (!pick) {
    const candidates4d = shuffled.filter(cand => {
      if (usedNames.has(cand.name)) return false;
      if (!canTraineeWork(cand.name, CH)) return false;
      return true;
    });
    candidates4d.sort((a, b) => (violationCount.get(a.name.toUpperCase())||0) - (violationCount.get(b.name.toUpperCase())||0));
    if (candidates4d.length > 0) pick = candidates4d[0];
  }

  if (pick) {
    assignments[ch] = pick.name;
    usedNames.add(pick.name);
    lastAssign.set(pick.name, ch);

    if (!todayChannels.has(pick.name)) todayChannels.set(pick.name, new Set());
    todayChannels.get(pick.name).add(CH);

    if (!channelCycle.has(pick.name)) channelCycle.set(pick.name, new Set());
    channelCycle.get(pick.name).add(ch);

    if (!channelCounts.has(pick.name)) channelCounts.set(pick.name, new Map());
    const m = channelCounts.get(pick.name);
    m.set(ch, (m.get(ch)||0)+1);

    updateStreaks(pick.name, CH);

    // Remove from must-get-channel list if they were in it (they got a channel now)
    mustGetChannelNextBlock.delete(pick.name);

    // If R1/R2 assigned to someone who works next block, they MUST get a channel next block
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(pick)) {
      mustGetChannelNextBlock.add(pick.name);
    }
  }
}
// ========== END PASS 4 ==========

const filled = Object.keys(assignments).length;

      // ========== 7TH CHANNEL (Fri/Sat nights 2200-0300) ==========
      // On Friday (day 5) and Saturday (day 6), add an additional "7th" dispatcher channel
      const dayOfWeek = dateObj.getDay(); // 0=Sun, 5=Fri, 6=Sat
      const isFriOrSat = (dayOfWeek === 5 || dayOfWeek === 6);
      const is7thBlock = SEVENTH_BLOCKS.has(b.key);

      if (isFriOrSat && is7thBlock && filled >= 10) {
        // Find someone for 7th channel from remaining available
        const remaining7th = shuffled.filter(c => !usedNames.has(c.name) && !isTrainee(c.name, dayKey));

        // Sort by fewest total assignments (fairness)
        remaining7th.sort((a,b2)=>{
          const ma = channelCounts.get(a.name) || new Map();
          const mb = channelCounts.get(b2.name) || new Map();
          const ta = Array.from(ma.values()).reduce((s,v)=>s+v,0);
          const tb = Array.from(mb.values()).reduce((s,v)=>s+v,0);
          return ta - tb;
        });

        if (remaining7th.length > 0) {
          const pick7 = remaining7th[0];
          assignments[SEVENTH_CHANNEL] = pick7.name;
          usedNames.add(pick7.name);
          lastAssign.set(pick7.name, SEVENTH_CHANNEL);

          // Track 7th channel worked today (to prevent same channel twice in one day)
          if (!todayChannels.has(pick7.name)) todayChannels.set(pick7.name, new Set());
          todayChannels.get(pick7.name).add("7TH");

          // Update balancing counts for 7th
          if (!channelCounts.has(pick7.name)) channelCounts.set(pick7.name, new Map());
          const m7 = channelCounts.get(pick7.name);
          m7.set(SEVENTH_CHANNEL, (m7.get(SEVENTH_CHANNEL)||0)+1);
        }
      }
      // ========== END 7TH CHANNEL ==========

      // SD (Special Detail): Use pre-assigned SD from earlier calculation
      // SD is now assigned FIRST (32 hrs mandatory/week) before channels are filled
      const sd = sdForBlock.slice(); // Copy pre-assigned SD for this block

      // CT overflow: show as a vertical list later; CT does NOT count as a channel in cycle tracking
      const ct = [];


if (available.length > 10) {
  // CT overflow with HARD monthly caps:
  // - We try to keep CT split as evenly as possible across the month.
  // - If CT is unavoidable after caps are hit, we allow a controlled "repeat":
  //     * MAX once per week per person
  //     * MUST be back-to-back (consecutive 4-hr blocks)
    const wmap = ctWeekCounts.get(wk) || new Map();
  const globalIdx = (day-1) * BLOCKS.length + bi;

  function capFor(name){
    // HARD CAP: nobody can be assigned to CT more than 10 times per month
    return 10;
  }
  function canTakeChannel(name, ch){
    const last = lastAssign.get(name);
    if (last && (last === ch || forbiddenBackToBack(last, ch))) return false;
    // Also check daily same-channel restriction
    const candDayChannels = todayChannels.get(name);
    const chUpper = String(ch).toUpperCase();
    if (candDayChannels && candDayChannels.has(chUpper)) return false;
    return true;
  }
  function atOrOverCap(name){
    return (ctMonthCounts.get(name) || 0) >= capFor(name);
  }

  // CRITICAL: First, ensure anyone in mustGetChannelNextBlock gets a channel (to avoid Relief->CT)
  // These people were on R1/R2 last block and MUST get a channel now
  let remaining = shuffled.filter(c => !usedNames.has(c.name));

  const mustGetPeople = remaining.filter(c => mustGetChannelNextBlock.has(c.name));
  for (const cand of mustGetPeople) {
    // Try to swap them into any channel
    for (const ch of CHANNELS) {
      const cur = assignments[ch];
      if (!cur) continue; // Empty channel - shouldn't happen but skip
      if (!canTakeChannel(cand.name, ch)) continue;

      // Check if current holder can go to CT (not on CTR recently)
      const holderLast = lastAssign.get(cur);
      const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
      const ctrSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
      if (ctrSet.has(holderLastUpper)) continue; // Holder can't go to CT
      if (mustGetChannelNextBlock.has(cur)) continue; // Holder also needs a channel

      // Swap: cand gets channel, cur goes to CT pool
      assignments[ch] = cand.name;
      usedNames.add(cand.name);
      usedNames.delete(cur);
      lastAssign.set(cand.name, ch);

      const chUpper = String(ch).toUpperCase();
      if (!todayChannels.has(cand.name)) todayChannels.set(cand.name, new Set());
      todayChannels.get(cand.name).add(chUpper);

      if (!channelCounts.has(cand.name)) channelCounts.set(cand.name, new Map());
      channelCounts.get(cand.name).set(ch, (channelCounts.get(cand.name).get(ch)||0)+1);

      mustGetChannelNextBlock.delete(cand.name); // They got their channel
      break;
    }
    remaining = shuffled.filter(c => !usedNames.has(c.name));
  }

  // If someone is capped, try to swap them into a channel (so they don't land in CT),
  // pushing a non-capped person into overflow instead.
  remaining = shuffled.filter(c => !usedNames.has(c.name));

  const cappedNow = remaining.filter(c => atOrOverCap(c.name));
  for (const cand of cappedNow) {
    let swapped = false;

    for (const ch of CHANNELS) {
      const cur = assignments[ch];
      if (!cur) continue;

      // only swap out someone who is NOT capped
      if (atOrOverCap(cur)) continue;
      if (!canTakeChannel(cand.name, ch)) continue;

      // swap
      assignments[ch] = cand.name;
      usedNames.add(cand.name);
      usedNames.delete(cur);

      // keep lastAssign consistent for cand
      lastAssign.set(cand.name, ch);

      // Track swapped-in channel worked today
      const swapCH = String(ch).toUpperCase();
      if (!todayChannels.has(cand.name)) todayChannels.set(cand.name, new Set());
      todayChannels.get(cand.name).add(swapCH);

      // update balancing counts for cand
      if (!channelCounts.has(cand.name)) channelCounts.set(cand.name, new Map());
      const mm = channelCounts.get(cand.name);
      mm.set(ch, (mm.get(ch) || 0) + 1);

      swapped = true;
      break;
    }

    if (swapped) {
      remaining = shuffled.filter(c => !usedNames.has(c.name));
    }
  }

  // Now assign CT STRICTLY under the hard cap.
  // Weekly soft cap: prefer people with fewer CT this week (spread across month)
  const CT_WEEKLY_SOFT_CAP = 3; // Soft cap: try to limit CT to 3 per person per week
  remaining = shuffled.filter(c => !usedNames.has(c.name));

  // Sort priority: under weekly soft cap > under monthly cap > lowest CT counts
  remaining.sort((a,b2)=>{
    const ca = ctMonthCounts.get(a.name)||0;
    const cb = ctMonthCounts.get(b2.name)||0;
    const oa = ca >= capFor(a.name);
    const ob = cb >= capFor(b2.name);

    // Weekly CT counts for spreading across month
    const wca = wmap.get(a.name)||0;
    const wcb = wmap.get(b2.name)||0;
    const woa = wca >= CT_WEEKLY_SOFT_CAP;
    const wob = wcb >= CT_WEEKLY_SOFT_CAP;

    // Priority: under monthly cap first
    if (oa !== ob) return oa ? 1 : -1;
    // Then prefer under weekly soft cap (spread CT across weeks)
    if (woa !== wob) return woa ? 1 : -1;
    // Then prefer lowest weekly CT (spread within week)
    if (wca !== wcb) return wca - wcb;
    // Then prefer lowest monthly CT
    if (ca !== cb) return ca - cb;
    return 0;
  });

  for (const cand of remaining) {
    const name = cand.name;
    // Training restriction: trainees should not be assigned to CT
    if (isTrainee(name, dayKey)) { continue; }

    // STRICT: R1, R2, CT should NEVER be back-to-back in any order
    const lastCh = lastAssign.get(name);
    if (lastCh) {
      const lastUpper = String(lastCh).toUpperCase();
      if (lastUpper === "CT" || lastUpper === "RELIEF 1" || lastUpper === "RELIEF 2" || lastUpper === "R1" || lastUpper === "R2") {
        continue; // Skip - they were just on R1/R2/CT
      }
    }

    // STRICT: CT/R1/R2 should NOT repeat in the same day in any combination
    const candDayChannels = todayChannels.get(name);
    if (candDayChannels) {
      if (candDayChannels.has("CT") || candDayChannels.has("RELIEF 1") || candDayChannels.has("RELIEF 2")) {
        continue; // Skip - they already had CT/R1/R2 today
      }
    }

    const needs = getNeeds(wk, name);
    // Weekly mix rule: CT counts toward the CT/R1/R2 bucket (2 blocks / 8 hrs target)
    if ((needs.ctr || 0) <= 0) { continue; }

    const cur = ctMonthCounts.get(name) || 0;
    const cap = capFor(name);

    if (cur >= cap) {
      continue;
    }

    // Soft weekly cap: skip if over soft cap AND others are available
    const weekCt = wmap.get(name)||0;
    const othersUnderWeeklyCap = remaining.some(c =>
      c.name !== name &&
      !ct.includes(c.name) &&
      (wmap.get(c.name)||0) < CT_WEEKLY_SOFT_CAP &&
      (ctMonthCounts.get(c.name)||0) < capFor(c.name)
    );
    if (weekCt >= CT_WEEKLY_SOFT_CAP && othersUnderWeeklyCap) {
      continue; // Skip this person, let someone else take CT
    }

    ct.push(name);
    // decrement weekly CT/R bucket need
    if ((needs.ctr||0) > 0) needs.ctr -= 1;
    updateStreaks(name, "CT");
    lastAssign.set(name, "CT"); // Track CT assignment for back-to-back prevention

    // Track CT in daily channels to prevent same-day repeat
    if (!todayChannels.has(name)) todayChannels.set(name, new Set());
    todayChannels.get(name).add("CT");

    wmap.set(name, (wmap.get(name) || 0) + 1);
    ctMonthCounts.set(name, cur + 1);
    lastCTAt.set(name, {dayKey, blockIdx: bi});
    lastCTGlobalIdx.set(name, globalIdx);
  }

  ctWeekCounts.set(wk, wmap);
}

// SAFETY NET: Anyone who is available but wasn't assigned to a channel or CT
// For people who were on CT/R1/R2, we MUST get them a channel to avoid back-to-back
const unassigned = available.filter(d => !usedNames.has(d.name));
const ctrNames = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);

for (const u of unassigned) {
  if (ct.includes(u.name)) continue;

  const lastCh = lastAssign.get(u.name);
  const lastUpper = lastCh ? String(lastCh).toUpperCase() : "";
  const wasOnCTR = ctrNames.has(lastUpper);

  // Also check if they had any CTR today (not just last block)
  const uDayChans = todayChannels.get(u.name);
  const hadCTRToday = uDayChans && (uDayChans.has("CT") || uDayChans.has("RELIEF 1") || uDayChans.has("RELIEF 2"));

  if (wasOnCTR || hadCTRToday) {
    // They were on CT/R1/R2 - MUST get a channel, not CT
    // Try to find an empty channel first
    let foundChannel = false;
    for (const ch of CHANNELS) {
      if (assignments[ch]) continue; // Already filled
      const chUpper = String(ch).toUpperCase();
      if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue; // Can't do R1/R2
      // Check daily same-channel restriction
      const uDayChannels = todayChannels.get(u.name);
      if (uDayChannels && uDayChannels.has(chUpper)) continue;
      if (!forbiddenBackToBack(lastUpper, chUpper)) {
        assignments[ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, ch);
        // Track channel worked today
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(chUpper);
        foundChannel = true;
        break;
      }
    }

    // If no empty channel, SWAP with someone who CAN go to CT (prefer no violations)
    if (!foundChannel) {
      const swapCands1 = [];
      for (const ch of CHANNELS) {
        const currentHolder = assignments[ch];
        if (!currentHolder) continue;
        const chUpper = String(ch).toUpperCase();
        if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue;
        if (forbiddenBackToBack(lastUpper, chUpper)) continue;
        const uDayChannels = todayChannels.get(u.name);
        if (uDayChannels && uDayChannels.has(chUpper)) continue;

        const holderLast = lastAssign.get(currentHolder);
        const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
        const holderWasOnCTR = ctrNames.has(holderLastUpper);
        const holderDayChannels = todayChannels.get(currentHolder);
        const holderHadCTToday = holderDayChannels && holderDayChannels.has("CT");
        const holderCTCount = ctMonthCounts.get(currentHolder) || 0;
        const holderAtCap = holderCTCount >= 10;

        if (!holderWasOnCTR && !holderHadCTToday && !holderAtCap) {
          const holderViol = violationCount.get(currentHolder.toUpperCase()) || 0;
          swapCands1.push({ ch, chUpper, currentHolder, holderCTCount, holderViol });
        }
      }
      // Sort: no violations first, then lowest CT
      swapCands1.sort((a, b) => {
        if (a.holderViol !== b.holderViol) return a.holderViol - b.holderViol;
        return a.holderCTCount - b.holderCTCount;
      });
      if (swapCands1.length > 0) {
        const best = swapCands1[0];
        assignments[best.ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, best.ch);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(best.chUpper);

        ct.push(best.currentHolder);
        lastAssign.set(best.currentHolder, "CT");
        updateStreaks(best.currentHolder, "CT");
        if (!todayChannels.has(best.currentHolder)) todayChannels.set(best.currentHolder, new Set());
        todayChannels.get(best.currentHolder).add("CT");
        ctMonthCounts.set(best.currentHolder, best.holderCTCount + 1);
        const wkMap = ctWeekCounts.get(wk) || new Map();
        wkMap.set(best.currentHolder, (wkMap.get(best.currentHolder) || 0) + 1);
        ctWeekCounts.set(wk, wkMap);

        foundChannel = true;
      }
    }

    // If still no channel, try harder to swap - find ANY channel holder who can go to CT (prefer no violations)
    if (!foundChannel) {
      const swapCands2 = [];
      for (const ch of CHANNELS) {
        const currentHolder = assignments[ch];
        if (!currentHolder) continue;
        const chUpper = String(ch).toUpperCase();
        if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue;
        if (forbiddenBackToBack(lastUpper, chUpper)) continue;
        const uDayChannels = todayChannels.get(u.name);
        if (uDayChannels && uDayChannels.has(chUpper)) continue;

        const holderLast = lastAssign.get(currentHolder);
        const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
        const holderWasOnCTR = ctrNames.has(holderLastUpper);
        const holderDayChannels = todayChannels.get(currentHolder);
        const holderHadCTRToday = holderDayChannels && (holderDayChannels.has("CT") || holderDayChannels.has("RELIEF 1") || holderDayChannels.has("RELIEF 2"));
        const holderCTCount2 = ctMonthCounts.get(currentHolder) || 0;
        const holderAtCap2 = holderCTCount2 >= 10;

        if (!holderWasOnCTR && !holderHadCTRToday && !holderAtCap2) {
          const holderViol = violationCount.get(currentHolder.toUpperCase()) || 0;
          swapCands2.push({ ch, chUpper, currentHolder, holderCTCount2, holderViol });
        }
      }
      // Sort: no violations first, then lowest CT
      swapCands2.sort((a, b) => {
        if (a.holderViol !== b.holderViol) return a.holderViol - b.holderViol;
        return a.holderCTCount2 - b.holderCTCount2;
      });
      if (swapCands2.length > 0) {
        const best = swapCands2[0];
        assignments[best.ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, best.ch);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(best.chUpper);

        ct.push(best.currentHolder);
        lastAssign.set(best.currentHolder, "CT");
        updateStreaks(best.currentHolder, "CT");
        if (!todayChannels.has(best.currentHolder)) todayChannels.set(best.currentHolder, new Set());
        todayChannels.get(best.currentHolder).add("CT");
        ctMonthCounts.set(best.currentHolder, best.holderCTCount2 + 1);
        const wkMap2 = ctWeekCounts.get(wk) || new Map();
        wkMap2.set(best.currentHolder, (wkMap2.get(best.currentHolder) || 0) + 1);
        ctWeekCounts.set(wk, wkMap2);

        foundChannel = true;
      }
    }

    // THIRD ATTEMPT: Allow swapping with someone OVER cap (uneven CT is better than violation)
    // Sort by CT count to prefer swapping with lowest CT person even if over cap
    if (!foundChannel) {
      const swapCandidates = [];
      for (const ch of CHANNELS) {
        const currentHolder = assignments[ch];
        if (!currentHolder) continue;
        const chUpper = String(ch).toUpperCase();
        if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue;
        if (forbiddenBackToBack(lastUpper, chUpper)) continue;
        const uDayChannels = todayChannels.get(u.name);
        if (uDayChannels && uDayChannels.has(chUpper)) continue;

        const holderLast = lastAssign.get(currentHolder);
        const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
        const holderWasOnCTR = ctrNames.has(holderLastUpper);
        const holderDayChannels = todayChannels.get(currentHolder);
        const holderHadCTRToday = holderDayChannels && (holderDayChannels.has("CT") || holderDayChannels.has("RELIEF 1") || holderDayChannels.has("RELIEF 2"));

        // Allow over-cap, but skip if they were on CTR or had CTR today (would cause violation)
        if (!holderWasOnCTR && !holderHadCTRToday) {
          const holderCT = ctMonthCounts.get(currentHolder) || 0;
          swapCandidates.push({ ch, chUpper, currentHolder, holderCT });
        }
      }

      // Sort by: 1) no violations first, 2) lowest CT count
      swapCandidates.sort((a, b) => {
        const aViol = violationCount.get(a.currentHolder.toUpperCase()) || 0;
        const bViol = violationCount.get(b.currentHolder.toUpperCase()) || 0;
        if (aViol !== bViol) return aViol - bViol; // Prefer no violations
        return a.holderCT - b.holderCT;
      });

      if (swapCandidates.length > 0) {
        const best = swapCandidates[0];
        assignments[best.ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, best.ch);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(best.chUpper);

        ct.push(best.currentHolder);
        lastAssign.set(best.currentHolder, "CT");
        updateStreaks(best.currentHolder, "CT");
        if (!todayChannels.has(best.currentHolder)) todayChannels.set(best.currentHolder, new Set());
        todayChannels.get(best.currentHolder).add("CT");
        ctMonthCounts.set(best.currentHolder, best.holderCT + 1);
        const wkMap3 = ctWeekCounts.get(wk) || new Map();
        wkMap3.set(best.currentHolder, (wkMap3.get(best.currentHolder) || 0) + 1);
        ctWeekCounts.set(wk, wkMap3);

        foundChannel = true;
      }
    }

    // Last resort: if still no channel, assign CT (violation is unavoidable)
    if (!foundChannel) {
      ct.push(u.name);
      lastAssign.set(u.name, "CT");
      updateStreaks(u.name, "CT");
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add("CT");
      // UPDATE CT COUNTS
      ctMonthCounts.set(u.name, (ctMonthCounts.get(u.name) || 0) + 1);
      const wkMapLR = ctWeekCounts.get(wk) || new Map();
      wkMapLR.set(u.name, (wkMapLR.get(u.name) || 0) + 1);
      ctWeekCounts.set(wk, wkMapLR);
      // TRACK VIOLATION (Relief->CT back-to-back)
      addViolation(u.name);
    }
  } else {
    // They weren't on CT/R1/R2 - check if they already had any CTR today
    const uDayChannels = todayChannels.get(u.name);
    const uHadCTRToday = uDayChannels && (uDayChannels.has("CT") || uDayChannels.has("RELIEF 1") || uDayChannels.has("RELIEF 2"));
    // Also check if they're at or over monthly CT cap
    const uCTCount = ctMonthCounts.get(u.name) || 0;
    if (!uHadCTRToday && uCTCount < 10) {
      ct.push(u.name);
      lastAssign.set(u.name, "CT");
      updateStreaks(u.name, "CT");
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add("CT");
      // UPDATE CT COUNTS
      ctMonthCounts.set(u.name, uCTCount + 1);
      const wkMapElse = ctWeekCounts.get(wk) || new Map();
      wkMapElse.set(u.name, (wkMapElse.get(u.name) || 0) + 1);
      ctWeekCounts.set(wk, wkMapElse);
    }
    // If they already had CTR today or at cap, force CT anyway — unassigned is never acceptable
    if (!ct.includes(u.name) && !usedNames.has(u.name)) {
      ct.push(u.name);
      lastAssign.set(u.name, "CT");
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add("CT");
      ctMonthCounts.set(u.name, (ctMonthCounts.get(u.name) || 0) + 1);
      const wkMapForce = ctWeekCounts.get(wk) || new Map();
      wkMapForce.set(u.name, (wkMapForce.get(u.name) || 0) + 1);
      ctWeekCounts.set(wk, wkMapForce);
    }
  }
}

// FINAL SWEEP: Catch anyone still not assigned (trainees, edge cases) — force to CT
const finalUnassigned = available.filter(d => !usedNames.has(d.name) && !ct.includes(d.name) && !sd.includes(d.name));
for (const u of finalUnassigned) {
  ct.push(u.name);
  lastAssign.set(u.name, "CT");
  if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
  todayChannels.get(u.name).add("CT");
  ctMonthCounts.set(u.name, (ctMonthCounts.get(u.name) || 0) + 1);
  const wkMapFinal = ctWeekCounts.get(wk) || new Map();
  wkMapFinal.set(u.name, (wkMapFinal.get(u.name) || 0) + 1);
  ctWeekCounts.set(wk, wkMapFinal);
}

      plan.days[dayKey][b.key] = { assignments, sd, ct, filled, needed: 10 };
    }
  }

  savePlan(plan);

  // Count ALL violations by scanning the final schedule (same logic as CSV export)
  const violationsFound = new Map(); // name -> count
  const ctrSet2 = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);

  for (let day = 1; day <= daysInMonth; day++) {
    const dateObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
    const dayKey = ymd(dateObj);
    const dayData = plan.days[dayKey];
    if (!dayData) continue;

    // Track assignments per person for this day
    const personAssignments = new Map(); // name -> [{blockIdx, channel}]

    for (let bi = 0; bi < BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
      const blockData = dayData[b.key];
      if (!blockData) continue;

      // Collect all assignments for this block
      for (const [ch, name] of Object.entries(blockData.assignments || {})) {
        if (!name) continue;
        const nameUpper = String(name).toUpperCase();
        if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
        personAssignments.get(nameUpper).push({ blockIdx: bi, channel: ch.toUpperCase(), blockKey: b.key });
      }
      for (const name of (blockData.ct || [])) {
        const nameUpper = String(name).toUpperCase();
        if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
        personAssignments.get(nameUpper).push({ blockIdx: bi, channel: "CT", blockKey: b.key });
      }
    }

    // Check for violations per person
    for (const [name, assignments] of personAssignments) {
      assignments.sort((a, b) => a.blockIdx - b.blockIdx);
      const dayChannels = new Map(); // channel -> count

      for (let i = 0; i < assignments.length; i++) {
        const curr = assignments[i];
        const chUpper = curr.channel;

        // Same channel twice in day (except SD)
        if (dayChannels.has(chUpper) && chUpper !== "SD") {
          violationsFound.set(name, (violationsFound.get(name) || 0) + 1);
        }
        dayChannels.set(chUpper, (dayChannels.get(chUpper) || 0) + 1);

        // CTR back-to-back
        if (i > 0) {
          const prev = assignments[i - 1];
          const prevChUpper = prev.channel;
          if (curr.blockIdx === prev.blockIdx + 1 && ctrSet2.has(chUpper) && ctrSet2.has(prevChUpper)) {
            violationsFound.set(name, (violationsFound.get(name) || 0) + 1);
          }
        }
      }
    }
  }

  let totalViolations = 0;
  for (const count of violationsFound.values()) {
    totalViolations += count;
  }
  const uniquePeopleWithViolations = violationsFound.size;

  // Compute max primary channel count and max CT count for non-SD people (quality metrics)
  const rebalanceChannels = ["North","East","South","West","Central","Northwest"];
  let _maxPrimCount = 0;
  const _primUpper = new Set(rebalanceChannels.map(ch => ch.toUpperCase()));
  // Build finalCounts from the plan
  const finalCounts = new Map();
  for (const dk of Object.keys(plan.days)) {
    const dayData = plan.days[dk];
    for (const bk of BLOCKS) {
      const bd = dayData[bk.key];
      if (!bd || !bd.assignments) continue;
      for (const [ch, nm] of Object.entries(bd.assignments)) {
        if (!nm) continue;
        if (!finalCounts.has(nm)) finalCounts.set(nm, new Map());
        const m = finalCounts.get(nm);
        m.set(ch.toUpperCase(), (m.get(ch.toUpperCase()) || 0) + 1);
      }
    }
  }
  for (const [name, m] of finalCounts) {
    if (SD_ELIGIBLE.has(name.toUpperCase())) continue;
    for (const [ch, count] of m) {
      if (_primUpper.has(ch.toUpperCase()) && count > _maxPrimCount) _maxPrimCount = count;
    }
  }

  // Max CT count across all non-SD people
  let _maxCTCount = 0;
  const _ctMap = new Map();
  for (const dk of Object.keys(plan.days)) {
    const dayData = plan.days[dk];
    for (const bk of BLOCKS) {
      const bd = dayData[bk.key];
      if (!bd || !bd.ct) continue;
      for (const nm of bd.ct) {
        if (SD_ELIGIBLE.has(String(nm).toUpperCase())) continue;
        _ctMap.set(nm, (_ctMap.get(nm) || 0) + 1);
      }
    }
  }
  for (const [, count] of _ctMap) {
    if (count > _maxCTCount) _maxCTCount = count;
  }

  // Store violation stats for display
  window.lastRandomizeStats = {
    totalViolations,
    uniquePeopleWithViolations,
    violationsByPerson: Object.fromEntries(violationsFound),
    maxPrimaryCount: _maxPrimCount,
    maxCTCount: _maxCTCount
  };

  return plan;
}
// ========== END OPTION B RANDOMIZER ==========

const channelColor = (()=>{
  const pal = [
    "rgba(245, 158, 11, .25)",
    "rgba(16, 185, 129, .25)",
    "rgba(59, 130, 246, .25)",
    "rgba(239, 68, 68, .25)",
    "rgba(168, 85, 247, .25)",
    "rgba(14, 165, 233, .25)",
    "rgba(244, 63, 94, .25)",
    "rgba(34, 197, 94, .25)",
    "rgba(250, 204, 21, .25)",
    "rgba(99, 102, 241, .25)",
  ];
  const map={};
  CHANNELS.forEach((c,i)=>map[c]=pal[i%pal.length]);
  // 7th channel color (distinct cyan)
  map[SEVENTH_CHANNEL] = "rgba(6, 182, 212, .35)";
  return map;
})();

function renderDay(dayKey) {
  const plan = loadPlan();
  const dayTitle = document.getElementById("dayTitle");
  const wrap = document.getElementById("dayTableWrap");
  if (!plan || !plan.days || !plan.days[dayKey]) {
    dayTitle.textContent = "No month plan yet – click Randomize Month";
    wrap.innerHTML = "";
    return;
  }
  const d = parseYMD(dayKey);
  dayTitle.textContent = d ? `${monthName(d.getMonth())} ${d.getDate()}, ${d.getFullYear()}` : dayKey;

  // ========== VIOLATION DETECTION FOR DAY ==========
  const ctrSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
  const personAssignments = new Map();
  const violationCells = new Set();

  // Get previous day's last block for cross-day detection
  const prevDate = d ? new Date(d.getFullYear(), d.getMonth(), d.getDate() - 1) : null;
  const prevDayKey = prevDate ? ymd(prevDate) : null;
  const prevDayBlocks = prevDayKey && plan.days[prevDayKey] ? plan.days[prevDayKey] : null;
  const prevLastBlockEntry = prevDayBlocks ? prevDayBlocks[BLOCKS[BLOCKS.length - 1].key] : null;

  // Collect assignments for today
  BLOCKS.forEach((b, bi) => {
    const entry = plan.days[dayKey][b.key];
    if (!entry) return;
    if (entry.assignments) {
      for (const [ch, nm] of Object.entries(entry.assignments)) {
        if (!nm) continue;
        const nameUpper = String(nm).toUpperCase();
        if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
        personAssignments.get(nameUpper).push({blockKey: b.key, blockIdx: bi, channel: ch});
      }
    }
    if (entry.ct && entry.ct.length) {
      for (const nm of entry.ct) {
        const nameUpper = String(nm).toUpperCase();
        if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
        personAssignments.get(nameUpper).push({blockKey: b.key, blockIdx: bi, channel: "CT"});
      }
    }
  });

  // Detect violations
  for (const [name, assignments] of personAssignments) {
    assignments.sort((a, b) => a.blockIdx - b.blockIdx);
    const dayChannels = new Map();

    // Check if first block continues from previous day's CTR
    if (assignments.length > 0 && assignments[0].blockIdx === 0 && prevLastBlockEntry) {
      const firstCh = String(assignments[0].channel).toUpperCase();
      if (ctrSet.has(firstCh)) {
        // Check prev day's last block for this person
        let prevAssignCh = null;
        if (prevLastBlockEntry.assignments) {
          for (const [ch, nm] of Object.entries(prevLastBlockEntry.assignments)) {
            if (String(nm).toUpperCase() === name) prevAssignCh = ch;
          }
        }
        if (!prevAssignCh && prevLastBlockEntry.ct) {
          if (prevLastBlockEntry.ct.some(n => String(n).toUpperCase() === name)) prevAssignCh = "CT";
        }
        if (prevAssignCh && ctrSet.has(String(prevAssignCh).toUpperCase())) {
          violationCells.add(`${dayKey}|${assignments[0].blockKey}|${name}`);
        }
      }
    }

    for (let i = 0; i < assignments.length; i++) {
      const curr = assignments[i];
      const chUpper = String(curr.channel).toUpperCase();
      // Same channel twice in day is a violation (except SD which can repeat)
      if (dayChannels.has(chUpper) && chUpper !== "SD") {
        violationCells.add(`${dayKey}|${curr.blockKey}|${name}`);
      }
      dayChannels.set(chUpper, (dayChannels.get(chUpper) || 0) + 1);
      if (i > 0) {
        const prev = assignments[i - 1];
        const prevChUpper = String(prev.channel).toUpperCase();
        if (curr.blockIdx === prev.blockIdx + 1 && ctrSet.has(chUpper) && ctrSet.has(prevChUpper)) {
          violationCells.add(`${dayKey}|${curr.blockKey}|${name}`);
          violationCells.add(`${dayKey}|${prev.blockKey}|${name}`);
        }
      }
    }
  }
  // ========== END VIOLATION DETECTION ==========

  // Channel abbreviations for display
  const chAbbrev = {"North":"N","South":"S","East":"E","West":"W","Central":"C","Northwest":"NW","Relief 1":"R1","Relief 2":"R2","DC1":"DC1","DC2":"DC2"};

  const dayNames = ['SUNDAY','MONDAY','TUESDAY','WEDNESDAY','THURSDAY','FRIDAY','SATURDAY'];
  const dayOfWeekName = d ? dayNames[d.getDay()] : '';

  let html = "<table style='table-layout:fixed; width:100%;'><thead>";

  // Row 1: Day of the week
  html += `<tr><th colspan="${BLOCKS.length + 1}" style="text-align:center; padding:0; border:none;">
    <div style="font-size:15px; font-weight:900; letter-spacing:3px; color:var(--muted); padding:8px 0 2px;">${dayOfWeekName}</div>
  </th></tr>`;

  // Row 2: Day Shift / Night Shift banners
  html += `<tr>`;
  html += `<th style="border:none;"></th>`;
  html += `<th colspan="3" style="padding:6px 0; border:1px solid var(--line); border-bottom:none; border-right:4px solid rgba(255,255,255,.4); font-size:11px; font-weight:800; letter-spacing:1.5px; color:#e2c87a; background:rgba(250,204,21,.06);">&#9788; DAY SHIFT</th>`;
  html += `<th colspan="3" style="padding:6px 0; border:1px solid var(--line); border-bottom:none; border-left:none; font-size:11px; font-weight:800; letter-spacing:1.5px; color:#94a3c4; background:rgba(100,116,160,.06);">&#9790; NIGHT SHIFT</th>`;
  html += `</tr>`;

  // Row 3: CHANNEL + block time labels
  html += `<tr><th style='width:90px;'>CHANNEL</th>`;
  for (const b of BLOCKS) html += `<th>${b.label}</th>`;
  html += "</tr>";

  // Row 4: COPY FOR BOARD buttons
  html += "<tr><th></th>";
  for (const b of BLOCKS) html += `<th style="text-align:center;"><button class="btn-copy-block" data-day="${dayKey}" data-block="${b.key}" title="Copy names for ${b.label}" style="padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,.12); background:#0c1320; color:#e6edf7; cursor:pointer; font-weight:700; font-size:11px;">COPY FOR BOARD</button></th>`;
  html += "</tr></thead><tbody>";

  for (let ci=0; ci<CHANNELS.length; ci++) {
    const ch = CHANNELS[ci];
    html += `<tr><td><b>${ch.toUpperCase()}</b></td>`;
    for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
      const entry = plan.days[dayKey][b.key];
      const nm = (entry.assignments||{})[ch] || "";
      const bg = channelColor[ch] || "rgba(255,255,255,.08)";
      const isViolation = nm && violationCells.has(`${dayKey}|${b.key}|${nm.toUpperCase()}`);
      const abbr = chAbbrev[ch] || ch;
      html += `<td>${ nm ? `<span class="assign-cell clickable-assign${isViolation ? ' violation' : ''}" data-day="${dayKey}" data-block="${b.key}" data-channel="${ch}" data-name="${escapeHtml(nm.toUpperCase())}" data-type="channel" style="background:${bg}; cursor:pointer;"><b>${abbr}</b> ${escapeHtml(nm.toUpperCase())}</span>` : `<span class="assign-cell needed-badge clickable-needed" data-day="${dayKey}" data-block="${b.key}" data-channel="${ch}" data-type="channel" style="cursor:pointer;"><b>${abbr}</b> NEEDED</span>` }</td>`;
    }
    html += "</tr>";
  }

  // 7th channel row (Fri/Sat nights only)
  const dayDate = parseYMD(dayKey);
  const dayOfWeek = dayDate ? dayDate.getDay() : -1;
  const showSeventhRow = (dayOfWeek === 5 || dayOfWeek === 6);
  if (showSeventhRow) {
    html += `<tr><td><b>${SEVENTH_CHANNEL}</b></td>`;
    for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
      const entry = plan.days[dayKey][b.key];
      const nm = (entry.assignments||{})[SEVENTH_CHANNEL] || "";
      const bg = channelColor[SEVENTH_CHANNEL] || "rgba(255,255,255,.08)";
      const show7th = SEVENTH_BLOCKS.has(b.key);
      const isViolation = nm && violationCells.has(`${dayKey}|${b.key}|${nm.toUpperCase()}`);
      html += `<td>${ (nm && show7th) ? `<span class="assign-cell clickable-assign${isViolation ? ' violation' : ''}" data-day="${dayKey}" data-block="${b.key}" data-channel="${SEVENTH_CHANNEL}" data-name="${escapeHtml(nm.toUpperCase())}" data-type="channel" style="background:${bg}; cursor:pointer;"><b>7th</b> ${escapeHtml(nm.toUpperCase())}</span>` : (show7th ? `<span class="assign-cell needed-badge clickable-needed" data-day="${dayKey}" data-block="${b.key}" data-channel="${SEVENTH_CHANNEL}" data-type="channel" style="cursor:pointer;"><b>7th</b> NEEDED</span>` : "<span class='small'>–</span>") }</td>`;
    }
    html += "</tr>";
  }

  html += `<tr><td><b>CT</b></td>`;
  let prevCT = new Set();
  for (let bi=0; bi<BLOCKS.length; bi++) {
    const b = BLOCKS[bi];
    const entry = plan.days[dayKey][b.key];
    const list = entry.ct || [];
    const curCT = new Set(list);
    const inner = list.length
      ? `<div class="ctlist">${list.map(n=>{
          const nameUpper = String(n).toUpperCase();
          const isRepeat = prevCT.has(n);
          const isViolation = violationCells.has(`${dayKey}|${b.key}|${nameUpper}`);
          const cls = (isRepeat || isViolation) ? "ctitem repeat" : "ctitem";
          const title = isRepeat ? ' title="Back-to-back CT (unavoidable)"' : (isViolation ? ' title="Violation: R1/CT/R2 back-to-back"' : "");
          return `<div class="${cls} clickable-assign" data-day="${dayKey}" data-block="${b.key}" data-channel="CT" data-name="${escapeHtml(nameUpper)}" data-type="ct" style="cursor:pointer;"${title}>${escapeHtml(nameUpper)}</div>`;
        }).join("")}</div>`
      : "";
    html += `<td>${inner}</td>`;
    prevCT = curCT;
  }
  html += "</tr>";

  html += `<tr><td><b>SD</b></td>`;
  for (let bi=0; bi<BLOCKS.length; bi++) {
    const b = BLOCKS[bi];
    const entry = plan.days[dayKey][b.key];
    const list = entry.sd || [];
    const inner = list.length
      ? `<div class="ctlist">${list.map(n=>{
          return `<div class="ctitem clickable-assign" data-day="${dayKey}" data-block="${b.key}" data-channel="SD" data-name="${escapeHtml(String(n).toUpperCase())}" data-type="sd" style="background:rgba(200,170,255,.15); color:rgba(200,170,255,.8); border-color:rgba(200,170,255,.25); cursor:pointer;">${escapeHtml(String(n).toUpperCase())}</div>`;
        }).join("")}</div>`
      : "";
    html += `<td>${inner}</td>`;
  }
  html += "</tr>";

  // VACATION row: dispatchers excluded (on vacation) for this day
  {
    const allDispatchers = normalizeBase()
      .filter(r => String(r.Position||"").trim().toUpperCase() === "DISPATCHER")
      .map(r => String(r.Employee||"").trim()).filter(Boolean);
    const vacNames = allDispatchers.filter(n => isExcluded(n, d)).map(n => n.toUpperCase()).sort();
    html += `<tr><td><b style="color:#7dd3fc;">VACATION</b></td>`;
    if (vacNames.length) {
      const items = vacNames.map(n =>
        `<div style="margin:1px 0;"><span class="assign-cell" style="background:rgba(125,211,252,.15); color:#7dd3fc; font-weight:700; font-size:10px; border:1px solid rgba(125,211,252,.3); cursor:default;">${escapeHtml(n)}</span></div>`
      ).join("");
      html += `<td colspan="${BLOCKS.length}">${items}</td>`;
    } else {
      html += `<td colspan="${BLOCKS.length}" style="color:var(--muted); font-size:10px;">None</td>`;
    }
    html += "</tr>";
  }

  // ABSENT row
  html += `<tr><td><b style="color:#f87171;">ABSENT</b></td>`;
  for (let bi=0; bi<BLOCKS.length; bi++) {
    const b = BLOCKS[bi];
    const entry = plan.days[dayKey][b.key];
    const absentList = (entry?.absent || []).map(n => String(n).toUpperCase()).filter(Boolean);
    if (absentList.length) {
      const items = absentList.map(n =>
        `<div style="margin:1px 0;"><span class="assign-cell clickable-absent" data-day="${dayKey}" data-block="${b.key}" data-name="${escapeHtml(n)}" style="background:rgba(248,113,113,.12); color:#f87171; font-weight:700; font-size:10px; border:1px solid rgba(248,113,113,.25); cursor:pointer;">${escapeHtml(n)}</span></div>`
      ).join("");
      html += `<td>${items}</td>`;
    } else {
      html += `<td></td>`;
    }
  }
  html += "</tr>";

  // UNASSIGNED row: people scheduled to work but not in any channel/CT/SD
  html += `<tr><td><b style="color:rgba(200,200,210,.7);">UNASSIGNED</b></td>`;
  for (let bi=0; bi<BLOCKS.length; bi++) {
    const b = BLOCKS[bi];
    const entry = plan.days[dayKey][b.key];
    const assignedNames = new Set();
    if (entry) {
      for (const nm of Object.values(entry.assignments||{})) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
      for (const nm of (entry.sd||[])) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
      for (const nm of (entry.ct||[])) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
      for (const nm of (entry.absent||[])) { assignedNames.add(String(nm).trim().toUpperCase()); }
    }
    const pool = buildDispatcherPoolForDate(d);
    const unassigned = pool.filter(p => worksBlock(p, d, b) && !assignedNames.has(String(p.name).trim().toUpperCase()));
    if (unassigned.length) {
      const items = unassigned.map(u =>
        `<div style="margin:1px 0;"><span class="assign-cell" style="background:rgba(200,200,210,.15); color:rgba(200,200,210,.7); font-weight:700; font-size:10px; border:1px solid rgba(200,200,210,.25); cursor:default;">${escapeHtml(String(u.name).toUpperCase())}</span></div>`
      ).join("");
      html += `<td>${items}</td>`;
    } else {
      html += `<td></td>`;
    }
  }
  html += "</tr>";

  html += "</tbody></table>";
  try { savePlan(plan); } catch(e) { console.warn(e); }
  wrap.innerHTML = html;

  renderInfoStats();
}

// Non-regular employees excluded from fairness stats
const EXCLUDED_FROM_STATS = new Set(["RAMIREZ","CLEMENT","MARZAHN","BROWNC","FOWLERL","GUIDRY","GROUNDS"]);

function computeTotals(plan) {
  const channelTotals = new Map(CHANNELS.map(c=>[c,0]));
  const dispatcherTotals = new Map();
  const dispatcherTop = new Map();
  const dispatcherChannelCounts = new Map();
  const shortfalls = [];

  for (const [dayKey, blocks] of Object.entries(plan.days||{})) {
    for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
      const entry = blocks[b.key];
      const filled = entry ? entry.filled : 0;
      if (filled < 10) shortfalls.push({ dayKey, block: b.label, filled });
      if (!entry) continue;
      for (const [ch, nm] of Object.entries(entry.assignments||{})) {
        const name = String(nm).trim().toUpperCase();
        if (EXCLUDED_FROM_STATS.has(name)) continue;
        channelTotals.set(ch, (channelTotals.get(ch)||0) + 1);
        dispatcherTotals.set(name, (dispatcherTotals.get(name)||0) + 1);
        if (!dispatcherTop.has(name)) dispatcherTop.set(name, new Map());
        const m = dispatcherTop.get(name);
        m.set(ch, (m.get(ch)||0)+1);
        if (!dispatcherChannelCounts.has(name)) dispatcherChannelCounts.set(name, new Map());
        const hm = dispatcherChannelCounts.get(name);
        hm.set(ch, (hm.get(ch)||0) + 1);
      }
      for (const nm of (entry.sd||[])) {
        const name = String(nm).trim().toUpperCase();
        if (EXCLUDED_FROM_STATS.has(name)) continue;
        dispatcherTotals.set(name, (dispatcherTotals.get(name)||0) + 1);
        if (!dispatcherChannelCounts.has(name)) dispatcherChannelCounts.set(name, new Map());
        const hm = dispatcherChannelCounts.get(name);
        hm.set("SD", (hm.get("SD")||0) + 1);
      }
      for (const nm of (entry.ct||[])) {
        const name = String(nm).trim().toUpperCase();
        if (EXCLUDED_FROM_STATS.has(name)) continue;
        dispatcherTotals.set(name, (dispatcherTotals.get(name)||0) + 1);
        if (!dispatcherChannelCounts.has(name)) dispatcherChannelCounts.set(name, new Map());
        const hm = dispatcherChannelCounts.get(name);
        hm.set("CT", (hm.get("CT")||0) + 1);
      }
    }
  }
  return {channelTotals, dispatcherTotals, dispatcherTop, dispatcherChannelCounts, shortfalls};
}

function renderStatsHtml(plan) {
  if (!plan || !plan.days) return '<div style="text-align:center; color:var(--muted); padding:20px;">NO DATA</div>';

  const PRIMARY = ["North","South","East","West","Central","Northwest"];
  const RELIEF_SET = new Set(["Relief 1","Relief 2"]);
  const DC_SET_S = new Set(["DC1","DC2"]);
  const DAY_BLOCKS = new Set(["0600-1000","1000-1400","1400-1800"]);
  const abbrMap = {North:"N",South:"S",East:"E",West:"W",Central:"C",Northwest:"NW"};

  function _cs(val, a) {
    const d = val - a;
    if (d <= -1.5) return 'color:#f87171; font-weight:700;';
    if (d >= 1.5) return 'color:#60a5fa; font-weight:700;';
    return '';
  }

  function _emptyRow() { return { North:0, South:0, East:0, West:0, Central:0, Northwest:0, relief:0, ct:0, dc:0, sd:0, total:0 }; }

  function _addToRow(ch, row) {
    if (PRIMARY.includes(ch)) row[ch]++;
    else if (RELIEF_SET.has(ch)) row.relief++;
    else if (DC_SET_S.has(ch)) row.dc++;
    row.total++;
  }

  // Build per-person combined totals + track which shifts each person works
  const allTotals = new Map();   // name -> row (combined across all blocks)
  const personShifts = new Map(); // name -> { day: bool, night: bool }

  for (const [dayKey, blocks] of Object.entries(plan.days || {})) {
    for (const b of BLOCKS) {
      const entry = blocks[b.key];
      if (!entry) continue;
      const isDay = DAY_BLOCKS.has(b.key);

      for (const [ch, nm] of Object.entries(entry.assignments || {})) {
        if (!nm) continue;
        const name = String(nm).trim().toUpperCase();
        if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
        if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
        _addToRow(ch, allTotals.get(name));
        if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
      }
      for (const nm of (entry.ct || [])) {
        const name = String(nm).trim().toUpperCase();
        if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
        if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
        const row = allTotals.get(name);
        row.ct++; row.total++;
        if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
      }
      // SD assignments
      for (const nm of (entry.sd || [])) {
        const name = String(nm).trim().toUpperCase();
        if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
        if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
        allTotals.get(name).sd++;
        if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
      }
    }
  }

  // Split into 4 groups: SD-eligible get their own table
  const sdGroup = new Map();
  const dayOnly = new Map();
  const nightOnly = new Map();
  const splitShift = new Map();
  for (const [name, row] of allTotals) {
    if (SD_ELIGIBLE.has(name)) { sdGroup.set(name, row); continue; }
    const s = personShifts.get(name);
    if (s.day && s.night) splitShift.set(name, row);
    else if (s.day) dayOnly.set(name, row);
    else nightOnly.set(name, row);
  }

  function _buildTable(title, totalsMap) {
    const names = Array.from(totalsMap.keys()).sort();
    if (names.length === 0) return '';

    const n = names.length || 1;
    const avg = _emptyRow();
    for (const [, r] of totalsMap) {
      for (const ch of PRIMARY) avg[ch] += r[ch];
      avg.relief += r.relief; avg.ct += r.ct; avg.dc += r.dc;
    }
    for (const ch of PRIMARY) avg[ch] /= n;
    avg.relief /= n; avg.ct /= n; avg.dc /= n;

    let h = `<h3 style="margin:12px 0 4px; font-size:12px; color:var(--text);">${title}</h3>`;
    h += `<table style="width:100%; border-collapse:collapse; font-size:11px; table-layout:fixed;"><thead><tr>`;
    h += `<th style="text-align:left; padding:3px 4px; width:90px;">NAME</th>`;
    for (const ch of PRIMARY) h += `<th style="text-align:center; padding:3px 2px; background:${channelColor[ch]||'transparent'};">${abbrMap[ch]}</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(168,85,247,.2);">R</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(220,220,230,.15);">CT</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(100,140,200,.15);">DC</th>`;
    h += `<th style="text-align:center; padding:3px 2px; font-weight:700;">TOT</th>`;
    h += `</tr></thead><tbody>`;

    for (const name of names) {
      const g = totalsMap.get(name);
      h += `<tr><td style="text-align:left; padding:2px 4px; font-weight:600; font-size:10px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(name)}</td>`;
      for (const ch of PRIMARY) h += `<td style="text-align:center; padding:2px; ${_cs(g[ch], avg[ch])}">${g[ch]}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(g.relief, avg.relief)}">${g.relief}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(g.ct, avg.ct)}">${g.ct}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(g.dc, avg.dc)}">${g.dc}</td>`;
      h += `<td style="text-align:center; padding:2px; font-weight:700;">${g.total}</td></tr>`;
    }

    h += `<tr style="border-top:2px solid var(--border); font-style:italic; color:var(--muted);">`;
    h += `<td style="text-align:left; padding:2px 4px;">AVG</td>`;
    for (const ch of PRIMARY) h += `<td style="text-align:center; padding:2px;">${avg[ch].toFixed(1)}</td>`;
    h += `<td style="text-align:center; padding:2px;">${avg.relief.toFixed(1)}</td>`;
    h += `<td style="text-align:center; padding:2px;">${avg.ct.toFixed(1)}</td>`;
    h += `<td style="text-align:center; padding:2px;">${avg.dc.toFixed(1)}</td>`;
    h += `<td></td></tr>`;
    h += `</tbody></table>`;
    return h;
  }

  function _buildSDTable(title, totalsMap) {
    const names = Array.from(totalsMap.keys()).sort();
    if (names.length === 0) return '';

    const n = names.length || 1;
    const avg = _emptyRow();
    for (const [, r] of totalsMap) {
      for (const ch of PRIMARY) avg[ch] += r[ch];
      avg.relief += r.relief; avg.ct += r.ct; avg.dc += r.dc; avg.sd += r.sd;
    }
    for (const ch of PRIMARY) avg[ch] /= n;
    avg.relief /= n; avg.ct /= n; avg.dc /= n; avg.sd /= n;

    let h = `<h3 style="margin:12px 0 4px; font-size:12px; color:var(--text);">${title}</h3>`;
    h += `<table style="width:100%; border-collapse:collapse; font-size:11px; table-layout:fixed;"><thead><tr>`;
    h += `<th style="text-align:left; padding:3px 4px; width:90px;">NAME</th>`;
    for (const ch of PRIMARY) h += `<th style="text-align:center; padding:3px 2px; background:${channelColor[ch]||'transparent'};">${abbrMap[ch]}</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(168,85,247,.2);">R</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(220,220,230,.15);">CT</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(100,140,200,.15);">DC</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(200,170,255,.2);">SD</th>`;
    h += `<th style="text-align:center; padding:3px 2px; font-weight:700;">TOT</th>`;
    h += `</tr></thead><tbody>`;

    for (const name of names) {
      const g = totalsMap.get(name);
      const chTotal = g.total + g.sd; // total includes channels+CT, add SD
      h += `<tr><td style="text-align:left; padding:2px 4px; font-weight:600; font-size:10px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(name)}</td>`;
      for (const ch of PRIMARY) h += `<td style="text-align:center; padding:2px; ${_cs(g[ch], avg[ch])}">${g[ch]}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(g.relief, avg.relief)}">${g.relief}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(g.ct, avg.ct)}">${g.ct}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(g.dc, avg.dc)}">${g.dc}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(g.sd, avg.sd)}">${g.sd}</td>`;
      h += `<td style="text-align:center; padding:2px; font-weight:700;">${chTotal}</td></tr>`;
    }

    h += `<tr style="border-top:2px solid var(--border); font-style:italic; color:var(--muted);">`;
    h += `<td style="text-align:left; padding:2px 4px;">AVG</td>`;
    for (const ch of PRIMARY) h += `<td style="text-align:center; padding:2px;">${avg[ch].toFixed(1)}</td>`;
    h += `<td style="text-align:center; padding:2px;">${avg.relief.toFixed(1)}</td>`;
    h += `<td style="text-align:center; padding:2px;">${avg.ct.toFixed(1)}</td>`;
    h += `<td style="text-align:center; padding:2px;">${avg.dc.toFixed(1)}</td>`;
    h += `<td style="text-align:center; padding:2px;">${avg.sd.toFixed(1)}</td>`;
    h += `<td></td></tr>`;
    h += `</tbody></table>`;
    return h;
  }

  return _buildSDTable("SD ELIGIBLE (Special Detail)", sdGroup)
       + _buildTable("DAY SHIFT (6A – 6P)", dayOnly)
       + _buildTable("NIGHT SHIFT (6P – 6A)", nightOnly)
       + _buildTable("SPLIT SHIFT (Day + Night)", splitShift);
}



function channelAbbrev(ch) {
  const map = { "North":"N","South":"S","East":"E","West":"W","Central":"C","Northwest":"NW","Relief 1":"R1","Relief 2":"R2","DC1":"DC1","DC2":"DC2","SD":"SD","CT":"CT","7th":"7th" };
  return map[ch] || ch;
}
function renderMonthRoster(mode, wrapId) {
  // cumulative counts per employee per channel for this render
  const countsByEmp = {};

  let plan = loadPlan();
  const wrap = document.getElementById(wrapId || "mRosterWrapDay");
  if (!wrap) return;

  // Ensure we have a plan for the currently selected month/year
  const selM = Number(document.getElementById("monthSel").value);
  const selY = Number(document.getElementById("yearSel").value);
  if (!plan || !plan.meta || plan.meta.year !== selY || plan.meta.monthIndex !== selM) {
    try { randomizeMonth(selY, selM); } catch(e) { console.error(e); }
    plan = loadPlan();
  }
  if (!plan || !plan.meta) { wrap.innerHTML = "<div class='small'>Click <b>Randomize Month</b> to generate a plan.</div>"; return; }

  const year = plan.meta.year;
  const monthIndex = plan.meta.monthIndex;
  const daysInMonth = new Date(year, monthIndex+1, 0).getDate();

  const shift = (String(mode||"DAY").toUpperCase()==="NIGHT") ? "NIGHT" : "DAY";
  const SELBLOCKS = (shift==="DAY") ? ["0600-1000","1000-1400","1400-1800"] : ["1800-2200","2200-0200","0200-0600"];
  const blockLabels = {
    "0600-1000":"6A-10A","1000-1400":"10A-2P","1400-1800":"2P-6P",
    "1800-2200":"6P-10P","2200-0200":"10P-2A","0200-0600":"2A-6A"
  };


  function worksAnyInShift(rec){
    if (!rec) return false;
    const days = ["MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY","SUNDAY"];
    for (const d of days){
      const s = rec[d];
      if (s && blocksWorkedForSchedule(s, shift).size) return true;
    }
    return false;
  }
  const baseAll = normalizeBase();
  const dispatchers = baseAll
    .filter(r => String(r.Position||"").trim().toUpperCase()==="DISPATCHER")
    .map(r => ({ name: String(r.Employee||"").trim(), seniority: Number(r.Seniority||0), rec:r }))
    .filter(d => d.name);

  const hires = getNewHires().map(n=>String(n).trim()).filter(Boolean)
    .filter(n => dispatchers.every(d => d.name.toUpperCase() !== n.toUpperCase()))
    .map(n => ({ name:n, seniority:0, rec:null, isHire:true }));

  let people = dispatchers.concat(hires).sort((a,b)=>{
    const sa = (isFinite(a.seniority)?a.seniority:999999);
    const sb = (isFinite(b.seniority)?b.seniority:999999);
    if (sa !== sb) return sa - sb;
    return a.name.localeCompare(b.name);
  });
  people = people.filter(p => p.isHire || worksAnyInShift(p.rec));

  const cols = [];
  for (let day=1; day<=daysInMonth; day++) {
    const d = new Date(year, monthIndex, day, 12,0,0,0);
    const dk = ymd(d);
    const dn = dayName(d);
    for (const bk of SELBLOCKS) cols.push({ dk, dn, bk, label: `${monthIndex+1}/${day} ${blockLabels[bk]}` });
  }

  const assignMap = {};
  for (let day=1; day<=daysInMonth; day++) {
    const d = new Date(year, monthIndex, day, 12,0,0,0);
    const dk = ymd(d);
    assignMap[dk] = {};
    const dayBlocks = (plan.days && plan.days[dk]) ? plan.days[dk] : null;
    for (const bk of SELBLOCKS) {
      const map = new Map();
      if (dayBlocks && dayBlocks[bk]) {
        const entry = dayBlocks[bk];
        for (const [ch, nm] of Object.entries(entry.assignments||{})) {
          map.set(String(nm).trim().toUpperCase(), ch);
        }
        for (const nm of (entry.sd||[])) {
          map.set(String(nm).trim().toUpperCase(), "SD");
        }
        for (const nm of (entry.ct||[])) {
          map.set(String(nm).trim().toUpperCase(), "CT");
        }
      }
      assignMap[dk][bk] = map;
    }
  }

  let html = `<div class="mroster-scroll"><table class="mroster-table"><thead><tr>`;
  html += `<th class="sticky-left">Employee</th>`;
  for (const c of cols) html += `<th>${c.label}</th>`;
  html += `</tr></thead><tbody>`;

  for (const p of people) {
    html += `<tr><td class="sticky-left"><b>${escapeHtml(p.name.toUpperCase())}</b></td>`;
    for (const c of cols) {
      const rec = p.rec;
      const schedVal = rec ? String(rec[c.dn]||"").trim().toUpperCase() : "";
      const worked = rec ? blocksWorkedForSchedule(schedVal, shift) : new Set();
      const workingThisBlock = worked.has(c.bk);
      if (!workingThisBlock) {
        html += `<td><span class="cellbtn off">OFF</span></td>`;
      } else if (isExcluded(p.name, new Date(c.dk + "T12:00:00"))) {
        html += `<td><span class="cellbtn" style="background:rgba(168,85,247,.25); color:#c4b5fd; font-weight:700; font-size:9px; border:1px solid rgba(168,85,247,.4);">VAC</span></td>`;
      } else {
        let ch = assignMap[c.dk][c.bk].get(String(p.name).trim().toUpperCase()) || "";

        const ab = ch ? channelAbbrev(ch) : "";
        const bg = (ch === "CT" ? "#ffffff" : (ch ? (channelColor[ch] || "rgba(255,255,255,.08)") : "rgba(255,255,255,.06)"));

        // Cumulative counts per employee per channel (increase left→right across the month)
        if (!countsByEmp[p.name]) countsByEmp[p.name] = {};
        if (ch) countsByEmp[p.name][ch] = (countsByEmp[p.name][ch] || 0) + 1;

        const cnt = ch ? (countsByEmp[p.name][ch] || 0) : 0;
        const label = ch ? `${ab} (${cnt})` : "";
        const dataType = (ch === "CT") ? "ct" : (ch === "SD") ? "sd" : "channel";
        html += `<td>${label ? `<span class="cellbtn clickable-assign" data-day="${c.dk}" data-block="${c.bk}" data-channel="${ch}" data-name="${escapeHtml(p.name.toUpperCase())}" data-type="${dataType}" style="background:${bg}; cursor:pointer; ${ch==="CT"?"color:#000 !important; border:2px solid #fff !important; box-shadow:none !important;":"color:var(--text);"}">${escapeHtml(label)}</span>` : `<span class="cellbtn" style="background:#facc15; color:#000; font-weight:900; font-size:10px; border:2px solid #eab308; animation:needPulse 1.2s ease-in-out infinite;">UN</span>`}</td>`;
      }
    }
    html += `</tr>`;
  }

  html += `</tbody></table></div>`;
  try { savePlan(plan); } catch(e) { console.warn(e); }
  wrap.innerHTML = html;
}

function renderWeek(anchorDayKey) {
  const plan = loadPlan();
  const wrap = document.getElementById("weekWrap");
  if (!plan) { wrap.innerHTML = "<div class='small'>Randomize a month first.</div>"; return; }

  const anchor = parseYMD(anchorDayKey) || new Date(plan.meta.year, plan.meta.monthIndex, 1, 12,0,0,0);
  const dow = anchor.getDay();
  const offsetToSat = (dow - 6 + 7) % 7;
  const start = new Date(anchor.getFullYear(), anchor.getMonth(), anchor.getDate() - offsetToSat, 12,0,0,0);

  const daysListAll = [];
  for (let i=0;i<7;i++) daysListAll.push(new Date(start.getFullYear(), start.getMonth(), start.getDate()+i, 12,0,0,0));
  // Filter to only days that have data in the plan
  const daysList = daysListAll.filter(d => plan.days[ymd(d)]);

  // ========== VIOLATION DETECTION FOR WEEK ==========
  const ctrSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
  const personAssignments = new Map();
  const violationCells = new Set();

  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    if (!blocks) continue;
    BLOCKS.forEach((b, bi) => {
      const entry = blocks[b.key];
      if (!entry) return;
      if (entry.assignments) {
        for (const [ch, nm] of Object.entries(entry.assignments)) {
          if (!nm) continue;
          const nameUpper = String(nm).toUpperCase();
          if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
          personAssignments.get(nameUpper).push({dayKey, blockKey: b.key, blockIdx: bi, channel: ch, dayNum: d.getDate(), dayIdx: daysList.indexOf(d)});
        }
      }
      if (entry.ct && entry.ct.length) {
        for (const nm of entry.ct) {
          const nameUpper = String(nm).toUpperCase();
          if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
          personAssignments.get(nameUpper).push({dayKey, blockKey: b.key, blockIdx: bi, channel: "CT", dayNum: d.getDate(), dayIdx: daysList.indexOf(d)});
        }
      }
    });
  }

  for (const [name, assignments] of personAssignments) {
    assignments.sort((a, b) => {
      if (a.dayIdx !== b.dayIdx) return a.dayIdx - b.dayIdx;
      return a.blockIdx - b.blockIdx;
    });
    const dayChannels = new Map();
    for (let i = 0; i < assignments.length; i++) {
      const curr = assignments[i];
      const chUpper = String(curr.channel).toUpperCase();
      if (!dayChannels.has(curr.dayKey)) dayChannels.set(curr.dayKey, new Map());
      const dayCh = dayChannels.get(curr.dayKey);
      // Same channel twice in day is a violation (except SD which can repeat)
      if (dayCh.has(chUpper) && chUpper !== "SD") {
        violationCells.add(`${curr.dayKey}|${curr.blockKey}|${name}`);
      }
      dayCh.set(chUpper, (dayCh.get(chUpper) || 0) + 1);
      if (i > 0) {
        const prev = assignments[i - 1];
        const prevChUpper = String(prev.channel).toUpperCase();
        const isConsecutive = (curr.dayKey === prev.dayKey && curr.blockIdx === prev.blockIdx + 1) ||
                              (curr.dayIdx === prev.dayIdx + 1 && prev.blockIdx === BLOCKS.length - 1 && curr.blockIdx === 0);
        if (isConsecutive && ctrSet.has(chUpper) && ctrSet.has(prevChUpper)) {
          violationCells.add(`${curr.dayKey}|${curr.blockKey}|${name}`);
          violationCells.add(`${prev.dayKey}|${prev.blockKey}|${name}`);
        }
      }
    }
  }
  // ========== END VIOLATION DETECTION ==========

  // Build a "daily-like" table: channels rows, (day x block) columns
  let html = `<div class="scroll-x"><table class="wide-table"><thead>`;

  // Row 1: day headers spanning 6 blocks each
  html += `<tr><th rowspan="2">Channel</th>`;
  for (const d of daysList) {
    const key = ymd(d);
    const lbl = `${["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][d.getDay()]} ${d.getMonth()+1}/${d.getDate()}`;
    html += `<th class="dayhead" colspan="${BLOCKS.length}" data-day="${key}" style="cursor:pointer" title="Click to load this day">${lbl}</th>`;
  }
  html += `</tr>`;

  // Row 2: block labels
  html += `<tr>`;
  for (let di=0; di<daysList.length; di++) {
    for (const b of BLOCKS) html += `<th class="subhead">${b.label}</th>`;
  }
  html += `</tr></thead><tbody>`;

  // Channel rows
  for (const ch of CHANNELS) {
    html += `<tr><td><b>${ch.toUpperCase()}</b></td>`;
    for (const d of daysList) {
      const dayKey = ymd(d);
      const blocks = plan.days[dayKey];
      for (const b of BLOCKS) {
        const entry = blocks ? blocks[b.key] : null;
        const nm = entry && entry.assignments ? (entry.assignments[ch] || "") : "";
        const bg = channelColor[ch] || "rgba(255,255,255,.08)";
        const short = entry && (entry.filled||0) < 10;
        const isViolation = nm && violationCells.has(`${dayKey}|${b.key}|${nm.toUpperCase()}`);
        const abbr = channelAbbrev(ch);
        html += `<td>${nm ? `<span class="assign-cell clickable-assign${isViolation ? ' violation' : ''}" data-day="${dayKey}" data-block="${b.key}" data-channel="${ch}" data-name="${escapeHtml(nm.toUpperCase())}" data-type="channel" style="background:${bg}; cursor:pointer; ${short?'outline:2px solid rgba(217,72,72,.6); outline-offset:1px;':''}">${abbr} ${escapeHtml(nm.toUpperCase())}</span>` : `<span class="assign-cell needed-badge clickable-needed" data-day="${dayKey}" data-block="${b.key}" data-channel="${ch}" data-type="channel" style="cursor:pointer;">${abbr} NEEDED</span>`}</td>`;
      }
    }
    html += `</tr>`;
  }

  // 7th channel row (Fri/Sat nights)
  html += `<tr><td><b>${SEVENTH_CHANNEL}</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const dow = d.getDay();
    const isFriSat = (dow === 5 || dow === 6);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const show7th = isFriSat && SEVENTH_BLOCKS.has(b.key);
      if (!show7th) { html += `<td><span class="small">–</span></td>`; continue; }
      const entry = blocks ? blocks[b.key] : null;
      const nm = entry && entry.assignments ? (entry.assignments[SEVENTH_CHANNEL] || "") : "";
      const bg = channelColor[SEVENTH_CHANNEL] || "rgba(255,255,255,.08)";
      html += `<td>${nm ? `<span class="assign-cell clickable-assign" data-day="${dayKey}" data-block="${b.key}" data-channel="${SEVENTH_CHANNEL}" data-name="${escapeHtml(nm.toUpperCase())}" data-type="channel" style="background:${bg}; cursor:pointer;">7th ${escapeHtml(nm.toUpperCase())}</span>` : `<span class="assign-cell needed-badge clickable-needed" data-day="${dayKey}" data-block="${b.key}" data-channel="${SEVENTH_CHANNEL}" data-type="channel" style="cursor:pointer;"><b>7th</b> NEEDED</span>`}</td>`;
    }
  }
  html += `</tr>`;

  // CT row
  html += `<tr><td><b>CT</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const entry = blocks ? blocks[b.key] : null;
      const list = entry && entry.ct ? entry.ct : [];
      if (list && list.length) {
        const items = list.map(n=>{
          const nameUpper = String(n).toUpperCase();
          const isViolation = violationCells.has(`${dayKey}|${b.key}|${nameUpper}`);
          return `<div style="margin:1px 0"><span class="assign-cell clickable-assign${isViolation ? ' violation' : ''}" data-day="${dayKey}" data-block="${b.key}" data-channel="CT" data-name="${escapeHtml(nameUpper)}" data-type="ct" style="background:rgba(220,220,230,.15); color:rgba(255,255,255,.7); border-color:rgba(220,220,230,.25); box-shadow:none; cursor:pointer;">CT ${escapeHtml(nameUpper)}</span></div>`;
        }).join("");
        html += `<td>${items}</td>`;
      } else {
        html += `<td></td>`;
      }
    }
  }
  html += `</tr>`;

  // SD row
  html += `<tr><td><b>SD</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const entry = blocks ? blocks[b.key] : null;
      const list = entry && entry.sd ? entry.sd : [];
      if (list && list.length) {
        const items = list.map(n=>`<div style="margin:1px 0"><span class="assign-cell clickable-assign" data-day="${dayKey}" data-block="${b.key}" data-channel="SD" data-name="${escapeHtml(n.toUpperCase())}" data-type="sd" style="background:rgba(200,170,255,.15); color:rgba(200,170,255,.8); border-color:rgba(200,170,255,.25); cursor:pointer;">SD ${escapeHtml(n.toUpperCase())}</span></div>`).join("");
        html += `<td>${items}</td>`;
      } else {
        html += `<td></td>`;
      }
    }
  }
  html += `</tr>`;

  // VACATION row: dispatchers excluded (on vacation) for each day
  html += `<tr><td class="sticky-col"><b style="color:#7dd3fc;">VACATION</b></td>`;
  {
    const allDispatchers = normalizeBase()
      .filter(r => String(r.Position||"").trim().toUpperCase() === "DISPATCHER")
      .map(r => String(r.Employee||"").trim()).filter(Boolean);
    for (const d of daysList) {
      const vacNames = allDispatchers.filter(n => isExcluded(n, d)).map(n => n.toUpperCase()).sort();
      if (vacNames.length) {
        const items = vacNames.map(n =>
          `<div style="margin:1px 0;"><span class="assign-cell" style="background:rgba(125,211,252,.15); color:#7dd3fc; font-weight:700; font-size:10px; border:1px solid rgba(125,211,252,.3); cursor:default;">${escapeHtml(n)}</span></div>`
        ).join("");
        html += `<td colspan="${BLOCKS.length}">${items}</td>`;
      } else {
        html += `<td colspan="${BLOCKS.length}" style="color:var(--muted); font-size:10px;">—</td>`;
      }
    }
  }
  html += `</tr>`;

  // ABSENT row
  html += `<tr><td class="sticky-col"><b style="color:#f87171;">ABSENT</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const entry = blocks ? blocks[b.key] : null;
      const absentList = (entry?.absent || []).map(n => String(n).toUpperCase()).filter(Boolean);
      if (absentList.length) {
        const items = absentList.map(n =>
          `<div style="margin:1px 0;"><span class="assign-cell clickable-absent" data-day="${dayKey}" data-block="${b.key}" data-name="${escapeHtml(n)}" style="background:rgba(248,113,113,.12); color:#f87171; font-weight:700; font-size:10px; border:1px solid rgba(248,113,113,.25); cursor:pointer;">${escapeHtml(n)}</span></div>`
        ).join("");
        html += `<td>${items}</td>`;
      } else {
        html += `<td></td>`;
      }
    }
  }
  html += `</tr>`;

  // UNASSIGNED row
  html += `<tr><td><b style="color:rgba(200,200,210,.7);">UNASSIGNED</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const entry = blocks ? blocks[b.key] : null;
      const assignedNames = new Set();
      if (entry) {
        for (const nm of Object.values(entry.assignments||{})) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
        for (const nm of (entry.sd||[])) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
        for (const nm of (entry.ct||[])) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
        for (const nm of (entry.absent||[])) { assignedNames.add(String(nm).trim().toUpperCase()); }
      }
      const pool = buildDispatcherPoolForDate(d);
      const unassigned = pool.filter(p => worksBlock(p, d, b) && !assignedNames.has(String(p.name).trim().toUpperCase()));
      if (unassigned.length) {
        const items = unassigned.map(u => `<div style="margin:1px 0"><span class="assign-cell" style="background:rgba(200,200,210,.15); color:rgba(200,200,210,.7); font-weight:700; font-size:10px; border:1px solid rgba(200,200,210,.25); cursor:default;">${escapeHtml(String(u.name).toUpperCase())}</span></div>`).join("");
        html += `<td>${items}</td>`;
      } else {
        html += `<td></td>`;
      }
    }
  }
  html += `</tr>`;

  html += `</tbody></table></div>`;
  try { savePlan(plan); } catch(e) { console.warn(e); }
  wrap.innerHTML = html;

  // Click day headers to load that day in Day tab
  wrap.querySelectorAll("th.dayhead[data-day]").forEach(th=>{
    th.addEventListener("click", ()=>{
      const dk = th.getAttribute("data-day");
      document.getElementById("dayPick").value = dk;
      setActiveTab("day");
      renderDay(dk);
    });
  });
}



function renderMonth(year, monthIndex) {
  const plan = loadPlan();
  const wrap = document.getElementById("monthWrap");
  if (!plan) { wrap.innerHTML = "<div class='small'>Randomize a month first.</div>"; return; }

  const daysInMonth = new Date(year, monthIndex+1, 0).getDate();
  const daysList = [];
  for (let day=1; day<=daysInMonth; day++) {
    daysList.push(new Date(year, monthIndex, day, 12,0,0,0));
  }

  // ========== VIOLATION DETECTION ==========
  // Build person assignment sequences and detect violations
  const ctrSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
  const personAssignments = new Map(); // name -> [{dayKey, blockIdx, channel}]
  const violationCells = new Set(); // "dayKey|blockKey|name" strings

  // Collect all assignments per person
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    if (!blocks) continue;
    BLOCKS.forEach((b, bi) => {
      const entry = blocks[b.key];
      if (!entry) return;
      // Channel assignments
      if (entry.assignments) {
        for (const [ch, nm] of Object.entries(entry.assignments)) {
          if (!nm) continue;
          const nameUpper = String(nm).toUpperCase();
          if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
          personAssignments.get(nameUpper).push({dayKey, blockKey: b.key, blockIdx: bi, channel: ch, dayNum: d.getDate()});
        }
      }
      // CT assignments
      if (entry.ct && entry.ct.length) {
        for (const nm of entry.ct) {
          const nameUpper = String(nm).toUpperCase();
          if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
          personAssignments.get(nameUpper).push({dayKey, blockKey: b.key, blockIdx: bi, channel: "CT", dayNum: d.getDate()});
        }
      }
    });
  }

  // Sort each person's assignments by day and block, then detect violations
  for (const [name, assignments] of personAssignments) {
    assignments.sort((a, b) => {
      if (a.dayNum !== b.dayNum) return a.dayNum - b.dayNum;
      return a.blockIdx - b.blockIdx;
    });

    // Track channels worked per day for same-channel violation
    const dayChannels = new Map(); // dayKey -> Map(channelUpper -> count)

    for (let i = 0; i < assignments.length; i++) {
      const curr = assignments[i];
      const chUpper = String(curr.channel).toUpperCase();

      // Check same-channel-in-day violation (SD can repeat, but nothing else)
      if (!dayChannels.has(curr.dayKey)) dayChannels.set(curr.dayKey, new Map());
      const dayCh = dayChannels.get(curr.dayKey);
      if (dayCh.has(chUpper) && chUpper !== "SD") {
        // Violation! Same channel twice in same day
        violationCells.add(`${curr.dayKey}|${curr.blockKey}|${name}`);
      }
      dayCh.set(chUpper, (dayCh.get(chUpper) || 0) + 1);

      // Check R1/CT/R2 back-to-back violation (with previous assignment)
      if (i > 0) {
        const prev = assignments[i - 1];
        const prevChUpper = String(prev.channel).toUpperCase();
        // Check if consecutive (same day adjacent block OR day boundary)
        const isConsecutive = (curr.dayKey === prev.dayKey && curr.blockIdx === prev.blockIdx + 1) ||
                              (curr.dayNum === prev.dayNum + 1 && prev.blockIdx === BLOCKS.length - 1 && curr.blockIdx === 0);
        if (isConsecutive && ctrSet.has(chUpper) && ctrSet.has(prevChUpper)) {
          // Violation! R1/CT/R2 back-to-back
          violationCells.add(`${curr.dayKey}|${curr.blockKey}|${name}`);
          violationCells.add(`${prev.dayKey}|${prev.blockKey}|${name}`);
        }
      }
    }
  }
  // ========== END VIOLATION DETECTION ==========

  let html = `<div class="scroll-x"><table class="wide-table"><thead>`;

  // Row 1: date headers spanning 6 blocks each
  html += `<tr><th rowspan="2">CHANNEL</th>`;
  for (const d of daysList) {
    const key = ymd(d);
    const lbl = `${monthIndex+1}/${d.getDate()}`;
    html += `<th class="dayhead" colspan="${BLOCKS.length}" data-day="${key}" style="cursor:pointer" title="Click to load this day">${lbl}</th>`;
  }
  html += `</tr>`;

  // Row 2: block labels
  html += `<tr>`;
  for (let di=0; di<daysList.length; di++) {
    for (const b of BLOCKS) html += `<th class="subhead">${b.label}</th>`;
  }
  html += `</tr></thead><tbody>`;

  // Channel rows
  for (const ch of CHANNELS) {
    const chAbbr = channelAbbrev(ch);
    html += `<tr><td><b>${ch.toUpperCase()}</b></td>`;
    for (const d of daysList) {
      const dayKey = ymd(d);
      const blocks = plan.days[dayKey];
      for (const b of BLOCKS) {
        const entry = blocks ? blocks[b.key] : null;
        const nm = entry && entry.assignments ? (entry.assignments[ch] || "") : "";
        const bg = channelColor[ch] || "rgba(255,255,255,.08)";
        const short = entry && (entry.filled||0) < 10;
        const isViolation = nm && violationCells.has(`${dayKey}|${b.key}|${nm.toUpperCase()}`);
        html += `<td>${nm ? `<span class="assign-cell month-cell clickable-assign${isViolation ? ' violation' : ''}" data-day="${dayKey}" data-block="${b.key}" data-channel="${ch}" data-name="${escapeHtml(nm.toUpperCase())}" data-type="channel" data-emp="${escapeHtml(nm.toUpperCase())}" style="background:${bg}; cursor:pointer; ${short?'outline:2px solid rgba(217,72,72,.6); outline-offset:1px;':''}"><b>${chAbbr}</b> ${escapeHtml(nm.toUpperCase())}</span>` : `<span class="assign-cell month-cell needed-badge clickable-needed" data-day="${dayKey}" data-block="${b.key}" data-channel="${ch}" data-type="channel" style="cursor:pointer;"><b>${chAbbr}</b> NEEDED</span>`}</td>`;
      }
    }
    html += `</tr>`;
  }

  // 7th channel row (Fri/Sat nights)
  html += `<tr><td><b>${SEVENTH_CHANNEL}</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const dow = d.getDay();
    const isFriSat = (dow === 5 || dow === 6);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const show7th = isFriSat && SEVENTH_BLOCKS.has(b.key);
      if (!show7th) { html += `<td><span class="small">–</span></td>`; continue; }
      const entry = blocks ? blocks[b.key] : null;
      const nm = entry && entry.assignments ? (entry.assignments[SEVENTH_CHANNEL] || "") : "";
      const bg = channelColor[SEVENTH_CHANNEL] || "rgba(255,255,255,.08)";
      html += `<td>${nm ? `<span class="assign-cell month-cell clickable-assign" data-day="${dayKey}" data-block="${b.key}" data-channel="${SEVENTH_CHANNEL}" data-name="${escapeHtml(nm.toUpperCase())}" data-type="channel" data-emp="${escapeHtml(nm.toUpperCase())}" style="background:${bg}; cursor:pointer;"><b>7th</b> ${escapeHtml(nm.toUpperCase())}</span>` : `<span class="assign-cell month-cell needed-badge clickable-needed" data-day="${dayKey}" data-block="${b.key}" data-channel="${SEVENTH_CHANNEL}" data-type="channel" style="cursor:pointer;"><b>7th</b> NEEDED</span>`}</td>`;
    }
  }
  html += `</tr>`;

  // CT row
  html += `<tr><td><b>CT</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const entry = blocks ? blocks[b.key] : null;
      const list = entry && entry.ct ? entry.ct : [];
      if (list && list.length) {
        const items = list.map(n=>{
          const nameUpper = String(n).toUpperCase();
          const isViolation = violationCells.has(`${dayKey}|${b.key}|${nameUpper}`);
          return `<div style="margin:2px 0"><span class="assign-cell month-cell clickable-assign${isViolation ? ' violation' : ''}" data-day="${dayKey}" data-block="${b.key}" data-channel="CT" data-name="${escapeHtml(nameUpper)}" data-type="ct" data-emp="${escapeHtml(nameUpper)}" style="background:rgba(220,220,230,.15); color:rgba(255,255,255,.7); border-color:rgba(220,220,230,.25); box-shadow:none; cursor:pointer;"><b>CT</b> ${escapeHtml(nameUpper)}</span></div>`;
        }).join("");
        html += `<td>${items}</td>`;
      } else {
        html += `<td></td>`;
      }
    }
  }
  html += `</tr>`;

  // SD row
  html += `<tr><td><b>SD</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const entry = blocks ? blocks[b.key] : null;
      const list = entry && entry.sd ? entry.sd : [];
      if (list && list.length) {
        const items = list.map(n=>`<div style="margin:2px 0"><span class="assign-cell month-cell clickable-assign" data-day="${dayKey}" data-block="${b.key}" data-channel="SD" data-name="${escapeHtml(String(n).toUpperCase())}" data-type="sd" data-emp="${escapeHtml(String(n).toUpperCase())}" style="background:rgba(200,170,255,.15); color:rgba(200,170,255,.8); border-color:rgba(200,170,255,.25); cursor:pointer;"><b>SD</b> ${escapeHtml(String(n).toUpperCase())}</span></div>`).join("");
        html += `<td>${items}</td>`;
      } else {
        html += `<td></td>`;
      }
    }
  }
  html += `</tr>`;

  // VACATION row: dispatchers excluded (on vacation) for each day
  html += `<tr><td class="sticky-col"><b style="color:#7dd3fc;">VACATION</b></td>`;
  {
    const allDispatchers = normalizeBase()
      .filter(r => String(r.Position||"").trim().toUpperCase() === "DISPATCHER")
      .map(r => String(r.Employee||"").trim()).filter(Boolean);
    for (const d of daysList) {
      const vacNames = allDispatchers.filter(n => isExcluded(n, d)).map(n => n.toUpperCase()).sort();
      if (vacNames.length) {
        const items = vacNames.map(n =>
          `<div style="margin:2px 0;"><span class="assign-cell month-cell" style="background:rgba(125,211,252,.15); color:#7dd3fc; font-weight:700; font-size:9px; border:1px solid rgba(125,211,252,.3); cursor:default;">${escapeHtml(n)}</span></div>`
        ).join("");
        html += `<td colspan="${BLOCKS.length}">${items}</td>`;
      } else {
        html += `<td colspan="${BLOCKS.length}" style="color:var(--muted); font-size:9px;">—</td>`;
      }
    }
  }
  html += `</tr>`;

  // ABSENT row
  html += `<tr><td class="sticky-col"><b style="color:#f87171;">ABSENT</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const entry = blocks ? blocks[b.key] : null;
      const absentList = (entry?.absent || []).map(n => String(n).toUpperCase()).filter(Boolean);
      if (absentList.length) {
        const items = absentList.map(n =>
          `<div style="margin:2px 0;"><span class="assign-cell month-cell clickable-absent" data-day="${dayKey}" data-block="${b.key}" data-name="${escapeHtml(n)}" style="background:rgba(248,113,113,.12); color:#f87171; font-weight:700; font-size:9px; border:1px solid rgba(248,113,113,.25); cursor:pointer;">${escapeHtml(n)}</span></div>`
        ).join("");
        html += `<td>${items}</td>`;
      } else {
        html += `<td></td>`;
      }
    }
  }
  html += `</tr>`;

  // UNASSIGNED row
  html += `<tr><td><b style="color:rgba(200,200,210,.7);">UNASSIGNED</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const entry = blocks ? blocks[b.key] : null;
      const assignedNames = new Set();
      if (entry) {
        for (const nm of Object.values(entry.assignments||{})) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
        for (const nm of (entry.sd||[])) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
        for (const nm of (entry.ct||[])) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
        for (const nm of (entry.absent||[])) { assignedNames.add(String(nm).trim().toUpperCase()); }
      }
      const pool = buildDispatcherPoolForDate(d);
      const unassigned = pool.filter(p => worksBlock(p, d, b) && !assignedNames.has(String(p.name).trim().toUpperCase()));
      if (unassigned.length) {
        const items = unassigned.map(u => `<div style="margin:2px 0"><span class="assign-cell month-cell" style="background:rgba(200,200,210,.15); color:rgba(200,200,210,.7); font-weight:700; font-size:9px; border:1px solid rgba(200,200,210,.25); cursor:default;">${escapeHtml(String(u.name).toUpperCase())}</span></div>`).join("");
        html += `<td>${items}</td>`;
      } else {
        html += `<td></td>`;
      }
    }
  }
  html += `</tr>`;

  html += `</tbody></table></div>`;

  // ========== CHANNEL TOTALS TABLE (Day / Night / Split) ==========
  {
    const PRIMARY_CHS = ["North","South","East","West","Central","Northwest"];
    const RELIEF_CHS = new Set(["RELIEF 1","RELIEF 2","R1","R2"]);
    const DC_CHS = new Set(["DC1","DC2"]);
    const DAY_BLK = new Set(["0600-1000","1000-1400","1400-1800"]);
    const abbrMap = {North:"N",South:"S",East:"E",West:"W",Central:"C",Northwest:"NW"};

    function _emptyRow() { return { North:0, South:0, East:0, West:0, Central:0, Northwest:0, relief:0, ct:0, dc:0, sd:0, total:0 }; }

    function _addToRow(chUpper, row) {
      if (chUpper === "NORTH") row.North++;
      else if (chUpper === "SOUTH") row.South++;
      else if (chUpper === "EAST") row.East++;
      else if (chUpper === "WEST") row.West++;
      else if (chUpper === "CENTRAL") row.Central++;
      else if (chUpper === "NORTHWEST") row.Northwest++;
      else if (RELIEF_CHS.has(chUpper)) row.relief++;
      else if (chUpper === "CT") row.ct++;
      else if (DC_CHS.has(chUpper)) row.dc++;
      row.total++;
    }

    // Build combined totals per person + track which shifts they work
    const allTotals = new Map();
    const personShifts = new Map(); // name -> { day, night }

    for (const [name, assignments] of personAssignments) {
      if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
      if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
      const row = allTotals.get(name);
      const shifts = personShifts.get(name);
      for (const a of assignments) {
        _addToRow(String(a.channel).toUpperCase(), row);
        if (DAY_BLK.has(a.blockKey)) shifts.day = true; else shifts.night = true;
      }
    }

    // Count SD blocks per person
    for (const d of daysList) {
      const dayKey = ymd(d);
      const blocks = plan.days[dayKey];
      if (!blocks) continue;
      for (const b of BLOCKS) {
        const entry = blocks[b.key];
        if (!entry) continue;
        for (const nm of (entry.sd || [])) {
          const nameUpper = String(nm).trim().toUpperCase();
          if (!allTotals.has(nameUpper)) allTotals.set(nameUpper, _emptyRow());
          allTotals.get(nameUpper).sd++;
        }
      }
    }

    // Split into 4 groups: SD-eligible get their own table
    const sdGroup = new Map();
    const dayOnly = new Map();
    const nightOnly = new Map();
    const splitShift = new Map();
    for (const [name, row] of allTotals) {
      if (SD_ELIGIBLE.has(name)) { sdGroup.set(name, row); continue; }
      const s = personShifts.get(name);
      if (s && s.day && s.night) splitShift.set(name, row);
      else if (s && s.day) dayOnly.set(name, row);
      else nightOnly.set(name, row);
    }

    function _cellStyle(val, avg) {
      if (avg === 0) return '';
      const diff = val - avg;
      if (diff <= -1.5) return 'color:#f87171; font-weight:700;';
      if (diff >= 1.5) return 'color:#60a5fa; font-weight:700;';
      return '';
    }

    function _buildShiftTable(title, totalsMap) {
      const sortedNames = Array.from(totalsMap.keys()).sort();
      if (sortedNames.length === 0) return '';

      const count = sortedNames.length || 1;
      const avgRow = _emptyRow();
      for (const [, row] of totalsMap) {
        for (const ch of PRIMARY_CHS) avgRow[ch] += row[ch];
        avgRow.relief += row.relief; avgRow.ct += row.ct; avgRow.dc += row.dc;
      }
      for (const ch of PRIMARY_CHS) avgRow[ch] /= count;
      avgRow.relief /= count; avgRow.ct /= count; avgRow.dc /= count;

      let t = `<div style="margin-top:18px;"><h3 style="margin:0 0 4px; font-size:12px; color:var(--text);">${title}</h3>`;
      t += `<table style="width:100%; border-collapse:collapse; font-size:11px; table-layout:fixed;">`;
      t += `<thead><tr>`;
      t += `<th style="text-align:left; padding:3px 4px; width:90px;">NAME</th>`;
      for (const ch of PRIMARY_CHS) t += `<th style="text-align:center; padding:3px 2px; background:${channelColor[ch] || 'transparent'};">${abbrMap[ch]}</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(168,85,247,.2);">R</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(220,220,230,.15);">CT</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(100,140,200,.15);">DC</th>`;
      t += `<th style="text-align:center; padding:3px 2px; font-weight:700;">TOT</th>`;
      t += `</tr></thead><tbody>`;

      for (const name of sortedNames) {
        const row = totalsMap.get(name);
        t += `<tr><td style="text-align:left; padding:2px 4px; font-weight:600; font-size:10px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(name)}</td>`;
        for (const ch of PRIMARY_CHS) t += `<td style="text-align:center; padding:2px; ${_cellStyle(row[ch], avgRow[ch])}">${row[ch]}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(row.relief, avgRow.relief)}">${row.relief}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(row.ct, avgRow.ct)}">${row.ct}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(row.dc, avgRow.dc)}">${row.dc}</td>`;
        t += `<td style="text-align:center; padding:2px; font-weight:700;">${row.total}</td></tr>`;
      }

      t += `<tr style="border-top:2px solid var(--border); font-style:italic; color:var(--muted);">`;
      t += `<td style="text-align:left; padding:2px 4px;">AVG</td>`;
      for (const ch of PRIMARY_CHS) t += `<td style="text-align:center; padding:2px;">${avgRow[ch].toFixed(1)}</td>`;
      t += `<td style="text-align:center; padding:2px;">${avgRow.relief.toFixed(1)}</td>`;
      t += `<td style="text-align:center; padding:2px;">${avgRow.ct.toFixed(1)}</td>`;
      t += `<td style="text-align:center; padding:2px;">${avgRow.dc.toFixed(1)}</td>`;
      t += `<td></td></tr>`;

      t += `</tbody></table></div>`;
      return t;
    }

    function _buildSDTable(title, totalsMap) {
      const sortedNames = Array.from(totalsMap.keys()).sort();
      if (sortedNames.length === 0) return '';

      const count = sortedNames.length || 1;
      const avgRow = _emptyRow();
      for (const [, row] of totalsMap) {
        for (const ch of PRIMARY_CHS) avgRow[ch] += row[ch];
        avgRow.relief += row.relief; avgRow.ct += row.ct; avgRow.dc += row.dc; avgRow.sd += row.sd;
      }
      for (const ch of PRIMARY_CHS) avgRow[ch] /= count;
      avgRow.relief /= count; avgRow.ct /= count; avgRow.dc /= count; avgRow.sd /= count;

      let t = `<div style="margin-top:18px;"><h3 style="margin:0 0 4px; font-size:12px; color:var(--text);">${title}</h3>`;
      t += `<table style="width:100%; border-collapse:collapse; font-size:11px; table-layout:fixed;">`;
      t += `<thead><tr>`;
      t += `<th style="text-align:left; padding:3px 4px; width:90px;">NAME</th>`;
      for (const ch of PRIMARY_CHS) t += `<th style="text-align:center; padding:3px 2px; background:${channelColor[ch] || 'transparent'};">${abbrMap[ch]}</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(168,85,247,.2);">R</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(220,220,230,.15);">CT</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(100,140,200,.15);">DC</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(200,170,255,.2);">SD</th>`;
      t += `<th style="text-align:center; padding:3px 2px; font-weight:700;">TOT</th>`;
      t += `</tr></thead><tbody>`;

      for (const name of sortedNames) {
        const row = totalsMap.get(name);
        const chTotal = row.total + row.sd;
        t += `<tr><td style="text-align:left; padding:2px 4px; font-weight:600; font-size:10px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(name)}</td>`;
        for (const ch of PRIMARY_CHS) t += `<td style="text-align:center; padding:2px; ${_cellStyle(row[ch], avgRow[ch])}">${row[ch]}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(row.relief, avgRow.relief)}">${row.relief}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(row.ct, avgRow.ct)}">${row.ct}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(row.dc, avgRow.dc)}">${row.dc}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(row.sd, avgRow.sd)}">${row.sd}</td>`;
        t += `<td style="text-align:center; padding:2px; font-weight:700;">${chTotal}</td></tr>`;
      }

      t += `<tr style="border-top:2px solid var(--border); font-style:italic; color:var(--muted);">`;
      t += `<td style="text-align:left; padding:2px 4px;">AVG</td>`;
      for (const ch of PRIMARY_CHS) t += `<td style="text-align:center; padding:2px;">${avgRow[ch].toFixed(1)}</td>`;
      t += `<td style="text-align:center; padding:2px;">${avgRow.relief.toFixed(1)}</td>`;
      t += `<td style="text-align:center; padding:2px;">${avgRow.ct.toFixed(1)}</td>`;
      t += `<td style="text-align:center; padding:2px;">${avgRow.dc.toFixed(1)}</td>`;
      t += `<td style="text-align:center; padding:2px;">${avgRow.sd.toFixed(1)}</td>`;
      t += `<td></td></tr>`;

      t += `</tbody></table></div>`;
      return t;
    }

    html += _buildSDTable("SD ELIGIBLE (Special Detail)", sdGroup);
    html += _buildShiftTable("DAY SHIFT TOTALS (6A – 6P)", dayOnly);
    html += _buildShiftTable("NIGHT SHIFT TOTALS (6P – 6A)", nightOnly);
    html += _buildShiftTable("SPLIT SHIFT TOTALS (Day + Night)", splitShift);
  }
  // ========== END CHANNEL TOTALS TABLE ==========

  try { savePlan(plan); } catch(e) { console.warn(e); }
  wrap.innerHTML = html;

  // Click date headers to load day in Day tab
  wrap.querySelectorAll("th.dayhead[data-day]").forEach(th=>{
    th.addEventListener("click", ()=>{
      const dk = th.getAttribute("data-day");
      document.getElementById("dayPick").value = dk;
      setActiveTab("day");
      renderDay(dk);
    });
  });
}


async function copyText(text) {
  try { await navigator.clipboard.writeText(text); showToast("Copied to clipboard."); }
  catch(e) { showToast("Copy failed. Try selecting and copying manually."); }
}
function buildDayText(dayKey) {
  const plan = loadPlan();
  if (!plan || !plan.days[dayKey]) return "NO PLAN YET.";
  const lines = [];
  lines.push(`DISPATCHER ROTATION – ${dayKey}`);
  for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
    lines.push("");
    lines.push(b.label.toUpperCase());
    const entry = plan.days[dayKey][b.key];
    // Main channels
    for (const ch of CHANNELS) {
      const nm = (entry.assignments[ch]||"");
      lines.push(`${ch.toUpperCase()}: ${nm ? nm.toUpperCase() : "NEEDED"}`);
    }
    // 7th channel (Fri/Sat 2200-0200 only)
    const dtxt = new Date(dayKey + "T12:00:00");
    const dowTxt = dtxt.getDay();
    if ((dowTxt === 5 || dowTxt === 6) && SEVENTH_BLOCKS.has(b.key)) {
      const nm7 = (entry.assignments[SEVENTH_CHANNEL]||"");
      lines.push(`7TH: ${nm7 ? nm7.toUpperCase() : "NEEDED"}`);
    }
    // SD
    for (const nm of (entry.sd||[])) lines.push(`SD: ${nm.toUpperCase()}`);
    // CT
    for (const nm of (entry.ct||[])) lines.push(`CT: ${nm.toUpperCase()}`);
  }
  return lines.join("\n");
}
function buildDayCSV(dayKey) {
  const plan = loadPlan();
  if (!plan || !plan.days[dayKey]) return "";
  const rows = [["DATE","BLOCK","CHANNEL","NAME"]];
  for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
    const entry = plan.days[dayKey][b.key];
    for (const ch of CHANNELS) {
      const nm = entry.assignments[ch]||"";
      rows.push([dayKey, b.label.toUpperCase(), ch.toUpperCase(), nm ? nm.toUpperCase() : "NEEDED"]);
    }
    // 7th channel (Fri/Sat 2200-0200 only)
    const dcsv = new Date(dayKey + "T12:00:00");
    const dowCsv = dcsv.getDay();
    if ((dowCsv === 5 || dowCsv === 6) && SEVENTH_BLOCKS.has(b.key)) {
      const nm7 = entry.assignments[SEVENTH_CHANNEL]||"";
      rows.push([dayKey, b.label.toUpperCase(), "7TH", nm7 ? nm7.toUpperCase() : "NEEDED"]);
    }
    for (const nm of (entry.sd||[])) rows.push([dayKey, b.label.toUpperCase(), "SD", nm.toUpperCase()]);
    for (const nm of (entry.ct||[])) rows.push([dayKey, b.label.toUpperCase(), "CT", nm.toUpperCase()]);
  }
  return rows.map(r => r.map(x=>`"${String(x).replaceAll('"','""')}"`).join(",")).join("\n");
}

function setActiveTab(tab) {
  document.querySelectorAll(".tab").forEach(t=>t.classList.toggle("active", t.getAttribute("data-tab")===tab));
  ["day","week","month","mroster","exceptions"].forEach(k => document.getElementById("tab_"+k).style.display = (k===tab) ? "" : "none");
  if (tab === "exceptions") renderExceptions();
  saveJSON(STORAGE.ui, {...loadJSON(STORAGE.ui, {}), tab});
}

function initSelectors() {
  const monthSel = document.getElementById("monthSel");
  const yearSel = document.getElementById("yearSel");
  monthSel.innerHTML = "";
  for (let i=0;i<12;i++) {
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = monthName(i);
    monthSel.appendChild(opt);
  }
  yearSel.innerHTML = "";
  const now = new Date();
  const y0 = now.getFullYear()-1;
  for (let y=y0; y<=y0+4; y++) {
    const opt = document.createElement("option");
    opt.value = String(y);
    opt.textContent = String(y);
    yearSel.appendChild(opt);
  }
  monthSel.value = String(now.getMonth());
  yearSel.value = String(now.getFullYear());
}

function renderExceptions() {
  const wrap = document.getElementById("exceptionsWrap");
  if (!wrap) return;
  const names = normalizeBase()
    .filter(r => String(r.Position||"").trim().toUpperCase() === "DISPATCHER")
    .map(r => String(r.Employee||"").trim()).filter(Boolean).sort();
  const opts = '<option value="">— SELECT —</option>' + names.map(n =>
    `<option value="${escapeHtml(n)}">${escapeHtml(n.toUpperCase())}</option>`
  ).join("");
  const vacRanges = getVacRanges();
  const trainerRanges = getTrainerRanges();

  let html = '<div style="display:grid; grid-template-columns:1fr 1fr; gap:16px;">';

  // --- Vacation / Exclusion table ---
  html += '<div>';
  html += '<h2 style="margin:0 0 10px; font-size:13px; letter-spacing:.5px;">VACATION / EXCLUSION</h2>';
  html += '<div style="display:flex; gap:6px; margin-bottom:10px; flex-wrap:wrap; align-items:end;">';
  html += `<div style="flex:1; min-width:120px;"><div style="font-size:9px; color:var(--muted); margin-bottom:2px;">EMPLOYEE</div><select id="vacName" style="width:100%; font-size:12px; padding:6px; border-radius:6px; box-sizing:border-box; background:var(--panel2); border:1px solid var(--line); color:var(--text);">${opts}</select></div>`;
  html += '<div style="min-width:110px;"><div style="font-size:9px; color:var(--muted); margin-bottom:2px;">FROM</div><input id="vacFrom" type="date" style="width:100%; font-size:12px; padding:6px; border-radius:6px; box-sizing:border-box;" /></div>';
  html += '<div style="min-width:110px;"><div style="font-size:9px; color:var(--muted); margin-bottom:2px;">TO (blank = rest of month)</div><input id="vacTo" type="date" style="width:100%; font-size:12px; padding:6px; border-radius:6px; box-sizing:border-box;" /></div>';
  html += '<button class="btn secondary" id="btnAddVac" style="font-size:11px; padding:6px 12px; border-radius:6px; white-space:nowrap;">ADD</button>';
  html += '</div>';
  html += '<table style="width:100%; table-layout:fixed;"><thead><tr><th style="text-align:left; width:35%;">NAME</th><th style="width:25%;">FROM</th><th style="width:25%;">TO</th><th style="width:15%;"></th></tr></thead><tbody>';
  if (vacRanges.length) {
    vacRanges.forEach((r, idx) => {
      html += `<tr><td style="text-align:left; font-weight:700;">${escapeHtml((r.name||"").toUpperCase())}</td><td>${r.from||"—"}</td><td>${r.to||"rest of month"}</td><td><button class="btn danger exc-del-vac" data-i="${idx}" style="font-size:10px; padding:3px 8px;">X</button></td></tr>`;
    });
  } else {
    html += '<tr><td colspan="4" style="color:var(--muted); font-size:11px;">No exclusions.</td></tr>';
  }
  html += '</tbody></table></div>';

  // --- Trainers table ---
  html += '<div>';
  html += '<h2 style="margin:0 0 10px; font-size:13px; letter-spacing:.5px;">TRAINERS</h2>';
  html += '<div style="display:flex; gap:6px; margin-bottom:10px; flex-wrap:wrap; align-items:end;">';
  html += `<div style="flex:1; min-width:120px;"><div style="font-size:9px; color:var(--muted); margin-bottom:2px;">EMPLOYEE</div><select id="traineeName" style="width:100%; font-size:12px; padding:6px; border-radius:6px; box-sizing:border-box; background:var(--panel2); border:1px solid var(--line); color:var(--text);">${opts}</select></div>`;
  html += '<div style="min-width:110px;"><div style="font-size:9px; color:var(--muted); margin-bottom:2px;">FROM</div><input id="traineeFrom" type="date" style="width:100%; font-size:12px; padding:6px; border-radius:6px; box-sizing:border-box;" /></div>';
  html += '<div style="min-width:110px;"><div style="font-size:9px; color:var(--muted); margin-bottom:2px;">TO (blank = rest of month)</div><input id="traineeTo" type="date" style="width:100%; font-size:12px; padding:6px; border-radius:6px; box-sizing:border-box;" /></div>';
  html += '<button class="btn secondary" id="btnAddTrainee" style="font-size:11px; padding:6px 12px; border-radius:6px; white-space:nowrap;">ADD</button>';
  html += '</div>';
  html += '<table style="width:100%; table-layout:fixed;"><thead><tr><th style="text-align:left; width:35%;">NAME</th><th style="width:25%;">FROM</th><th style="width:25%;">TO</th><th style="width:15%;"></th></tr></thead><tbody>';
  if (trainerRanges.length) {
    trainerRanges.forEach((r, idx) => {
      html += `<tr><td style="text-align:left; font-weight:700;">${escapeHtml((r.name||"").toUpperCase())}</td><td>${r.from||"—"}</td><td>${r.to||"rest of month"}</td><td><button class="btn danger exc-del-tr" data-ti="${idx}" style="font-size:10px; padding:3px 8px;">X</button></td></tr>`;
    });
  } else {
    html += '<tr><td colspan="4" style="color:var(--muted); font-size:11px;">No trainers.</td></tr>';
  }
  html += '</tbody></table></div>';

  html += '</div>';
  wrap.innerHTML = html;

  // Wire delete buttons for vacations
  wrap.querySelectorAll(".exc-del-vac").forEach(btn => {
    btn.addEventListener("click", () => {
      const i = Number(btn.getAttribute("data-i"));
      const v = getVacRanges(); v.splice(i,1); saveJSON(STORAGE.vac, v);
      renderExceptions(); renderInfoStats();
      const dk = document.getElementById("dayPick").value;
      if (dk) renderDay(dk);
    });
  });
  // Wire delete buttons for trainers
  wrap.querySelectorAll(".exc-del-tr").forEach(btn => {
    btn.addEventListener("click", () => {
      const i = Number(btn.getAttribute("data-ti"));
      const t = getTrainerRanges(); t.splice(i,1); saveJSON(STORAGE.training, t);
      renderExceptions(); renderInfoStats();
    });
  });
}

function renderVacList() {
  const list = document.getElementById("vacList");
  if (!list) return;
  const ranges = getVacRanges();
  if (!ranges.length) { list.innerHTML = "<div class='small'>NO EXCLUSIONS.</div>"; return; }
  list.innerHTML = ranges.map((r, idx)=>{
    const from = r.from ? r.from : "–";
    const to = r.to ? r.to : "–";
    return `<div class="pill">
      <div><b>${escapeHtml((r.name||"").toUpperCase())}</b><div class="meta">FROM: ${from} &nbsp; TO: ${to}</div></div>
      <button data-i="${idx}">X</button>
    </div>`;
  }).join("");
  list.querySelectorAll("button[data-i]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const i = Number(btn.getAttribute("data-i"));
      const v = getVacRanges(); v.splice(i,1); saveJSON(STORAGE.vac, v);
      renderVacList();
      const dk = document.getElementById("dayPick").value;
      if (dk) renderDay(dk);
    });
  });
}

function renderTraineeList() {
  const list = document.getElementById("traineeList");
  if (!list) return;
  const ranges = getTrainerRanges();
  if (!ranges.length) { list.innerHTML = "<div class='small'>NO TRAINERS.</div>"; return; }
  list.innerHTML = ranges.map((r, idx)=>{
    const from = r.from ? r.from : "–";
    const to = r.to ? r.to : "–";
    return `<div class="pill">
      <div><b>${escapeHtml(r.name.toUpperCase())}</b><div class="meta">FROM: ${from} TO: ${to}</div></div>
      <button data-ti="${idx}">X</button>
    </div>`;
  }).join("");
  list.querySelectorAll("button[data-ti]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const i = Number(btn.getAttribute("data-ti"));
      const t = getTrainerRanges(); t.splice(i,1); saveJSON(STORAGE.training, t);
      renderTraineeList();
    });
  });
}

// ========== FAIRNESS STATS ==========
function calculateFairnessStats() {
  const plan = loadPlan();
  if (!plan || !plan.days) return null;

  const empStats = new Map();
  const channelCounts = {};
  let totalAssignments = 0;

  // Count eligible blocks per employee across the month (accounts for vacation/exclusion)
  const eligibleBlocks = new Map(); // name -> count of blocks they could have worked
  for (const dayKey of Object.keys(plan.days)) {
    const dateObj = parseYMD(dayKey);
    if (!dateObj) continue;
    const pool = buildDispatcherPoolForDate(dateObj);
    for (const disp of pool) {
      const nm = String(disp.name).trim().toUpperCase();
      if (EXCLUDED_FROM_STATS.has(nm)) continue;
      let blocksThisDay = 0;
      for (const b of BLOCKS) {
        if (worksBlock(disp, dateObj, b)) blocksThisDay++;
      }
      eligibleBlocks.set(nm, (eligibleBlocks.get(nm) || 0) + blocksThisDay);
    }
  }

  for (const [dayKey, dayData] of Object.entries(plan.days)) {
    const dateObj2 = parseYMD(dayKey);
    for (const [blockKey, blockData] of Object.entries(dayData)) {
      if (!blockData || typeof blockData !== 'object') continue;

      for (const [ch, name] of Object.entries(blockData.assignments || {})) {
        if (!name) continue;
        const nm = name.toUpperCase();
        if (EXCLUDED_FROM_STATS.has(nm)) continue;
        // Skip assignments on days the person is on vacation
        if (dateObj2 && isExcluded(name, dateObj2)) continue;
        totalAssignments++;
        if (!empStats.has(nm)) empStats.set(nm, { total: 0, channels: {}, ct: 0, sd: 0 });
        empStats.get(nm).total++;
        empStats.get(nm).channels[ch] = (empStats.get(nm).channels[ch] || 0) + 1;
        channelCounts[ch] = (channelCounts[ch] || 0) + 1;
      }

      for (const name of (blockData.ct || [])) {
        if (!name) continue;
        const nm = name.toUpperCase();
        if (EXCLUDED_FROM_STATS.has(nm)) continue;
        if (dateObj2 && isExcluded(name, dateObj2)) continue;
        if (!empStats.has(nm)) empStats.set(nm, { total: 0, channels: {}, ct: 0, sd: 0 });
        empStats.get(nm).ct++;
      }

      for (const name of (blockData.sd || [])) {
        if (!name) continue;
        const nm = name.toUpperCase();
        if (EXCLUDED_FROM_STATS.has(nm)) continue;
        if (dateObj2 && isExcluded(name, dateObj2)) continue;
        if (!empStats.has(nm)) empStats.set(nm, { total: 0, channels: {}, ct: 0, sd: 0 });
        empStats.get(nm).sd++;
      }
    }
  }

  // Compute expected assignments per person proportional to their eligible blocks
  const totalEligible = Array.from(eligibleBlocks.values()).reduce((a, b) => a + b, 0);
  // Store expected on each empStats entry
  for (const [nm, s] of empStats) {
    const eb = eligibleBlocks.get(nm) || 0;
    s.eligibleBlocks = eb;
    s.expected = totalEligible > 0 ? totalAssignments * (eb / totalEligible) : 0;
  }

  const totals = Array.from(empStats.values()).map(s => s.total);
  const avg = totals.length ? totals.reduce((a,b) => a+b, 0) / totals.length : 0;

  // Spread is now based on adjusted diff (actual - expected) instead of raw totals
  const diffs = Array.from(empStats.values()).map(s => s.total - s.expected);
  const maxDiff = Math.max(...diffs, 0);
  const minDiff = Math.min(...diffs, 0);
  const spread = Math.round((maxDiff - minDiff) * 10) / 10;

  return {
    empStats,
    eligibleBlocks,
    channelCounts,
    totalAssignments,
    avgPerPerson: avg,
    maxDiff,
    minDiff,
    spread,
    fairnessScore: spread <= 5 ? 'EXCELLENT' : spread <= 10 ? 'GOOD' : spread <= 20 ? 'FAIR' : 'POOR'
  };
}

function renderInfoStats() {
  const plan = loadPlan();
  const stats = calculateFairnessStats();

  // FAIRNESS STATS popup content (includes HOW IT WORKS at top)
  let fairHtml = '';

  fairHtml += `<div class="how-it-works-box" style="padding:10px 14px; margin-bottom:10px; background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.1); border-radius:8px; font-size:11px; line-height:1.7; color:var(--muted);">
    <div style="font-weight:800; font-size:12px; color:var(--text); margin-bottom:6px;">HOW IT WORKS</div>
    <div>The system builds the entire month's rotation automatically by running up to <b style="color:var(--text);">500 randomized attempts</b> and keeping the most balanced result. Each attempt fills every 4-hour block across all 10 channels, always picking the person with the fewest assignments first. It skips anyone on vacation, keeps trainees on East/South/West/Central only, prevents CT or Relief from being assigned back-to-back, and won't repeat the same channel twice in one day. A 7th channel is added on Friday and Saturday nights. The <b style="color:var(--text);">FAIRNESS %</b> column shows how close each person's assignments are to what they should have gotten based on their availability. 100% means perfectly even. The closer to 100%, the fairer it is. <span style="color:#22c55e">Green</span> = 90%+ (fair), <span style="color:#f59e0b">yellow</span> = 80\u201389% (slightly off), <span style="color:#ef4444">red</span> = below 80% (noticeably off). Every employee is treated equally by the algorithm.</div>
  </div>`;

  if (stats) {
    const scoreClass = stats.fairnessScore === 'EXCELLENT' ? 'good' : stats.fairnessScore === 'GOOD' ? 'good' : stats.fairnessScore === 'FAIR' ? 'warn' : 'bad';
    const sorted = Array.from(stats.empStats.entries()).sort((a,b) => b[1].total - a[1].total);

    fairHtml += `<div style="display:flex; gap:8px; margin-bottom:10px;">
      <div class="stat-card" style="flex:1; padding:6px 8px;">
        <div class="stat-value" style="font-size:16px;">${stats.totalAssignments}</div>
        <div class="stat-label" style="font-size:9px;">TOTAL</div>
      </div>
      <div class="stat-card" style="flex:1; padding:6px 8px;">
        <div class="stat-value" style="font-size:16px;">${stats.empStats.size}</div>
        <div class="stat-label" style="font-size:9px;">EMPLOYEES</div>
      </div>
      <div class="stat-card" style="flex:1; padding:6px 8px;">
        <div class="stat-value" style="font-size:16px;">${stats.avgPerPerson.toFixed(1)}</div>
        <div class="stat-label" style="font-size:9px;">AVG/PERSON</div>
      </div>
      <div class="stat-card ${scoreClass}" style="flex:1; padding:6px 8px;">
        <div class="stat-value" style="font-size:16px;">${stats.fairnessScore}</div>
        <div class="stat-label" style="font-size:9px;">SPREAD: ${stats.spread}</div>
      </div>
    </div>`;

    fairHtml += '<div style="overflow:auto; max-height:360px;">';
    fairHtml += '<table style="width:100%; font-size:11px;"><thead><tr><th>NAME</th><th>TOTAL</th><th>EXPECTED</th><th>7TH</th><th>CT</th><th>FAIRNESS %</th></tr></thead><tbody>';
    sorted.forEach(([name, s]) => {
      const fairPct = s.expected > 0 ? Math.round(100 - (Math.abs(s.total - s.expected) / s.expected) * 100) : 100;
      const clampedPct = Math.max(0, Math.min(100, fairPct));
      const pctClass = clampedPct >= 90 ? 'color:#22c55e' : clampedPct >= 80 ? 'color:#f59e0b' : 'color:#ef4444';
      const seventh = s.channels[SEVENTH_CHANNEL] || 0;
      fairHtml += `<tr>
        <td style="text-align:left; font-weight:600;">${escapeHtml(name)}</td>
        <td>${s.total}</td>
        <td>${s.expected.toFixed(1)}</td>
        <td>${seventh}</td>
        <td>${s.ct}</td>
        <td style="${pctClass}; font-weight:700;">${clampedPct}%</td>
      </tr>`;
    });
    fairHtml += '</tbody></table></div>';
  } else {
    fairHtml = '<div style="text-align:center; color:var(--muted); padding:20px;">NO DATA — RANDOMIZE A MONTH FIRST</div>';
  }

  // CHANNEL TOTALS popup content
  let chTotalsHtml = '';
  if (plan && plan.days) {
    chTotalsHtml = renderStatsHtml(plan);
  } else {
    chTotalsHtml = '<div style="text-align:center; color:var(--muted); padding:20px;">NO DATA — RANDOMIZE A MONTH FIRST</div>';
  }

  // Write to popups
  const fairEl = document.getElementById("fairnessPopupContent");
  if (fairEl) fairEl.innerHTML = fairHtml;
  const chEl = document.getElementById("channelTotalsPopupContent");
  if (chEl) chEl.innerHTML = chTotalsHtml;
}

function boot() {
  normalizeBase();
  initSelectors();
  const ui = loadJSON(STORAGE.ui, {});
  if (ui && ui.tab) setActiveTab(ui.tab);

  // ===== Channel Flash Text =====
  const channelInner = document.getElementById("channelInner");
  if (channelInner) {
    const channels = ["N","E","S","W","NW","C","DC1","DC2","R1","R2","CT"];
    let ci = 0;
    channelInner.textContent = channels[0];
    channelInner.style.transition = "transform .2s ease-in";
    setInterval(() => {
      channelInner.style.transform = "rotateX(90deg)";
      setTimeout(() => {
        ci = (ci + 1) % channels.length;
        channelInner.textContent = channels[ci];
        channelInner.style.transition = "none";
        channelInner.style.transform = "rotateX(-90deg)";
        requestAnimationFrame(() => {
          channelInner.style.transition = "transform .2s ease-out";
          channelInner.style.transform = "rotateX(0deg)";
        });
      }, 200);
    }, 500);
  }

  const now = new Date();
  document.getElementById("dayPick").value = ymd(now);

  // Pill popup toggles (HOW IT WORKS, FAIRNESS STATS, CHANNEL TOTALS)
  const popups = [
    { btn: "btnFairnessStats", popup: "fairnessPopup" },
    { btn: "btnChannelTotals", popup: "channelTotalsPopup" }
  ];
  popups.forEach(({ btn: btnId, popup: popupId }) => {
    const btn = document.getElementById(btnId);
    const popup = document.getElementById(popupId);
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      // Close other popups first
      popups.forEach(p => {
        if (p.popup !== popupId) document.getElementById(p.popup).style.display = "none";
      });
      popup.style.display = popup.style.display === "none" ? "block" : "none";
      // Re-populate stats when opening
      if (popup.style.display === "block") renderInfoStats();
    });
  });
  document.addEventListener("click", (e) => {
    popups.forEach(({ btn: btnId, popup: popupId }) => {
      const btn = document.getElementById(btnId);
      const popup = document.getElementById(popupId);
      if (!popup.contains(e.target) && e.target !== btn) {
        popup.style.display = "none";
      }
    });
  });

  // EXPORT TOTALS button
  document.getElementById("btnExportTotals").addEventListener("click", () => {
    const plan = loadPlan();
    if (!plan || !plan.days) { showToast("No plan to export. Randomize first."); return; }

    const PRIMARY = ["North","South","East","West","Central","Northwest"];
    const RELIEF_SET = new Set(["Relief 1","Relief 2"]);
    const DC_SET_E = new Set(["DC1","DC2"]);
    const DAY_BLOCKS_E = new Set(["0600-1000","1000-1400","1400-1800"]);

    function _emptyRow() { return { North:0, South:0, East:0, West:0, Central:0, Northwest:0, r1:0, r2:0, ct:0, dc1:0, dc2:0, sd:0, total:0 }; }

    const allTotals = new Map();
    const personShifts = new Map();

    for (const [dayKey, blocks] of Object.entries(plan.days || {})) {
      for (const b of BLOCKS) {
        const entry = blocks[b.key];
        if (!entry) continue;
        const isDay = DAY_BLOCKS_E.has(b.key);

        for (const [ch, nm] of Object.entries(entry.assignments || {})) {
          if (!nm) continue;
          const name = String(nm).trim().toUpperCase();
          if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
          if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
          const row = allTotals.get(name);
          if (PRIMARY.includes(ch)) row[ch]++;
          else if (ch === "Relief 1") row.r1++;
          else if (ch === "Relief 2") row.r2++;
          else if (ch === "DC1") row.dc1++;
          else if (ch === "DC2") row.dc2++;
          row.total++;
          if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
        }
        for (const nm of (entry.ct || [])) {
          const name = String(nm).trim().toUpperCase();
          if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
          if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
          allTotals.get(name).ct++; allTotals.get(name).total++;
          if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
        }
        for (const nm of (entry.sd || [])) {
          const name = String(nm).trim().toUpperCase();
          if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
          if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
          allTotals.get(name).sd++;
          if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
        }
      }
    }

    // Group into 4 categories
    const groups = { "SD ELIGIBLE": new Map(), "DAY SHIFT": new Map(), "NIGHT SHIFT": new Map(), "SPLIT SHIFT": new Map() };
    for (const [name, row] of allTotals) {
      if (SD_ELIGIBLE.has(name)) groups["SD ELIGIBLE"].set(name, row);
      else {
        const s = personShifts.get(name);
        if (s.day && s.night) groups["SPLIT SHIFT"].set(name, row);
        else if (s.day) groups["DAY SHIFT"].set(name, row);
        else groups["NIGHT SHIFT"].set(name, row);
      }
    }

    const meta = plan.meta || {};
    const hdr = "NAME\tN\tS\tE\tW\tC\tNW\tR1\tR2\tR_TOT\tCT\tDC1\tDC2\tDC_TOT\tSD\tTOTAL";
    let txt = `ROTATION EXPORT — ${monthName(meta.monthIndex || 0)} ${meta.year || ""}\n`;
    txt += `Generated: ${new Date().toLocaleString()}\n`;
    txt += `Violations: ${window.lastRandomizeStats?.totalViolations ?? "?"}\n\n`;

    for (const [groupName, map] of Object.entries(groups)) {
      const names = Array.from(map.keys()).sort();
      if (names.length === 0) continue;

      txt += `=== ${groupName} (${names.length} people) ===\n`;
      txt += hdr + "\n";

      let avgRow = _emptyRow(); avgRow.r1 = 0; avgRow.r2 = 0; avgRow.dc1 = 0; avgRow.dc2 = 0;
      for (const name of names) {
        const r = map.get(name);
        const rTot = r.r1 + r.r2;
        const dcTot = r.dc1 + r.dc2;
        const grand = r.total + r.sd;
        txt += `${name}\t${r.North}\t${r.South}\t${r.East}\t${r.West}\t${r.Central}\t${r.Northwest}\t${r.r1}\t${r.r2}\t${rTot}\t${r.ct}\t${r.dc1}\t${r.dc2}\t${dcTot}\t${r.sd}\t${grand}\n`;
        for (const ch of PRIMARY) avgRow[ch] += r[ch];
        avgRow.r1 += r.r1; avgRow.r2 += r.r2; avgRow.ct += r.ct; avgRow.dc1 += r.dc1; avgRow.dc2 += r.dc2; avgRow.sd += r.sd; avgRow.total += r.total;
      }
      const n = names.length;
      const aR = (avgRow.r1 + avgRow.r2) / n;
      const aDC = (avgRow.dc1 + avgRow.dc2) / n;
      txt += `AVG\t${(avgRow.North/n).toFixed(1)}\t${(avgRow.South/n).toFixed(1)}\t${(avgRow.East/n).toFixed(1)}\t${(avgRow.West/n).toFixed(1)}\t${(avgRow.Central/n).toFixed(1)}\t${(avgRow.Northwest/n).toFixed(1)}\t${(avgRow.r1/n).toFixed(1)}\t${(avgRow.r2/n).toFixed(1)}\t${aR.toFixed(1)}\t${(avgRow.ct/n).toFixed(1)}\t${(avgRow.dc1/n).toFixed(1)}\t${(avgRow.dc2/n).toFixed(1)}\t${aDC.toFixed(1)}\t${(avgRow.sd/n).toFixed(1)}\t${((avgRow.total+avgRow.sd)/n).toFixed(1)}\n`;

      // Min/Max row
      let mins = _emptyRow(), maxs = _emptyRow();
      for (const ch of PRIMARY) { mins[ch] = Infinity; maxs[ch] = 0; }
      mins.r1 = Infinity; mins.r2 = Infinity; mins.ct = Infinity; mins.dc1 = Infinity; mins.dc2 = Infinity; mins.sd = Infinity;
      maxs.r1 = 0; maxs.r2 = 0; maxs.ct = 0; maxs.dc1 = 0; maxs.dc2 = 0; maxs.sd = 0;
      let minRTot = Infinity, maxRTot = 0, minDCTot = Infinity, maxDCTot = 0, minGrand = Infinity, maxGrand = 0;
      for (const name of names) {
        const r = map.get(name);
        for (const ch of PRIMARY) { mins[ch] = Math.min(mins[ch], r[ch]); maxs[ch] = Math.max(maxs[ch], r[ch]); }
        mins.r1 = Math.min(mins.r1, r.r1); maxs.r1 = Math.max(maxs.r1, r.r1);
        mins.r2 = Math.min(mins.r2, r.r2); maxs.r2 = Math.max(maxs.r2, r.r2);
        mins.ct = Math.min(mins.ct, r.ct); maxs.ct = Math.max(maxs.ct, r.ct);
        mins.dc1 = Math.min(mins.dc1, r.dc1); maxs.dc1 = Math.max(maxs.dc1, r.dc1);
        mins.dc2 = Math.min(mins.dc2, r.dc2); maxs.dc2 = Math.max(maxs.dc2, r.dc2);
        mins.sd = Math.min(mins.sd, r.sd); maxs.sd = Math.max(maxs.sd, r.sd);
        const rT = r.r1+r.r2, dT = r.dc1+r.dc2, g = r.total+r.sd;
        minRTot = Math.min(minRTot, rT); maxRTot = Math.max(maxRTot, rT);
        minDCTot = Math.min(minDCTot, dT); maxDCTot = Math.max(maxDCTot, dT);
        minGrand = Math.min(minGrand, g); maxGrand = Math.max(maxGrand, g);
      }
      txt += `MIN\t${mins.North}\t${mins.South}\t${mins.East}\t${mins.West}\t${mins.Central}\t${mins.Northwest}\t${mins.r1}\t${mins.r2}\t${minRTot}\t${mins.ct}\t${mins.dc1}\t${mins.dc2}\t${minDCTot}\t${mins.sd}\t${minGrand}\n`;
      txt += `MAX\t${maxs.North}\t${maxs.South}\t${maxs.East}\t${maxs.West}\t${maxs.Central}\t${maxs.Northwest}\t${maxs.r1}\t${maxs.r2}\t${maxRTot}\t${maxs.ct}\t${maxs.dc1}\t${maxs.dc2}\t${maxDCTot}\t${maxs.sd}\t${maxGrand}\n`;
      txt += `SPREAD\t${maxs.North-mins.North}\t${maxs.South-mins.South}\t${maxs.East-mins.East}\t${maxs.West-mins.West}\t${maxs.Central-mins.Central}\t${maxs.Northwest-mins.Northwest}\t${maxs.r1-mins.r1}\t${maxs.r2-mins.r2}\t${maxRTot-minRTot}\t${maxs.ct-mins.ct}\t${maxs.dc1-mins.dc1}\t${maxs.dc2-mins.dc2}\t${maxDCTot-minDCTot}\t${maxs.sd-mins.sd}\t${maxGrand-minGrand}\n`;
      txt += "\n";
    }

    // Copy to clipboard and download
    navigator.clipboard.writeText(txt).then(() => showToast("Exported & copied to clipboard!")).catch(() => {});
    const blob = new Blob([txt], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `rotation_totals_${meta.year || ""}_${String((meta.monthIndex||0)+1).padStart(2,"0")}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  });

  // EXPORT CSV button — formatted Excel document (HTML table → .xls, Excel 2007 compatible)
  document.getElementById("btnExportCSV").addEventListener("click", () => {
    const plan = loadPlan();
    if (!plan || !plan.days) { showToast("No plan to export. Randomize first."); return; }

    const PRIMARY = ["North","South","East","West","Central","Northwest"];
    const DAY_BLOCKS_E = new Set(["0600-1000","1000-1400","1400-1800"]);

    function _emptyRow() { return { North:0, South:0, East:0, West:0, Central:0, Northwest:0, r1:0, r2:0, ct:0, dc1:0, dc2:0, sd:0, total:0 }; }

    const allTotals = new Map();
    const personShifts = new Map();

    for (const [dayKey, blocks] of Object.entries(plan.days || {})) {
      for (const b of BLOCKS) {
        const entry = blocks[b.key];
        if (!entry) continue;
        const isDay = DAY_BLOCKS_E.has(b.key);
        for (const [ch, nm] of Object.entries(entry.assignments || {})) {
          if (!nm) continue;
          const name = String(nm).trim().toUpperCase();
          if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
          if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
          const row = allTotals.get(name);
          if (PRIMARY.includes(ch)) row[ch]++;
          else if (ch === "Relief 1") row.r1++;
          else if (ch === "Relief 2") row.r2++;
          else if (ch === "DC1") row.dc1++;
          else if (ch === "DC2") row.dc2++;
          row.total++;
          if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
        }
        for (const nm of (entry.ct || [])) {
          const name = String(nm).trim().toUpperCase();
          if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
          if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
          allTotals.get(name).ct++; allTotals.get(name).total++;
          if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
        }
        for (const nm of (entry.sd || [])) {
          const name = String(nm).trim().toUpperCase();
          if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
          if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
          allTotals.get(name).sd++;
          if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
        }
      }
    }

    const groups = { "SD ELIGIBLE": new Map(), "DAY SHIFT": new Map(), "NIGHT SHIFT": new Map(), "SPLIT SHIFT": new Map() };
    for (const [name, row] of allTotals) {
      if (SD_ELIGIBLE.has(name)) groups["SD ELIGIBLE"].set(name, row);
      else {
        const s = personShifts.get(name);
        if (s.day && s.night) groups["SPLIT SHIFT"].set(name, row);
        else if (s.day) groups["DAY SHIFT"].set(name, row);
        else groups["NIGHT SHIFT"].set(name, row);
      }
    }

    const meta = plan.meta || {};
    const viol = window.lastRandomizeStats?.totalViolations ?? "?";
    const groupColors = {
      "SD ELIGIBLE":  { bg: "#7C3AED", light: "#EDE9FE" },
      "DAY SHIFT":    { bg: "#2563EB", light: "#DBEAFE" },
      "NIGHT SHIFT":  { bg: "#1E3A5F", light: "#E0E7EF" },
      "SPLIT SHIFT":  { bg: "#D97706", light: "#FEF3C7" }
    };
    const colHdrs = ["NAME","N","S","E","W","C","NW","R1","R2","R_TOT","CT","DC1","DC2","DC_TOT","SD","TOTAL"];
    const numCols = colHdrs.length;

    // --- Build HTML table ---
    let h = `<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">
<head><meta charset="utf-8">
<!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet>
<x:Name>Rotation</x:Name>
<x:WorksheetOptions><x:FitToPage/><x:Print><x:FitWidth>1</x:FitWidth></x:Print></x:WorksheetOptions>
</x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]-->
<style>
  td, th { font-family: Calibri, Arial, sans-serif; font-size: 11pt; padding: 4px 8px; border: 1px solid #D1D5DB; text-align: center; }
  th { font-weight: 700; }
  .title { font-size: 16pt; font-weight: 800; color: #1E293B; border: none; text-align: left; padding: 8px 8px 2px; }
  .subtitle { font-size: 10pt; color: #64748B; border: none; text-align: left; padding: 2px 8px 8px; }
  .grp-hdr { color: #FFFFFF; font-size: 12pt; font-weight: 800; text-align: left; letter-spacing: 1px; }
  .col-hdr { background: #374151; color: #FFFFFF; font-size: 10pt; font-weight: 700; }
  .name-col { text-align: left; font-weight: 600; }
  .row-even { background: #FFFFFF; }
  .row-odd { background: #F9FAFB; }
  .row-avg { background: #DBEAFE; font-weight: 700; font-style: italic; }
  .row-min { background: #D1FAE5; font-weight: 600; }
  .row-max { background: #FEE2E2; font-weight: 600; }
  .row-spread { background: #FEF9C3; font-weight: 800; }
  .viol-bad { color: #DC2626; font-weight: 800; }
  .viol-good { color: #16A34A; font-weight: 800; }
</style>
</head><body>
<table cellspacing="0" cellpadding="0">`;

    // Title rows
    h += `<tr><td class="title" colspan="${numCols}">ROTATION EXPORT &mdash; ${monthName(meta.monthIndex || 0)} ${meta.year || ""}</td></tr>`;
    h += `<tr><td class="subtitle" colspan="${numCols}">Generated: ${new Date().toLocaleString()} &nbsp;&nbsp;|&nbsp;&nbsp; Violations: <span class="${Number(viol) <= 2 ? 'viol-good' : 'viol-bad'}">${viol}</span></td></tr>`;
    h += `<tr><td colspan="${numCols}" style="border:none;">&nbsp;</td></tr>`;

    function _dataRow(vals, cls) {
      return `<tr class="${cls}"><td class="name-col ${cls}">${vals[0]}</td>${vals.slice(1).map(v => `<td class="${cls}">${v}</td>`).join("")}</tr>`;
    }

    for (const [groupName, map] of Object.entries(groups)) {
      const names = Array.from(map.keys()).sort();
      if (names.length === 0) continue;
      const gc = groupColors[groupName] || { bg: "#374151", light: "#F3F4F6" };

      // Group header
      h += `<tr><td class="grp-hdr" colspan="${numCols}" style="background:${gc.bg};">${groupName} (${names.length} people)</td></tr>`;
      // Column headers
      h += `<tr>${colHdrs.map(c => `<th class="col-hdr">${c}</th>`).join("")}</tr>`;

      // Data rows
      let avgAcc = _emptyRow();
      let mins = {}, maxs = {};
      for (const k of ["North","South","East","West","Central","Northwest","r1","r2","ct","dc1","dc2","sd"]) { mins[k] = Infinity; maxs[k] = 0; }
      let minRTot=Infinity, maxRTot=0, minDCTot=Infinity, maxDCTot=0, minGrand=Infinity, maxGrand=0;

      names.forEach((name, i) => {
        const r = map.get(name);
        const rTot = r.r1 + r.r2;
        const dcTot = r.dc1 + r.dc2;
        const grand = r.total + r.sd;
        const cls = (i % 2 === 0) ? "row-even" : "row-odd";
        h += _dataRow([name, r.North, r.South, r.East, r.West, r.Central, r.Northwest, r.r1, r.r2, rTot, r.ct, r.dc1, r.dc2, dcTot, r.sd, grand], cls);

        for (const ch of PRIMARY) avgAcc[ch] += r[ch];
        avgAcc.r1 += r.r1; avgAcc.r2 += r.r2; avgAcc.ct += r.ct; avgAcc.dc1 += r.dc1; avgAcc.dc2 += r.dc2; avgAcc.sd += r.sd; avgAcc.total += r.total;
        for (const k of ["North","South","East","West","Central","Northwest","r1","r2","ct","dc1","dc2","sd"]) { mins[k] = Math.min(mins[k], r[k]); maxs[k] = Math.max(maxs[k], r[k]); }
        const rT=r.r1+r.r2, dT=r.dc1+r.dc2, g=r.total+r.sd;
        minRTot=Math.min(minRTot,rT); maxRTot=Math.max(maxRTot,rT);
        minDCTot=Math.min(minDCTot,dT); maxDCTot=Math.max(maxDCTot,dT);
        minGrand=Math.min(minGrand,g); maxGrand=Math.max(maxGrand,g);
      });

      const n = names.length;
      h += _dataRow(["AVG", (avgAcc.North/n).toFixed(1), (avgAcc.South/n).toFixed(1), (avgAcc.East/n).toFixed(1), (avgAcc.West/n).toFixed(1), (avgAcc.Central/n).toFixed(1), (avgAcc.Northwest/n).toFixed(1), (avgAcc.r1/n).toFixed(1), (avgAcc.r2/n).toFixed(1), ((avgAcc.r1+avgAcc.r2)/n).toFixed(1), (avgAcc.ct/n).toFixed(1), (avgAcc.dc1/n).toFixed(1), (avgAcc.dc2/n).toFixed(1), ((avgAcc.dc1+avgAcc.dc2)/n).toFixed(1), (avgAcc.sd/n).toFixed(1), ((avgAcc.total+avgAcc.sd)/n).toFixed(1)], "row-avg");
      h += _dataRow(["MIN", mins.North, mins.South, mins.East, mins.West, mins.Central, mins.Northwest, mins.r1, mins.r2, minRTot, mins.ct, mins.dc1, mins.dc2, minDCTot, mins.sd, minGrand], "row-min");
      h += _dataRow(["MAX", maxs.North, maxs.South, maxs.East, maxs.West, maxs.Central, maxs.Northwest, maxs.r1, maxs.r2, maxRTot, maxs.ct, maxs.dc1, maxs.dc2, maxDCTot, maxs.sd, maxGrand], "row-max");
      h += _dataRow(["SPREAD", maxs.North-mins.North, maxs.South-mins.South, maxs.East-mins.East, maxs.West-mins.West, maxs.Central-mins.Central, maxs.Northwest-mins.Northwest, maxs.r1-mins.r1, maxs.r2-mins.r2, maxRTot-minRTot, maxs.ct-mins.ct, maxs.dc1-mins.dc1, maxs.dc2-mins.dc2, maxDCTot-minDCTot, maxs.sd-mins.sd, maxGrand-minGrand], "row-spread");

      // Spacer row between groups
      h += `<tr><td colspan="${numCols}" style="border:none; height:12px;">&nbsp;</td></tr>`;
    }

    h += `</table></body></html>`;

    const blob = new Blob(["\uFEFF" + h], { type: "application/vnd.ms-excel;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `rotation_${meta.year || ""}_${String((meta.monthIndex||0)+1).padStart(2,"0")}.xls`;
    a.click();
    URL.revokeObjectURL(url);
    showToast("Excel file exported!");
  });

  // EXPORT CSV button — full month assignments as CSV for Excel 2007+
  document.getElementById("btnExportMonthCSV").addEventListener("click", () => {
    const plan = loadPlan();
    if (!plan || !plan.days) { showToast("No plan to export. Randomize first."); return; }
    const meta = plan.meta || {};
    const year = meta.year || new Date().getFullYear();
    const monthIndex = meta.monthIndex ?? new Date().getMonth();
    const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();
    const dayNames = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
    const ctrSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);

    // Build person assignment sequences for violation detection (same as renderMonth)
    const personAssignments = new Map();
    const daysList = [];
    for (let day = 1; day <= daysInMonth; day++) daysList.push(new Date(year, monthIndex, day, 12, 0, 0, 0));

    for (const d of daysList) {
      const dayKey = ymd(d);
      const blocks = plan.days[dayKey];
      if (!blocks) continue;
      BLOCKS.forEach((b, bi) => {
        const entry = blocks[b.key];
        if (!entry) return;
        if (entry.assignments) {
          for (const [ch, nm] of Object.entries(entry.assignments)) {
            if (!nm) continue;
            const nameUpper = String(nm).toUpperCase();
            if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
            personAssignments.get(nameUpper).push({ dayKey, blockKey: b.key, blockIdx: bi, channel: ch, dayNum: d.getDate() });
          }
        }
        if (entry.ct && entry.ct.length) {
          for (const nm of entry.ct) {
            const nameUpper = String(nm).toUpperCase();
            if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
            personAssignments.get(nameUpper).push({ dayKey, blockKey: b.key, blockIdx: bi, channel: "CT", dayNum: d.getDate() });
          }
        }
      });
    }

    // Detect violations
    const violationCells = new Map(); // "dayKey|blockKey|name" -> violationType
    for (const [name, assignments] of personAssignments) {
      assignments.sort((a, b) => a.dayNum !== b.dayNum ? a.dayNum - b.dayNum : a.blockIdx - b.blockIdx);
      const dayChannels = new Map();
      for (let i = 0; i < assignments.length; i++) {
        const curr = assignments[i];
        const chUpper = String(curr.channel).toUpperCase();
        if (!dayChannels.has(curr.dayKey)) dayChannels.set(curr.dayKey, new Map());
        const dayCh = dayChannels.get(curr.dayKey);
        if (dayCh.has(chUpper) && chUpper !== "SD") {
          violationCells.set(`${curr.dayKey}|${curr.blockKey}|${name}`, "Same channel repeated");
        }
        dayCh.set(chUpper, (dayCh.get(chUpper) || 0) + 1);
        if (i > 0) {
          const prev = assignments[i - 1];
          const prevChUpper = String(prev.channel).toUpperCase();
          const isConsecutive = (curr.dayKey === prev.dayKey && curr.blockIdx === prev.blockIdx + 1) ||
                                (curr.dayNum === prev.dayNum + 1 && prev.blockIdx === BLOCKS.length - 1 && curr.blockIdx === 0);
          if (isConsecutive && ctrSet.has(chUpper) && ctrSet.has(prevChUpper)) {
            violationCells.set(`${curr.dayKey}|${curr.blockKey}|${name}`, "R/CT back-to-back");
            violationCells.set(`${prev.dayKey}|${prev.blockKey}|${name}`, "R/CT back-to-back");
          }
        }
      }
    }

    // Build previous assignment lookup: for each person, track their last channel per block
    const prevAssignLookup = new Map(); // "dayKey|blockKey|name" -> prevChannel
    for (const [name, assignments] of personAssignments) {
      for (let i = 0; i < assignments.length; i++) {
        if (i > 0) {
          prevAssignLookup.set(`${assignments[i].dayKey}|${assignments[i].blockKey}|${name}`, assignments[i - 1].channel);
        }
      }
    }

    // Build CSV rows
    const esc = (v) => { const s = String(v ?? ""); return /[,"\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s; };
    const rows = [["Date","Day","Block","Employee","Assignment","PrevAssignment","Violation","ViolationType"]];

    for (const d of daysList) {
      const dayKey = ymd(d);
      const dow = dayNames[d.getDay()];
      const dateStr = `${monthIndex + 1}/${d.getDate()}/${year}`;
      const blocks = plan.days[dayKey];
      if (!blocks) continue;

      for (const b of BLOCKS) {
        const entry = blocks[b.key];
        if (!entry) continue;
        const blockLabel = b.label.replace(/—/g, "–");

        // Collect all assignments for this block into an array, then sort by employee
        const blockRows = [];

        // Channel assignments
        for (const ch of CHANNELS) {
          const nm = (entry.assignments || {})[ch] || "";
          if (nm) {
            const nameUpper = String(nm).toUpperCase();
            const vKey = `${dayKey}|${b.key}|${nameUpper}`;
            const prev = prevAssignLookup.get(vKey) || "";
            const viol = violationCells.has(vKey) ? "YES" : "";
            const violType = violationCells.get(vKey) || "";
            blockRows.push([dateStr, dow, blockLabel, nameUpper, ch, prev, viol, violType]);
          }
        }

        // 7th channel (Fri/Sat night blocks)
        const isFriSat = (d.getDay() === 5 || d.getDay() === 6);
        if (isFriSat && SEVENTH_BLOCKS.has(b.key)) {
          const nm7 = (entry.assignments || {})[SEVENTH_CHANNEL] || "";
          if (nm7) {
            const nameUpper = String(nm7).toUpperCase();
            const vKey = `${dayKey}|${b.key}|${nameUpper}`;
            const prev = prevAssignLookup.get(vKey) || "";
            const viol = violationCells.has(vKey) ? "YES" : "";
            const violType = violationCells.get(vKey) || "";
            blockRows.push([dateStr, dow, blockLabel, nameUpper, "7th", prev, viol, violType]);
          }
        }

        // CT assignments
        for (const nm of (entry.ct || [])) {
          const nameUpper = String(nm).toUpperCase();
          const vKey = `${dayKey}|${b.key}|${nameUpper}`;
          const prev = prevAssignLookup.get(vKey) || "";
          const viol = violationCells.has(vKey) ? "YES" : "";
          const violType = violationCells.get(vKey) || "";
          blockRows.push([dateStr, dow, blockLabel, nameUpper, "CT", prev, viol, violType]);
        }

        // SD assignments
        for (const nm of (entry.sd || [])) {
          const nameUpper = String(nm).toUpperCase();
          const vKey = `${dayKey}|${b.key}|${nameUpper}`;
          const prev = prevAssignLookup.get(vKey) || "";
          blockRows.push([dateStr, dow, blockLabel, nameUpper, "SD", prev, "", ""]);
        }

        // Sort by employee name within each block
        blockRows.sort((a, b) => a[3].localeCompare(b[3]));
        for (const r of blockRows) rows.push(r);
      }
    }

    const csv = rows.map(r => r.map(esc).join(",")).join("\n");
    const blob = new Blob(["\uFEFF" + csv], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `rotation_${year}_${String(monthIndex + 1).padStart(2, "0")}.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    showToast("CSV file exported!");
  });

  // Event delegation for btnAddVac and btnAddTrainee
  document.addEventListener("click", (e)=>{
    if (e.target && e.target.id === "btnAddVac") {
      const sel = document.getElementById("vacName");
      const name = sel.value.trim();
      const from = document.getElementById("vacFrom").value || "";
      const to = document.getElementById("vacTo").value || "";
      if (!name) return showToast("Select a name first.");
      const v = getVacRanges(); v.push({name, from, to}); saveJSON(STORAGE.vac, v);
      sel.selectedIndex = 0;
      document.getElementById("vacFrom").value = "";
      document.getElementById("vacTo").value = "";
      renderExceptions(); renderInfoStats(); showToast("Added exclusion.");
    }
    if (e.target && e.target.id === "btnAddTrainee") {
      const sel = document.getElementById("traineeName");
      const name = sel.value.trim().toUpperCase();
      const from = document.getElementById("traineeFrom").value || "";
      const to = document.getElementById("traineeTo").value || "";
      if (!name) return showToast("Select a trainer first.");
      const ranges = getTrainerRanges();
      ranges.push({name, from, to});
      saveJSON(STORAGE.training, ranges);
      sel.selectedIndex = 0;
      document.getElementById("traineeFrom").value = "";
      document.getElementById("traineeTo").value = "";
      renderExceptions(); renderInfoStats();
      showToast("Added trainer. They will only be assigned E, S, W, C.");
    }
  });

  // ========== SWAP TIP BUBBLE ==========
  function showSwapTip() {
    const tip = document.getElementById("swapTip");
    if (!tip) return;
    tip.style.display = "block";
    tip.onclick = () => { tip.style.display = "none"; };
  }

  // ========== CLICK-TO-CHANGE MODAL ==========
  let currentCallOffData = null;

  function showCallOffModal(dayKey, blockKey, channel, name, type) {
    currentCallOffData = { dayKey, blockKey, channel, name, type };
    const blockLabel = BLOCKS.find(b => b.key === blockKey)?.label || blockKey;
    document.getElementById("callOffModalTitle").textContent = `SWAP: ${name}`;
    document.getElementById("callOffModalInfo").innerHTML = `
      <strong>DATE:</strong> ${dayKey}<br>
      <strong>BLOCK:</strong> ${blockLabel}<br>
      <strong>CURRENT:</strong> ${channel}
    `;

    // Show MOVE section only for SD assignments
    const moveSection = document.getElementById("moveToSection");
    const moveBtn = document.getElementById("btnMoveTo");
    if (type === "sd") {
      moveSection.style.display = "block";
      moveBtn.style.display = "inline-block";
      const moveSel = document.getElementById("moveToSelect");
      moveSel.innerHTML = "";
      // CT option
      const ctOpt = document.createElement("option");
      ctOpt.value = "ct";
      ctOpt.textContent = "CT (CALLTAKING)";
      moveSel.appendChild(ctOpt);
      // Empty channel slots
      const plan2 = loadPlan();
      const bd = plan2.days[dayKey]?.[blockKey];
      if (bd) {
        for (const ch of CHANNELS) {
          const assigned = bd.assignments?.[ch];
          if (!assigned || String(assigned).trim() === "") {
            const opt = document.createElement("option");
            opt.value = `channel|${ch}`;
            opt.textContent = ch.toUpperCase();
            moveSel.appendChild(opt);
          }
        }
      }
    } else {
      moveSection.style.display = "none";
      moveBtn.style.display = "none";
    }

    // Populate swap dropdown with all assignments in this block
    const plan = loadPlan();
    const blockData = plan.days[dayKey]?.[blockKey];
    const swapSelect = document.getElementById("swapSelect");
    swapSelect.innerHTML = "";

    if (blockData) {
      // Add channel assignments
      for (const [ch, nm] of Object.entries(blockData.assignments || {})) {
        if (nm && nm.toUpperCase() !== name.toUpperCase()) {
          const opt = document.createElement("option");
          opt.value = `channel|${ch}|${nm}`;
          opt.textContent = `${channelAbbrev(ch)}: ${nm.toUpperCase()}`;
          swapSelect.appendChild(opt);
        }
      }
      // Add CT assignments
      for (const nm of (blockData.ct || [])) {
        if (nm && nm.toUpperCase() !== name.toUpperCase()) {
          const opt = document.createElement("option");
          opt.value = `ct|CT|${nm}`;
          opt.textContent = `CT: ${nm.toUpperCase()}`;
          swapSelect.appendChild(opt);
        }
      }
      // Add SD assignments
      for (const nm of (blockData.sd || [])) {
        if (nm && nm.toUpperCase() !== name.toUpperCase()) {
          const opt = document.createElement("option");
          opt.value = `sd|SD|${nm}`;
          opt.textContent = `SD: ${nm.toUpperCase()}`;
          swapSelect.appendChild(opt);
        }
      }
    }

    if (swapSelect.options.length === 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "-- NO OTHER ASSIGNMENTS --";
      swapSelect.appendChild(opt);
    }

    document.getElementById("callOffModalResult").innerHTML = "";
    document.getElementById("callOffModal").style.display = "flex";
  }

  function hideCallOffModal() {
    document.getElementById("callOffModal").style.display = "none";
    currentCallOffData = null;
  }

  // Event delegation for clickable assignments
  document.addEventListener("click", (e) => {
    const target = e.target.closest(".clickable-assign");
    if (!target) return;

    const dayKey = target.getAttribute("data-day");
    const blockKey = target.getAttribute("data-block");
    const channel = target.getAttribute("data-channel");
    const name = target.getAttribute("data-name");
    const type = target.getAttribute("data-type");

    if (dayKey && blockKey && name) {
      showCallOffModal(dayKey, blockKey, channel, name, type);
    }
  });

  // Modal buttons
  document.getElementById("btnModalCancel").addEventListener("click", hideCallOffModal);
  document.getElementById("callOffModal").addEventListener("click", (e) => {
    if (e.target.id === "callOffModal") hideCallOffModal(); // Click outside to close
  });

  document.getElementById("btnModalSwap").addEventListener("click", () => {
    if (!currentCallOffData) return;
    const { dayKey, blockKey, channel, name, type } = currentCallOffData;

    const swapSelect = document.getElementById("swapSelect");
    const swapValue = swapSelect.value;
    if (!swapValue) { showToast("NO ASSIGNMENT SELECTED TO SWAP."); return; }

    const [swapType, swapChannel, swapName] = swapValue.split("|");

    const plan = loadPlan();
    const blockData = plan.days[dayKey]?.[blockKey];
    if (!blockData) return hideCallOffModal();

    // Get current person's name and swap target's name
    const personA = name.toUpperCase();
    const personB = swapName.toUpperCase();

    // Perform the swap based on types
    // Remove personA from their current position
    if (type === "channel") {
      blockData.assignments[channel] = personB;
    } else if (type === "ct") {
      const idx = blockData.ct.findIndex(n => String(n).toUpperCase() === personA);
      if (idx !== -1) blockData.ct[idx] = personB;
    } else if (type === "sd") {
      const idx = blockData.sd.findIndex(n => String(n).toUpperCase() === personA);
      if (idx !== -1) blockData.sd[idx] = personB;
    }

    // Put personA in personB's position
    if (swapType === "channel") {
      blockData.assignments[swapChannel] = personA;
    } else if (swapType === "ct") {
      const idx = blockData.ct.findIndex(n => String(n).toUpperCase() === personB);
      if (idx !== -1) blockData.ct[idx] = personA;
    } else if (swapType === "sd") {
      const idx = blockData.sd.findIndex(n => String(n).toUpperCase() === personB);
      if (idx !== -1) blockData.sd[idx] = personA;
    }

    savePlan(plan);

    // Record swap in history
    const blockLabel = BLOCKS.find(b => b.key === blockKey)?.label || blockKey;
    addSwapHistory({
      name1: personA,
      name2: personB,
      date: dayKey,
      block: blockLabel
    });

    hideCallOffModal();

    // Refresh views
    const dk = document.getElementById("dayPick").value;
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    renderDay(dk); renderWeek(dk); renderMonth(y, m);
    showToast(`SWAPPED ${personA} ↔ ${personB}`);
  });

  // ========== MARK ABSENT ==========
  document.getElementById("btnMarkAbsent").addEventListener("click", () => {
    if (!currentCallOffData) return;
    const { dayKey, blockKey, channel, name, type } = currentCallOffData;

    const plan = loadPlan();
    const blockData = plan.days[dayKey]?.[blockKey];
    if (!blockData) return hideCallOffModal();

    const personName = name.toUpperCase();

    // Remove person from their current position
    if (type === "channel") {
      blockData.assignments[channel] = "";
    } else if (type === "ct") {
      const idx = blockData.ct.findIndex(n => String(n).toUpperCase() === personName);
      if (idx !== -1) blockData.ct.splice(idx, 1);
    } else if (type === "sd") {
      const idx = blockData.sd.findIndex(n => String(n).toUpperCase() === personName);
      if (idx !== -1) blockData.sd.splice(idx, 1);
    }

    // Track as absent
    if (!blockData.absent) blockData.absent = [];
    if (!blockData.absent.some(n => String(n).toUpperCase() === personName)) {
      blockData.absent.push(personName);
    }

    savePlan(plan);
    hideCallOffModal();

    // Refresh views
    const dk = document.getElementById("dayPick").value;
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    renderDay(dk); renderWeek(dk); renderMonth(y, m);
    showToast(`${personName} MARKED ABSENT — SLOT NOW NEEDS COVERAGE`);
  });

  // ========== MOVE SD TO CT / CHANNEL ==========
  document.getElementById("btnMoveTo").addEventListener("click", () => {
    if (!currentCallOffData) return;
    const { dayKey, blockKey, name, type } = currentCallOffData;
    if (type !== "sd") return;

    const moveSel = document.getElementById("moveToSelect");
    const moveValue = moveSel.value;
    if (!moveValue) { showToast("SELECT A DESTINATION."); return; }

    const plan = loadPlan();
    const blockData = plan.days[dayKey]?.[blockKey];
    if (!blockData) return hideCallOffModal();

    const personName = name.toUpperCase();

    // Remove from SD
    const idx = blockData.sd.findIndex(n => String(n).toUpperCase() === personName);
    if (idx !== -1) blockData.sd.splice(idx, 1);

    let dest;
    if (moveValue === "ct") {
      // Add to CT
      if (!blockData.ct) blockData.ct = [];
      blockData.ct.push(personName);
      dest = "CT";
    } else if (moveValue.startsWith("channel|")) {
      // Add to channel
      const ch = moveValue.split("|")[1];
      blockData.assignments[ch] = personName;
      dest = ch.toUpperCase();
    }

    savePlan(plan);
    hideCallOffModal();

    const dk = document.getElementById("dayPick").value;
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    renderDay(dk); renderWeek(dk); renderMonth(y, m);
    showToast(`${personName} MOVED FROM SD → ${dest}`);
  });

  // ========== ASSIGN TO EMPTY SLOT MODAL ==========
  let currentAssignSlotData = null;

  function showAssignSlotModal(dayKey, blockKey, channel) {
    const plan = loadPlan();
    const blockData = plan.days[dayKey]?.[blockKey];
    if (!blockData) return;

    const ctList = (blockData.ct || []).filter(n => n && String(n).trim() !== "");
    if (ctList.length === 0) {
      showToast("NO ONE AVAILABLE IN CT FOR THIS BLOCK");
      return;
    }

    currentAssignSlotData = { dayKey, blockKey, channel };

    const blockLabel = BLOCKS.find(b => b.key === blockKey)?.label || blockKey;
    document.getElementById("assignSlotModalTitle").textContent = `ASSIGN TO: ${channel}`;
    document.getElementById("assignSlotModalInfo").innerHTML = `
      <strong>DATE:</strong> ${dayKey}<br>
      <strong>BLOCK:</strong> ${blockLabel}<br>
      <strong>CHANNEL:</strong> ${channel}<br>
      <span style="font-size:12px; opacity:.7;">Select someone from CT to fill this slot.</span>
    `;

    const sel = document.getElementById("assignSlotSelect");
    sel.innerHTML = "";
    for (const nm of ctList) {
      const opt = document.createElement("option");
      opt.value = nm;
      opt.textContent = nm.toUpperCase();
      sel.appendChild(opt);
    }

    document.getElementById("assignSlotModal").style.display = "flex";
  }

  function hideAssignSlotModal() {
    document.getElementById("assignSlotModal").style.display = "none";
    currentAssignSlotData = null;
  }

  // Click on NEEDED badge → open assign modal
  document.addEventListener("click", (e) => {
    const target = e.target.closest(".clickable-needed");
    if (!target) return;

    const dayKey = target.getAttribute("data-day");
    const blockKey = target.getAttribute("data-block");
    const channel = target.getAttribute("data-channel");

    if (dayKey && blockKey && channel) {
      showAssignSlotModal(dayKey, blockKey, channel);
    }
  });

  // ASSIGN button
  document.getElementById("btnAssignSlot").addEventListener("click", () => {
    if (!currentAssignSlotData) return;
    const { dayKey, blockKey, channel } = currentAssignSlotData;

    const sel = document.getElementById("assignSlotSelect");
    const selectedName = sel.value;
    if (!selectedName) { showToast("SELECT SOMEONE TO ASSIGN."); return; }

    const plan = loadPlan();
    const blockData = plan.days[dayKey]?.[blockKey];
    if (!blockData) return hideAssignSlotModal();

    // Assign person to channel
    blockData.assignments[channel] = selectedName;

    // Remove person from CT
    const idx = blockData.ct.findIndex(n => String(n).toUpperCase() === selectedName.toUpperCase());
    if (idx !== -1) blockData.ct.splice(idx, 1);

    savePlan(plan);
    hideAssignSlotModal();

    // Refresh views
    const dk = document.getElementById("dayPick").value;
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    renderDay(dk); renderWeek(dk); renderMonth(y, m);
    showToast(`${selectedName.toUpperCase()} ASSIGNED TO ${channel}`);
  });

  // Cancel & close assign modal
  document.getElementById("btnAssignSlotCancel").addEventListener("click", hideAssignSlotModal);
  document.getElementById("assignSlotModal").addEventListener("click", (e) => {
    if (e.target.id === "assignSlotModal") hideAssignSlotModal();
  });

  // ========== UNDO ABSENT (click absent name → return to CT) ==========
  document.addEventListener("click", (e) => {
    const target = e.target.closest(".clickable-absent");
    if (!target) return;

    const dayKey = target.getAttribute("data-day");
    const blockKey = target.getAttribute("data-block");
    const absentName = target.getAttribute("data-name");
    if (!dayKey || !blockKey || !absentName) return;

    const blockLabel = BLOCKS.find(b => b.key === blockKey)?.label || blockKey;
    if (!confirm(`Return ${absentName} to CT for ${dayKey} ${blockLabel}?`)) return;

    const plan = loadPlan();
    const blockData = plan.days[dayKey]?.[blockKey];
    if (!blockData) return;

    // Remove from absent list
    if (blockData.absent) {
      const idx = blockData.absent.findIndex(n => String(n).toUpperCase() === absentName.toUpperCase());
      if (idx !== -1) blockData.absent.splice(idx, 1);
    }

    // Add back to CT
    if (!blockData.ct) blockData.ct = [];
    blockData.ct.push(absentName);

    savePlan(plan);

    // Refresh views
    const dk = document.getElementById("dayPick").value;
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    renderDay(dk); renderWeek(dk); renderMonth(y, m);
    showToast(`${absentName} RETURNED TO CT`);
  });

  // ========== END CLICK-TO-CHANGE MODAL ==========

  // Track best violation count for this session
  let bestViolationCount = Infinity;

  function updateViolationDisplay() {
    const stats = window.lastRandomizeStats;
    if (!stats) return;

    document.getElementById("violationStats").style.display = "inline-flex";
    document.getElementById("violationCount").textContent = stats.totalViolations;
    document.getElementById("violationPeople").textContent = stats.uniquePeopleWithViolations;

    if (stats.totalViolations < bestViolationCount) {
      bestViolationCount = stats.totalViolations;
      document.getElementById("violationBest").style.display = "inline";
      document.getElementById("violationStats").style.background = "rgba(34,197,94,0.15)";
      document.getElementById("violationStats").style.borderColor = "rgba(34,197,94,0.4)";
    } else {
      document.getElementById("violationBest").style.display = "none";
      document.getElementById("violationStats").style.background = "rgba(239,68,68,0.15)";
      document.getElementById("violationStats").style.borderColor = "rgba(239,68,68,0.4)";
    }
  }

  // ========== RANDOMIZE & SAVE ==========
  let _lastRandomizeFn = randomizeMonth; // Track which randomizer was last used

  async function _doRandomize(randomFn, btnEl) {
    const pwd = prompt("ENTER PASSWORD TO RANDOMIZE:");
    if (pwd !== "911911") { showToast("INCORRECT PASSWORD."); return; }
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    const btnLabel = btnEl.textContent; // remember original label
    bestViolationCount = Infinity;
    _lastRandomizeFn = randomFn;

    btnEl.disabled = true;
    btnEl.textContent = "RANDOMIZING...";

    let attempts = 0;
    let viol = Infinity;
    const maxAttempts = 75;
    let bestPlan = null;
    let bestViol = Infinity;
    let bestSpread = Infinity;
    let bestCT = Infinity;
    let bestScore = Infinity;

    // Composite score: violations dominate, then primary spread, then CT spread
    function _qualityScore(v, spread, ct) {
      return (v || 0) * 10000 + (spread || 0) * 100 + (ct || 0) * 10;
    }

    while (attempts < maxAttempts) {
      try {
        randomFn(y, m);
        viol = window.lastRandomizeStats?.totalViolations ?? Infinity;
      } catch (err) {
        console.error("randomize error on attempt " + attempts + ":", err);
        viol = Infinity;
      }
      attempts++;

      const spread = window.lastRandomizeStats?.maxPrimaryCount || 0;
      const ct = window.lastRandomizeStats?.maxCTCount || 0;
      const score = _qualityScore(viol, spread, ct);

      if (score < bestScore) {
        bestScore = score;
        bestViol = viol;
        bestSpread = spread;
        bestCT = ct;
        bestPlan = JSON.parse(JSON.stringify(loadPlan()));
      }

      // Perfect: 0 violations with tight balance
      if (bestViol === 0 && bestSpread <= 5 && bestCT <= 10) break;
      // Great: very few violations with good balance
      if (bestViol <= 2 && bestSpread <= 6 && bestCT <= 11 && attempts >= 15) break;
      // Good: acceptable result
      if (bestViol <= 3 && bestSpread <= 6 && attempts >= 40) break;
      // Good enough: stop after 60 attempts if we have ≤5 violations
      if (bestViol <= 5 && attempts >= 60) break;

      btnEl.textContent = `RANDOMIZING... (${attempts}/${maxAttempts}, best: ${bestViol}v/${bestSpread}ch/${bestCT}ct)`;
    }

    // Always restore best plan and update stats
    if (bestPlan) {
      savePlan(bestPlan);
      viol = bestViol;
    }
    // Always sync stats to match the best plan kept
    window.lastRandomizeStats = window.lastRandomizeStats || {};
    window.lastRandomizeStats.totalViolations = bestViol === Infinity ? 0 : bestViol;
    window.lastRandomizeStats.maxPrimaryCount = bestSpread === Infinity ? 0 : bestSpread;
    window.lastRandomizeStats.maxCTCount = bestCT === Infinity ? 0 : bestCT;

    updateViolationDisplay();
    const dk = ymd(new Date());
    document.getElementById("dayPick").value = dk;
    renderDay(dk); renderWeek(dk); renderMonth(y,m); if (loadJSON(STORAGE.ui, {}).tab==="mroster") renderMonthRostersIfActive();
    showSwapTip();

    // Log what we're about to save
    const savePlanCheck = loadPlan();
    const saveFirstDay = savePlanCheck ? Object.keys(savePlanCheck.days || {})[0] : null;
    const saveFirstBlock = saveFirstDay ? savePlanCheck.days[saveFirstDay] : null;
    const saveFirstBlockKey = saveFirstBlock ? Object.keys(saveFirstBlock)[0] : null;
    const saveFirstAssign = saveFirstBlockKey && saveFirstBlock[saveFirstBlockKey]?.assignments
      ? Object.values(saveFirstBlock[saveFirstBlockKey].assignments).slice(0,3).join(", ")
      : "none";
    console.log("RANDOMIZE: About to save. First day assignments:", saveFirstDay, "→", saveFirstAssign);

    // Save to Firebase immediately — block everything until done
    btnEl.textContent = "SAVING TO FIREBASE...";
    if (autoSaveTimer) clearTimeout(autoSaveTimer);
    if (realtimeUnsubscribe) { realtimeUnsubscribe(); realtimeUnsubscribe = null; }
    isSyncing = true;
    setSyncStatus("SAVING...", "pending");

    let ok = false;
    try {
      ok = await saveRotationToFirebase();
    } catch (err) {
      console.error("Save after randomize failed:", err);
    }

    isSyncing = false;
    btnEl.disabled = false;
    btnEl.textContent = btnLabel;

    if (ok) {
      lastSavedAt = Date.now();
      setSyncStatus("SYNCED", "good");
      const plan = loadPlan();
      const docId = plan && plan.meta ? `rotation_${plan.meta.year}_${plan.meta.monthIndex}` : "unknown";
      showToast(`SAVED & VERIFIED! Doc: ${docId} — ${viol} violations (${attempts} attempts)`);
    } else {
      setSyncStatus("SAVE FAILED", "bad");
      alert("FAILED TO SAVE TO FIREBASE. Your rotation was NOT saved. Check your internet and try again.");
    }

    // Reconnect realtime sync now that Firebase has the new data
    startRealtimeSync(y, m);
  }

  document.getElementById("btnRandomizeA").addEventListener("click", async () => {
    await _doRandomize(randomizeMonth, document.getElementById("btnRandomizeA"));
  });
  document.getElementById("btnRandomizeB").addEventListener("click", async () => {
    await _doRandomize(randomizeMonthB, document.getElementById("btnRandomizeB"));
  });

  // When month/year changes, try to load from Firebase
  const monthYearChanged = async () => {
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    setSyncStatus("LOADING...", "pending");
    const loaded = await loadRotationFromFirebase(y, m);
    if (loaded) {
      setSyncStatus("SYNCED", "good");
      const plan = loadPlan();
      if (plan && plan.meta && plan.meta.year === y && plan.meta.monthIndex === m) {
        const dk = ymd(new Date(y, m, 1, 12, 0, 0, 0));
        document.getElementById("dayPick").value = dk;
        renderDay(dk); renderWeek(dk); renderMonth(y, m);
        if (loadJSON(STORAGE.ui, {}).tab === "mroster") renderMonthRostersIfActive();
      }
    } else {
      setSyncStatus("LOCAL", null);
    }
    startRealtimeSync(y, m);
  };
  document.getElementById("monthSel").addEventListener("change", monthYearChanged);
  document.getElementById("yearSel").addEventListener("change", monthYearChanged);

  const btnRandomizeAgain = document.getElementById("btnRandomizeAgain");
  if (btnRandomizeAgain) {
    btnRandomizeAgain.addEventListener("click", ()=>{
      const m = Number(document.getElementById("monthSel").value);
      const y = Number(document.getElementById("yearSel").value);
      _lastRandomizeFn(y, m);
      updateViolationDisplay();
      const viol = window.lastRandomizeStats?.totalViolations || 0;
      const isBest = viol <= bestViolationCount;
      showToast(`Re-randomized ${monthName(m)} ${y}. Violations: ${viol}${isBest ? ' (Best!)' : ''}`);
      const dk = document.getElementById("dayPick").value || ymd(new Date(y,m,1,12,0,0,0));
      renderDay(dk); renderWeek(dk); renderMonth(y,m); if (loadJSON(STORAGE.ui, {}).tab==="mroster") renderMonthRostersIfActive();
    });
  }

  const btnHardReset = document.getElementById("btnHardReset");
  if (btnHardReset) {
    btnHardReset.addEventListener("click", ()=>{
      for (const k of Object.values(STORAGE)) localStorage.removeItem(k);
      showToast("Cleared saved data. Reloading...");
      setTimeout(()=>location.reload(), 600);
    });
  }

  // ========== THEME TOGGLE ==========
  function applyTheme(isLight) {
    document.body.classList.toggle("light", isLight);
    document.getElementById("themeIcon").textContent = isLight ? "🌙" : "☀️";
    document.getElementById("themeLabel").textContent = isLight ? "DARK" : "LIGHT";
    saveJSON(STORAGE.theme, isLight ? "light" : "dark");
  }
  document.getElementById("btnThemeToggle").addEventListener("click", () => {
    applyTheme(!document.body.classList.contains("light"));
  });
  // Apply saved theme
  if (loadJSON(STORAGE.theme, "dark") === "light") applyTheme(true);

  // Employee management removed — employees are managed in the base data

  // ========== SWAP HISTORY ==========
  function getSwapHistory() {
    return loadJSON(STORAGE.swapHistory, []);
  }
  function addSwapHistory(entry) {
    const history = getSwapHistory();
    history.unshift({ ...entry, timestamp: new Date().toISOString() });
    if (history.length > 100) history.length = 100; // Keep last 100
    saveJSON(STORAGE.swapHistory, history);
  }
  function renderSwapHistory() {
    const list = document.getElementById("historyList");
    const history = getSwapHistory();

    if (history.length === 0) {
      list.innerHTML = '<div style="color:var(--muted); text-align:center; padding:20px;">NO SWAPS RECORDED YET</div>';
      return;
    }

    let html = '';
    history.forEach(h => {
      const time = new Date(h.timestamp).toLocaleString();
      html += `<div class="history-item">
        <span class="history-time">${escapeHtml(time.split(',')[0])}</span>
        <span class="history-action"><b>${escapeHtml(h.name1)}</b> ↔ <b>${escapeHtml(h.name2)}</b> (${escapeHtml(h.date)} ${escapeHtml(h.block)})</span>
      </div>`;
    });
    list.innerHTML = html;
  }

  document.getElementById("btnSwapHistory").addEventListener("click", () => {
    document.getElementById("historyModal").classList.add("show");
    renderSwapHistory();
  });
  document.getElementById("btnCloseHistoryModal").addEventListener("click", () => {
    document.getElementById("historyModal").classList.remove("show");
  });
  document.getElementById("btnClearHistory").addEventListener("click", () => {
    saveJSON(STORAGE.swapHistory, []);
    renderSwapHistory();
    showToast("HISTORY CLEARED");
  });

  // Close modals on overlay click
  document.querySelectorAll('.modal-overlay').forEach(modal => {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.classList.remove('show');
    });
  });

  document.getElementById("dayPick").addEventListener("change", ()=>{
    const dk = document.getElementById("dayPick").value;
    renderDay(dk); renderWeek(dk);
  });

  // Day arrow navigation
  function shiftDay(offset) {
    const picker = document.getElementById("dayPick");
    const current = parseYMD(picker.value);
    if (!current) return;
    current.setDate(current.getDate() + offset);
    const newKey = ymd(current);
    picker.value = newKey;
    renderDay(newKey); renderWeek(newKey);
  }
  document.getElementById("btnDayPrev").addEventListener("click", () => shiftDay(-1));
  document.getElementById("btnDayNext").addEventListener("click", () => shiftDay(1));

  document.querySelectorAll(".tab").forEach(t=>{
    t.addEventListener("click", ()=>{
      const tab = t.getAttribute("data-tab");
      setActiveTab(tab);
      const dk = document.getElementById("dayPick").value;
      const m = Number(document.getElementById("monthSel").value);
      const y = Number(document.getElementById("yearSel").value);
      if (tab==="day") renderDay(dk);
      if (tab==="week") renderWeek(dk);
      if (tab==="month") renderMonth(y,m);
      if (tab==="mroster") renderMonthRostersIfActive();
    });
  });

  // Event delegation for per-block Copy buttons (dynamically created in renderDay)
  document.addEventListener("click", (e)=>{
    if (e.target && e.target.classList.contains("btn-copy-block")) {
      const dayKey = e.target.getAttribute("data-day");
      const blockKey = e.target.getAttribute("data-block");
      const plan = loadPlan();
      if (!plan || !plan.days[dayKey] || !plan.days[dayKey][blockKey]) {
        showToast("No data for this block.");
        return;
      }
      const entry = plan.days[dayKey][blockKey];
      const names = [];
      const chAbbr = {"North":"N","South":"S","East":"E","West":"W","Central":"C","Northwest":"NW","Relief 1":"R1","Relief 2":"R2","DC1":"DC1","DC2":"DC2"};
      // Collect only main channels: North, South, East, West, Central, Northwest, Relief 1, Relief 2, DC1, DC2
      for (const ch of CHANNELS) {
        const nm = (entry.assignments||{})[ch];
        names.push(nm ? nm.toUpperCase() : `${chAbbr[ch]||ch}: NEEDED`);
      }
      const text = names.join("\n");
      copyText(text);
    }
  });

  // Month Timeline search functionality
  function applyMonthSearch() {
    const searchVal = document.getElementById("monthSearch").value.trim().toUpperCase();
    const wrap = document.getElementById("monthWrap");
    const cells = wrap.querySelectorAll(".month-cell");

    if (!searchVal) {
      // Clear search - remove all highlights
      wrap.classList.remove("search-active");
      cells.forEach(cell => {
        cell.classList.remove("search-match", "search-dim");
      });
      return;
    }

    // Apply search
    wrap.classList.add("search-active");
    let matchCount = 0;
    cells.forEach(cell => {
      const emp = cell.getAttribute("data-emp") || "";
      if (emp.includes(searchVal)) {
        cell.classList.add("search-match");
        cell.classList.remove("search-dim");
        matchCount++;
      } else {
        cell.classList.remove("search-match");
        cell.classList.add("search-dim");
      }
    });

    if (matchCount === 0 && searchVal) {
      showToast(`No matches found for "${searchVal}"`);
    }
  }

  document.getElementById("monthSearch").addEventListener("input", applyMonthSearch);
  document.getElementById("monthSearch").addEventListener("keyup", (e) => {
    if (e.key === "Escape") {
      document.getElementById("monthSearch").value = "";
      applyMonthSearch();
    }
  });

  // Week Timeline search functionality
  function applyWeekSearch() {
    const searchVal = document.getElementById("weekSearch").value.trim().toUpperCase();
    const wrap = document.getElementById("weekWrap");
    const cells = wrap.querySelectorAll(".assign-cell");

    if (!searchVal) {
      cells.forEach(cell => { cell.style.opacity = "1"; });
      return;
    }

    let matchCount = 0;
    cells.forEach(cell => {
      const text = cell.textContent.toUpperCase();
      if (text.includes(searchVal)) {
        cell.style.opacity = "1";
        cell.style.outline = "2px solid #4aa3ff";
        matchCount++;
      } else {
        cell.style.opacity = "0.25";
        cell.style.outline = "none";
      }
    });

    if (matchCount === 0 && searchVal) {
      showToast(`NO MATCHES FOR "${searchVal}"`);
    }
  }

  document.getElementById("weekSearch").addEventListener("input", applyWeekSearch);
  document.getElementById("weekSearch").addEventListener("keyup", (e) => {
    if (e.key === "Escape") {
      document.getElementById("weekSearch").value = "";
      applyWeekSearch();
    }
  });

  // Roster (Day-only + Night-only) – always render both when the tab is active
  function renderMonthRostersIfActive(){
    const active = loadJSON(STORAGE.ui, {}).tab || "day";
    if (active !== "mroster") return;
    renderMonthRoster("DAY", "mRosterWrapDay");
    renderMonthRoster("NIGHT", "mRosterWrapNight");
  }

  // Always load today's date
  const today = ymd(new Date());
  document.getElementById("dayPick").value = today;

  // Try loading from Firebase first, then render
  (async function initializeWithFirebase() {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth();

    setSyncStatus("LOADING...", "pending");

    // Load dispatcher employees from Firestore
    const empLoaded = await loadEmployeesFromFirestore();
    if (!empLoaded) {
      console.warn("Could not load employees from Firestore — BASE is empty");
    }

    // Try to load rotation plan from Firebase
    const firebaseLoaded = await loadRotationFromFirebase(year, month);

    if (firebaseLoaded) {
      setSyncStatus("SYNCED", "good");
    } else {
      setSyncStatus("LOCAL", null);
    }

    // Now render with whatever data we have
    const plan = loadPlan();
    if (plan && plan.meta) {
      document.getElementById("monthSel").value = String(plan.meta.monthIndex);
      document.getElementById("yearSel").value = String(plan.meta.year);

      // Log first assignment so we can verify data survived
      const firstDayKey = Object.keys(plan.days || {})[0];
      const firstBlock = firstDayKey ? plan.days[firstDayKey] : null;
      const firstBlockKey = firstBlock ? Object.keys(firstBlock)[0] : null;
      const firstAssign = firstBlockKey && firstBlock[firstBlockKey]?.assignments
        ? Object.values(firstBlock[firstBlockKey].assignments).slice(0,3).join(", ")
        : "none";
      console.log("INIT: First day assignments:", firstDayKey, "→", firstAssign);

      document.getElementById("dayPick").value = today;
      renderDay(today); renderWeek(today); renderMonth(plan.meta.year, plan.meta.monthIndex);
      showSwapTip();
    } else {
      renderDay(today);
    }

    // NO realtime sync on page load — only the explicit load above is trusted
    // Realtime sync will start after user interaction (randomize, month change, etc.)
    initialLoadDone = true;
    console.log("INIT: Complete. No realtime sync on load.");
  })();
}


// Global error handler (shows on screen so you can screenshot it)
window.addEventListener('error', (ev)=>{
  try{
    const msg = (ev && ev.error && ev.error.message) ? ev.error.message : (ev && ev.message) ? ev.message : 'Unknown error';
    console.error(ev.error || ev);
    const el = document.getElementById('debugBanner');
    if (el) { el.style.display='block'; el.textContent = 'ERROR: ' + msg; }
    if (typeof showToast === 'function') showToast('Error: ' + msg);
  }catch(_){}
});
document.addEventListener("DOMContentLoaded", ()=>{
  try { boot(); }
  catch(e) {
    console.error(e);
    showToast("Fatal error: <code>" + escapeHtml(e && e.stack ? e.stack : String(e)) + "</code>");
    alert(String(e && e.stack ? e.stack : e));
  }
});

</script>

<div style="text-align:center; padding:20px 10px; margin-top:20px; border-top:1px solid var(--line); color:var(--muted); font-size:11px; letter-spacing:.5px;">
  Built and Maintained by T. Martinez &middot; Version 1.0
</div>

</body>
</html>
