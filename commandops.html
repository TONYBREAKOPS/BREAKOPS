<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CommandOps</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ccircle cx='32' cy='32' r='29' stroke='%23233043' stroke-width='2' fill='%230b0f14'/%3E%3Ccircle cx='32' cy='32' r='20' stroke='%23233043' stroke-width='1' fill='none' opacity='.5'/%3E%3Ccircle cx='32' cy='32' r='11' stroke='%23233043' stroke-width='1' fill='none' opacity='.35'/%3E%3Cline x1='32' y1='4' x2='32' y2='60' stroke='%23233043' stroke-width='1' opacity='.3'/%3E%3Cline x1='4' y1='32' x2='60' y2='32' stroke='%23233043' stroke-width='1' opacity='.3'/%3E%3Cpath d='M32,32 L32,3 A29,29 0 0,1 56,14 Z' fill='%234aa3ff' opacity='.5'/%3E%3Cline x1='32' y1='32' x2='32' y2='3' stroke='%234aa3ff' stroke-width='2' opacity='.8'/%3E%3Ccircle cx='32' cy='32' r='3' fill='%234aa3ff'/%3E%3Ccircle cx='24' cy='20' r='2' fill='%234aa3ff' opacity='.6'/%3E%3Ccircle cx='44' cy='26' r='1.5' fill='%234aa3ff' opacity='.5'/%3E%3C/svg%3E"/>
<style>

:root{
  color-scheme:dark;
  --bg:#0b0f14;
  --card:#111826;
  --muted:#9aa4b2;
  --text:#e7eef8;
  --accent:#4aa3ff;
  --border:#233043;
  --ok:#3fe7b6;
  --bad:#ff6b6b;
  --warn:#ffe066;
}
body.light{
  --bg:#e8eaef;
  --card:#dde1e8;
  --muted:#4a5568;
  --text:#1a1a2e;
  --accent:#0369a1;
  --border:rgba(0,0,0,.12);
  --ok:#059669;
  --bad:#e11d48;
  --warn:#d97706;
}
*,*::before,*::after{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;min-height:100vh;
  font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
  color:var(--text);
  background:var(--bg);
}
body.light{
  background:var(--bg);
}
body.light header{
  background:linear-gradient(180deg, rgba(232,234,239,.98), rgba(232,234,239,.75));
  backdrop-filter:blur(10px);
}
body.light header div{ color:#000 !important; }
body.light header label{ color:#000 !important; font-weight:600 !important; }
body.light button{
  background:rgba(0,0,0,.05) !important;
  border-color:var(--border) !important;
  color:#000 !important;
}
body.light button.primary{
  border-color:rgba(3,105,161,.5) !important;
  background:rgba(3,105,161,.12) !important;
  color:#000 !important;
}
body.light .pill{
  background:rgba(0,0,0,.04) !important;
  border-color:var(--border) !important;
  color:#000 !important;
}
body.light .pill.bad{ color:#b91c1c !important; border-color:rgba(185,28,28,.3) !important; background:rgba(185,28,28,.06) !important; }
body.light .pill.good{ color:#047857 !important; border-color:rgba(4,120,87,.3) !important; background:rgba(4,120,87,.06) !important; }

/* Light mode: universal dark text */
body.light, body.light *:not(.statusShort):not(.statusStaffed):not(.statusOver):not(.adeqStatus){
  color:#000;
}
body.light .muted, body.light label, body.light .small{ color:#1a1a2e !important; }

/* Light mode: all inputs/selects/buttons */
body.light input, body.light select, body.light textarea,
body.light .customSelBtn, body.light button.secondary{
  background:var(--card) !important;
  color:#000 !important;
  border-color:var(--border) !important;
  font-weight:600 !important;
}
body.light select option{
  background:var(--card) !important;
  color:#000 !important;
}
body.light .roleSel, body.light .seatSel, body.light .presentSel, body.light .absReasonSel, body.light .othTypeSel,
body.light .inlineSel, body.light select{
  color:#000 !important;
  font-weight:700 !important;
  background:var(--card) !important;
  border-color:var(--border) !important;
  box-shadow:none !important;
  text-shadow:none !important;
  -webkit-text-fill-color:#000 !important;
}
body.light .hrsIn{ color:#000 !important; font-weight:700 !important; }
body.light .customSelDrop{
  background:var(--bg) !important;
  border-color:var(--border) !important;
  box-shadow:0 8px 24px rgba(0,0,0,.10) !important;
}
body.light .customSelOpt{ color:#1a1a2e !important; }
body.light .customSelOpt:hover{ background:rgba(0,0,0,.06) !important; }

/* Light mode: staffing numbers (adeq) */
body.light .adeqBox{
  background:var(--card) !important;
  border-color:var(--border) !important;
  box-shadow:none !important;
}
body.light .adeqBoxHead{
  background:rgba(0,0,0,.03) !important;
  border-color:var(--border) !important;
  color:#000 !important;
}
body.light .adeqBoxSub{
  color:rgba(0,0,0,.40) !important;
  border-color:var(--border) !important;
}
body.light .adeqTbl{ background:transparent !important; }
body.light .adeqTbl th{ color:#222 !important; background:rgba(0,0,0,.02) !important; }
body.light .adeqTbl td{ color:#000 !important; border-color:rgba(0,0,0,.05) !important; background:transparent !important; }
body.light .adeqTbl tr{ background:transparent !important; }
body.light .adeqSectionLabel{ color:#1a1a2e !important; }
body.light .adeqDivider{
  background:linear-gradient(to right, transparent, rgba(0,0,0,.12), transparent) !important;
}

/* Light mode: role cards */
body.light .card.boardCard{
  background:var(--card) !important;
  border-color:var(--border) !important;
  box-shadow:none !important;
}
body.light .roleCard-CALLTAKER{ background:rgba(56,140,255,.08) !important; border-color:rgba(56,140,255,.15) !important; }
body.light .roleCard-DISPATCHER{ background:rgba(192,132,252,.08) !important; border-color:rgba(192,132,252,.15) !important; }
body.light .roleCard-PIC{ background:rgba(45,212,191,.08) !important; border-color:rgba(45,212,191,.15) !important; }
body.light .roleCard-SUPERVISOR{ background:rgba(251,191,36,.08) !important; border-color:rgba(251,191,36,.15) !important; }
body.light .roleCard-ABSENT{ background:rgba(251,113,133,.08) !important; border-color:rgba(251,113,133,.12) !important; }
body.light .roleCard-OTH{ background:rgba(156,163,175,.08) !important; border-color:rgba(156,163,175,.15) !important; }

/* Light mode: section headers */
body.light h2.blockHdr{ color:#1a1a2e !important; }

/* Light mode: roster tables */
body.light .rosterTbl th{ background:rgba(0,0,0,.03) !important; color:#000 !important; }
body.light .rosterTbl td{ color:#000 !important; border-color:rgba(0,0,0,.05) !important; background:transparent !important; }
body.light .nameCol{ color:#000 !important; font-weight:700 !important; }
body.light .empName{ color:#000 !important; font-weight:700 !important; }
body.light .rowPill{ background:rgba(0,0,0,.07) !important; color:#000 !important; font-weight:700 !important; }
body.light .otBadge{ color:#b45309 !important; }
body.light .hrsIn{ color:#1a1a2e !important; }

/* Light mode: error/note */
body.light .err, body.light #errTxt{ color:#b91c1c !important; }
body.light .note{ color:#92400e !important; }

/* Light mode: comment rows */
body.light .cmt-btn{ color:#111 !important; }
body.light .cmt-btn.has-cmt{ color:#d97706 !important; text-shadow:none !important; }
body.light .cmt-row textarea{
  background:rgba(255,255,255,.8) !important;
  color:#1a1a2e !important;
  border-color:var(--border) !important;
}

/* Light mode: staffing status */
body.light .statusShort{ color:#b91c1c !important; font-weight:900 !important; text-shadow:none !important; }
body.light .statusStaffed{ color:#b45309 !important; font-weight:900 !important; text-shadow:none !important; }
body.light .statusOver{ color:#047857 !important; font-weight:900 !important; text-shadow:none !important; }
body.light .diag{ background:rgba(232,234,239,.96) !important; border-color:var(--border) !important; }
@keyframes radarSweep{
  0%{transform:rotate(0deg)}
  100%{transform:rotate(360deg)}
}
@keyframes logoPulse{
  0%,100%{opacity:.75}
  50%{opacity:.9}
}
.radar-logo{
  animation:logoPulse 4s ease-in-out infinite;
}
a{color:inherit}
header{
  padding:14px 18px 12px;
  position:sticky; top:0; z-index:10;
  backdrop-filter:blur(10px);
  background:linear-gradient(180deg, rgba(11,15,20,.98), rgba(11,15,20,.75));
  border-bottom:1px solid var(--border);
}
h1{margin:0;font-size:32px;letter-spacing:.3px;font-weight:750;text-align:center}
.small{font-size:12px;color:var(--muted);margin-top:4px}
.controls{
  display:grid;
  grid-template-columns:repeat(6,minmax(170px,1fr));
  gap:10px;
  margin-top:12px
}
label{display:block;font-size:11px;color:var(--muted);margin:0 0 6px}
input,select,button{font:inherit}
input,select{
  width:100%;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid var(--border);
  background:#0c1320;
  color:var(--text);
  outline:none;
}
input:focus,select:focus{
  border-color:var(--accent);
  box-shadow:0 0 0 3px rgba(74,163,255,.15);
}
button{
  padding:10px 12px;
  border-radius:12px;
  border:1px solid var(--border);
  background:#0c1320;
  color:var(--text);
  cursor:pointer;
  font-weight:700;
  transition: transform .05s ease, background .2s ease, border-color .2s ease;
}
button:hover{background:rgba(255,255,255,.06); border-color:rgba(255,255,255,.18)}
button:active{transform: translateY(1px)}
button.primary{
  border-color:rgba(74,163,255,.5);
  background:var(--accent);
  color:#fff;
}
.diag{
position:fixed;bottom:0;left:0;right:0;z-index:999;
padding:8px 16px;gap:10px;align-items:center;flex-wrap:wrap;
background:rgba(11,15,20,.96);border-top:1px solid var(--border);
backdrop-filter:blur(10px)}
.pill{
  display:inline-flex;align-items:center;gap:7px;
  padding:7px 10px;
  border-radius:999px;
  border:1px solid var(--border);
  background:rgba(255,255,255,.02);
  color:var(--muted);
  font-size:12px;
}
.pill.bad{border-color:rgba(251,113,133,.45); background:rgba(251,113,133,.10); color:#ffd5dd}
.pill.good{border-color:rgba(52,211,153,.40); background:rgba(52,211,153,.10); color:#d7ffe9}
@keyframes syncPulse{0%,100%{opacity:1}50%{opacity:.5}}
#pillSync{transition:all .2s ease}
#pillSync:not(.good):not(.bad){animation:syncPulse 1s ease-in-out infinite;border-color:rgba(74,163,255,.45);background:rgba(74,163,255,.10);color:#a5d4ff}
#absentBar{
  display:grid;
  grid-template-columns:repeat(3, minmax(520px, 1fr));
  gap:14px;
  width:100%;
  padding:0 18px;
  box-sizing:border-box;
}
.absentCell{
  display:flex;justify-content:flex-start;gap:6px;
}
.absentPill{
  display:inline-flex;align-items:center;gap:6px;
  padding:5px 10px;border-radius:999px;font-size:11px;font-weight:800;
  border:1px solid var(--border);
  background:#0c1320;color:#cfe3ff;
  letter-spacing:.04em;text-transform:uppercase;
  width:auto;
}
.absentPill .absentCount{
  font-weight:900;color:var(--bad);
}
.absentPill.zero .absentCount{color:#fff;}
.absentPill.otPill .absentCount{color:#fde047;}
body.light .absentPill{background:var(--card);border-color:var(--border);color:#222;}
body.light .absentPill .absentCount{color:#b91c1c;}
body.light .absentPill.zero .absentCount{color:#222;}
body.light .absentPill.otPill .absentCount{color:#b45309;}

main{padding:14px 18px 50px}
.grid{
  display:grid;
  grid-template-columns:repeat(3, minmax(520px, 1fr));
  gap:14px;
  align-items:start
}
.card{
  border-radius:14px;
  border:1px solid var(--border);
  background:var(--card);
  overflow:hidden;
}
.card h2{
  margin:0;
  padding:12px 14px;
  font-size:13px;
  letter-spacing:.35px;
  font-weight:800;
  color:var(--text);
  background:#0c1320;
  border-bottom:1px solid var(--border);
  display:flex;
  justify-content:space-between;
  align-items:center;
  border-top-left-radius:13px;
  border-top-right-radius:13px;
}
.blockHdr{ text-align:center; justify-content:center !important; }

.section{padding:12px 14px;border-bottom:1px solid var(--border)}
.tables{display:grid;grid-template-columns:1fr;gap:10px}

table{width:100%;border-collapse:separate;border-spacing:0;font-size:12px;border:none;border-radius:0}
.tblWrap{border:1px solid var(--border);border-radius:12px !important;overflow:hidden !important;background:#0c1320;isolation:isolate;}
.tblWrap thead th{background:transparent !important;}
body.light .tblWrap{background:var(--card);}
th,td{padding:7px 8px;vertical-align:middle}
th{
  color:var(--muted);
  font-weight:700;
  text-align:left;
  background:#0c1320;
  border-bottom:1px solid var(--border);
}
tbody tr td{border-bottom:1px solid rgba(255,255,255,.06)}
tbody tr:hover td{background:rgba(255,255,255,.04)}
.roleHdr{display:flex;justify-content:space-between;align-items:center;margin:4px 0 10px}
.roleHdr b{font-size:12px;letter-spacing:.2px}
.tag{font-size:11px;color:var(--muted)}

.rowPill{
  display:inline-block;
  padding:4px 9px;
  border-radius:999px;
  border:1px solid var(--border);
  background:rgba(255,255,255,.04);
  color:var(--text);
}
.rowPill.editable{cursor:pointer}
.inlineSel, .seatSel{
  width:100%;
  padding:8px 10px;
  border-radius:12px;
  border:1px solid var(--border);
  background:#0c1320;
  color:var(--text);
}
.seatSel{max-width:140px}
.compact{white-space:nowrap}

.timeEdit{display:none;gap:6px}
.timeEdit input{
  padding:8px 10px;
  border-radius:12px;
  border:1px solid var(--border);
  background:#0c1320;
  color:var(--text);
}

.otBar{display:flex;flex-direction:column;gap:8px}
.otBarRow{display:flex;gap:8px;align-items:end}
.otBarRow .mini{flex:1 1 0;min-width:0}
.otBarRow .miniSm{flex:0 0 auto;min-width:80px}
.otBar input, .otBar select{max-width:none;width:100%;box-sizing:border-box}
.otBar button{padding:9px 12px;border-radius:12px;white-space:nowrap}



.statusBadge{
  display:inline;
  font-size:12px;
  font-weight:900;
  margin-left:4px;
}
.statusShort{color:var(--bad);}
.statusStaffed{color:var(--warn);}
.statusOver{color:var(--ok);}


/* Hrs field tuning */
td input[type="number"]{
  width:48px !important;
  min-width:48px !important;
  max-width:48px !important;
  padding:4px 6px !important;
  font-size:15px !important;
  font-weight:600;
  text-align:center;
}


/* Role field (CT/DP/PIC/SUP) tuning */
td select{
  font-size:14px !important;
}

td select.roleSel,
td select[onchange*="setRoleVal"]{
  width:70px !important;
  min-width:70px !important;
  max-width:70px !important;
  padding:4px 6px !important;
  font-weight:600;
  text-align:center;
}

/* If role is rendered as pill */
.rowPill{
  min-width:60px;
  padding:3px 6px !important;
  font-size:13px !important;
  font-weight:600;
  text-align:center;
}





/* Extra-compact Seat selector */
.seatSel{
  width:60px !important;
  min-width:60px !important;
  max-width:60px !important;
  padding:2px 4px !important;
  font-size:13px !important;
  font-weight:600;
  text-align:center;
}


/* Strip outer card for adeq — adeqBox IS the container */
.roleCard-adeq{
  border:none !important;
  background:transparent !important;
  box-shadow:none !important;
  padding:0 !important;
  overflow:visible !important;
}
.roleCard-adeq h2.blockHdr{
  background:transparent !important;
  border:none !important;
  padding:0 !important;
  height:0 !important;
  overflow:hidden !important;
  margin:0 !important;
}
.roleCard-adeq .section{
  border-bottom:none !important;
  padding:0 !important;
}
/* Adequate box — covMini style (single clean container) */
.adeqBox{margin:0;border:1px solid var(--border);border-radius:12px;overflow:hidden;background:#0c1320;}
.adeqBoxHead{padding:7px 8px;background:rgba(255,255,255,0.03);border-bottom:1px solid var(--border);
  font-size:12px;font-weight:900;color:#cfe3ff;text-align:center;letter-spacing:.06em;text-transform:uppercase;}
.adeqBoxSub{padding:5px 8px;border-bottom:1px solid var(--border);
  font-size:10px;font-weight:700;color:rgba(255,255,255,.45);text-align:center;letter-spacing:.08em;text-transform:uppercase;}
.adeqTbl{width:100%;border-collapse:collapse;border:none;border-radius:0;font-size:12px}
.adeqTbl th,.adeqTbl td{padding:7px 8px;border-bottom:1px solid var(--border);font-size:12px;text-align:center}
.adeqTbl th{color:#cfe3ff;background:rgba(255,255,255,0.03);position:static;font-weight:600;text-align:center}
.adeqTbl td{color:var(--text);text-align:center}
.adeqTbl tr:last-child td{border-bottom:none}
.adeqHour{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
.adeqSectionRow td{padding:8px 8px 4px 8px;border-bottom:none}
.adeqSectionRow td{text-align:left !important}
.adeqSectionLabel{font-weight:800;letter-spacing:.3px;font-size:12px;color:#cfe3ff}
.adeqDivider{height:1px;background:linear-gradient(to right, transparent, rgba(255,255,255,.14), transparent);margin-top:4px}
.statusPill{font-weight:900}
.statusShort{color:#ff4d4d;font-weight:900}
.statusStaffed{color:#fde047;font-weight:900}
.statusOver{color:#86efac;font-weight:900}


/* v108: stacked rows across blocks */
#blocks{display:flex;flex-direction:column;gap:10px;}
#blocks .row3{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px;}


/* v111: link each block column so top/bottom align */
#blocks{display:grid !important; grid-template-columns:repeat(3,minmax(0,1fr)) !important; gap:10px !important;}
.blockCol{display:flex; flex-direction:column; gap:10px;}


/* Status = bold colored text only (no pill) */
.statusPill{background:transparent !important;padding:0 !important;border-radius:0 !important;box-shadow:none !important;}
.statusOver{color:#86efac !important;font-weight:900 !important;}
.statusStaffed{color:#fde047 !important;font-weight:900 !important;}
.statusShort{color:#ff4d4d !important;font-weight:900 !important;}

/* Block layout */
.blocksWrap{ align-items:start !important; }
.blockColumn{ display:flex !important; flex-direction:column !important; gap:10px !important; }
.blockColumn .adeqBox{ margin-bottom:0 !important; }

/* Additional BreakOps-inherited components */
.header{display:flex;align-items:center;gap:14px;margin-bottom:14px}
.sub{color:var(--muted);margin-top:2px}

@media (max-width:1100px){.controls{grid-template-columns:1fr 1fr;}}
#workDateDisplay{ font-size:12px;font-weight:800;color:var(--accent);white-space:nowrap; }

.btn{background:transparent;border:1px solid var(--border);color:var(--text);padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:800}
.btn:hover{border-color:rgba(255,255,255,.25)}
button.secondary{background:#0c1320}
.row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}

@media (max-width:1100px){.grid3{grid-template-columns:1fr}}
.sectionTitle{display:flex;align-items:baseline;justify-content:space-between;gap:12px;margin:18px 0 10px}
.sectionTitle h2{margin:0;font-size:16px;letter-spacing:.3px}
thead th{
  text-align:left;font-size:12px;color:var(--muted);
  background:#0c1320;
  padding:8px 10px;border-bottom:1px solid var(--border)
}
tbody td{padding:8px 10px;border-bottom:1px solid rgba(255,255,255,.06)}
tbody tr:last-child td{border-bottom:none}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
.statusOk{color:var(--ok);font-weight:800}
.otRow{background:rgba(255,214,0,.08)}
.otBadge{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,214,0,.35);color:#ffeaa6;font-size:12px;margin-left:6px}
.cmt-inner{display:flex;gap:8px;align-items:center}
.cmt-inner textarea{flex:1}
.otRemoveBtn{background:rgba(255,77,77,.12);border:1px solid rgba(255,77,77,.3);color:#ff4d4d;font-size:11px;font-weight:800;cursor:pointer;padding:5px 10px;border-radius:8px;white-space:nowrap}
.otRemoveBtn:hover{background:rgba(255,77,77,.25)}

.statusBad{color:var(--bad);font-weight:800}
.pulsing{outline:3px solid rgba(255,214,0,.85); box-shadow:0 0 0 6px rgba(255,214,0,.15)}
.err{display:none;margin-top:10px;border:1px solid rgba(255,95,95,.45);background:rgba(255,95,95,.10);padding:10px 12px;border-radius:14px;color:#ffd0d0}
.note{display:none;margin-top:10px;border:1px solid rgba(255,214,0,.35);background:rgba(255,214,0,.08);padding:10px 12px;border-radius:14px;color:#ffeaa6}
a.help{color:var(--accent);text-decoration:none}

@media (max-width:1000px){.grid2{grid-template-columns:1fr}}

/* Worked time compact display */
.workedPill{
  display:inline-block;
  font-size:12px;
  line-height:1;
  padding:6px 10px;
  border:1px solid var(--border);
  border-radius:999px;
  background:rgba(255,255,255,.04);
  color:var(--text);
  cursor:default;
  user-select:none;
  min-width:64px;
  text-align:center;
}
.workedPill:hover{ background:rgba(255,255,255,.08); }
.workedEdit{
  display:none;
  align-items:center;
  gap:6px;
}
.workedEdit input[type="time"]{
  width:88px;
  padding:6px 8px;
  border-radius:10px;
  border:1px solid var(--border);
  background:#0c1320;
  color:var(--text);
}
.workedDash{opacity:.7}

/* Compact Role + Assignment pills (double-click to edit) */
.rolePill,.assignPill{
  display:inline-block;
  font-size:12px;
  line-height:1;
  padding:6px 10px;
  border:1px solid var(--border);
  border-radius:999px;
  background:rgba(255,255,255,.04);
  color:var(--text);
  user-select:none;
  min-width:52px;
  text-align:center;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  max-width:140px;
}
.assignPill{ min-width:80px; max-width:180px; text-align:left; }
.rolePill:hover,.assignPill:hover{ background:rgba(255,255,255,.10); }
.roleEdit,.assignEdit{ display:none; }
.roleEdit select,.assignEdit select{ width:100%; min-width:120px; }

/* BreakOps unified card/panel styling */
.blockCard,.panel,.cardLike,.listCard,.block,.sectionCard{
  background:var(--card) !important;
  border:1px solid var(--border) !important;
  border-radius:14px !important;
  padding:16px !important;
}
/* Controls global override */
input,select,button,textarea{
  background:#0c1320 !important;
  color:var(--text) !important;
  border:1px solid var(--border) !important;
  border-radius:12px !important;
  padding:10px 12px !important;
}
body.light input, body.light select, body.light textarea{
  background:var(--card) !important;
  color:#000 !important;
  border-color:var(--border) !important;
  -webkit-text-fill-color:#000 !important;
}
body.light input[type="time"]{
  background:var(--card) !important;
  color:#000 !important;
  -webkit-text-fill-color:#000 !important;
}
body.light select option{
  background:var(--card) !important;
  color:#000 !important;
}
body.light button{
  background:rgba(0,0,0,.06) !important;
  color:#000 !important;
  border-color:var(--border) !important;
}
body.light button.primary, body.light .primary, body.light .btnPrimary{
  background:rgba(3,105,161,.12) !important;
  border-color:rgba(3,105,161,.35) !important;
  color:#000 !important;
}
body.light .customSelBtn{
  background:var(--card) !important;
  color:#000 !important;
  border-color:var(--border) !important;
}
body.light .customSelDrop, body.light .customSelMenu{
  background:var(--bg) !important;
  border-color:var(--border) !important;
  box-shadow:0 8px 24px rgba(0,0,0,.10) !important;
}
body.light .customSelOpt{ color:#000 !important; }
body.light .customSelOpt:hover{ background:rgba(0,0,0,.08) !important; }
body.light .timeEdit{
  background:var(--card) !important;
  border-color:var(--border) !important;
  box-shadow:0 8px 20px rgba(0,0,0,.08) !important;
}
body.light .timeEdit input[type="time"]{
  background:var(--bg) !important;
  color:#000 !important;
  border-color:var(--border) !important;
  -webkit-text-fill-color:#000 !important;
}
body.light button.secondary{
  background:var(--card) !important;
  color:#000 !important;
}
button.primary,.primary,.btnPrimary{
  background:var(--accent) !important;
  border-color:rgba(74,163,255,.5) !important;
  color:#fff !important;
}
/* Pills and meta chips */
.pill,.chip,.badge{
  border:1px solid var(--border) !important;
  border-radius:999px !important;
  padding:7px 10px !important;
  color:var(--muted) !important;
  background:rgba(255,255,255,.02) !important;
}
/* Tables */
table{border:none !important;border-radius:0 !important;}
thead th{
  color:var(--muted) !important;
  background:#0c1320 !important;
  border-bottom:1px solid var(--border) !important;
}
tbody td{border-bottom:1px solid rgba(255,255,255,.06) !important;}



/* v117: Uniform board layout (rows aligned across all 3 blocks) */
#blocks.boardGrid{
  display:grid !important;
  grid-template-columns:repeat(3, minmax(520px, 1fr)) !important;
  gap:10px !important;
  align-items:start !important;
}
.boardCard{height:100%;}

/* Row comments */
.cmt-btn{
  background:none;border:none;padding:0;margin:0;cursor:pointer;
  font-size:10px;opacity:.35;transition:opacity .15s;line-height:1;
  color:var(--muted);vertical-align:middle;
  width:14px;height:14px;display:inline-flex;align-items:center;justify-content:center;
}
.cmt-btn:hover{opacity:.7}
.cmt-btn.has-cmt{opacity:1;color:#fbbf24;text-shadow:0 0 6px rgba(251,191,36,.5)}
.cmt-row{display:none}
.cmt-row.open{display:table-row}
.cmt-row td{
  padding:2px 6px 6px !important;border:none !important;
  position:relative;
}
.cmt-row textarea{
  width:100%;min-height:28px;max-height:80px;
  padding:4px 8px;border-radius:8px;
  border:1px solid var(--border);
  background:#0c1320;
  color:var(--text);font:11px/1.4 inherit;
  resize:none;outline:none;
  display:block;
}
.cmt-row textarea:focus{
  border-color:var(--accent);
  box-shadow:0 0 0 3px rgba(74,163,255,.12);
}


/* v118: Single panel (one 4-hr block) view */
.singlePanel .boardGrid{
  grid-template-columns: 1fr !important;
}
.singlePanel .boardCard{
  max-width:none !important;
}




/* v120: Single panel truly fills the page (no max-width cap) */
.singlePanelMode{
  padding:24px !important;
}
.singlePanelMode .blocksWrap{
  display:flex !important;
  justify-content:center !important;
  width:100% !important;
  max-width:none !important;
}
.singlePanelMode .blockColumn{
  flex:1 1 auto !important;
  width:100% !important;
  max-width:none !important;
  margin:0 !important;
}
.singlePanelMode .blockCard,
.singlePanelMode .panel,
.singlePanelMode .sectionCard{
  width:100% !important;
}
/* Make cards breathe larger in single mode */
.singlePanelMode .blockCard{
  padding:22px !important;
  border-radius:22px !important;
}
/* Slightly increase typography in single mode */
.singlePanelMode h1{font-size:42px !important;}
.singlePanelMode .sub, .singlePanelMode .muted, .singlePanelMode label{font-size:14px !important;}
.singlePanelMode table{font-size:14px !important;}
.singlePanelMode th{font-size:13px !important;}
/* Enlarge interactive controls a bit */
.singlePanelMode select,
.singlePanelMode input,
.singlePanelMode button{
  font-size:14px !important;
  padding:12px 14px !important;
}


/* v121: Adequate staffing — clean compact (admin-style) */
.adeqBox,
.adeqBox *{
  text-transform: uppercase !important;
}
.adeqTbl{
  font-size:12px !important;
  border-spacing:0 !important;
}
.adeqHour{
  font-variant-numeric:tabular-nums !important;
}


/* v122: Role smaller, Seat bigger/selectable */

/* Role selector (CT/DP/PIC/SUP) */
select.roleSelect,
select.role,
.roleSelect,
.role-select{
  font-size:11px !important;
  padding:4px 6px !important;
  min-width:54px !important;
  height:26px !important;
  text-align:center !important;
  font-weight:700 !important;
}

/* Seat selector (make larger & readable when closed) */
select.seatSelect,
select.seat,
.seatSelect,
.seat-select{
  font-size:14px !important;
  padding:6px 10px !important;
  min-width:90px !important;
  height:34px !important;
  font-weight:800 !important;
  letter-spacing:.03em !important;
}


/* v124: Seat visible without click + compact Present + ALL CAPS tables + Adequate no ellipsis */

/* ALL TABLE TEXT CAPS */
table, thead th, tbody td { text-transform: uppercase !important; }

/* Seat selector: show value clearly when NOT clicked */
.seatSel{
  width:140px !important;
  min-width:140px !important;
  max-width:140px !important;
  padding:6px 10px !important;
  font-size:14px !important;
  font-weight:800 !important;
  text-align:left !important;
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
}

/* Present selector: smaller but readable (Y/N) */
.presentSel{
  width:120px !important;
  min-width:120px !important;
  max-width:120px !important;
  padding:4px 8px !important;
  font-size:13px !important;
  font-weight:800 !important;
  text-align:center !important;
}
.presentSel.partial-ring{
  box-shadow:0 0 0 3px #f59e0b, 0 0 8px rgba(245,158,11,0.5);
  border-radius:4px;
  background:#3d2e00 !important;
  color:#fbbf24 !important;
  border-color:#f59e0b !important;
}

/* Adequate box: clean word handling */
.adeqTbl{
  table-layout:auto !important;
}
.adeqTbl th,.adeqTbl td{
  white-space:nowrap !important;
  overflow:visible !important;
  text-overflow:clip !important;
}


/* v125: Seat size by role */

/* Default (CT) = compact */
.seatSel{
  width:100px !important;
  min-width:100px !important;
  max-width:100px !important;
  font-size:13px !important;
}

/* Non-CT (DP/PIC/SUP) = wider */
tr:has(.roleSelect[value]:not([value="CT"])) .seatSel,
tr:has(select[value]:not([value="CT"])) .seatSel{
  width:140px !important;
  min-width:140px !important;
  max-width:140px !important;
  font-size:14px !important;
  font-weight:800 !important;
}


/* v126: Prevent seat text cutoff for DP/PIC/SUP + make Role as small as possible */

/* Role selector tighter */
.roleSelect, select.roleSelect, .role, select.role{
  width:48px !important;
  min-width:48px !important;
  max-width:48px !important;
  padding:3px 6px !important;
  font-size:12px !important;
}

/* Seat selector default (CT) stays compact */
.seatSel{
  text-overflow:ellipsis !important;
}

/* Seat selector for DP/PIC/SUP: wide + no ellipsis */
.seatSelWide{
  width:180px !important;
  min-width:180px !important;
  max-width:180px !important;
  font-size:14px !important;
  font-weight:800 !important;
  white-space:nowrap !important;
  overflow:visible !important;
  text-overflow:clip !important;
}

/* Apply wide seat for Dispatcher/PIC/SUP tables (by table header label) */
.sectionTitle:has(+ table) { } /* noop */

/* Heuristic: make seat wide inside DISPATCHER/PIC/SUP sections */
.sectionCard[data-role="DISPATCHER"] .seatSel,
.sectionCard[data-role="PIC"] .seatSel,
.sectionCard[data-role="SUP"] .seatSel,
.blockCard[data-role="DISPATCHER"] .seatSel,
.blockCard[data-role="PIC"] .seatSel,
.blockCard[data-role="SUP"] .seatSel{
  width:180px !important;
  min-width:180px !important;
  max-width:180px !important;
  font-size:14px !important;
  font-weight:800 !important;
  white-space:nowrap !important;
  overflow:visible !important;
  text-overflow:clip !important;
}

/* Fallback: any seat select in rows where Role != CT */
tr:has(select option:checked:not([value="CT"])) .seatSel{
  width:180px !important;
  min-width:180px !important;
  max-width:180px !important;
  font-size:14px !important;
  font-weight:800 !important;
  text-overflow:clip !important;
}


/* v127: Seat bubble shows up to ~6 letters + prevent table from pushing off right */

/* Ensure everything sizes inside the card */
*, *::before, *::after { box-sizing: border-box; }
.sectionCard, .blockCard, .panel, .card, .listCard { max-width: 100% !important; overflow-x: hidden !important; }
table { width: 100% !important; max-width: 100% !important; }

/* Keep table cells from forcing horizontal overflow */
th, td {
  max-width: 1px; /* enables ellipsis in fixed-ish tables */
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Role: as small as possible */
.roleSelect, select.roleSelect, .role, select.role{
  width:44px !important;
  min-width:44px !important;
  max-width:44px !important;
  padding:3px 6px !important;
  font-size:12px !important;
}

/* Seat: sized to fit ~6 characters visibly (assuming you shortened values in DB) */
.seatSel, select.seatSel, .seatSelect, select.seatSelect, .seat, select.seat{
  width:92px !important;
  min-width:92px !important;
  max-width:92px !important;
  padding:5px 8px !important;
  font-size:13px !important;
  font-weight:800 !important;
  text-transform: uppercase !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}

/* Present selector compact */
.presentSel{
  width:120px !important;
  min-width:120px !important;
  max-width:120px !important;
  padding:4px 8px !important;
  font-size:13px !important;
  font-weight:800 !important;
  text-align:center !important;
}

/* In single-panel mode, let the card breathe but still no horizontal overflow */
.singlePanelMode .blockColumn { max-width: 100% !important; }
.singlePanelMode .blocksWrap { max-width: 100% !important; }


/* v128: Make seat selector truly compact (~6 chars wide) */

/* Force seat selector smaller */
.seatSel,
select.seatSel,
.seatSelect,
select.seatSelect,
.seat,
select.seat{
  width:70px !important;
  min-width:70px !important;
  max-width:70px !important;
  padding:4px 6px !important;
  font-size:12px !important;
  font-weight:800 !important;
  line-height:1.1 !important;
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
}

/* Also shrink wrapper cells if any */
td.seatCell,
th.seatCell{
  width:70px !important;
  max-width:70px !important;
}


/* v129: Compact seat + auto-trim display */
select.seatSel,
select.seat,
select.seatSelect{
  width:52px !important;
  min-width:52px !important;
  max-width:52px !important;
  padding:2px 4px !important;
  font-size:11px !important;
  font-weight:700 !important;
  text-align:center !important;
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
}


/* v130: Left-align seat selector text */
select.seatSel,
select.seat,
select.seatSelect{
  text-align: left !important;
  padding-left: 6px !important;
}


/* Absence reason selector (shown only in ABSENT section) */
.absReasonSel, select.absReasonSel{
  width:120px !important;
  min-width:120px !important;
  max-width:120px !important;
  padding:2px 6px !important;
  font-size:11px !important;
  font-weight:800 !important;
  text-transform: uppercase !important;
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
}

/* OTH type selector (SD/TRN/B/ADM) */
.othTypeSel, select.othTypeSel{
  width:70px !important;
  min-width:70px !important;
  max-width:70px !important;
  padding:2px 6px !important;
  font-size:11px !important;
  font-weight:800 !important;
  text-transform: uppercase !important;
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
}

/* FINAL OVERRIDE: Seat selector truly compact */
select.seatSel,
select.seat,
select.seatSelect,
.seatSel,
.seatSelect{
  width:48px !important;
  min-width:48px !important;
  max-width:48px !important;
  padding:2px 4px !important;
  font-size:11px !important;
  font-weight:700 !important;
  text-align:left !important;
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
}


/* ===== Custom Select (dropdown width = options only) ===== */
.customSel{ position:relative; display:inline-block; vertical-align:middle; }
.customSelBtn{
  display:inline-flex; align-items:center; justify-content:space-between; gap:6px;
  background:#0c1320;
  color:var(--text);
  border:1px solid var(--border);
  border-radius:12px;
  padding:4px 6px;
  font-size:12px;
  font-weight:700;
  line-height:1.1;
  cursor:pointer;
  user-select:none;
  width:auto;
}
.customSel--role .customSelBtn{min-width:44px;}
.customSel--seat .customSelBtn{min-width:52px; max-width:60px;}
.customSel--present .customSelBtn{min-width:90px; max-width:120px;}
.customSel--absreason .customSelBtn{min-width:90px;}

.customSelBtn .lbl{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.customSelBtn .car{ opacity:.75; font-size:11px; }
.customSelMenu{
  position:absolute;
  top:calc(100% + 6px);
  left:0;
  background:#0c1320;
  border:1px solid var(--border);
  border-radius:12px;
  box-shadow:0 4px 12px rgba(0,0,0,.25);
  padding:6px;
  display:none;
  z-index:9999;
  min-width:160px;
  max-height:260px;
  overflow:auto;
}
/* Role selector: show all options without scrolling */
.customSel--role .customSelMenu{
  max-height:none;
  overflow:visible;
}
.customSelMenu.open{ display:block; }
.customSelOpt.kbHL{
  background:rgba(77,163,255,.25) !important;
  outline:2px solid rgba(77,163,255,.5);
}
body.light .customSelOpt.kbHL{
  background:rgba(30,100,200,.15) !important;
  outline:2px solid rgba(30,100,200,.3);
}
.customSelOpt{
  display:block;
  width:100%;
  text-align:left;
  padding:7px 10px;
  border-radius:10px;
  border:0;
  background:transparent;
  color:var(--text);
  font:inherit;
  cursor:pointer;
  white-space:nowrap;
}
.customSelOpt:hover{ background:rgba(255,255,255,.06); }
.customSelOpt[aria-selected="true"]{ background:rgba(77,163,255,.18); }

/* ===== Fix: controls were unclickable / time end input clipped =====
   The global td/th max-width + overflow rules can clip interactive controls.
   We keep the table from overflowing by using fixed layout + explicit column widths,
   and we allow control cells to overflow visibly.
*/
.rosterTbl{ table-layout:fixed; width:100% !important; }
.rosterTbl th, .rosterTbl td{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:65px !important; }
.rosterTbl th:first-child,
.rosterTbl td:first-child{
  width: 12ch !important;
  max-width: 12ch !important;
  padding-right: 6px !important;
}
.rosterTbl th.nameCol, .rosterTbl td.nameCol{ width:40%; }
.rosterTbl th.roleCol, .rosterTbl td.roleCol{ width:78px; }
.rosterTbl th.seatCol, .rosterTbl td.seatCol{ width:78px; }
.rosterTbl th.workedCol, .rosterTbl td.workedCol{ width:180px; }
.rosterTbl th.hrsCol, .rosterTbl td.hrsCol{ width:70px; }
.rosterTbl th.presCol, .rosterTbl td.presCol{ width:130px !important; min-width:130px !important; }

/* control cells must allow popups/inputs to be visible and clickable */
.rosterTbl td.ctrlCell, .rosterTbl th.ctrlCol{
  overflow:visible !important;
  text-overflow:clip !important;
  max-width:none !important;
}

/* ensure custom select button occupies full cell and receives clicks */
.customSel{ width:100%; }
.customSelBtn{ width:100%; pointer-events:auto; }

/* worked editor should be fully visible */
.timeEdit{ white-space:nowrap; }
.timeEdit input[type="time"]{ width:88px; }



/* ===== v140: Fix roster fit + restore Worked pill styling ===== */

/* Restore Worked pill look (it was getting overridden) */
.rosterTbl .rowPill{
  display:inline-block !important;
  padding:6px 10px !important;
  border:1px solid var(--border) !important;
  border-radius:999px !important;
  background:rgba(255,255,255,.06) !important;
  color:var(--text) !important;
  font-weight:800 !important;
  min-width:74px !important;
  text-align:center !important;
}

/* Roster table column sizing: balanced and readable */
.rosterTbl{ table-layout:fixed !important; width:100% !important; }
.rosterTbl th, .rosterTbl td{ max-width:none !important; }

/* Name: single line with ellipsis */
.rosterTbl th.nameCol, .rosterTbl td.nameCol{
  width:24% !important;
}
.rosterTbl td.nameCol{
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
  line-height:1.15 !important;
}

/* Role/Seat/Worked/Hrs/P: tighter but clickable */
.rosterTbl th.roleCol, .rosterTbl td.roleCol{ width:56px !important; }
.rosterTbl th.seatCol, .rosterTbl td.seatCol{ width:96px !important; }
.rosterTbl th.workedCol, .rosterTbl td.workedCol{ width:132px !important; }
.rosterTbl th.hrsCol, .rosterTbl td.hrsCol{ width:64px !important; }
.rosterTbl th.presCol, .rosterTbl td.presCol{ width:130px !important; min-width:130px !important; }

/* Make custom-select triggers fill their cells cleanly (no weird skinny menus) */
.customSelBtn{
  height:28px !important;
  border-radius:999px !important;
  padding:4px 10px !important;
}
.customSelMenu{
  padding:6px !important;
}
.customSelOpt{
  border-radius:10px !important;
  padding:8px 10px !important;
}

/* Worked editor: always show BOTH inputs when opened */
.rosterTbl .timeEdit{
  gap:6px !important;
}
.rosterTbl .timeEdit input[type="time"]{
  width:84px !important;
}

/* Mobile/narrow screens: keep it readable without squishing names to nothing */
@media (max-width: 720px){
  .rosterTbl th.nameCol, .rosterTbl td.nameCol{ width:36% !important; }
  .rosterTbl th.seatCol, .rosterTbl td.seatCol{ width:88px !important; }
  .rosterTbl th.workedCol, .rosterTbl td.workedCol{ width:120px !important; }
}


/* v142: Worked editor pops below (not to the right) */
.rosterTbl { overflow: visible !important; }
.ctrlCell.workedCol { position: relative !important; overflow: visible !important; }
.timeEdit{
  position:absolute !important;
  left:0 !important;
  top:calc(100% + 6px) !important;
  display:none;
  align-items:center;
  gap:6px;
  padding:8px 10px;
  border-radius:12px;
  border:1px solid var(--border);
  background:#0c1320;
  box-shadow:0 8px 24px rgba(0,0,0,.35);
  z-index:80;
}
.timeEdit input[type="time"]{ width:92px !important; }


/* v143: Column sizing so ROLE + SEAT show fully, and WORKED never overlaps HRS */
table.rosterTbl{
  table-layout:auto !important; /* allow columns to hug content */
  width:100% !important;
}

/* Let Name shrink to content so ROLE starts right after the name */
.rosterTbl th.nameCol, .rosterTbl td.nameCol{
  width:auto !important;
  min-width:160px !important;
}
.rosterTbl td.nameCol{
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
  line-height:1.3 !important;
}

/* Fixed widths so selections show fully when NOT engaged */
.rosterTbl th.roleCol, .rosterTbl td.roleCol{
  width:92px !important;
  min-width:92px !important;
  padding-right:16px !important; /* space between ROLE and SEAT */
}
.rosterTbl th.seatCol, .rosterTbl td.seatCol{
  width:170px !important;
  min-width:170px !important;
  padding-left:0 !important;
}

.rosterTbl th.workedCol, .rosterTbl td.workedCol{
  width:150px !important;
  min-width:150px !important;
}
.rosterTbl th.hrsCol, .rosterTbl td.hrsCol{
  width:76px !important;
  min-width:76px !important;
}
.rosterTbl th.presCol, .rosterTbl td.presCol{
  width:100px !important;
  min-width:100px !important;
}

/* Custom dropdown in roster: fill its cell, but show full selected text */
.rosterTbl .ddWrap{display:inline-block !important; width:100% !important;}
.rosterTbl .ddBtn{width:100% !important; justify-content:space-between !important;}
.rosterTbl .ddText{
  max-width:none !important;
  overflow:visible !important;
  text-overflow:clip !important;
  white-space:nowrap !important;
}

/* Worked editor popover: open BELOW worked, centered, never into HRS */
.rosterTbl td.workedCol{position:relative !important; overflow:visible !important;}
.rosterTbl .timeEdit{
  position:absolute !important;
  left:50% !important;
  transform:translateX(-50%) !important;
  top:calc(100% + 6px) !important;
  z-index:999 !important;
  background:#0c1320 !important;
  border:1px solid rgba(255,255,255,.16) !important;
  border-radius:12px !important;
  padding:8px !important;
  box-shadow:0 8px 24px rgba(0,0,0,.35) !important;
  display:none !important;
  gap:8px !important;
}
.rosterTbl .timeEdit input[type="time"]{
  width:92px !important;
  padding:8px 10px !important;
}
.rosterTbl .timeEdit.open{display:flex !important;}




/* ===== v145 FINAL ROSTER LAYOUT OVERRIDES (fix core width/spacing issues) ===== */
/* Core problem was multiple conflicting .rosterTbl width rules + global td clipping.
   These overrides are last, so they win. */

table.rosterTbl{
  table-layout: fixed !important;
  width: 100% !important;
}

.rosterTbl th, .rosterTbl td{
  max-width: none !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
}

/* Name column sizing */
.rosterTbl th.nameCol, .rosterTbl td.nameCol{ width:26% !important; }
.rosterTbl td.nameCol{
  white-space: nowrap !important;   /* single line */
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  line-height: 1.15 !important;
}

/* Put ROLE immediately after NAME, and let selections show in closed state */
/* Use percentages so NAME never collapses to 0px on narrower cards */
.rosterTbl th.nameCol, .rosterTbl td.nameCol{ width: 24% !important; }
.rosterTbl th.roleCol, .rosterTbl td.roleCol{ width: 13% !important; }
.rosterTbl th.seatCol, .rosterTbl td.seatCol{ width: 18% !important; }
.rosterTbl th.workedCol, .rosterTbl td.workedCol{ width: 15% !important; }
.rosterTbl th.hrsCol, .rosterTbl td.hrsCol{ width: 7% !important; }
.rosterTbl th.presCol, .rosterTbl td.presCol{ width:130px !important; min-width:130px !important; }

/* Ensure controls don't get squished / keep readable */
.rosterTbl td.ctrlCell, .rosterTbl th.ctrlCol{
  padding-left: 10px !important;
  padding-right: 10px !important;
}

/* Custom dropdown closed text: show full value (no C...) inside allowed width */
.rosterTbl .ddBtn{
  width: 100% !important;
}
.rosterTbl .ddText{
  overflow: hidden !important;
  text-overflow: clip !important;   /* prefer showing full within the column */
  white-space: nowrap !important;
}

/* Worked popover: open BELOW worked pill, not sideways */
.rosterTbl td.workedCol{
  position: relative !important;
  overflow: visible !important;
}
.rosterTbl .timeEdit{
  position: absolute !important;
  left: 50% !important;
  top: calc(100% + 8px) !important;
  transform: translateX(-50%) !important;
  z-index: 9999 !important;
  display: none !important;
  gap: 8px !important;
  padding: 10px 10px !important;
  border-radius: 14px !important;
  border: 1px solid var(--border) !important;
  background: #0c1320 !important;
  box-shadow: 0 8px 24px rgba(0,0,0,.35) !important;
}
.rosterTbl .timeEdit.open{
  display: flex !important;
}
.rosterTbl .timeEdit input[type="time"]{
  width: 92px !important;
}

/* Keep dropdown menus sized to content but never clipped by table/card */
.ddMenu{
  max-width: none !important;
}


/* v148: Tight NAME so ROLE sits close (no huge blank runway) */
.rosterTable { table-layout: auto !important; width:100% !important; }
.rosterTable th.nameCol,
.rosterTable td.nameCol{
  width:1% !important;            /* shrink-to-fit */
  white-space:nowrap !important;  /* keep name compact */
  padding-right:8px !important;   /* about ~4 letters space */
}
.rosterTable th.nameCol{padding-left:12px !important;}
/* If a name is long, allow wrap only in the NAME cell by adding title tooltip via existing text (optional) */
/* Keep other cells from stretching */
.rosterTable th, .rosterTable td{ vertical-align:middle; }



/* v149: Show full selected values (no ellipsis) without needing to click */
.rosterTbl th,
.rosterTbl td{
  /* keep layout stable */
  white-space: nowrap !important;
}

/* Do NOT show "..." for selected values; clip instead */
.rosterTbl .customSelBtn .lbl,
.rosterTbl .ddText,
.rosterTbl select{
  overflow: hidden !important;
  text-overflow: clip !important;
  white-space: nowrap !important;
}

/* Give the closed dropdown a bit more room so values are readable */
.rosterTbl td.roleCol .customSelBtn,
.rosterTbl td.seatCol .customSelBtn,
.rosterTbl td.presCol .customSelBtn{
  padding-left: 10px !important;
  padding-right: 10px !important;
}

/* If any older rules force ellipsis on the buttons, override them */
.customSelBtn .lbl{ text-overflow: clip !important; }


/* ===== v150: Clickable dropdowns + show selected text (no ellipsis) ===== */
.rosterTbl td, .rosterTbl th{ position:relative; }

/* Keep cells from swallowing clicks */
.rosterTbl td{ pointer-events:auto; }

/* Ensure custom dropdown trigger is always on top and clickable */
.customSel{ position:relative; z-index:20; width:100%; }
.customSelBtn{
  position:relative;
  z-index:21;
  pointer-events:auto;
}

/* Show selected value without "C..." while keeping the row compact */
.customSelBtn .lbl{
  overflow:hidden !important;
  text-overflow:clip !important;   /* removes the "..." */
  white-space:nowrap !important;
}

/* If any global rules set pointer-events oddly, force menu + options clickable */
.customSelMenu, .customSelOpt{ pointer-events:auto; }

/* Native selects (if any remain) should also show value without ellipsis */
.rosterTbl select{
  text-overflow:clip !important;
}

/* Prevent hidden Worked editor overlay from blocking clicks */
.timeEdit{ pointer-events:none; }
.timeEdit.open{ pointer-events:auto; }



/* v152: Scoot columns slightly left (tighter NAME) */

/* === FIX: Seat dropdown always on top === */

/* Allow table + rows to show popups */
.rosterTbl,
.rosterTbl tbody,
.rosterTbl tr,
.rosterTbl td {
  overflow: visible !important;
}

/* Make seat dropdown stack above other rows */
.customSel--seat {
  position: relative !important;
  z-index: 2000 !important;
}

/* Force dropdown menu highest layer */
.customSel--seat .customSelMenu {
  position: absolute !important;
  z-index: 99999 !important;
  min-width:220px;
  white-space:nowrap;
  overflow-x:hidden;
}

/* Prevent other controls from covering it */
.customSel,
.customSelBtn {
  position: relative !important;
  z-index: 1000 !important;
}


/* === v154 FIX: Ensure dropdown menu overlays rows below (table stacking) === */
/* Give each row a stacking context so z-index can work */
.rosterTbl tbody tr{ position:relative; z-index:0; }
/* When any custom select menu is open in a row, lift that whole row above others */
.rosterTbl tbody tr:has(.customSelMenu.open){ z-index: 99998 !important; }
/* Keep the open menu above everything */
.customSelMenu.open{ z-index: 99999 !important; }
/* Safety: don't let other buttons sit above the menu */
.customSelBtn{ z-index: 1; }



/* === v155 FIX: Seat shows full number (CT31) + prevent ROLE/SEAT/HRS/PRESENT stacking === */

/* Give the roster table a little more breathing room for control columns */
table.rosterTbl{
  table-layout: fixed !important;
  width: 100% !important;
}

/* Rebalance column widths so controls don't get forced into tiny wrap/stack */
.rosterTbl th.nameCol,  .rosterTbl td.nameCol  { width: 32% !important; }
.rosterTbl th.roleCol,  .rosterTbl td.roleCol  { width: 10% !important; }
.rosterTbl th.seatCol,  .rosterTbl td.seatCol  { width: 14% !important; }
.rosterTbl th.workedCol,.rosterTbl td.workedCol{ width: 18% !important; }
.rosterTbl th.hrsCol,   .rosterTbl td.hrsCol   { width: 8%  !important; }
.rosterTbl th.presCol,  .rosterTbl td.presCol  { width: 130px !important; min-width:130px !important; }

/* Keep each control on ONE line and aligned (no vertical stacking) */
.rosterTbl td.ctrlCell{
  white-space: nowrap !important;
}
.customSelBtn{
  display:flex !important;
  flex-wrap: nowrap !important;
  align-items:center !important;
  justify-content:space-between !important;
  white-space: nowrap !important;
}

/* Seat label: show the full seat (e.g., CT31) in the closed button */
.customSel--seat .customSelBtn{ min-width: 72px !important; }
.customSel--seat .customSelBtn .lbl{
  overflow: hidden !important;
  text-overflow: clip !important;
  white-space: nowrap !important;
}

/* Make ROLE slightly tighter so it sits closer to NAME */
.customSel--role .customSelBtn{ min-width: 56px !important; }

/* If any legacy rule forces ellipsis/clip too aggressively, override for seat only */
.customSel--seat .customSelBtn .lbl{ max-width: none !important; }


/* === v156: Tight NAME so other columns shift left === */

/* Let NAME shrink instead of reserving big space */
.rosterTbl th.nameCol,
.rosterTbl td.nameCol{
  width: 1% !important;          /* shrink-to-fit */
  min-width: 120px !important;  /* still readable */
  max-width: 180px !important;
  white-space: nowrap !important;
  padding-right: 6px !important;
}

/* Remove extra padding between NAME and ROLE */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-left: 2px !important;
}

/* Pull all control columns slightly left */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol,
.rosterTbl th.seatCol,
.rosterTbl td.seatCol,
.rosterTbl th.workedCol,
.rosterTbl td.workedCol,
.rosterTbl th.hrsCol,
.rosterTbl td.hrsCol,
.rosterTbl th.presCol,
.rosterTbl td.presCol{
  padding-left: 4px !important;
  padding-right: 4px !important;
}


/* === v157: Keep NAME readable while still shifting columns left === */
.rosterTbl th.nameCol,
.rosterTbl td.nameCol{
  width: 18% !important;         /* give NAME a bit more room */
  min-width: 150px !important;
  max-width: 260px !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  padding-right: 10px !important;
}
.rosterTbl th.nameCol{ padding-left: 12px !important; }

/* Keep the columns pulled left, but not squished */
.rosterTbl th.roleCol, .rosterTbl td.roleCol{ padding-left: 6px !important; }
.rosterTbl th.seatCol, .rosterTbl td.seatCol,
.rosterTbl th.workedCol, .rosterTbl td.workedCol,
.rosterTbl th.hrsCol, .rosterTbl td.hrsCol,
.rosterTbl th.presCol, .rosterTbl td.presCol{
  padding-left: 6px !important;
  padding-right: 6px !important;
}


/* ===== v158: Worked editor pops UP and is NOT transparent ===== */
.rosterTbl td.workedCol{ position: relative !important; overflow: visible !important; }

/* Popover: open ABOVE the worked pill */
.rosterTbl .timeEdit{
  position: absolute !important;
  left: 50% !important;
  bottom: calc(100% + 8px) !important;  /* pop UP */
  top: auto !important;
  transform: translateX(-50%) !important;

  z-index: 99999 !important;

  /* solid background (not see-through) */
  background: #0c1320 !important;
  opacity: 1 !important;

  border: 1px solid rgba(255,255,255,.22) !important;
  border-radius: 14px !important;
  padding: 10px 12px !important;
  box-shadow: 0 8px 24px rgba(0,0,0,.35) !important;

  display: none !important;
  gap: 8px !important;
  white-space: nowrap !important;
}

/* When opened, show it */
.rosterTbl .timeEdit.open{ display: flex !important; }

/* Make sure the inputs are readable */
.rosterTbl .timeEdit input[type="time"]{
  background: #0c1320 !important;
  color: var(--text) !important;
  border: 1px solid var(--border) !important;
  opacity: 1 !important;
}


/* === v159: Dropdown menus always visible (flip up if near bottom) === */
.customSelMenu{ z-index: 99999 !important; }
.customSelMenu.flipUp{
  top: auto !important;
  bottom: calc(100% + 6px) !important;
}
/* Raise the row/card when any custom menu is open (helps table stacking contexts) */
tr:has(.customSelMenu.open){
  position: relative !important;
  z-index: 5000 !important;
}


/* ===== v160: Wider SEAT display for DISPATCHER / PIC / SUP so selected value is readable ===== */

/* Keep CALL TAKER seat compact by default */
.rosterTbl td.seatCol .customSel--seat .customSelBtn{
  min-width: 50px !important;
  max-width: 100% !important;
  width: auto !important;
}

/* Make SEAT wider in Dispatcher/PIC/SUP sections */
.sectionCard[data-role="DISPATCHER"] td.seatCol .customSel--seat .customSelBtn,
.sectionCard[data-role="PIC"] td.seatCol .customSel--seat .customSelBtn,
.sectionCard[data-role="SUP"] td.seatCol .customSel--seat .customSelBtn,
.sectionCard[data-role="SUPERVISOR"] td.seatCol .customSel--seat .customSelBtn{
  min-width: 60px !important;
  max-width: 100% !important;
  width: auto !important;
  padding-left: 8px !important;
  padding-right: 8px !important;
}

/* Give the SEAT column itself a bit more room in those sections */
.sectionCard[data-role="DISPATCHER"] table.rosterTbl th.seatCol,
.sectionCard[data-role="DISPATCHER"] table.rosterTbl td.seatCol,
.sectionCard[data-role="PIC"] table.rosterTbl th.seatCol,
.sectionCard[data-role="PIC"] table.rosterTbl td.seatCol,
.sectionCard[data-role="SUP"] table.rosterTbl th.seatCol,
.sectionCard[data-role="SUP"] table.rosterTbl td.seatCol,
.sectionCard[data-role="SUPERVISOR"] table.rosterTbl th.seatCol,
.sectionCard[data-role="SUPERVISOR"] table.rosterTbl td.seatCol{
  width: 22% !important;
}

/* Show selected text with ellipsis if needed */
.customSel--seat .customSelBtn .lbl{
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
  max-width: 70px !important;
}


/* === v162: ABSENT REASON dropdown: no internal scroll + always on top === */

/* Let popups escape the cards too */
.card, .panel, .blockCard, .sectionCard, .listCard{
  overflow: visible !important;
}

/* Absent reason menu: show all options (no scroll), solid background */
.customSel--absreason{ position:relative !important; z-index: 9000 !important; }
.customSel--absreason .customSelMenu{
  max-height: none !important;
  overflow: visible !important;
  background: #0c1320 !important;
  border: 1px solid var(--border) !important;
  z-index: 99999 !important;
  box-shadow: 0 8px 24px rgba(0,0,0,.40) !important;
}

/* If flipped up, keep it above */
.customSel--absreason .customSelMenu.flipUp{
  top: auto !important;
  bottom: calc(100% + 8px) !important;
}

/* When an absent menu is open, lift the row extra high */
.rosterTbl tbody tr:has(.customSel--absreason .customSelMenu.open){
  position: relative !important;
  z-index: 99998 !important;
}


/* v163: Remove aggressive cut-off for SUP role selector */
.sectionCard[data-role="SUP"] table.rosterTbl th.roleCol,
.sectionCard[data-role="SUP"] table.rosterTbl td.roleCol,
.sectionCard[data-role="SUPERVISOR"] table.rosterTbl th.roleCol,
.sectionCard[data-role="SUPERVISOR"] table.rosterTbl td.roleCol{
  width: 72px !important;
  min-width: 72px !important;
}

.sectionCard[data-role="SUP"] .customSel--role .customSelBtn,
.sectionCard[data-role="SUPERVISOR"] .customSel--role .customSelBtn{
  min-width: 64px !important;
  padding-left: 10px !important;
  padding-right: 10px !important;
}

.sectionCard[data-role="SUP"] .customSel--role .customSelBtn .lbl,
.sectionCard[data-role="SUPERVISOR"] .customSel--role .customSelBtn .lbl{
  text-overflow: clip !important;
}



/* v164: STAFFING NUMBERS header — clean compact */
.adeqBoxHead{
  text-align:center !important;
  letter-spacing:.06em !important;
  background: rgba(255,255,255,0.03) !important;
  border-bottom:1px solid var(--border) !important;
  color: #cfe3ff !important;
  text-shadow: none !important;
  font-size:12px !important;
  padding:7px 8px !important;
}

/* === FINAL FIX: SUP role never clips (v168) === */

/* Widen ROLE column in Supervisor section */
.sectionCard[data-role="SUP"] .rosterTbl th.roleCol,
.sectionCard[data-role="SUP"] .rosterTbl td.roleCol,
.sectionCard[data-role="SUPERVISOR"] .rosterTbl th.roleCol,
.sectionCard[data-role="SUPERVISOR"] .rosterTbl td.roleCol{
  width: 72px !important;
  min-width: 72px !important;
}

/* Widen ROLE dropdown button in Supervisor section */
.sectionCard[data-role="SUP"] .customSel--role .customSelBtn,
.sectionCard[data-role="SUPERVISOR"] .customSel--role .customSelBtn{
  min-width: 64px !important;
  width: 64px !important;
  padding-left: 10px !important;
  padding-right: 10px !important;
}

/* Prevent label clipping */
.sectionCard[data-role="SUP"] .customSel--role .lbl,
.sectionCard[data-role="SUPERVISOR"] .customSel--role .lbl{
  overflow: visible !important;
  text-overflow: clip !important;
  white-space: nowrap !important;
}


/* === v169: SUP label fix (caret was stealing space, last letter clipped) === */

/* In Supervisor section, make the ROLE button wide enough for 3 letters + caret */
.sectionCard[data-role="SUP"] .customSel--role .customSelBtn,
.sectionCard[data-role="SUPERVISOR"] .customSel--role .customSelBtn{
  min-width: 78px !important;
  width: 78px !important;
  max-width: 78px !important;
  padding-left: 10px !important;
  padding-right: 14px !important; /* extra space so 'P' never clips */
}

/* Ensure the label can use space and doesn't get ellipsis/clip by global rules */
.sectionCard[data-role="SUP"] .customSel--role .customSelBtn .lbl,
.sectionCard[data-role="SUPERVISOR"] .customSel--role .customSelBtn .lbl{
  flex: 1 1 auto !important;
  min-width: 0 !important;
  overflow: visible !important;
  text-overflow: clip !important;
  white-space: nowrap !important;
  padding-right: 10px !important; /* space before caret */
}

/* Also widen ROLE column a touch so button isn't constrained by cell */
.sectionCard[data-role="SUP"] .rosterTbl th.roleCol,
.sectionCard[data-role="SUP"] .rosterTbl td.roleCol,
.sectionCard[data-role="SUPERVISOR"] .rosterTbl th.roleCol,
.sectionCard[data-role="SUPERVISOR"] .rosterTbl td.roleCol{
  width: 88px !important;
  min-width: 88px !important;
}


/* === v170: ROLE labels (esp SUP) must never clip anywhere === */

/* Table cell clipping rules in older blocks can chop the role button. Undo for role column cells. */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  overflow: visible !important;
  max-width: none !important;
}

/* Give role buttons enough real width for 3 letters + caret, everywhere */
.customSel--role .customSelBtn{
  min-width: 78px !important;
  width: auto !important;
  max-width: none !important;
  padding-right: 14px !important; /* space for caret so last letter doesn't clip */
}

/* Ensure the label text itself is not ellipsed/clipped */
.customSel--role .customSelBtn .lbl{
  overflow: visible !important;
  text-overflow: clip !important;
  white-space: nowrap !important;
  padding-right: 10px !important;
}


/* === v171: Prevent ROLE + SEAT controls from visually merging === */

/* Restore a little breathing room between ROLE and SEAT columns */
.rosterTbl th.roleCol, .rosterTbl td.roleCol{ padding-right: 10px !important; }
.rosterTbl th.seatCol, .rosterTbl td.seatCol{ padding-left: 10px !important; }

/* Add a small gap between adjacent custom selects inside the same row */
.rosterTbl td.roleCol .customSel{ margin-right: 8px !important; }
.rosterTbl td.seatCol .customSel{ margin-left: 0 !important; }

/* Make sure buttons don't spill into neighboring cells */
.rosterTbl td.roleCol .customSelBtn,
.rosterTbl td.seatCol .customSelBtn{
  width: 100% !important;
  max-width: 100% !important;
}

/* Keep the caret inside the button without overlapping edges */
.customSelBtn{
  box-sizing: border-box !important;
}


/* === v172: Scoot ROLE left so it never touches SEAT === */

/* Shift ROLE column slightly left */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-left: 2px !important;
  padding-right: 14px !important; /* bigger gap before SEAT */
}

/* Shift SEAT slightly right */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 14px !important;
}

/* Add visual gap between pills */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 10px !important;
}

/* Prevent buttons from stretching into neighbors */
.rosterTbl td.roleCol .customSelBtn,
.rosterTbl td.seatCol .customSelBtn{
  box-sizing: border-box !important;
  max-width: calc(100% - 6px) !important;
}


/* === v173: Scoot ROLE further left for more separation === */

/* Push ROLE content further left, increase gap to SEAT */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-left: 0px !important;
  padding-right: 20px !important; /* larger gap */
}

/* Push SEAT slightly right */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 18px !important;
}

/* Stronger margin between buttons */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 14px !important;
}


/* === v174: Scoot ROLE even more left (final tuning) === */

/* Maximize gap between ROLE and SEAT */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-left: 0px !important;
  padding-right: 26px !important; /* bigger gap */
}

/* Push SEAT further right */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 22px !important;
}

/* Extra margin between buttons */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 18px !important;
}


/* === v175: Scoot ROLE further left (max separation) === */

/* Increase gap between ROLE and SEAT even more */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-left: 0px !important;
  padding-right: 32px !important; /* max gap */
}

/* Push SEAT further right */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 26px !important;
}

/* Extra margin between buttons */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 22px !important;
}


/* === v176: Scoot ROLE ultra left (maximum safe spacing) === */

/* Push ROLE far left and open big gutter */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-left: 0px !important;
  padding-right: 42px !important; /* ultra gap */
}

/* Push SEAT further right */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 34px !important;
}

/* Strong margin between buttons */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 28px !important;
}


/* === v177: Lock ROLE bubble to 4-letter width (compact, no clipping) === */

/* ROLE column: fixed compact size */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  width: 56px !important;
  min-width: 56px !important;
  max-width: 56px !important;
  padding-right: 18px !important; /* keep gap to SEAT */
}

/* ROLE button: fits up to 4 letters + caret */
.customSel--role .customSelBtn{
  min-width: 44px !important;
  max-width: 44px !important;
  width: 44px !important;

  padding: 3px 6px !important;
  font-size: 12px !important;
  font-weight: 700 !important;
  text-align: center !important;
}

/* ROLE label: never clip */
.customSel--role .customSelBtn .lbl{
  overflow: visible !important;
  text-overflow: clip !important;
  white-space: nowrap !important;
}


/* === v178: Bring SEAT closer to ROLE (balanced spacing) === */

/* Reduce gap after ROLE */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-right: 10px !important; /* was 18px */
}

/* Reduce left padding on SEAT */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 8px !important; /* was much larger */
}

/* Reduce extra margin between buttons */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 6px !important;
}


/* === v179: Bring SEAT even closer to ROLE (fine tune) === */

/* Further reduce gap after ROLE */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-right: 6px !important; /* tighter */
}

/* Further reduce left padding on SEAT */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 4px !important; /* tighter */
}

/* Reduce margin between buttons more */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 3px !important;
}


/* === v180: Bring SEAT MUCH closer to ROLE (aggressive tighten) === */

/* Almost remove gap after ROLE */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-right: 2px !important;
}

/* Minimal left padding on SEAT */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 2px !important;
}

/* Nearly remove margin between buttons */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 1px !important;
}


/* === v181: ROLE → SEAT ultra-close (4x tighter) === */

/* Remove almost all gap after ROLE */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-right: 0px !important;
}

/* Remove left padding on SEAT */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 0px !important;
}

/* Eliminate margin between buttons */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 0px !important;
}

/* Slight negative nudge to pull SEAT left (safe) */
.rosterTbl td.seatCol .customSel{
  margin-left: -4px !important;
}


/* === v182: ROLE → SEAT shift ~0.5 inch left (strong offset) === */

/* Remove all padding between ROLE and SEAT */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-right: 0px !important;
}

.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 0px !important;
}

/* No margins */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 0px !important;
}

/* Big left shift for SEAT (~48px ≈ half inch on most screens) */
.rosterTbl td.seatCol .customSel,
.rosterTbl td.seatCol .customSelBtn{
  margin-left: -48px !important;
}

/* Ensure no overlap clipping */
.rosterTbl td.seatCol,
.rosterTbl td.roleCol{
  overflow: visible !important;
}


/* === v183: Align SEAT column header with shifted column === */

/* Shift SEAT header left to match cells */
.rosterTbl th.seatCol{
  padding-left: 0px !important;
  margin-left: -48px !important; /* match body shift */
}

/* Keep header visible */
.rosterTbl thead th{
  overflow: visible !important;
}


/* === v184: Keep current layout working (no new UI) ===
   Replace margin-left hacks on SEAT with transform so controls don't collide/merge
   and header stays aligned. */

/* Neutralize previous margin-left shifts (if present) */
.rosterTbl td.seatCol .customSel,
.rosterTbl td.seatCol .customSelBtn{
  margin-left: 0px !important;
}

/* Apply visual shift without breaking table layout */
.rosterTbl td.seatCol .customSel,
.rosterTbl td.seatCol .customSelBtn{
  transform: translateX(-48px) !important;
}

/* Align SEAT header with the same transform */
.rosterTbl th.seatCol{
  margin-left: 0px !important;
  transform: translateX(-48px) !important;
}

/* Ensure header/cells remain clickable/visible */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  overflow: visible !important;
  position: relative !important;
  z-index: 2 !important;
}
.rosterTbl td.roleCol{
  position: relative !important;
  z-index: 3 !important;
}

/* Small safety gap so ROLE and shifted SEAT never visually fuse */
.rosterTbl td.roleCol .customSelBtn{ margin-right: 2px !important; }


/* === v185: Fix chopped header row by removing transforms and using real column sizing === */

/* Undo v184 transform shifts */
.rosterTbl td.seatCol .customSel,
.rosterTbl td.seatCol .customSelBtn,
.rosterTbl th.seatCol{
  transform: none !important;
}

/* Ensure header row stays intact */
.rosterTbl thead th{
  overflow: visible !important;
  text-overflow: clip !important;
  white-space: nowrap !important;
}

/* Use predictable column widths so headers line up clean */
.rosterTbl{
  table-layout: fixed !important;
}

/* NAME gets enough room, but not too much */
.rosterTbl th.nameCol, .rosterTbl td.nameCol{
  width: 140px !important;
  min-width: 140px !important;
  max-width: 140px !important;
}

/* ROLE compact (4 letters) */
.rosterTbl th.roleCol, .rosterTbl td.roleCol{
  width: 64px !important;
  min-width: 64px !important;
  max-width: 64px !important;
  padding-right: 8px !important;
}

/* SEAT reasonably wide and close to ROLE */
.rosterTbl th.seatCol, .rosterTbl td.seatCol{
  width: 92px !important;
  min-width: 92px !important;
  max-width: 92px !important;
  padding-left: 6px !important;
}

/* WORKED / HRS / PRESENT */
.rosterTbl th.workedCol, .rosterTbl td.workedCol{ width: 110px !important; }
.rosterTbl th.hrsCol, .rosterTbl td.hrsCol{ width: 70px !important; }
.rosterTbl th.presCol, .rosterTbl td.presCol{ width: 130px !important; min-width:130px !important; }

/* Keep pills inside their cells */
.rosterTbl td.roleCol .customSelBtn,
.rosterTbl td.seatCol .customSelBtn{
  max-width: 100% !important;
}


/* === v186: Responsive columns so 3 panels fit (no chopped headers) === */

.rosterTbl{ width:100% !important; table-layout:fixed !important; }

/* Let cards shrink */
.blockCard, .sectionCard, .card{ min-width:0 !important; }

/* Responsive column widths */
.rosterTbl th.nameCol,  .rosterTbl td.nameCol  { width: clamp(110px, 22%, 160px) !important; }
.rosterTbl th.roleCol,  .rosterTbl td.roleCol  { width: clamp(52px,  8%,  70px) !important; }
.rosterTbl th.seatCol,  .rosterTbl td.seatCol  { width: clamp(70px, 12%, 110px) !important; }
.rosterTbl th.workedCol,.rosterTbl td.workedCol{ width: clamp(86px, 16%, 130px) !important; }
.rosterTbl th.hrsCol,   .rosterTbl td.hrsCol   { width: clamp(56px,  8%,  80px) !important; }
.rosterTbl th.presCol,  .rosterTbl td.presCol  { width: 130px !important; min-width:130px !important; }

/* Keep headers readable */
.rosterTbl thead th{
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}


/* === v189: Center + widen in single-panel view (CSS-only, safe) === */

body.singlePanel #blocks{
  display: grid !important;
  grid-template-columns: minmax(520px, min(1200px, 96vw)) !important;
  justify-content: center !important;
}

body.singlePanel #blocks .boardCard{
  width: 100% !important;
  max-width: min(1200px, 96vw) !important;
  margin-left: auto !important;
  margin-right: auto !important;
}

/* Highlight ring for unselected dropdowns */
@keyframes pulseRing {
  0%   { box-shadow: 0 0 0 2px rgba(251,113,133,.6); }
  50%  { box-shadow: 0 0 0 5px rgba(251,113,133,.25); }
  100% { box-shadow: 0 0 0 2px rgba(251,113,133,.6); }
}
.unselected-ring {
  animation: pulseRing 2s ease-in-out infinite;
  border-color: rgba(251,113,133,.7) !important;
}

/* Yellow highlight on focused custom select button */
.customSelBtn:focus {
  outline: none !important;
  border-color: #ffe033 !important;
  box-shadow: 0 0 0 3px rgba(255,224,51,.45), 0 0 12px rgba(255,224,51,.25) !important;
  background: rgba(255,224,51,.12) !important;
}

/* Adeq box — clean compact override */
.adeqBox {
  background: #0c1320 !important;
}
.adeqTbl {
  background: transparent !important;
}
.adeqTbl tr {
  background: transparent !important;
}

/* Status text (clean, no pill, just colored text like admin) */
.statusOver  { color: #86efac !important; font-weight: 900 !important; font-size:12px !important; }
.statusStaffed { color: #fde047 !important; font-weight: 900 !important; font-size:12px !important; }
.statusShort { color: #ff4d4d !important; font-weight: 900 !important; font-size:12px !important; }

/* Role section labels in adeq table */
.adeqRole-CALLTAKER .adeqSectionLabel,
.adeqRole-DISPATCHER .adeqSectionLabel,
.adeqRole-PIC .adeqSectionLabel { color: #cfe3ff !important; }

/* Card backgrounds for roster tables */
.card.boardCard {
  background: var(--card) !important;
  border: 1px solid var(--border) !important;
}

/* Role-tinted cards */
.roleCard-CALLTAKER {
  background: rgba(56,140,255,.06) !important;
  border-color: rgba(56,140,255,.15) !important;
}
.roleCard-CALLTAKER h2.blockHdr { color: #fff !important; }

.roleCard-DISPATCHER {
  background: rgba(192,132,252,.06) !important;
  border-color: rgba(192,132,252,.15) !important;
}
.roleCard-DISPATCHER h2.blockHdr { color: #fff !important; }

.roleCard-PIC {
  background: rgba(45,212,191,.06) !important;
  border-color: rgba(45,212,191,.15) !important;
}
.roleCard-PIC h2.blockHdr { color: #fff !important; }

.roleCard-SUPERVISOR {
  background: rgba(251,191,36,.06) !important;
  border-color: rgba(251,191,36,.15) !important;
}
.roleCard-SUPERVISOR h2.blockHdr { color: #fff !important; }

.roleCard-ABSENT {
  background: rgba(251,113,133,.04) !important;
  border-color: rgba(251,113,133,.12) !important;
}
.roleCard-ABSENT h2.blockHdr { color: #fff !important; }

.roleCard-OTH {
  background: rgba(156,163,175,.06) !important;
  border-color: rgba(156,163,175,.15) !important;
}
.roleCard-OTH h2.blockHdr { color: #fff !important; }

/* === FINAL layout: Name left, everything else centered, no overlap === */
.rosterTbl {
  table-layout: fixed !important;
  width: 100% !important;
}
.rosterTbl th, .rosterTbl td {
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
  padding: 7px 6px !important;
  text-align: center !important;
}
/* Name column: left-aligned, single line with ellipsis */
.rosterTbl th.nameCol, .rosterTbl td.nameCol {
  text-align: left !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  line-height: 1.2 !important;
}
/* Center the header text for all non-name columns */
.rosterTbl th { text-align: center !important; }
.rosterTbl th.nameCol { text-align: left !important; }

/* Controls inside cells: centered */
.rosterTbl td.ctrlCell {
  text-align: center !important;
  overflow: visible !important;
}
.rosterTbl td.ctrlCell select,
.rosterTbl td.ctrlCell input,
.rosterTbl td.ctrlCell .customSelBtn {
  text-align: center !important;
  margin: 0 auto !important;
}
/* Custom select */
.customSel { overflow: visible !important; }
.customSelBtn {
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  max-width: 100% !important;
  justify-content: center !important;
}
.customSel--seat .customSelBtn {
  max-width: 100% !important;
  width: auto !important;
  min-width: 52px !important;
}
/* Worked pill centered */
.rosterTbl .rowPill { margin: 0 auto !important; }
/* Hrs input centered */
.rosterTbl .hrsIn { text-align: center !important; margin: 0 auto !important; }

/* Typing mode indicator for custom selects */
.customSelBtn.typing-mode {
  outline: 2px solid var(--accent) !important;
  outline-offset: -2px !important;
  background: rgba(74,163,255,.15) !important;
}
body.light .customSelBtn.typing-mode {
  outline: 2px solid var(--accent) !important;
  background: rgba(3,105,161,.1) !important;
}

/* FINAL: Name column - single line, no wrap, ellipsis when truncated */
.rosterTbl td.nameCol {
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  max-width: 180px !important;
}
.rosterTbl td.nameCol .empName {
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  display: inline-block !important;
  max-width: 100% !important;
  vertical-align: middle !important;
}
/* OT/Partial badges inline with name */
.rosterTbl td.nameCol .otBadge {
  display: inline-block !important;
  vertical-align: middle !important;
  margin-left: 4px !important;
}
/* OT badge below name for OT-only employees */
.otNameWrap {
  display: inline-block;
  text-align: left;
}
.rosterTbl td.nameCol .otBadgeTop {
  display: block !important;
  margin-left: 0 !important;
  margin-top: 2px !important;
  border: none !important;
  border-radius: 0 !important;
  padding: 0 !important;
}

/* Login Form Styles */
#loginOverlay{
  position:fixed;
  inset:0;
  background:var(--bg);
  z-index:100000;
  display:flex;
  align-items:center;
  justify-content:center;
}
#loginOverlay.hidden{ display:none; }
.login-box{
  background:var(--card);
  border:1px solid var(--border);
  border-radius:16px;
  padding:32px 40px;
  width:100%;
  max-width:360px;
  box-shadow:0 8px 32px rgba(0,0,0,.3);
}
.login-box h2{
  margin:0 0 8px;
  font-size:24px;
  text-align:center;
  color:var(--text);
}
.login-box .subtitle{
  text-align:center;
  color:var(--muted);
  font-size:13px;
  margin-bottom:24px;
}
.login-box label{
  display:block;
  font-size:12px;
  color:var(--muted);
  margin-bottom:6px;
}
.login-box input[type="email"],
.login-box input[type="password"]{
  width:100%;
  padding:12px 14px;
  border-radius:10px;
  border:1px solid var(--border);
  background:#0c1320;
  color:var(--text);
  font-size:14px;
  margin-bottom:16px;
  outline:none;
}
.login-box input:focus{
  border-color:var(--accent);
  box-shadow:0 0 0 3px rgba(74,163,255,.15);
}
.login-box .btn-login{
  width:100%;
  padding:12px;
  border-radius:10px;
  border:none;
  background:var(--accent);
  color:#fff;
  font-size:14px;
  font-weight:700;
  cursor:pointer;
  margin-top:8px;
}
.login-box .btn-login:hover{ background:#3b8fd9; }
.login-box .btn-login:disabled{ opacity:.6; cursor:not-allowed; }
.login-box .login-error{
  background:rgba(255,95,95,.12);
  border:1px solid rgba(255,95,95,.3);
  color:#ff6b6b;
  padding:10px 12px;
  border-radius:8px;
  font-size:13px;
  margin-bottom:16px;
  display:none;
}
.login-box .login-error.show{ display:block; }
#userInfo{
  display:flex;
  align-items:center;
  gap:10px;
  font-size:12px;
  color:var(--muted);
}
#userInfo .user-email{ color:var(--text); font-weight:600; }
#btnLogout{
  padding:4px 10px;
  font-size:11px;
  border-radius:8px;
  border:1px solid var(--border);
  background:transparent;
  color:var(--text);
  cursor:pointer;
}
#btnLogout:hover{ background:rgba(255,255,255,.06); }

</style>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
<script>
  // Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyA6KELmSyotefK0zhahQZ0-mbYur8_nTsg",
    authDomain: "commandops-93846.firebaseapp.com",
    databaseURL: "https://commandops-93846-default-rtdb.firebaseio.com",
    projectId: "commandops-93846",
    storageBucket: "commandops-93846.firebasestorage.app",
    messagingSenderId: "262613721964",
    appId: "1:262613721964:web:478a694d357234e3be4949"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
  db.enablePersistence({synchronizeTabs:true}).catch(err=>{
    console.warn("Firestore persistence not enabled:", err.code);
  });
  const auth = firebase.auth();

  // Auth state listener
  let authReady = false;
  auth.onAuthStateChanged((user) => {
    authReady = true;
    const overlay = document.getElementById('loginOverlay');
    const userInfo = document.getElementById('userInfo');
    const userEmail = document.getElementById('userEmail');

    if (user) {
      // User is signed in
      overlay.classList.add('hidden');
      userInfo.style.display = 'flex';
      userEmail.textContent = user.email;
    } else {
      // User is signed out
      overlay.classList.remove('hidden');
      userInfo.style.display = 'none';
      userEmail.textContent = '';
    }
  });

  // Login form handler
  document.addEventListener('DOMContentLoaded', () => {
    const loginForm = document.getElementById('loginForm');
    const loginError = document.getElementById('loginError');
    const btnLogin = document.getElementById('btnLogin');
    const btnLogout = document.getElementById('btnLogout');

    loginForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;

      loginError.classList.remove('show');
      btnLogin.disabled = true;
      btnLogin.textContent = 'Signing in...';

      try {
        await auth.signInWithEmailAndPassword(email, password);
      } catch (err) {
        let msg = 'Sign in failed';
        if (err.code === 'auth/user-not-found') msg = 'No account found with this email';
        else if (err.code === 'auth/wrong-password') msg = 'Incorrect password';
        else if (err.code === 'auth/invalid-email') msg = 'Invalid email address';
        else if (err.code === 'auth/too-many-requests') msg = 'Too many attempts. Try again later.';
        else if (err.code === 'auth/invalid-credential') msg = 'Invalid email or password';
        loginError.textContent = msg;
        loginError.classList.add('show');
      }

      btnLogin.disabled = false;
      btnLogin.textContent = 'Sign In';
    });

    btnLogout.addEventListener('click', () => {
      auth.signOut();
    });
  });
</script>

</head>
<body>

<!-- Login Overlay -->
<div id="loginOverlay">
  <div class="login-box">
    <h2>CommandOps</h2>
    <p class="subtitle">Sign in to continue</p>
    <div id="loginError" class="login-error"></div>
    <form id="loginForm">
      <label>Email</label>
      <input type="email" id="loginEmail" placeholder="you@example.com" required autocomplete="email"/>
      <label>Password</label>
      <input type="password" id="loginPassword" placeholder="Enter password" required autocomplete="current-password"/>
      <button type="submit" class="btn-login" id="btnLogin">Sign In</button>
    </form>
  </div>
</div>

<header>
  <div style="display:flex;align-items:center;gap:14px;margin-bottom:10px;">
    <svg class="radar-logo" width="38" height="38" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg" style="flex-shrink:0">
      <!-- outer ring -->
      <circle cx="32" cy="32" r="29" stroke="#233043" stroke-width="1.5" fill="none"/>
      <!-- range rings -->
      <circle cx="32" cy="32" r="20" stroke="#233043" stroke-width=".6" fill="none" opacity=".5"/>
      <circle cx="32" cy="32" r="11" stroke="#233043" stroke-width=".6" fill="none" opacity=".35"/>
      <!-- crosshair lines -->
      <line x1="32" y1="4" x2="32" y2="60" stroke="#233043" stroke-width=".5" opacity=".3"/>
      <line x1="4" y1="32" x2="60" y2="32" stroke="#233043" stroke-width=".5" opacity=".3"/>
      <!-- sweep beam (animated) -->
      <g style="transform-origin:32px 32px;animation:radarSweep 4s linear infinite">
        <defs>
          <linearGradient id="sweepG" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="#4aa3ff" stop-opacity=".6"/>
            <stop offset="100%" stop-color="#4aa3ff" stop-opacity="0"/>
          </linearGradient>
        </defs>
        <path d="M32,32 L32,3 A29,29 0 0,1 56,14 Z" fill="url(#sweepG)" opacity=".5"/>
        <line x1="32" y1="32" x2="32" y2="3" stroke="#4aa3ff" stroke-width="1" opacity=".8"/>
      </g>
      <!-- center dot -->
      <circle cx="32" cy="32" r="2" fill="#4aa3ff" opacity=".9"/>
      <!-- blips -->
      <circle cx="24" cy="20" r="1.5" fill="#4aa3ff" opacity=".5"/>
      <circle cx="44" cy="26" r="1" fill="#4aa3ff" opacity=".35"/>
      <circle cx="38" cy="42" r="1.2" fill="#4aa3ff" opacity=".4"/>
    </svg>
    <div style="display:flex;flex-direction:column;gap:1px;">
      <h1 style="text-align:left;font-size:28px;font-weight:900;letter-spacing:.04em;margin:0;">CommandOps</h1>
      <span style="font-size:10px;letter-spacing:.18em;text-transform:uppercase;color:var(--muted);font-weight:600;">All Stations, All Shifts</span>
    </div>
    <div id="userInfo" style="margin-left:auto;display:none;align-items:center;gap:10px;">
      <span class="pill" id="pillUnfilled" style="font-size:10px;padding:4px 8px;cursor:pointer;" title="Click for details">0 UNFILLED</span>
      <span class="pill good" id="pillFirebase" style="font-size:10px;padding:4px 8px;">Firebase: connected</span>
      <span class="pill" id="pillSync" style="font-size:10px;padding:4px 8px;">Sync: idle</span>
      <span class="user-email" id="userEmail"></span>
      <button id="btnLogout" type="button">Sign Out</button>
    </div>
    <button id="themeToggle" type="button" style="width:auto;padding:6px 14px;font-size:12px;font-weight:700;border-radius:10px;">&#9789; Dark</button>
  </div>

  <input id="weekStart" type="hidden"/>
  <input id="workDate" type="hidden"/>

  <div class="controls">
    <div>
      <select id="ppSel"></select>
    </div>
    <div>
      <select id="weekSel">
        <option value="1">Week 1</option>
        <option value="2">Week 2</option>
      </select>
    </div>
    <div>
      <select id="daySel"></select>
      <span id="workDateDisplay" style="display:none"></span>
    </div>
    <div>
      <select id="shiftSel">
        <option value="DAY">Day Shift (0600–1800)</option>
        <option value="NIGHT">Night Shift (1800–0600)</option>
      </select>
    </div>
    <div style="display:flex;gap:8px;align-items:end">
      <select id="panelViewSel">
        <option value="all">All 3 blocks</option>
      </select>
      <input id="empSearch" type="text" placeholder="Search…" style="width:140px;padding:8px 8px;font-size:12px;border:1px solid var(--border);border-radius:12px;background:#0c1320;color:var(--text);" oninput="filterByEmployee(this.value)"/>
    </div>

    <div>
      <input id="dbFile" type="file" accept=".xlsx" style="display:none"/>
      <input id="teamsFile" type="file" accept=".xlsx,.csv" style="display:none"/>
      <div style="display:flex;gap:8px">
        <button class="primary" id="btnImport" style="padding:6px 10px;font-size:11px;">Import OT</button>
        <button class="primary" id="btnSaveXlsx" title="Export current day/shift/block data to Excel" style="padding:6px 10px;font-size:11px;">Save XLSX</button>
        <button class="primary" id="btnTimesheet" title="Generate timesheet for pay period" style="padding:6px 10px;font-size:11px;">Timesheet</button>
      </div>
    </div>
  </div>
</header>

<main>
  <div id="blocks" class="grid"></div>
</main>

<footer class="diag" style="display:block;">
  <div id="absentBar"></div>
  <span class="pill" id="pillXlsx" style="display:none">XLSX: …</span>
  <span class="pill" id="pillDb" style="display:none">DB: not loaded</span>
  <span class="pill" id="pillAdeq" style="display:none">Adequate: not loaded</span>
  <span class="pill" id="pillSeats" style="display:none">Seats: not loaded</span>
  <span class="pill" id="pillOt" style="display:none">Teams OT: not imported</span>
  <span class="pill err" id="pillErr" style="display:none">Error: <span id="errTxt"></span></span>
</footer>

<script>
// ===== XLSX loader =====
function setErr(msg){
  const p=document.getElementById("pillErr");
  document.getElementById("errTxt").textContent=msg;
  p.style.display="inline-flex";
}
function clearErr(){
  document.getElementById("pillErr").style.display="none";
  document.getElementById("errTxt").textContent="";
}
(function ensureXLSX(){
  const pill=document.getElementById("pillXlsx");
  const tryLocal=()=>{
    if(window.XLSX){ pill.textContent="XLSX: ready"; pill.classList.add("good"); return; }
    pill.textContent="XLSX: not loaded (CDN blocked). Put xlsx.full.min.js next to this HTML.";
    pill.classList.add("bad");
  };
  if(window.XLSX){ pill.textContent="XLSX: ready"; pill.classList.add("good"); return; }
  const s=document.createElement("script");
  s.src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js";
  s.onload=()=>{ pill.textContent="XLSX: ready"; pill.classList.add("good"); };
  s.onerror=tryLocal;
  document.head.appendChild(s);
  setTimeout(tryLocal, 1500);
})();

// ===== Helpers =====
const BLOCKS_DAY = [
  {id:"0600-1000", start:"06:00", end:"10:00"},
  {id:"1000-1400", start:"10:00", end:"14:00"},
  {id:"1400-1800", start:"14:00", end:"18:00"},
];
const BLOCKS_NIGHT = [
  {id:"1800-2200", start:"18:00", end:"22:00"},
  {id:"2200-0200", start:"22:00", end:"02:00"},
  {id:"0200-0600", start:"02:00", end:"06:00"},
];
function getBlocks(){ return document.getElementById("shiftSel").value==="NIGHT" ? BLOCKS_NIGHT : BLOCKS_DAY; }
function pad2(n){ return String(n).padStart(2,"0"); }
function toISODate(d){ return d.getFullYear()+"-"+pad2(d.getMonth()+1)+"-"+pad2(d.getDate()); }
function parseISO(s){ const [y,m,d]=s.split("-").map(Number); return new Date(y,m-1,d); }

function addDaysISO(iso, days){
  // iso: YYYY-MM-DD
  const d = parseISO(iso);
  d.setDate(d.getDate() + (days||0));
  return toISODate(d);
}

function dayNameFromISO(iso){
  const d=parseISO(iso);
  const names=["SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"];
  return names[d.getDay()];
}
function minutesOf(timeStr){
  const [h,m]=String(timeStr||"00:00").split(":").map(Number);
  return (h*60)+(m||0);
}
function overlapMinutes(aStart,aEnd,bStart,bEnd){
  const s=Math.max(aStart,bStart);
  const e=Math.min(aEnd,bEnd);
  return Math.max(0, e-s);
}
function roundQuarterHours(mins){ return Math.round((mins/60)*4)/4; }
function minToHHMM(m){
  const hh=Math.floor(m/60)%24, mm=m%60;
  return pad2(hh)+":"+pad2(mm);
}
function esc(s){
  return String(s)
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/'/g,"&#39;").replace(/"/g,"&quot;");
}
function sheetToJson(ws){ return XLSX.utils.sheet_to_json(ws,{defval:""}); }
function sheetToGrid(ws){ return XLSX.utils.sheet_to_json(ws,{header:1, defval:""}); }

// ===== Data state =====
let BASE_EMP=[];
let PANEL_VIEW = 'all'
const rowComments = {};  // key: "blockId|empName" => comment string
let ADEQ={CALLTAKER:{},DISPATCHER:{},PIC:{},SUPERVISOR:{}};
let SEATS={CALLTAKER:[],DISPATCHER:[],PIC:[],SUPERVISOR:[]};
let ABSENT_REASONS=[];

let OT_BY_CTX=new Map(); // ctxKey -> array of OT entries
let EDITS_BY_CTX=new Map(); // ctxKey -> Map(emp->edit)

function ctxKey(iso, shift, blockId){ return iso+"|"+shift+"|"+blockId; }
function editsMapFor(key){ if(!EDITS_BY_CTX.has(key)) EDITS_BY_CTX.set(key,new Map()); return EDITS_BY_CTX.get(key); }
function ensureEdit(key, emp){
  const m=editsMapFor(key);
  if(!m.has(emp)) m.set(emp,{Present:"YES",Hours:"",Role:"",Assignment:"",AbsenceReason:"",PartialReason:"",WorkedStart:"",WorkedEnd:"",OthType:""});
  return m.get(emp);
}
function getEditVal(key, emp, field){
  const m=editsMapFor(key);
  return m.has(emp) ? m.get(emp)[field] : "";
}
function normalizeRole(pos){
  const p=String(pos||"").toUpperCase().trim();
  if(p.includes("CALL") || p==="CT") return "CALLTAKER";
  if(p.includes("DISP") || p==="DP") return "DISPATCHER";
  if(p.includes("PIC")) return "PIC";
  if(p.includes("SUP")) return "SUPERVISOR";
  if(p==="OTH" || p==="OTHER") return "OTH";
  return p||"";
}

// ===== Firebase Data Loading =====
async function loadFromFirebase(){
  clearErr();
  const pDb=document.getElementById("pillDb");
  const pA=document.getElementById("pillAdeq");
  const pS=document.getElementById("pillSeats");

  pDb.textContent="DB: loading...";
  pDb.classList.remove("good","bad");

  try {
    // Fire ALL Firestore queries in parallel
    const adeqMap = [
      ["Calltaker_Adequate_Staffing", "CALLTAKER", "Calltaker Adequate staffing"],
      ["Dispatcher_Adequate_Staffing", "DISPATCHER", "Dispatcher Adequate Staffing"],
      ["PIC_Adequate_Staffing", "PIC", "PIC Adequate Staffing"],
    ];
    const seatMap = [
      ["Calltaker_Seat_Assignments", "CALLTAKER"],
      ["Dispatcher_Seat_Assignments", "DISPATCHER"],
      ["PIC_Seat_Assignments", "PIC"],
      ["Supervisor_seat_Assignments", "SUPERVISOR"],
    ];

    const [empSnap, ...otherSnaps] = await Promise.all([
      db.collection('employees').get(),
      ...adeqMap.map(([c])=> db.collection(c).get().catch(e=>{ console.warn("Failed to load "+c, e); return null; })),
      ...seatMap.map(([c])=> db.collection(c).get().catch(e=>{ console.warn("Failed to load "+c, e); return null; })),
      db.collection('Absent_Reason').get().catch(e=>{ console.warn("Failed to load Absent_Reason", e); return null; }),
    ]);

    // 1. Process employees
    BASE_EMP = empSnap.docs.map(doc => {
      const r = doc.data();
      return {
        Employee: r.Employee || doc.id,
        SENIORITY: r.SENIORITY ?? r.Seniority ?? "",
        POSITION: normalizeRole(r.POSITION ?? r.Position ?? ""),
        SATURDAY: r.SATURDAY ?? "",
        SUNDAY: r.SUNDAY ?? "",
        MONDAY: r.MONDAY ?? "",
        TUESDAY: r.TUESDAY ?? "",
        WEDNESDAY: r.WEDNESDAY ?? "",
        THURSDAY: r.THURSDAY ?? "",
        FRIDAY: r.FRIDAY ?? "",
      };
    }).filter(r=>r.Employee);

    pDb.textContent="DB: loaded ("+BASE_EMP.length+")";
    pDb.classList.toggle("good", BASE_EMP.length>0);
    if(!BASE_EMP.length) pDb.classList.add("bad");

    // 2. Process adequate staffing
    ADEQ={CALLTAKER:{},DISPATCHER:{},PIC:{},SUPERVISOR:{}};
    const dayColMap = {
      "Sun": "SUNDAY", "Mon": "MONDAY", "Tue": "TUESDAY",
      "Wed": "WEDNESDAY", "Thu": "THURSDAY", "Fri": "FRIDAY", "Sat": "SATURDAY"
    };
    let adeqLoaded = 0;
    for(let ai=0; ai<adeqMap.length; ai++){
      const [collection, role, timeField] = adeqMap[ai];
      const snap = otherSnaps[ai];
      if(!snap) continue;
      snap.docs.forEach(doc => {
        const data = doc.data();
        const timeVal = data[timeField];
        if(timeVal === "Time" || timeVal === undefined || timeVal === null) return;
        const hourKey = String(timeVal).replace(/[^0-9]/g,"").padStart(4,"0");
        if(!hourKey) return;
        for(const [colName, dayName] of Object.entries(dayColMap)){
          const val = data[colName];
          if(val !== undefined && val !== null && val !== ""){
            const num = Number(val);
            if(Number.isFinite(num)){
              if(!ADEQ[role][dayName]) ADEQ[role][dayName] = {};
              ADEQ[role][dayName][hourKey] = num;
              adeqLoaded++;
            }
          }
        }
      });
    }
    pA.textContent = adeqLoaded > 0 ? "Adequate: loaded" : "Adequate: not loaded";
    pA.classList.toggle("good", adeqLoaded > 0);
    if(adeqLoaded === 0) pA.classList.add("bad");

    // 3. Process seat assignments
    SEATS={CALLTAKER:[],DISPATCHER:[],PIC:[],SUPERVISOR:[]};
    let seatsLoaded = 0;
    for(let si=0; si<seatMap.length; si++){
      const [collection, role] = seatMap[si];
      const snap = otherSnaps[adeqMap.length + si];
      if(!snap) continue;
      const vals = snap.docs.map(doc => {
        const data = doc.data();
        return Object.values(data)[0];
      }).map(v => String(v||"").trim()).filter(Boolean);
      if(vals.length){
        SEATS[role] = vals;
        seatsLoaded += vals.length;
      }
    }

    // 4. Process absent reasons
    ABSENT_REASONS = [];
    const absSnap = otherSnaps[adeqMap.length + seatMap.length];
    if(absSnap){
      const seen = new Set();
      absSnap.docs.forEach(doc => {
        const data = doc.data();
        const reason = Object.values(data)[0];
        const s = String(reason||"").trim();
        if(s && !seen.has(s)){
          seen.add(s);
          ABSENT_REASONS.push(s);
        }
      });
    }

    const seatsOk = Object.values(SEATS).some(arr=>Array.isArray(arr)&&arr.length);
    const absOk = (ABSENT_REASONS && ABSENT_REASONS.length);
    pS.textContent = (seatsOk ? "Seats: loaded" : "Seats: not loaded") + " · " + (absOk ? ("Absent Reasons: "+ABSENT_REASONS.length) : "Absent Reasons: not loaded");
    pS.classList.toggle("good", !!seatsOk && !!absOk);
    if(!(seatsOk && absOk)) pS.classList.add("bad");

    console.log("SheetOps: loaded from Firebase", {
      employees: BASE_EMP.length,
      adeq: adeqLoaded,
      seats: seatsLoaded,
      absReasons: ABSENT_REASONS.length,
    });
    return true;
  } catch(err){
    console.error("Firebase load error:", err);
    setErr("Firebase load failed: " + (err.message || err));
    pDb.textContent="DB: Firebase error";
    pDb.classList.add("bad");
    return false;
  }
}

// ===== Firebase Data Saving =====
async function saveEditsToFirebase(iso, shift){
  const key = iso + "|" + shift;
  const docId = iso + "_" + shift;

  // Collect all edits for this date/shift
  const allEdits = {};
  for(const [ctxKey, editsMap] of EDITS_BY_CTX.entries()){
    if(ctxKey.startsWith(key)){
      const blockId = ctxKey.split("|")[2];
      for(const [emp, edit] of editsMap.entries()){
        if(!allEdits[emp]) allEdits[emp] = {};
        allEdits[emp][blockId] = edit;
      }
    }
  }

  // Collect OT entries
  const otEntries = [];
  for(const [ctxKey, otArr] of OT_BY_CTX.entries()){
    if(ctxKey.startsWith(key)){
      const blockId = ctxKey.split("|")[2];
      for(const ot of otArr){
        otEntries.push({...ot, blockId: blockId});
      }
    }
  }

  // Save to Firebase
  try {
    await db.collection('daily_edits').doc(docId).set({
      date: iso,
      shift: shift,
      edits: allEdits,
      ot: otEntries,
      comments: Object.fromEntries(Object.entries(rowComments).filter(([k,v]) => v)),
      savedAt: new Date().toISOString()
    }, {merge: true});
    console.log("Saved edits to Firebase:", docId);
    return true;
  } catch(err){
    console.error("Firebase save error:", err);
    setErr("Failed to save: " + (err.message || err));
    return false;
  }
}

async function loadEditsFromFirebase(iso, shift){
  const docId = iso + "_" + shift;
  try {
    const doc = await db.collection('daily_edits').doc(docId).get();
    if(doc.exists){
      const data = doc.data();
      // Restore edits
      if(data.edits){
        for(const [emp, blocks] of Object.entries(data.edits)){
          for(const [blockId, edit] of Object.entries(blocks)){
            const ctx = ctxKey(iso, shift, blockId);
            const m = editsMapFor(ctx);
            m.set(emp, edit);
          }
        }
      }
      // Restore OT
      if(data.ot){
        for(const entry of data.ot){
          const ctx = ctxKey(iso, shift, entry.blockId || "");
          if(!OT_BY_CTX.has(ctx)) OT_BY_CTX.set(ctx, []);
          OT_BY_CTX.get(ctx).push(entry);
        }
      }
      // Restore comments
      if(data.comments){
        Object.assign(rowComments, data.comments);
      }
      console.log("Loaded edits from Firebase:", docId);
      return true;
    }
  } catch(err){
    console.warn("Failed to load edits from Firebase:", err);
  }
  return false;
}

// ===== Auto-Save & Real-Time Sync =====
let autoSaveTimer = null;
let realtimeUnsubscribe = null;
let lastSavedAt = null; // track to ignore our own writes
let isSyncing = false;

function setSyncStatus(status, isGood = null) {
  const pill = document.getElementById("pillSync");
  if (!pill) return;
  pill.textContent = "Sync: " + status;
  pill.classList.remove("good", "bad");
  if (isGood === true) pill.classList.add("good");
  if (isGood === false) pill.classList.add("bad");
}

function scheduleAutoSave() {
  // Debounce: wait 1.5 seconds after last change before saving
  if (autoSaveTimer) clearTimeout(autoSaveTimer);
  setSyncStatus("pending...");

  autoSaveTimer = setTimeout(async () => {
    const iso = document.getElementById("workDate").value;
    const shift = document.getElementById("shiftSel").value;
    if (!iso || !shift) return;

    setSyncStatus("saving...");
    isSyncing = true;
    const ok = await saveEditsToFirebase(iso, shift);
    isSyncing = false;

    if (ok) {
      lastSavedAt = Date.now();
      setSyncStatus("synced", true);
    } else {
      setSyncStatus("failed", false);
    }
  }, 1500);
}

function startRealtimeSync(iso, shift) {
  // Stop any existing listener
  if (realtimeUnsubscribe) {
    realtimeUnsubscribe();
    realtimeUnsubscribe = null;
  }

  if (!iso || !shift) return;

  const docId = iso + "_" + shift;

  realtimeUnsubscribe = db.collection('daily_edits').doc(docId).onSnapshot((doc) => {
    // Skip if we're currently saving (to avoid feedback loop)
    if (isSyncing) return;

    // Skip if this is likely our own write (within 2 seconds of our save)
    if (lastSavedAt && Date.now() - lastSavedAt < 2000) return;

    if (!doc.exists) return;

    const data = doc.data();
    if (!data) return;

    console.log("Realtime update received:", docId);
    setSyncStatus("updating...");

    // Clear current edits for this date/shift and reload
    const keyPrefix = iso + "|" + shift;
    for (const [ctxKey] of EDITS_BY_CTX.entries()) {
      if (ctxKey.startsWith(keyPrefix)) {
        EDITS_BY_CTX.delete(ctxKey);
      }
    }
    for (const [ctxKey] of OT_BY_CTX.entries()) {
      if (ctxKey.startsWith(keyPrefix)) {
        OT_BY_CTX.delete(ctxKey);
      }
    }

    // Restore edits from snapshot
    if (data.edits) {
      for (const [emp, blocks] of Object.entries(data.edits)) {
        for (const [blockId, edit] of Object.entries(blocks)) {
          const ctx = ctxKey(iso, shift, blockId);
          const m = editsMapFor(ctx);
          m.set(emp, edit);
        }
      }
    }

    // Restore OT from snapshot
    if (data.ot) {
      for (const entry of data.ot) {
        const ctx = ctxKey(iso, shift, entry.blockId || "");
        if (!OT_BY_CTX.has(ctx)) OT_BY_CTX.set(ctx, []);
        OT_BY_CTX.get(ctx).push(entry);
      }
    }

    // Restore comments from snapshot
    if (data.comments) {
      // Clear existing comments for this context
      for (const key of Object.keys(rowComments)) {
        if (key.includes("|")) delete rowComments[key];
      }
      Object.assign(rowComments, data.comments);
    }

    // Re-render UI
    renderAll();
    setSyncStatus("live", true);

  }, (err) => {
    console.error("Realtime sync error:", err);
    setSyncStatus("error", false);
  });
}

// ===== Workbook helpers =====
function loadWorkbook(arrayBuf){ return XLSX.read(arrayBuf,{type:"array"}); }
function getSheet(wb, names){
  for(const n of names){ if(wb.Sheets[n]) return {name:n, ws:wb.Sheets[n]}; }
  const keys=Object.keys(wb.Sheets||{});
  for(const n of names){
    const k=keys.find(x=>x.toLowerCase()===String(n).toLowerCase());
    if(k) return {name:k, ws:wb.Sheets[k]};
  }
  return null;
}

// ===== Adequate parsing =====
function dayAbbrevToName(s){
  const t=String(s||"").trim().toLowerCase();
  const map={sun:"SUNDAY",mon:"MONDAY",tue:"TUESDAY",wed:"WEDNESDAY",thu:"THURSDAY",fri:"FRIDAY",sat:"SATURDAY"};
  return map[t]||"";
}
function parseAdequateSheet(wb, sheetNames, role){
  const sh=getSheet(wb, sheetNames);
  if(!sh) return 0;
  const grid=sheetToGrid(sh.ws);
  let hdrIdx=-1;
  for(let i=0;i<Math.min(grid.length,15);i++){
    const c0=String((grid[i]||[])[0]||"").trim().toLowerCase();
    if(c0==="time" || c0==="hour" || c0==="hrs"){ hdrIdx=i; break; }
  }
  if(hdrIdx<0) return 0;
  const headers=(grid[hdrIdx]||[]).map(x=>String(x||"").trim());
  const colDay=[];
  let dayCols=0;
  for(let j=1;j<headers.length;j++){
    const dn=dayAbbrevToName(headers[j]);
    colDay[j]=dn;
    if(dn){ dayCols++; if(!ADEQ[role][dn]) ADEQ[role][dn]={}; }
  }
  let written=0;
  for(let i=hdrIdx+1;i<grid.length;i++){
    const row=grid[i]||[];
    const t=row[0];
    const hourKey=String(t||"").trim();
    const hk = hourKey.replace(/[^0-9]/g,"");
    if(!hk) continue;
    const hk4 = hk.padStart(4,"0");
    for(let j=1;j<headers.length;j++){
      const dn=colDay[j];
      if(!dn) continue;
      const v=row[j];
      if(v==="" || v===null || v===undefined) continue;
      const num=Number(v);
      if(!Number.isFinite(num)) continue;
      ADEQ[role][dn][hk4]=num;
      written++;
    }
  }
  return written;
}

// ===== Seats parsing =====
function parseSeats(wb){
  let loaded=0;
  const seatMap = [
    ["Calltaker Seat Assignments","CALLTAKER"],
    ["Dispatcher Seat Assignments","DISPATCHER"],
    ["PIC Seat Assignments","PIC"],
    ["Supervisor seat Assignments","SUPERVISOR"],
    ["Supervisor Seat Assignments","SUPERVISOR"],
  ];
  for(const [sheetName, role] of seatMap){
    const sh=getSheet(wb,[sheetName]);
    if(sh){
      const vals=sheetToJson(sh.ws).map(r=>Object.values(r)[0]).map(v=>String(v||"").trim()).filter(Boolean);
      if(vals.length){ SEATS[role]=vals; loaded+=vals.length; }
    }
  }
  const p=document.getElementById("pillSeats");
  p.textContent = loaded ? ("Seats: loaded") : "Seats: not loaded";
  p.classList.toggle("good", !!loaded);
  if(!loaded) p.classList.add("bad");
}


function parseAbsentReasons(wb){
  ABSENT_REASONS=[];
  const sh=getSheet(wb, ["Absent Reason","Absence Reason","Absense Reasons","Absent Reasons","ABSENT REASON","ABSENCE REASON","ABSENSE REASONS"]);
  if(!sh) return 0;
  const grid=sheetToGrid(sh.ws);
  // take first column, skip header-ish cells, de-dupe
  const seen=new Set();
  for(let i=0;i<grid.length;i++){
    const v = (grid[i]||[])[0];
    const s = String(v||"").trim();
    if(!s) continue;
    const low=s.toLowerCase();
    if(low==="absent reason"||low==="absence reason"||low==="absense reason"||low==="reason") continue;
    if(!seen.has(s)){
      seen.add(s);
      ABSENT_REASONS.push(s);
    }
  }
  return ABSENT_REASONS.length;
}



// ===== Database parsing =====
function parseDatabase(wb){
  clearErr();
  // employees
  const empSheet = getSheet(wb, ["Employee Database"]) || {name:Object.keys(wb.Sheets)[0], ws:wb.Sheets[Object.keys(wb.Sheets)[0]]};
  const rows=sheetToJson(empSheet.ws);
  BASE_EMP = rows.map(r=>{
    const e = (r.Employee ?? r.EMPLOYEE ?? r.Name ?? r.NAME ?? "").toString().trim();
    return {
      Employee: e,
      SENIORITY: r.SENIORITY ?? r.Seniority ?? "",
      POSITION: normalizeRole(r.POSITION ?? r.Position ?? ""),
      SATURDAY: r.SATURDAY ?? "",
      SUNDAY: r.SUNDAY ?? "",
      MONDAY: r.MONDAY ?? "",
      TUESDAY: r.TUESDAY ?? "",
      WEDNESDAY: r.WEDNESDAY ?? "",
      THURSDAY: r.THURSDAY ?? "",
      FRIDAY: r.FRIDAY ?? "",
    };
  }).filter(r=>r.Employee);

  const pDb=document.getElementById("pillDb");
  pDb.textContent="DB: loaded ("+BASE_EMP.length+")";
  pDb.classList.toggle("good", BASE_EMP.length>0);
  if(!BASE_EMP.length) pDb.classList.add("bad");

  // seats
  SEATS={CALLTAKER:[],DISPATCHER:[],PIC:[],SUPERVISOR:[]};
  parseSeats(wb);
  parseAbsentReasons(wb);

  // adequate
  ADEQ={CALLTAKER:{},DISPATCHER:{},PIC:{},SUPERVISOR:{}};
  const ct=parseAdequateSheet(wb, ["Calltaker Adequate Staffing"], "CALLTAKER");
  const dp=parseAdequateSheet(wb, ["Dispatcher Adequate Staffing"], "DISPATCHER");
  const pic=parseAdequateSheet(wb, ["PIC Adequate Staffing"], "PIC");
  const sup=parseAdequateSheet(wb, ["Supervisor Adequate Staffing","SUP Adequate Staffing","Supervisors Adequate Staffing"], "SUPERVISOR");
  const pA=document.getElementById("pillAdeq");
  const ok = (ct+dp+pic+sup)>0;
  pA.textContent = ok ? "Adequate: loaded" : "Adequate: not loaded";
  pA.classList.toggle("good", ok);
  if(!ok) pA.classList.add("bad");

  // combine Seats + Absent Reasons status in one pill
  const pS=document.getElementById("pillSeats");
  const seatsOk = Object.values(SEATS).some(arr=>Array.isArray(arr)&&arr.length);
  const absOk = (ABSENT_REASONS&&ABSENT_REASONS.length);
  pS.textContent = (seatsOk? "Seats: loaded" : "Seats: not loaded") + " · " + (absOk? ("Absent Reasons: "+ABSENT_REASONS.length) : "Absent Reasons: not loaded");
  pS.classList.toggle("good", !!seatsOk && !!absOk);
  if(!(seatsOk && absOk)) pS.classList.add("bad");
}

function shiftForDay(emp, dayName){ return String(emp[dayName]||"").trim(); }
function parseShiftString(s){
  const str=String(s||"").toUpperCase().replace(/\s+/g,"");
  if(!str || str==="OFF") return null;
  const parts=str.split("-");
  if(parts.length!==2) return null;
  const toMin=(token)=>{
    const m=token.match(/(\d{1,2})(?::(\d{2}))?([AP])/);
    if(!m) return null;
    let h=parseInt(m[1],10);
    const mm=m[2]?parseInt(m[2],10):0;
    const ap=m[3];
    if(ap==="A"){ if(h===12) h=0; } else { if(h!==12) h+=12; }
    return h*60+mm;
  };
  const a=toMin(parts[0]), b=toMin(parts[1]);
  if(a===null||b===null) return null;
  let start=a, end=b;
  if(end<=start) end+=1440;
  return {start,end,raw:str};
}

// ===== Block windows / hour segments =====
function blockWindowMinutes(block){
  // IMPORTANT: For NIGHT shift, blocks that start after midnight (e.g., 0200-0600)
  // belong to the NEXT calendar day in the 1800-0600 workday window.
  const isNight = (document.getElementById("shiftSel") && document.getElementById("shiftSel").value==="NIGHT");
  const nightStart = 18*60; // 1800
  let s = minutesOf(block.start);
  let e = minutesOf(block.end);
  if(e<=s) e += 1440;       // handles blocks like 2200-0200
  if(isNight && s < nightStart){
    // shift after-midnight blocks into next-day minutes so they overlap 6P-6A shifts
    s += 1440;
    e += 1440;
  }
  return {startMin:s, endMin:e};
}
function hourSegments(block){
  const isNight = (document.getElementById("shiftSel") && document.getElementById("shiftSel").value==="NIGHT");
  const nightStart = 18*60; // 1800

  // Keep the special label mapping for 2200-0200, but the minute values are already in "next-day" space.
  if(block.id==="2200-0200"){
    return [
      {label:"2200", start:1320, end:1380},
      {label:"2300", start:1380, end:1440},
      {label:"2400", start:1440, end:1500},
      {label:"0100", start:1500, end:1560},
    ];
  }

  // For NIGHT shift, blocks that begin after midnight need +1440 so overlap math works.
  let s = minutesOf(block.start);
  if(isNight && s < nightStart) s += 1440;

  const labels=[];
  for(let i=0;i<4;i++){
    const hh=((Math.floor((minutesOf(block.start)+i*60)/60))%24);
    labels.push(String(hh*100).padStart(4,"0"));
  }

  return [
    {label:labels[0], start:s, end:s+60},
    {label:labels[1], start:s+60, end:s+120},
    {label:labels[2], start:s+120, end:s+180},
    {label:labels[3], start:s+180, end:s+240},
  ];
}

// ===== Teams OT import =====
function cap(s){ s=String(s||"").trim(); if(!s) return ""; return s[0].toUpperCase()+s.slice(1); }
function lastNameKeyFromAny(member, email){
  const em=String(email||"").trim().toLowerCase();
  if(em.includes("@")){
    const local=em.split("@")[0];
    const toks=local.split(".").filter(Boolean);
    if(toks.length>=2){
      return {lastParts:[cap(toks[toks.length-1])], fi:cap((toks[0][0]||""))};
    }
  }
  const m=String(member||"").trim();
  if(!m) return {lastParts:[],fi:""};
  if(m.includes(",")){
    const [last, first]=m.split(",").map(s=>s.trim());
    const lastParts = last.split(/\s+/).filter(Boolean);
    return {lastParts:lastParts.map(cap), fi:cap((first||"")[0]||"")};
  }
  const toks=m.split(/\s+/).filter(Boolean);
  if(toks.length===1) return {lastParts:[cap(toks[0])], fi:""};
  return {lastParts:[cap(toks[toks.length-1])], fi:cap((toks[0][0]||""))};
}
function findEmpByKey(key){
  if(!key || !key.lastParts || !key.lastParts.length) return null;
  const fi=key.fi.toUpperCase();
  let best=null;
  for(const lp of key.lastParts){
    const last=lp.toUpperCase();
    for(const e of BASE_EMP){
      const up=String(e.Employee||"").trim().toUpperCase();
      if(up===last) return e;
      if(fi && up===last+fi) return e;
      if(up.startsWith(last) && !best) best=e;
    }
  }
  return best;
}
function parseTeamsFileToRows(wbOrText){
  if(typeof wbOrText === "string"){
    const lines=wbOrText.split(/\r?\n/).filter(l=>l.trim().length);
    if(lines.length<2) return [];
    const hdr=lines[0].split(",").map(h=>h.trim());
    return lines.slice(1).map(line=>{
      const cols=line.split(",");
      const o={};
      hdr.forEach((h,i)=>o[h]=cols[i]??"");
      return o;
    });
  }else{
    const wb=wbOrText;
    const sh=getSheet(wb, ["Shifts","Shift","Schedule","schedule","shifts"]) || {name:Object.keys(wb.Sheets)[0], ws:wb.Sheets[Object.keys(wb.Sheets)[0]]};
    return sheetToJson(sh.ws);
  }
}
function detectTeamsCols(row){
  const keys=Object.keys(row||{});
  const get=(cands)=>{
    for(const c of cands){
      const k=keys.find(k=>k.toLowerCase()===c.toLowerCase());
      if(k) return k;
    }
    return null;
  };
  return {
    member: get(["Member","Name","Employee","User"]),
    email: get(["Work Email","Email","User email","UserEmail","UPN"]),
    startDate: get(["Start Date","StartDate","Start date"]),
    startTime: get(["Start Time","StartTime","Start time"]),
    endDate: get(["End Date","EndDate","End date"]),
    endTime: get(["End Time","EndTime","End time"]),
    startDT: get(["Start","Start DateTime","StartDateTime"]),
    endDT: get(["End","End DateTime","EndDateTime"]),
  };
}
function parseMeansDateTime(d,t){
  if(!d && !t) return null;
  const dd = (d instanceof Date) ? d : String(d||"").trim();
  const tt = String(t||"").trim();
  let dateObj=null;
  if(dd instanceof Date) dateObj=dd;
  else if(dd){
    if(dd.includes("/")){
      const [m,da,y]=dd.split("/").map(Number);
      dateObj=new Date(y, m-1, da);
    }else if(dd.includes("-")){
      dateObj=parseISO(dd);
    }
  }
  if(!dateObj) return null;
  let hh=0, mm=0;
  if(tt){
    const m=tt.match(/(\d{1,2}):(\d{2})/);
    if(m){ hh=parseInt(m[1],10); mm=parseInt(m[2],10); }
  }
  dateObj.setHours(hh,mm,0,0);
  return dateObj;
}
function addOtToCtx(iso, shift, blockId, empName, role, wsMin, weMin){
  const key=ctxKey(iso,shift,blockId);
  if(!OT_BY_CTX.has(key)) OT_BY_CTX.set(key,[]);
  const arr=OT_BY_CTX.get(key);
  const existing=arr.find(o=>o.emp===empName);
  if(existing){
    existing.ws=Math.min(existing.ws, wsMin);
    existing.we=Math.max(existing.we, weMin);
  } else {
    arr.push({emp:empName, role, ws:wsMin, we:weMin, isOT:true});
  }
}
async function importTeamsWeek(file){
  clearErr();
  if(!window.XLSX){ setErr("XLSX not loaded."); return null; }
  if(!BASE_EMP.length){ setErr("Load Database first."); return null; }
  const ws=document.getElementById("weekStart").value;
  if(!ws){ setErr("Pick Week Start (Saturday)."); return null; }
  const weekStart=parseISO(ws);
  const weekEnd=new Date(weekStart.getTime()+6*86400000);
  // Merge: don't clear OT_BY_CTX so multiple week imports accumulate.
  // Cross-week night shift OT (e.g., 1/31 02:00 → 1/30 NIGHT) survives.
  // Page reload resets everything if a fresh start is needed.

  let text=null, wb=null;
  if(file.name.toLowerCase().endsWith(".csv")) text = await file.text();
  else wb = loadWorkbook(await file.arrayBuffer());

  const rows=parseTeamsFileToRows(text||wb);
  let total=0, imported=0, invalid=0, noMatch=0;
  const noMatchExamples=[];
  for(const r of rows){
    total++;
    const cols=detectTeamsCols(r);
    const member=r[cols.member] ?? "";
    const email=r[cols.email] ?? "";
    let start=null,end=null;
    if(cols.startDT) start = new Date(r[cols.startDT]);
    if(cols.endDT) end = new Date(r[cols.endDT]);
    if(!start && (cols.startDate||cols.startTime)) start = parseMeansDateTime(r[cols.startDate], r[cols.startTime]);
    if(!end && (cols.endDate||cols.endTime)) end = parseMeansDateTime(r[cols.endDate], r[cols.endTime]);
    if(!(start instanceof Date) || isNaN(start) || !(end instanceof Date) || isNaN(end) || end<=start){ invalid++; continue; }

    // Try email-based key first, then fall back to member-name-based key
    const keyEmail=lastNameKeyFromAny("",email);
    const keyMember=lastNameKeyFromAny(member,"");
    const emp=findEmpByKey(keyEmail) || findEmpByKey(keyMember);
    if(!emp){ noMatch++; if(noMatchExamples.length<8) noMatchExamples.push({member,email}); continue; }

    // walk days touched
    let cur=new Date(start.getFullYear(), start.getMonth(), start.getDate());
    const endDay=new Date(end.getFullYear(), end.getMonth(), end.getDate());
    while(cur<=endDay){
      if(cur<weekStart || cur>weekEnd){ cur=new Date(cur.getTime()+86400000); continue; }
      const iso=toISODate(cur);

      // minutes for THIS date (0..1440), plus allow crossing into next day by extending end
      const isStartDay = (start.getFullYear()===cur.getFullYear() && start.getMonth()===cur.getMonth() && start.getDate()===cur.getDate());
      let sMin = isStartDay
                ? (start.getHours()*60+start.getMinutes())
                : 0;
      let eMin = (end.getFullYear()===cur.getFullYear() && end.getMonth()===cur.getMonth() && end.getDate()===cur.getDate())
                ? (end.getHours()*60+end.getMinutes())
                : 1440;

      // if this is start day and end spills to next day, extend
      if(endDay>cur && (end.getHours()*60+end.getMinutes())>=0){
        // extend by full day + next-day end time
        eMin = 1440 + (end.getHours()*60+end.getMinutes());
      }

      // OT in 0000-0600 belongs to the previous day's NIGHT shift viewing context.
      // When user views "Saturday NIGHT", that covers 1800 Sat → 0600 Sun.
      // Teams exports "Sunday 02:00" but user views it under Saturday.
      // So remap: use previous day's ISO and shift minutes by +1440 to match
      // blockWindowMinutes (which puts 0200-0600 at 1560-1800 for NIGHT).
      const isPostMidnightNightOT = (isStartDay && sMin < 360 && eMin <= 360);
      if(isPostMidnightNightOT){
        const prevDate = new Date(cur.getTime() - 86400000);
        const prevIso = toISODate(prevDate);
        const sMinShifted = sMin + 1440;
        const eMinShifted = eMin + 1440;
        // Compute night block windows with +1440 for post-midnight blocks
        const nightBlockWindows = BLOCKS_NIGHT.map(b => {
          let bs = minutesOf(b.start), be = minutesOf(b.end);
          if(be <= bs) be += 1440;
          if(bs < 1080) { bs += 1440; be += 1440; }
          return {id: b.id, startMin: bs, endMin: be};
        });
        for(const nbw of nightBlockWindows){
          const ov = overlapMinutes(sMinShifted, eMinShifted, nbw.startMin, nbw.endMin);
          if(ov > 0){
            addOtToCtx(prevIso, "NIGHT", nbw.id, emp.Employee, emp.POSITION||"", sMinShifted, eMinShifted);
            imported++;
          }
        }
      } else {
        // place OT into BOTH shift sets, by overlap with each block window
        for(const sh of ["DAY","NIGHT"]){
          const blocks = (sh==="NIGHT")?BLOCKS_NIGHT:BLOCKS_DAY;
          for(const b of blocks){
            const bw=blockWindowMinutes(b);
            const ov=overlapMinutes(sMin,eMin,bw.startMin,bw.endMin);
            if(ov>0){
              addOtToCtx(iso, sh, b.id, emp.Employee, emp.POSITION||"", sMin, eMin);
              imported++;
            }
          }
        }
      }
      cur=new Date(cur.getTime()+86400000);
    }
  }
  const pill=document.getElementById("pillOt");
  pill.textContent = `Teams OT: ${imported} placed | ${total} rows | ${noMatch} no-match | ${invalid} invalid`;
  pill.classList.toggle("good", imported>0 && noMatch===0 && invalid===0);
  pill.classList.toggle("bad", (noMatch>0 || invalid>0 || imported===0));
  pill.style.cursor = (noMatch>0 || invalid>0) ? "pointer" : "default";
  pill.title = (noMatch>0 || invalid>0) ? "Click for details" : "";
  pill.onclick = (noMatch>0 || invalid>0) ? ()=>showOtImportReport(total, imported, invalid, noMatch, noMatchExamples) : null;
  if(noMatchExamples.length) console.warn("NoMatch examples:", noMatchExamples);
  return {total, imported, invalid, noMatch, noMatchExamples};
}

function showOtImportReport(total, imported, invalid, noMatch, noMatchExamples){
  let msg = `OT IMPORT REPORT\n────────────────────\n`;
  msg += `Total rows in file: ${total}\n`;
  msg += `Successfully placed: ${imported}\n`;
  msg += `Invalid (bad date/time): ${invalid}\n`;
  msg += `No match (employee not in DB): ${noMatch}\n`;
  if(noMatchExamples.length){
    msg += `\nNO-MATCH EMPLOYEES (first ${noMatchExamples.length}):\n`;
    for(const ex of noMatchExamples){
      msg += `  • ${ex.member || "(no name)"}  ${ex.email || "(no email)"}\n`;
    }
    msg += `\nThese names could not be matched to anyone in the loaded database.\nCheck spelling or ensure they exist in the DB file.`;
  }
  alert(msg);
}

function filterByEmployee(query){
  const q = query.trim().toUpperCase();
  document.querySelectorAll(".rosterTbl tbody tr").forEach(tr => {
    if(tr.classList.contains("cmt-row")){
      const prev = tr.previousElementSibling;
      if(prev) tr.style.display = prev.style.display;
      return;
    }
    const nameCell = tr.querySelector(".nameCol");
    if(!nameCell) return;
    const name = nameCell.textContent.toUpperCase();
    tr.style.display = (!q || name.includes(q)) ? "" : "none";
  });
}

// ===== Rendering =====
function roleCode(role){
  if(role==="CALLTAKER") return "CT";
  if(role==="DISPATCHER") return "DP";
  if(role==="SUPERVISOR") return "SUP";
  if(role==="PIC") return "PIC";
  return role||"";
}
function blockTitle(block){
  const parts=block.id.split("-");
  const a=parts[0], b=parts[1];
  const fmt=(hhmm)=>{
    const h=parseInt(hhmm.slice(0,2),10);
    const m=hhmm.slice(2);
    const h12=((h+11)%12)+1;
    return h12+(m==="00"?"":":"+m);
  };
  return fmt(a)+"-"+fmt(b);
}
function renderStaffingTable(iso, shift, block, role){
  const segs=hourSegments(block);
  const rows=computeRowsForBlock(iso, shift, block);
  const list=rows[role]||[];
  const counts=[0,0,0,0];

  // headcount per hour segment uses workedStart/workedEnd
  for(const r of list){
    const key=ctxKey(iso,shift,block.id);
    const ed=ensureEdit(key,r.emp);
    const ws=ed.WorkedStart || r.workedStart;
    const we=ed.WorkedEnd || r.workedEnd;
    let aS=minutesOf(ws), aE=minutesOf(we);
    // handle 22-02 wrap
    if(block.id==="2200-0200" && aE<=aS) aE += 1440;

    const segsUse = (block.id==="2200-0200")
      ? [{start:1320,end:1380},{start:1380,end:1440},{start:1440,end:1500},{start:1500,end:1560}]
      : segs.map(s=>({start:s.start,end:s.end}));

    for(let i=0;i<4;i++){
      if(overlapMinutes(aS,aE,segsUse[i].start,segsUse[i].end)>0) counts[i]+=1;
    }
  }

  const d=dayNameFromISO(iso);

  function badge(adeq, sched){
    const aNum = Number(adeq);
    const sNum = Number(sched);
    if(!Number.isFinite(aNum) || !Number.isFinite(sNum)) return "";
    if(sNum < aNum) return ` <span class="statusShort">SHORT ${aNum-sNum}</span>`;
    if(sNum === aNum) return ` <span class="statusStaffed">STAFFED</span>`;
    return ` <span class="statusOver">OVER ${sNum-aNum}</span>`;
  }

  let html="<div class='tblWrap'><table><thead><tr><th class='compact'>Hr</th><th>Adeq</th><th>Sched</th></tr></thead><tbody>";
  for(let i=0;i<4;i++){
    const hk=segs[i].label;
    const lookupKey = (hk==="2400") ? "0000" : hk;
    const a=(ADEQ[role] && ADEQ[role][d] && ADEQ[role][d][lookupKey]!==undefined) ? ADEQ[role][d][lookupKey] : "";
    const b=badge(a, counts[i]);
    html += `<tr><td class='compact'>${hk}</td><td>${a!==""?a:""}</td><td>${counts[i]}${b}</td></tr>`;
  }
  html+="</tbody></table></div>";
  return html;
}

function computeRowsForBlock(iso, shift, block){
  const dname=dayNameFromISO(iso);
  const bw=blockWindowMinutes(block);
  const res={CALLTAKER:[],DISPATCHER:[],PIC:[],SUPERVISOR:[],ABSENT:[],OTH:[]};

  // scheduled
  for(const e of BASE_EMP){
    const shStr = shiftForDay(e, dname);
    const sh=parseShiftString(shStr);
    if(!sh) continue;
    // overlap with this shift blocks only (DAY/NIGHT selection)
    // note: roster shiftStr may cover both; we just overlap block window
    const ov=overlapMinutes(sh.start,sh.end,bw.startMin,bw.endMin);
    if(ov<=0) continue;

    const key=ctxKey(iso,shift,block.id);
    const ed=ensureEdit(key,e.Employee);

    const wStartMin = Math.max(bw.startMin, sh.start);
    const wEndMin = Math.min(bw.endMin, sh.end);
    const workedStart = ed.WorkedStart || minToHHMM(wStartMin%1440);
    const workedEnd = ed.WorkedEnd || minToHHMM(wEndMin%1440);
    const mins = overlapMinutes(wStartMin,wEndMin,bw.startMin,bw.endMin);
    const hours = (ed.Hours!=="" ? Number(ed.Hours) : roundQuarterHours(mins));

    const role = normalizeRole(ed.Role||e.POSITION);
    const present=(ed.Present||"YES");
    const row={emp:e.Employee, sen:e.SENIORITY, shiftStr:shStr, role, present, hours, assignment:(ed.Assignment||""), workedStart, workedEnd, isOT:false};
    if(present==="NO") res.ABSENT.push(row);
    else if(present==="PARTIAL"){
      if(res[role]) res[role].push(row);
      // ghost ABSENT row with missed time
      const schedStart = Math.max(bw.startMin, sh.start);
      const schedEnd = Math.min(bw.endMin, sh.end);
      const schedHrs = roundQuarterHours(overlapMinutes(schedStart, schedEnd, bw.startMin, bw.endMin));
      const actualStart = minutesOf(workedStart);
      const actualEnd = minutesOf(workedEnd);
      const missedHrs = Math.max(0, schedHrs - hours);
      // determine missed time range
      let missedStart, missedEnd;
      if(actualStart > schedStart && actualEnd < schedEnd){
        missedStart = minToHHMM(schedStart%1440); missedEnd = minToHHMM(actualStart%1440);
      } else if(actualEnd < schedEnd){
        missedStart = minToHHMM(actualEnd%1440); missedEnd = minToHHMM(schedEnd%1440);
      } else if(actualStart > schedStart){
        missedStart = minToHHMM(schedStart%1440); missedEnd = minToHHMM(actualStart%1440);
      } else {
        missedStart = ""; missedEnd = "";
      }
      res.ABSENT.push({emp:e.Employee, sen:e.SENIORITY, shiftStr:shStr, role, present:"PARTIAL", hours:missedHrs, assignment:"", workedStart:missedStart, workedEnd:missedEnd, isOT:false, isPartial:true});
    }
    else if(res[role]) res[role].push(row);
  }

  // OT entries for this ctx
  const key=ctxKey(iso,shift,block.id);
  const otList=OT_BY_CTX.get(key)||[];
  for(const ot of otList){
    const ed=ensureEdit(key, ot.emp);
    const role=normalizeRole(ed.Role||ot.role||"");
    const wStart = Math.max(bw.startMin, ot.ws);
    const wEnd = Math.min(bw.endMin, ot.we);
    const mins=overlapMinutes(wStart,wEnd,bw.startMin,bw.endMin);
    const hours=(ed.Hours!=="" ? Number(ed.Hours) : roundQuarterHours(mins));
    const present=(ed.Present||"YES");
    const workedStartOT = ed.WorkedStart||minToHHMM(wStart%1440);
    const workedEndOT = ed.WorkedEnd||minToHHMM(wEnd%1440);
    const row={emp:ot.emp, sen:"", shiftStr:"OT", role, present, hours, assignment:(ed.Assignment||""), workedStart:workedStartOT, workedEnd:workedEndOT, isOT:true};
    if(present==="NO") res.ABSENT.push(row);
    else if(present==="PARTIAL"){
      if(res[role]) res[role].push(row);
      const schedStartOT = Math.max(bw.startMin, ot.ws);
      const schedEndOT = Math.min(bw.endMin, ot.we);
      const schedHrsOT = roundQuarterHours(overlapMinutes(schedStartOT, schedEndOT, bw.startMin, bw.endMin));
      const actStartOT = minutesOf(workedStartOT);
      const actEndOT = minutesOf(workedEndOT);
      const missedHrsOT = Math.max(0, schedHrsOT - hours);
      let mStartOT, mEndOT;
      if(actStartOT > schedStartOT && actEndOT < schedEndOT){
        mStartOT = minToHHMM(schedStartOT%1440); mEndOT = minToHHMM(actStartOT%1440);
      } else if(actEndOT < schedEndOT){
        mStartOT = minToHHMM(actEndOT%1440); mEndOT = minToHHMM(schedEndOT%1440);
      } else if(actStartOT > schedStartOT){
        mStartOT = minToHHMM(schedStartOT%1440); mEndOT = minToHHMM(actStartOT%1440);
      } else { mStartOT = ""; mEndOT = ""; }
      res.ABSENT.push({emp:ot.emp, sen:"", shiftStr:"OT", role, present:"PARTIAL", hours:missedHrsOT, assignment:"", workedStart:mStartOT, workedEnd:mEndOT, isOT:true, isPartial:true});
    }
    else if(res[role]) res[role].push(row);
  }
  return res;
}


function renderRoleTable(iso, shift, block, role, rows){
  const key=ctxKey(iso,shift,block.id);
  const rolePlural = {
    "CALLTAKER":"CALLTAKERS",
    "DISPATCHER":"DISPATCHERS",
    "PIC":"PICs",
    "SUPERVISOR":"SUPERVISORS",
    "ABSENT":"ABSENT",
    "OTH":"OTHER"
  };
  const roleLabel = rolePlural[role] || role;
  const count=rows.length;

  const isAbsent = (role==="ABSENT");
  const seatOpts = isAbsent ? [] : (SEATS[role]||[]);
  let html = ``;

  html += `<div class="tblWrap"><table class="rosterTbl"><thead><tr>
    <th class="nameCol">Name</th>
    ${isAbsent ? "" : '<th class="ctrlCol roleCol">Role</th>'}
    <th class="ctrlCol seatCol">${isAbsent ? "Reason" : "Seat"}</th>
    <th class="ctrlCol workedCol">${isAbsent ? "Missed" : "Worked"}</th>
    <th class="ctrlCol hrsCol">Hrs</th>
    <th class="ctrlCol presCol">PRESENT</th>
    <th style="width:16px;max-width:16px;padding:0"></th>
  </tr></thead><tbody>`;

  for(const r of rows){
    const ed=ensureEdit(key,r.emp);
    const roleNorm=normalizeRole(ed.Role||r.role);
    const seat=ed.Assignment||r.assignment||"";
    const ws = r.isPartial ? r.workedStart : (ed.WorkedStart||r.workedStart);
    const we = r.isPartial ? r.workedEnd : (ed.WorkedEnd||r.workedEnd);
    const hrs = r.isPartial ? r.hours : (ed.Hours!==""?Number(ed.Hours):r.hours);
    const present=ed.Present||r.present||"YES";
    const absReason = r.isPartial ? (ed.PartialReason || "") : (ed.AbsenceReason || "");
    const cmtKey = r.isPartial ? key+'|'+r.emp+'|PARTIAL' : key+'|'+r.emp;

    const rowBg = r.isOT ? " style='background:rgba(180,180,200,0.12)'" : "";

    const thirdCol = isAbsent
      ? (r.isPartial
        ? `<select class="absReasonSel" onchange="setPartialReason('${esc(key)}','${esc(r.emp)}', this.value)">
             <option value=""${absReason===""?" selected":""}>—</option>
             ${ABSENT_REASONS.map(x=>`<option value="${esc(x)}"${absReason===x?" selected":""}>${esc(x)}</option>`).join("")}
           </select>`
        : `<select class="absReasonSel" onchange="setAbsenceReason('${esc(key)}','${esc(r.emp)}', this.value)">
             <option value=""${absReason===""?" selected":""}>—</option>
             ${ABSENT_REASONS.map(x=>`<option value="${esc(x)}"${absReason===x?" selected":""}>${esc(x)}</option>`).join("")}
           </select>`)
      : `<select class="seatSel" onchange="setSeatVal('${esc(key)}','${esc(r.emp)}', this.value)">
           ${renderSeatOptions(seatOpts, seat)}
         </select>`;

    html += `<tr${rowBg}>
      <td class="nameCol">${r.isOT?`<span class="otNameWrap"><span class="empName">${esc(r.emp)}</span><span class="otBadge otBadgeTop">OT</span></span>`:`<span class="empName">${esc(r.emp)}</span>`}${r.isPartial?`<span class="otBadge" style="background:#e67e22">P</span>`:""}</td>
      ${isAbsent ? "" : `<td class="ctrlCell roleCol">
        <select class="roleSel" onchange="setRoleVal('${esc(key)}','${esc(r.emp)}', this.value)">
          ${renderRoleOptions(roleNorm)}
        </select>
      </td>`}
      <td class="ctrlCell seatCol">${thirdCol}</td>
      <td class="ctrlCell workedCol">
        ${r.isPartial
          ? `<span class="rowPill">${shortWorked(ws,we)}</span>`
          : `<span class="rowPill editable" onclick="openTimeEdit(this,event)">${shortWorked(ws,we)}</span>
        <span class="timeEdit">
          <input type="time" value="${esc(ws)}" data-timekey="${esc(key)}" data-timeemp="${esc(r.emp)}" data-timefield="WorkedStart" data-timeorig="${esc(ws)}"/>
          <input type="time" value="${esc(we)}" data-timekey="${esc(key)}" data-timeemp="${esc(r.emp)}" data-timefield="WorkedEnd" data-timeorig="${esc(we)}"/>
        </span>`}
      </td>
      <td class="ctrlCell hrsCol">${r.isPartial
        ? hrs
        : `<input class="hrsIn" type="number" step="0.25" value="${hrs}" data-hrskey="${esc(key)}" data-hrsemp="${esc(r.emp)}" data-hrsorig="${hrs}"/>`}</td>
      <td class="ctrlCell presCol">
        ${r.isPartial ? `<span style="font-size:14px;color:#e67e22;font-weight:900;letter-spacing:.04em">PARTIAL</span>` : `<select class="presentSel${present==="PARTIAL"?" partial-ring":""}" onchange="setPresent('${esc(key)}','${esc(r.emp)}', this.value)">
          <option value="YES"${present==="YES"?" selected":""}>YES</option>
          <option value="PARTIAL"${present==="PARTIAL"?" selected":""}>PARTIAL</option>
          <option value="NO"${present==="NO"?" selected":""}>NO</option>
        </select>`}
      </td>
      <td style="width:16px;max-width:16px;padding:0 2px;text-align:center"><button class="cmt-btn${(rowComments[cmtKey]||'').trim()?` has-cmt`:``}" title="Comment">&#128172;</button></td>
    </tr>
    <tr class="cmt-row${(rowComments[cmtKey]||'').trim()?' open':''}">
      <td colspan="${isAbsent?7:8}"><div class="cmt-inner"><textarea data-cmtkey="${esc(cmtKey)}" placeholder="Comment…">${esc(rowComments[cmtKey]||'')}</textarea>${r.isOT?`<button class="otRemoveBtn" onclick="removeOT('${esc(key)}','${esc(r.emp)}')">Remove OT</button>`:''}</div></td>
    </tr>`;
  }

  html += "</tbody></table></div>";
  return html;
}

function renderOthTable(iso, shift, block, rows){
  const key=ctxKey(iso,shift,block.id);
  const count=rows.length;

  let html = `<div class="tblWrap"><table class="rosterTbl"><thead><tr>
    <th class="nameCol">Name</th>
    <th class="ctrlCol roleCol">Role</th>
    <th class="ctrlCol seatCol">Reason</th>
    <th class="ctrlCol workedCol">Worked</th>
    <th class="ctrlCol hrsCol">Hrs</th>
    <th class="ctrlCol presCol">PRESENT</th>
    <th style="width:16px;max-width:16px;padding:0"></th>
  </tr></thead><tbody>`;

  for(const r of rows){
    const ed=ensureEdit(key,r.emp);
    const roleNorm=normalizeRole(ed.Role||r.role);
    const ws = r.isPartial ? r.workedStart : (ed.WorkedStart||r.workedStart);
    const we = r.isPartial ? r.workedEnd : (ed.WorkedEnd||r.workedEnd);
    const hrs = r.isPartial ? r.hours : (ed.Hours!==""?Number(ed.Hours):r.hours);
    const present=ed.Present||r.present||"YES";
    const othType = ed.OthType || "";
    const cmtKey = r.isPartial ? key+'|'+r.emp+'|PARTIAL' : key+'|'+r.emp;

    const rowBg = r.isOT ? " style='background:rgba(180,180,200,0.12)'" : "";

    html += `<tr${rowBg}>
      <td class="nameCol">${r.isOT?`<span class="otNameWrap"><span class="empName">${esc(r.emp)}</span><span class="otBadge otBadgeTop">OT</span></span>`:`<span class="empName">${esc(r.emp)}</span>`}${r.isPartial?`<span class="otBadge" style="background:#e67e22">P</span>`:""}</td>
      <td class="ctrlCell roleCol">
        <select class="roleSel" onchange="setRoleVal('${esc(key)}','${esc(r.emp)}', this.value)">
          ${renderRoleOptions(roleNorm)}
        </select>
      </td>
      <td class="ctrlCell seatCol">
        <select class="othTypeSel" onchange="setOthType('${esc(key)}','${esc(r.emp)}', this.value)">
          <option value=""${othType===""?" selected":""}>—</option>
          <option value="SD"${othType==="SD"?" selected":""}>SD</option>
          <option value="TRN"${othType==="TRN"?" selected":""}>TRN</option>
          <option value="B"${othType==="B"?" selected":""}>B</option>
          <option value="ADM"${othType==="ADM"?" selected":""}>ADM</option>
        </select>
      </td>
      <td class="ctrlCell workedCol">
        ${r.isPartial
          ? `<span class="rowPill">${shortWorked(ws,we)}</span>`
          : `<span class="rowPill editable" onclick="openTimeEdit(this,event)">${shortWorked(ws,we)}</span>
        <span class="timeEdit">
          <input type="time" value="${esc(ws)}" data-timekey="${esc(key)}" data-timeemp="${esc(r.emp)}" data-timefield="WorkedStart" data-timeorig="${esc(ws)}"/>
          <input type="time" value="${esc(we)}" data-timekey="${esc(key)}" data-timeemp="${esc(r.emp)}" data-timefield="WorkedEnd" data-timeorig="${esc(we)}"/>
        </span>`}
      </td>
      <td class="ctrlCell hrsCol">${r.isPartial
        ? hrs
        : `<input class="hrsIn" type="number" step="0.25" value="${hrs}" data-hrskey="${esc(key)}" data-hrsemp="${esc(r.emp)}" data-hrsorig="${hrs}"/>`}</td>
      <td class="ctrlCell presCol">
        ${r.isPartial ? `<span style="font-size:14px;color:#e67e22;font-weight:900;letter-spacing:.04em">PARTIAL</span>` : `<select class="presentSel${present==="PARTIAL"?" partial-ring":""}" onchange="setPresent('${esc(key)}','${esc(r.emp)}', this.value)">
          <option value="YES"${present==="YES"?" selected":""}>YES</option>
          <option value="PARTIAL"${present==="PARTIAL"?" selected":""}>PARTIAL</option>
          <option value="NO"${present==="NO"?" selected":""}>NO</option>
        </select>`}
      </td>
      <td style="width:16px;max-width:16px;padding:0 2px;text-align:center"><button class="cmt-btn${(rowComments[cmtKey]||'').trim()?` has-cmt`:``}" title="Comment">&#128172;</button></td>
    </tr>
    <tr class="cmt-row${(rowComments[cmtKey]||'').trim()?' open':''}">
      <td colspan="7"><div class="cmt-inner"><textarea data-cmtkey="${esc(cmtKey)}" placeholder="Comment…">${esc(rowComments[cmtKey]||'')}</textarea>${r.isOT?`<button class="otRemoveBtn" onclick="removeOT('${esc(key)}','${esc(r.emp)}')">Remove OT</button>`:''}</div></td>
    </tr>`;
  }

  html += "</tbody></table></div>";
  return html;
}

function setOthType(key, emp, val){
  const ed=ensureEdit(key,emp);
  ed.OthType=val;
  renderCard(key);
}

function renderRoleOptions(selected){
  const opts=[
    ["CALLTAKER","CT"],
    ["DISPATCHER","DP"],
    ["PIC","PIC"],
    ["SUPERVISOR","SUP"],
    ["OTH","OTH"],
  ];
  return opts.map(([v,t])=>`<option value="${v}"${v===selected?" selected":""}>${t}</option>`).join("");
}
function renderSeatOptions(opts, selected){
  const cur=String(selected||"");
  const top = `<option value=""${cur===""?" selected":""}>—</option>`;
  const rest = (opts||[]).map(v=>{
    const s=String(v||"");
    return `<option value="${esc(s)}"${s===cur?" selected":""}>${esc(s)}</option>`;
  }).join("");
  return top+rest;
}
function shortWorked(ws, we){
  const fmt=(t)=>{
    const [hh,mm]=String(t||"00:00").split(":");
    let h=parseInt(hh,10);
    const m=parseInt(mm||"0",10);
    const h12=((h+11)%12)+1;
    return h12+(m?":"+pad2(m):"");
  };
  return fmt(ws)+"-"+fmt(we);
}

// ===== Per-block Add OT / Extra =====
function renderAddOtBar(block){
  const empOptions = ['<option value="">Select employee…</option>'].concat(
    BASE_EMP.map(e=>`<option value="${esc(e.Employee)}">${esc(e.Employee.toUpperCase())}</option>`)
  ).join("");
  return `
    <div class="otBar">
      <div class="otBarRow">
        <div class="mini">
          <label class="tag">Add OT (from roster)</label>
          <select id="otEmp_${block.id}">${empOptions}</select>
        </div>
        <div class="mini">
          <label class="tag">Or add Extra (type name)</label>
          <input id="otExtra_${block.id}" type="text" placeholder="Extra name"/>
        </div>
      </div>
      <div class="otBarRow">
        <div class="miniSm">
          <label class="tag">Role</label>
          <select id="otRole_${block.id}">
            <option value="CALLTAKER">CT</option>
            <option value="DISPATCHER">DP</option>
            <option value="PIC">PIC</option>
            <option value="SUPERVISOR">SUP</option>
            <option value="OTH">OTH</option>
          </select>
        </div>
        <div class="miniSm">
          <label class="tag">Segment</label>
          <select id="otSeg_${block.id}">
            <option value="4/4">4/4</option>
            <option value="1/2">1/2</option>
            <option value="2/2">2/2</option>
          </select>
        </div>
        <div class="miniSm">
          <button class="primary" onclick="addOTForBlock('${block.id}')">Add</button>
        </div>
      </div>
    </div>
  `;
}

function addOTForBlock(blockId){
  clearErr();
  const iso=document.getElementById("workDate").value;
  const shift=document.getElementById("shiftSel").value;
  if(!iso){ setErr("Pick Work date."); return; }

  const empSel=document.getElementById("otEmp_"+blockId);
  const roleSel=document.getElementById("otRole_"+blockId);
  const segSel=document.getElementById("otSeg_"+blockId);
  const extra=document.getElementById("otExtra_"+blockId);

  const chosen = (extra && extra.value.trim()) ? extra.value.trim() : (empSel?empSel.value:"");
  if(!chosen){ setErr("Pick an employee or type an Extra name."); return; }

  const role=roleSel?roleSel.value:"CALLTAKER";
  const seg=segSel?segSel.value:"4/4";
  const block=(shift==="NIGHT"?BLOCKS_NIGHT:BLOCKS_DAY).find(b=>b.id===blockId);
  const bw=blockWindowMinutes(block);

  let ws=bw.startMin, we=bw.endMin;
  if(seg==="1/2"){ we = ws + 120; }
  if(seg==="2/2"){ ws = ws + 120; }

  const key=ctxKey(iso,shift,blockId);
  const arr=OT_BY_CTX.get(key)||[];
  arr.push({emp:chosen, role:role, ws:ws, we:we, isOT:true});
  OT_BY_CTX.set(key,arr);

  // reset inputs
  if(extra) extra.value="";
  if(empSel) empSel.value="";
  renderAll();
  scheduleAutoSave();
}

function removeOT(key, emp){
  const arr = OT_BY_CTX.get(key)||[];
  const idx = arr.findIndex(o=>o.emp===emp);
  if(idx>=0) arr.splice(idx,1);
  OT_BY_CTX.set(key,arr);
  renderAll();
  scheduleAutoSave();
}

// ===== Edits =====
function openTimeEdit(pillEl, ev){
  if(ev){ ev.stopPropagation(); }

  // close any other open time editors
  document.querySelectorAll('.timeEdit.open').forEach(ed=>{
    ed.classList.remove('open');
    ed.style.display='none';
    const p = ed.parentElement && ed.parentElement.querySelector('.rowPill');
    if(p) p.style.display='inline-block';
  });

  const td=pillEl.parentElement;
  pillEl.style.display="none";
  const edit=td.querySelector(".timeEdit");
  if(!edit) return;
  edit.style.display="flex";
  edit.classList.add('open');
}
function setWorked(key, emp, field, val){
  const ed=ensureEdit(key,emp);
  ed[field]=val;

  // recalc hours based on overlap with block
  const [iso,shift,blockId]=key.split("|");
  const block=(shift==="NIGHT"?BLOCKS_NIGHT:BLOCKS_DAY).find(b=>b.id===blockId);
  const bw=blockWindowMinutes(block);
  let aS=minutesOf(ed.WorkedStart||block.start);
   let aE=minutesOf(ed.WorkedEnd||block.end);
   // For NIGHT shift, times after midnight must be treated as next-day minutes
   if(shift==="NIGHT"){
     const nightStart = 18*60;
     if(aS < nightStart) aS += 1440;
     if(aE < nightStart) aE += 1440;
   }
  if(shift==="NIGHT" && aE<=aS) aE+=1440;

  const mins=overlapMinutes(aS,aE,bw.startMin,bw.endMin);
  ed.Hours = String(roundQuarterHours(mins));

  // Auto-detect PARTIAL: if worked hours are less than full block scheduled hours
  const fullMins=overlapMinutes(bw.startMin,bw.endMin,bw.startMin,bw.endMin);
  if(ed.Present==="YES" && roundQuarterHours(mins) < roundQuarterHours(fullMins) && roundQuarterHours(mins) > 0){
    ed.Present="PARTIAL";
  }
  // Auto-revert to YES if hours restored to full
  if(ed.Present==="PARTIAL" && roundQuarterHours(mins) >= roundQuarterHours(fullMins)){
    ed.Present="YES";
    ed.PartialReason="";
  }
  renderAll(); // worked times affect staffing numbers across blocks
  scheduleAutoSave();
}
function setHours(key, emp, val){
  const ed=ensureEdit(key,emp);
  ed.Hours=String(val);
  renderCard(key);
  scheduleAutoSave();
}
function setPresent(key, emp, val){
  const ed=ensureEdit(key,emp);
  ed.Present=val;
  if(val==="NO") ed.Hours="0";
  if(val==="YES"){ ed.AbsenceReason=""; ed.PartialReason=""; }
  if(val==="PARTIAL") ed.AbsenceReason="";
  renderAll(); // employee moves between role card and ABSENT, affects staffing
  scheduleAutoSave();
}
function setRoleVal(key, emp, val){
  const ed=ensureEdit(key,emp);
  ed.Role=val;
  renderAll(); // role change moves rows and affects staffing counts per role
  scheduleAutoSave();
}
function setSeatVal(key, emp, val){
  const ed=ensureEdit(key,emp);
  ed.Assignment=val;
  renderCard(key);
  scheduleAutoSave();
}
function setAbsenceReason(key, emp, val){
  const ed=ensureEdit(key,emp);
  ed.AbsenceReason=val;
  renderCard(key);
  scheduleAutoSave();
}
function setPartialReason(key, emp, val){
  const ed=ensureEdit(key,emp);
  ed.PartialReason=val;
  renderCard(key);
  scheduleAutoSave();
}

// close time editors on click outside
document.addEventListener("click",(e)=>{
  const t=e.target;
  if(t.closest(".timeEdit") || t.type==="time") return;
  if(t.closest(".rowPill.editable")) return;
  if(t.closest(".customSel") || t.closest(".customSelMenu") || t.closest(".customSelBtn")) return;
  document.querySelectorAll(".timeEdit").forEach(el=>{ el.style.display="none"; });
  // show the pill back
  document.querySelectorAll(".rowPill.editable").forEach(el=>{ el.style.display="inline-block"; });
});

// ===== Prevent arrow keys from auto-selecting in dropdowns =====
document.addEventListener("keydown", function(e){
  const sel = e.target;
  if(sel.tagName==="SELECT" && (sel.classList.contains("roleSel") || sel.classList.contains("seatSel") || sel.classList.contains("presentSel") || sel.classList.contains("absReasonSel"))){
    if(e.key==="ArrowUp" || e.key==="ArrowDown"){
      e.preventDefault();
    }
  }
  // Shift+Enter on presentSel: toggle backwards (NO→PARTIAL→YES)
  if(sel.tagName==="SELECT" && sel.classList.contains("presentSel") && e.key==="Enter" && e.shiftKey){
    e.preventDefault();
    const order = ["YES","PARTIAL","NO"];
    const cur = sel.value;
    const idx = order.indexOf(cur);
    const prev = order[(idx - 1 + order.length) % order.length];
    sel.value = prev;
    sel.dispatchEvent(new Event("change"));
  }
});

// ===== Hours input: commit on Enter, revert on Escape =====
document.addEventListener("keydown", function(e){
  const inp = e.target;
  if(inp.classList.contains("hrsIn")){
    if(e.key === "Enter"){
      e.preventDefault();
      inp.blur();
      setHours(inp.dataset.hrskey, inp.dataset.hrsemp, inp.value);
    } else if(e.key === "Escape"){
      inp.value = inp.dataset.hrsorig;
      inp.blur();
    }
    return;
  }
  if(inp.dataset.timekey){
    if(e.key === "Enter"){
      e.preventDefault();
      inp.blur();
      setWorked(inp.dataset.timekey, inp.dataset.timeemp, inp.dataset.timefield, inp.value);
    } else if(e.key === "Escape"){
      inp.value = inp.dataset.timeorig;
      inp.blur();
    }
  }
});
// Hours input: also commit on blur if value changed
document.addEventListener("focusout", function(e){
  const inp = e.target;
  if(inp.classList.contains("hrsIn") && inp.dataset.hrskey){
    if(inp.value !== inp.dataset.hrsorig){
      setHours(inp.dataset.hrskey, inp.dataset.hrsemp, inp.value);
    }
    return;
  }
  if(inp.dataset.timekey){
    if(inp.value !== inp.dataset.timeorig){
      setWorked(inp.dataset.timekey, inp.dataset.timeemp, inp.dataset.timefield, inp.value);
    }
  }
}, true);

// ===== Render =====

function adeqGet(role, day, hk){
  // Tolerate hour keys stored as "0000" vs "000" vs 0 vs 100, etc.
  // hk is expected like "0000","0100","1200"...
  const node = (ADEQ && ADEQ[role] && ADEQ[role][day]) ? ADEQ[role][day] : null;
  if(!node) return undefined;

  const n = parseInt(hk, 10);
  const candidates = [];
  if(hk) candidates.push(hk);
  // "2400" is displayed for midnight but DB stores "0000" — try both
  if(hk === "2400"){ candidates.push("0000"); candidates.push("0"); }
  if(Number.isFinite(n)) candidates.push(String(n));          // "0","100","200"
  if(hk && hk.length === 4) candidates.push(hk.slice(0,3));  // "000","010"
  if(hk && hk.length === 4) candidates.push(hk.replace(/^0+/, '') || "0"); // "0","100"
  // Deduplicate and return first defined
  const seen = new Set();
  for(const k of candidates){
    if(k==null) continue;
    const kk = String(k);
    if(seen.has(kk)) continue;
    seen.add(kk);
    if(Object.prototype.hasOwnProperty.call(node, kk) && node[kk]!==undefined && node[kk]!==null && node[kk]!=="" ){
      return node[kk];
    }
  }
  return undefined;
}



function buildAdeqRowsForRole(iso, shift, block, role){
  const segs=hourSegments(block);
  const rows=computeRowsForBlock(iso, shift, block);
  const list=rows[role]||[];
  const counts=[0,0,0,0];

  for(const r of list){
    const key=ctxKey(iso,shift,block.id);
    const ed=ensureEdit(key,r.emp);
    const ws=ed.WorkedStart || r.workedStart;
    const we=ed.WorkedEnd || r.workedEnd;
    let aS=minutesOf(ws), aE=minutesOf(we);
     // For NIGHT shift, after-midnight times must be treated as next-day minutes
     if(shift==="NIGHT"){
       const nightStart = 18*60;
       if(aS < nightStart) aS += 1440;
       if(aE < nightStart) aE += 1440;
       if(aE <= aS) aE += 1440;
     }else{
       if(aE <= aS) aE += 1440;
     }

    const segsUse = (block.id==="2200-0200")
      ? [{start:1320,end:1380},{start:1380,end:1440},{start:1440,end:1500},{start:1500,end:1560}]
      : segs.map(s=>({start:s.start,end:s.end}));

    for(let i=0;i<4;i++){
      if(overlapMinutes(aS,aE,segsUse[i].start,segsUse[i].end)>0) counts[i]+=1;
    }
  }

  const hours = segs.map(s => {
    const m = s.start % 1440;
    if(s.start >= 1440 && m === 0) return "2400";
    return ((Math.floor(m/60))*100).toString().padStart(4,"0");
  });
   const d0 = dayNameFromISO(iso);
   const d1 = dayNameFromISO(addDaysISO(iso, 1));
   const out=[];
   for(let i=0;i<4;i++){
     const hk=hours[i];
     // For NIGHT shift, segments after midnight belong to NEXT calendar day for ADEQ lookup.
     const segStart = segs[i] && typeof segs[i].start==='number' ? segs[i].start : 0;
     const dUse = (shift==="NIGHT" && segStart>=1440) ? d1 : d0;
     const av = adeqGet(role, dUse, hk);
     const adeq = (av!==undefined) ? Number(av) : NaN;
    const sched = counts[i]||0;

    let stTxt="", stCls="";
    if(Number.isFinite(adeq)){
      if(sched < adeq){ stTxt=`SHORT ${adeq-sched}`; stCls="statusShort"; }
      else if(sched === adeq){ stTxt="STAFFED"; stCls="statusStaffed"; }
      else { stTxt=`OVER ${sched-adeq}`; stCls="statusOver"; }
    }
    out.push({hour:hk, adeq:(Number.isFinite(adeq)?adeq:""), sched, stTxt, stCls});
  }
  return out;
}

function renderAdequateBox(iso, shift, block){
  const roleDefs=[
    {key:"CALLTAKER", label:"Calltakers"},
    {key:"DISPATCHER", label:"Dispatchers"},
    {key:"PIC", label:"PIC"},
  ];

  const sLabel = String(shift||"").toUpperCase()==="DAY" ? "DAYS" : String(shift||"").toUpperCase()==="NIGHT" ? "NIGHTS" : String(shift||"").toUpperCase();

  let body = `<tr>
    <th style="width:22%">Hour</th><th style="width:22%">Adequate</th><th style="width:22%">Scheduled</th><th style="width:34%">Status</th>
  </tr>`;

  for(const rd of roleDefs){
    body += `<tr class="adeqSectionRow adeqRole-${rd.key}"><td colspan="4">
      <div class="adeqSectionLabel">${rd.label}</div>
      <div class="adeqDivider"></div>
    </td></tr>`;

    const rows = buildAdeqRowsForRole(iso, shift, block, rd.key);
    for(const r of rows){
      body += `<tr>
        <td class="adeqHour">${r.hour}</td>
        <td class="adeqHour">${r.adeq}</td>
        <td class="adeqHour">${r.sched}</td>
        <td class="mono">${r.stTxt?`<span class="${r.stCls}">${r.stTxt}</span>`:""}</td>
      </tr>`;
    }
  }

  return `<div class="adeqBox">
    <div class="adeqBoxHead">${sLabel} ${block.id}</div>
    <div class="adeqBoxSub">STAFFING NUMBERS</div>
    <table class="adeqTbl"><thead></thead><tbody>${body}</tbody></table>
  </div>`;
}


// ===== Custom Select (dropdown width = options only) =====
let __openCustomMenu = null;

function __measureTextPx(text, font){
  // Canvas is the most reliable way to measure option text widths
  const c = __measureTextPx._c || (__measureTextPx._c=document.createElement('canvas'));
  const ctx = c.getContext('2d');
  ctx.font = font || '12px system-ui';
  return Math.ceil(ctx.measureText(text).width);
}

/* Highlight option by index via keyboard — does NOT apply value yet */
function _kbHighlightOpt(menu, opts, idx){
  opts.forEach((o,i)=>{
    o.classList.toggle('kbHL', i===idx);
  });
  opts[idx].scrollIntoView({block:'nearest'});
}

function enhanceSelects(root=document){
  const selects = root.querySelectorAll('select.roleSel, select.seatSel, select.presentSel, select.absReasonSel, select.othTypeSel');
  selects.forEach(sel=>{
    if(sel.dataset.customized === "1") return;

    // Build wrapper + button + menu
    const wrap = document.createElement('span');
    wrap.className = 'customSel';
    const cs = getComputedStyle(sel);
    // Make button compact (don't inherit 100% table-cell width)
    if(sel.classList.contains('roleSel')) wrap.classList.add('customSel--role');
    if(sel.classList.contains('seatSel')) wrap.classList.add('customSel--seat');
    if(sel.classList.contains('presentSel')) wrap.classList.add('customSel--present');
    if(sel.classList.contains('absReasonSel')) wrap.classList.add('customSel--absreason');
    if(sel.classList.contains('othTypeSel')) wrap.classList.add('customSel--othtype');
    wrap.style.width = 'auto';

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'customSelBtn';
    btn.innerHTML = `<span class="lbl"></span><span class="car">▾</span>`;

    const menu = document.createElement('div');
    menu.className = 'customSelMenu';

    // compute dropdown width based on options
    const font = `${cs.fontWeight} ${cs.fontSize} ${cs.fontFamily}`;
    let maxW = 0;
    Array.from(sel.options).forEach(o=>{
      const t = (o.textContent || '').trim();
      maxW = Math.max(maxW, __measureTextPx(t, font));
    });
    // padding + menu chrome
    const menuW = Math.max(48, maxW + 28); // 28px for paddings/caret space
    menu.style.minWidth = menuW + 'px';
    menu.style.width = menuW + 'px';

    function syncLabel(){
      const opt = sel.options[sel.selectedIndex];
      const t = opt ? (opt.textContent||'').trim() : '';
      const lbl = btn.querySelector('.lbl');
      lbl.textContent = t;

      // show full value on hover and size the CLOSED button to the selected value (capped)
      btn.title = t;

      const fontNow = `${cs.fontWeight} ${cs.fontSize} ${cs.fontFamily}`;
      const textW = __measureTextPx(t, fontNow);

      // per-select caps so it never becomes "huge to the right"
      let min = 44, max = 120;
      if(sel.classList.contains('roleSel')){ min = 44; max = 56; }
      if(sel.classList.contains('presentSel')){ min = 90; max = 120; }
      if(sel.classList.contains('seatSel')){ min = 56; max = 140; }
      if(sel.classList.contains('absReasonSel')){ min = 90; max = 220; }
      if(sel.classList.contains('othTypeSel')){ min = 50; max = 70; }

      const w = Math.max(min, Math.min(max, textW + 34)); // +padding + caret
      btn.style.width = w + 'px';
    }

    function rebuildMenu(){
      menu.innerHTML = '';
      Array.from(sel.options).forEach(o=>{
        const optBtn = document.createElement('button');
        optBtn.type = 'button';
        optBtn.className = 'customSelOpt';
        optBtn.textContent = (o.textContent || '').trim();
        optBtn.setAttribute('aria-selected', o.selected ? 'true' : 'false');
        optBtn.addEventListener('click', ()=>{
          sel.value = o.value;
          // fire native change so existing logic runs (role change, seat change, etc.)
          try{
            if(typeof sel.onchange === 'function') sel.onchange.call(sel, new Event('change'));
          }catch(_e){}
          sel.dispatchEvent(new Event('change', {bubbles:true}));
          sel.dispatchEvent(new Event('input', {bubbles:true}));
          // update selected markers
          Array.from(menu.querySelectorAll('.customSelOpt')).forEach(b=>b.setAttribute('aria-selected','false'));
          optBtn.setAttribute('aria-selected','true');
          syncLabel();
          closeMenu();
        });
        menu.appendChild(optBtn);
      });
    }

    function closeMenu(){
      menu.classList.remove('open');
      menu.classList.remove('flipUp');
      menu.style.left = '';
      menu.style.top = '';
      menu.style.bottom = '';
      // drop row z-index (table stacking fix)
      const tr = wrap.closest('tr');
      if(tr){ tr.style.zIndex = ''; tr.classList.remove('rowMenuOpen'); }
      if(__openCustomMenu === menu) __openCustomMenu = null;
    }
    function openMenu(){
      if(__openCustomMenu && __openCustomMenu !== menu){
        __openCustomMenu.classList.remove('open');
        __openCustomMenu.classList.remove('flipUp');
        const prev = __openCustomMenu.closest('.customSel');
        if(prev){ const trPrev = prev.closest('tr'); if(trPrev){ trPrev.style.zIndex=''; trPrev.classList.remove('rowMenuOpen'); } }
      }
      rebuildMenu();
      syncLabel();
      btn._hlIdx = sel.selectedIndex;

      // reset positioning each time
      menu.classList.remove('flipUp');
      menu.style.position = 'fixed';
      menu.style.left = '0px';
      menu.style.top = '';
      menu.style.bottom = '';

      menu.classList.add('open');
      __openCustomMenu = menu;
      btn.focus();

      // raise row while menu is open (helps with table stacking contexts)
      const tr = wrap.closest('tr');
      if(tr){ tr.style.zIndex = '5000'; tr.classList.add('rowMenuOpen'); }

      // position fixed relative to button's viewport rect
      const btnRect = btn.getBoundingClientRect();
      const menuRect = menu.getBoundingClientRect();

      // Flip UP if there's not enough room below but there is room above
      const roomBelow = window.innerHeight - btnRect.bottom - 6;
      const roomAbove = btnRect.top;
      if(roomBelow < menuRect.height && roomAbove > (menuRect.height + 8)){
        menu.classList.add('flipUp');
        menu.style.top = (btnRect.top - menuRect.height - 4) + 'px';
      } else {
        menu.style.top = (btnRect.bottom + 4) + 'px';
      }

      // align left edge with button, prevent going off right edge
      let menuLeft = btnRect.left;
      const menuW = menu.getBoundingClientRect().width;
      if(menuLeft + menuW > window.innerWidth - 8){
        menuLeft = window.innerWidth - menuW - 8;
      }
      menu.style.left = Math.max(8, menuLeft) + 'px';
    }

    menu.addEventListener('mousedown', (e)=>{ e.preventDefault(); });
    // Single click behavior depends on selector type
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(menu.classList.contains('open')){
        closeMenu();
      } else if(sel.classList.contains('roleSel') || sel.classList.contains('presentSel')){
        // Role and Present selectors: open on single click
        openMenu();
      }
      // Other selectors: just focus for typing
    });
    // Double click: open the menu (for non-role selectors)
    btn.addEventListener('dblclick', (e)=>{
      e.stopPropagation();
      if(menu.classList.contains('open')) closeMenu();
      else openMenu();
    });

    /* Keyboard support for custom selects */
    /* Type preview: show what's typed + first match without committing */
    btn._typeBuffer = "";
    btn._showTypePreview = function(buf){
      const lbl = btn.querySelector('.lbl');
      if(!buf){
        syncLabel();
        btn.classList.remove('typing-mode');
        return;
      }
      btn.classList.add('typing-mode');
      // Exact match only on textContent or value
      const bufUp = buf.toUpperCase();
      const options = Array.from(sel.options);
      let matchIdx = options.findIndex(o => (o.textContent||"").trim().toUpperCase() === bufUp);
      if(matchIdx < 0) matchIdx = options.findIndex(o => (o.value||"").toUpperCase() === bufUp);

      if(matchIdx >= 0){
        const matchText = (options[matchIdx].textContent||"").trim();
        lbl.innerHTML = `<span style="color:var(--accent);font-weight:900">${matchText}</span>`;
      } else {
        lbl.innerHTML = `<span style="color:var(--bad);font-weight:900">${buf}?</span>`;
      }
    };

    btn.addEventListener('keydown', (e)=>{
      const isOpen = menu.classList.contains('open');
      if(e.key === 'Enter'){
        e.preventDefault();
        /* FIRST: Check for typed value - exact match only */
        if(btn._typeBuffer && btn._typeBuffer.length > 0){
          const typed = btn._typeBuffer.toUpperCase();
          const options = Array.from(sel.options);
          let optIdx = options.findIndex(o => (o.textContent||"").trim().toUpperCase() === typed);
          if(optIdx < 0) optIdx = options.findIndex(o => (o.value||"").toUpperCase() === typed);

          // Close menu if open
          if(isOpen) closeMenu();

          if(optIdx >= 0){
            // Calculate next field before changing DOM
            const selType = sel.classList.contains('seatSel') ? '.customSel--seat' :
                           sel.classList.contains('roleSel') ? '.customSel--role' :
                           sel.classList.contains('presentSel') ? '.customSel--present' :
                           sel.classList.contains('absReasonSel') ? '.customSel--absreason' :
                           sel.classList.contains('othTypeSel') ? '.customSel--othtype' : null;
            let nextIdx = -1;
            if(selType){
              const allOfType = Array.from(document.querySelectorAll(selType + ' .customSelBtn'));
              const idx = allOfType.indexOf(btn);
              if(idx >= 0 && idx < allOfType.length - 1) nextIdx = idx + 1;
            }

            sel.selectedIndex = optIdx;
            btn._typeBuffer = "";
            btn.classList.remove('typing-mode');
            const lbl = btn.querySelector('.lbl');
            if(lbl) lbl.textContent = (sel.options[optIdx].textContent||"").trim();

            // Schedule focus on next field
            if(selType && nextIdx >= 0){
              window.__pendingFocus = { selType: selType, idx: nextIdx };
            }

            sel.dispatchEvent(new Event('change', {bubbles:true}));
            return;
          }
          // No match - clear and stay
          btn._typeBuffer = "";
          btn.classList.remove('typing-mode');
          syncLabel();
          return;
        }
        /* SECOND: If menu open with highlighted item, click it */
        if(isOpen && btn._hlIdx >= 0){
          const opts = Array.from(menu.querySelectorAll('.customSelOpt'));
          if(opts[btn._hlIdx]){
            const selType2 = sel.classList.contains('seatSel') ? '.customSel--seat' :
                             sel.classList.contains('roleSel') ? '.customSel--role' :
                             sel.classList.contains('presentSel') ? '.customSel--present' :
                             sel.classList.contains('absReasonSel') ? '.customSel--absreason' :
                             sel.classList.contains('othTypeSel') ? '.customSel--othtype' : null;
            let nextIdx2 = -1;
            if(selType2){
              const allOfType2 = Array.from(document.querySelectorAll(selType2 + ' .customSelBtn'));
              const ci = allOfType2.indexOf(btn);
              if(ci >= 0 && ci < allOfType2.length - 1) nextIdx2 = ci + 1;
            }
            if(selType2 && nextIdx2 >= 0) window.__pendingFocus = { selType: selType2, idx: nextIdx2 };
            opts[btn._hlIdx].click();
            btn._hlIdx = -1;
            return;
          }
        }
        if(isOpen) closeMenu();
        /* Figure out which index to jump to BEFORE the DOM re-renders */
        const selType = sel.classList.contains('seatSel') ? '.customSel--seat' :
                        sel.classList.contains('roleSel') ? '.customSel--role' :
                        sel.classList.contains('presentSel') ? '.customSel--present' :
                        sel.classList.contains('absReasonSel') ? '.customSel--absreason' :
                        sel.classList.contains('othTypeSel') ? '.customSel--othtype' : null;
        let nextIdx = -1;
        if(selType){
          const allOfType = Array.from(document.querySelectorAll(selType + ' .customSelBtn'));
          const idx = allOfType.indexOf(btn);
          if(idx >= 0 && idx < allOfType.length - 1) nextIdx = idx + 1;
        }
        /* Schedule focus on next row after DOM re-renders (only if no pending match was processed) */
        if(selType && nextIdx >= 0){
          window.__pendingFocus = { selType: selType, idx: nextIdx };
        }
      } else if(e.key === ' '){
        e.preventDefault();
        if(isOpen) closeMenu(); else openMenu();
      } else if(e.key === 'Escape'){
        e.preventDefault();
        if(isOpen) closeMenu();
      } else if(e.key === 'ArrowDown' || e.key === 'ArrowRight'){
        e.preventDefault();
        if(isOpen){
          const opts = Array.from(menu.querySelectorAll('.customSelOpt'));
          if(!opts.length) return;
          if(btn._hlIdx == null) btn._hlIdx = -1;
          btn._hlIdx = Math.min(btn._hlIdx + 1, opts.length - 1);
          _kbHighlightOpt(menu, opts, btn._hlIdx);
          return;
        }
        if(sel.selectedIndex < sel.options.length - 1){
          sel.selectedIndex++;
          sel.dispatchEvent(new Event('change', {bubbles:true}));
          syncLabel();
        }
      } else if(e.key === 'ArrowUp' || e.key === 'ArrowLeft'){
        e.preventDefault();
        if(isOpen){
          const opts = Array.from(menu.querySelectorAll('.customSelOpt'));
          if(!opts.length) return;
          if(btn._hlIdx == null) btn._hlIdx = opts.length;
          btn._hlIdx = Math.max(btn._hlIdx - 1, 0);
          _kbHighlightOpt(menu, opts, btn._hlIdx);
          return;
        }
        if(sel.selectedIndex > 0){
          sel.selectedIndex--;
          sel.dispatchEvent(new Event('change', {bubbles:true}));
          syncLabel();
        }
      } else if(e.key === 'Tab'){
        if(isOpen) closeMenu();
      } else if(e.key === 'Backspace'){
        /* Allow correcting typed buffer */
        e.preventDefault();
        if(!btn._typeBuffer) btn._typeBuffer = "";
        btn._typeBuffer = btn._typeBuffer.slice(0, -1);
        btn._showTypePreview(btn._typeBuffer);
      } else if(e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey){
        /* Type-to-search: show preview but don't auto-select */
        e.preventDefault();
        if(!btn._typeBuffer) btn._typeBuffer = "";
        if(!btn._typeClear) btn._typeClear = null;
        clearTimeout(btn._typeClear);
        btn._typeBuffer += e.key.toUpperCase();
        btn._showTypePreview(btn._typeBuffer);
        btn._typeClear = setTimeout(()=>{ btn._typeBuffer = ""; btn.classList.remove('typing-mode'); btn._showTypePreview(""); }, 2000);
      }
    });

    /* On blur: discard any uncommitted type buffer and restore label */
    btn.addEventListener('blur', ()=>{
      btn._typeBuffer = "";
      btn.classList.remove('typing-mode');
      const lbl = btn.querySelector('.lbl');
      if(lbl) lbl.style.opacity = "";
      syncLabel();
    });

    // Build DOM
    sel.parentNode.insertBefore(wrap, sel);
    wrap.appendChild(btn);
    wrap.appendChild(menu);
    wrap.appendChild(sel);

    // Hide native select but keep it for value + event handlers
    sel.style.display = 'none';
    sel.tabIndex = -1;
    sel.setAttribute('aria-hidden','true');
    sel.dataset.customized = "1";

    // Keep label in sync if code changes select value
    sel.addEventListener('change', ()=>{ syncLabel(); });

    syncLabel();
  });

  // one-time outside click handler
  if(!document.body.dataset.customSelBound){
    document.body.dataset.customSelBound = "1";
    document.addEventListener('click', (e)=>{
      // close any open custom menus if click is outside
      if(__openCustomMenu && !e.target.closest('.customSel')){
        __openCustomMenu.classList.remove('open');
        __openCustomMenu.classList.remove('flipUp');
        const prev = __openCustomMenu.closest('.customSel');
        if(prev){ const trPrev = prev.closest('tr'); if(trPrev){ trPrev.style.zIndex=''; trPrev.classList.remove('rowMenuOpen'); } }
        __openCustomMenu = null;
      }
      // close worked editors if click is outside the editor/pill
      if(!e.target.closest('.timeEdit') && !e.target.closest('.rowPill')){
        document.querySelectorAll('.timeEdit.open').forEach(ed=>{
          ed.classList.remove('open');
          ed.style.display='none';
          const p = ed.parentElement && ed.parentElement.querySelector('.rowPill');
          if(p) p.style.display='inline-block';
        });
      }
    });
    document.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape' && __openCustomMenu){
        __openCustomMenu.classList.remove('open');
        __openCustomMenu.classList.remove('flipUp');
        const prev = __openCustomMenu.closest('.customSel');
        if(prev){ const trPrev = prev.closest('tr'); if(trPrev){ trPrev.style.zIndex=''; trPrev.classList.remove('rowMenuOpen'); } }
        __openCustomMenu = null;
      }
      // Arrow keys handled by btn keydown handler via _kbSelectOpt
    });
  }
}


function updateUnfilledCount(){
  const pill = document.getElementById("pillUnfilled");
  if(!pill) return;
  try{
    const iso = document.getElementById("workDate").value;
    const shift = document.getElementById("shiftSel").value;
    const blocks = getBlocks();
    const blocksShown = (PANEL_VIEW==='all') ? blocks : blocks.filter(b=>b.id===PANEL_VIEW);
    if(!iso || !BASE_EMP.length){ pill.innerHTML="0 UNFILLED"; pill.className="pill good"; return; }

    let seats=0, reasons=0;
    for(const b of blocksShown){
      const key = ctxKey(iso, shift, b.id);
      const rows = computeRowsForBlock(iso, shift, b);
      // Unfilled seats: non-absent roles with empty assignment
      for(const role of ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR"]){
        for(const r of (rows[role]||[])){
          const ed = ensureEdit(key, r.emp);
          if(!(ed.Assignment||r.assignment||"")) seats++;
        }
      }
      // Unfilled absent reasons
      for(const r of (rows.ABSENT||[])){
        const ed = ensureEdit(key, r.emp);
        if(r.isPartial){
          if(!(ed.PartialReason||"")) reasons++;
        } else {
          if(!(ed.AbsenceReason||"")) reasons++;
        }
      }
    }
    const total = seats + reasons;
    const parts = [];
    if(seats) parts.push(seats+" seat"+(seats>1?"s":""));
    if(reasons) parts.push(reasons+" reason"+(reasons>1?"s":""));
    pill.innerHTML = total === 0 ? "0 UNFILLED" : `<span style="color:#ff4d4d;font-weight:900">${total}</span> UNFILLED!`;
    pill.title = total === 0 ? "All fields filled" : parts.join(", ");
    pill.className = total === 0 ? "pill good" : "pill bad";
    pill._unfilledMsg = total === 0 ? "All fields filled!" : "Unfilled: " + parts.join(", ");
  }catch(e){ console.warn("updateUnfilledCount:", e); }
}

document.addEventListener("click", function(e){
  const pill = e.target.closest("#pillUnfilled");
  if(pill && pill._unfilledMsg) alert(pill._unfilledMsg);
});

function renderAll(){
  clearErr();
  try{
    const iso=document.getElementById("workDate").value;
    const shift=document.getElementById("shiftSel").value;
    const blocks=getBlocks();
    const blocksShown = (PANEL_VIEW==='all') ? blocks : blocks.filter(b=>b.id===PANEL_VIEW);
    const grid=document.getElementById("blocks");

    if(!iso || !BASE_EMP.length){
      grid.innerHTML = "";
      return;
    }

    grid.classList.add("boardGrid");
    document.body.classList.toggle('singlePanel', PANEL_VIEW!=='all');

    // Compute once per block
    const rowsByBlock = {};
    for(const b of blocks){
      rowsByBlock[b.id] = computeRowsForBlock(iso, shift, b);
    }

    const sections = [
      {title:"Adequate Staffing", role:"adeq", render:(b)=>`<div class="section">${renderAdequateBox(iso, shift, b)}</div>`, getTitle:(b)=>"STAFFING NUMBERS"},
      {title:"Calltakers", role:"CALLTAKER", render:(b)=>renderRoleTable(iso, shift, b, "CALLTAKER", rowsByBlock[b.id].CALLTAKER), getTitle:(b)=>`CALLTAKERS: ${(rowsByBlock[b.id].CALLTAKER||[]).length}`},
      {title:"Dispatchers", role:"DISPATCHER", render:(b)=>renderRoleTable(iso, shift, b, "DISPATCHER", rowsByBlock[b.id].DISPATCHER), getTitle:(b)=>`DISPATCHERS: ${(rowsByBlock[b.id].DISPATCHER||[]).length}`},
      {title:"PIC", role:"PIC", render:(b)=>renderRoleTable(iso, shift, b, "PIC", rowsByBlock[b.id].PIC), getTitle:(b)=>`PIC: ${(rowsByBlock[b.id].PIC||[]).length}`},
      {title:"SUP", role:"SUPERVISOR", render:(b)=>renderRoleTable(iso, shift, b, "SUPERVISOR", rowsByBlock[b.id].SUPERVISOR), getTitle:(b)=>`SUPERVISORS: ${(rowsByBlock[b.id].SUPERVISOR||[]).length}`},
      {title:"OUT", role:"ABSENT", render:(b)=>renderRoleTable(iso, shift, b, "ABSENT", rowsByBlock[b.id].ABSENT), getTitle:(b)=>`ABSENT: ${(rowsByBlock[b.id].ABSENT||[]).length}`},
      {title:"OTHER", role:"OTH", render:(b)=>renderOthTable(iso, shift, b, rowsByBlock[b.id].OTH), getTitle:(b)=>`OTHER: ${(rowsByBlock[b.id].OTH||[]).length}`},
      {title:"OT / Extra", role:"ot", render:(b)=>`<div class="section">${renderAddOtBar(b)}</div>`, getTitle:(b)=>"OT / EXTRA"},
    ];

    const shiftLabel = (s)=>{
      const up = String(s||"").toUpperCase();
      // normalize DAY/NIGHT into plural DAYS/NIGHTS
      if (up === "DAY") return "DAYS";
      if (up === "NIGHT") return "NIGHTS";
      if (up.endsWith("S")) return up;
      return up + "S";
    };

    const makeCell=(b, sec, colIdx, rowIdx)=>{
      const isFirst = (rowIdx === 1);
      const hdrText = isFirst ? `${shiftLabel(shift)} ${b.id}` : sec.getTitle(b);
      return `
      <div class="card boardCard roleCard-${sec.role}" data-role="${sec.role}" data-block="${b.id}" style="grid-column:${colIdx}; grid-row:${rowIdx};">
        <h2 class="blockHdr">${hdrText}</h2>
        ${sec.render(b)}
      </div>
    `;
    };

    let out="";
    blocksShown.forEach((b, bi)=>{
      const col = bi+1;
      sections.forEach((sec, si)=>{
        const row = si+1;
        out += makeCell(b, sec, col, row);
      });
    });
    grid.innerHTML = out;
    enhanceSelects(grid);

    // Update absent count bar in footer — match grid columns to blocks
    const absentBar = document.getElementById("absentBar");
    if(absentBar){
      absentBar.style.gridTemplateColumns = `repeat(${blocksShown.length}, minmax(520px, 1fr))`;
      let abHtml = "";
      for(const b of blocksShown){
        const cnt = (rowsByBlock[b.id].ABSENT||[]).length;
        const cls = cnt === 0 ? "absentPill zero" : "absentPill";
        let otCnt = 0;
        for(const role of ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR","ABSENT","OTH"]){
          for(const r of (rowsByBlock[b.id][role]||[])) if(r.isOT) otCnt++;
        }
        const otCls = otCnt === 0 ? "absentPill zero" : "absentPill otPill";
        abHtml += `<div class="absentCell"><span class="${cls}"><span class="absentCount">${cnt} ABSENT</span></span><span class="${otCls}"><span class="absentCount">${otCnt} OT</span></span></div>`;
      }
      absentBar.innerHTML = abHtml;
    }

    updateUnfilledCount();

  }catch(err){
    console.error(err);
    setErr("Render failed: " + (err && err.message ? err.message : err));
  }
}

/* Targeted single-card re-render for fast edits */
function renderCard(ctxKeyStr){
  try{
    const [iso, shift, blockId] = ctxKeyStr.split("|");
    const blocks = getBlocks();
    const b = blocks.find(x=>x.id===blockId);
    if(!b) return renderAll();

    const rowsByBlock = computeRowsForBlock(iso, shift, b);

    const sectionDefs = [
      {role:"adeq", render:()=>`<div class="section">${renderAdequateBox(iso, shift, b)}</div>`, getTitle:()=>"STAFFING NUMBERS"},
      {role:"CALLTAKER", render:()=>renderRoleTable(iso, shift, b, "CALLTAKER", rowsByBlock.CALLTAKER), getTitle:()=>`CALLTAKERS: ${(rowsByBlock.CALLTAKER||[]).length}`},
      {role:"DISPATCHER", render:()=>renderRoleTable(iso, shift, b, "DISPATCHER", rowsByBlock.DISPATCHER), getTitle:()=>`DISPATCHERS: ${(rowsByBlock.DISPATCHER||[]).length}`},
      {role:"PIC", render:()=>renderRoleTable(iso, shift, b, "PIC", rowsByBlock.PIC), getTitle:()=>`PIC: ${(rowsByBlock.PIC||[]).length}`},
      {role:"SUPERVISOR", render:()=>renderRoleTable(iso, shift, b, "SUPERVISOR", rowsByBlock.SUPERVISOR), getTitle:()=>`SUPERVISORS: ${(rowsByBlock.SUPERVISOR||[]).length}`},
      {role:"ABSENT", render:()=>renderRoleTable(iso, shift, b, "ABSENT", rowsByBlock.ABSENT), getTitle:()=>`ABSENT: ${(rowsByBlock.ABSENT||[]).length}`},
      {role:"OTH", render:()=>renderOthTable(iso, shift, b, rowsByBlock.OTH), getTitle:()=>`OTHER: ${(rowsByBlock.OTH||[]).length}`},
      {role:"ot", render:()=>`<div class="section">${renderAddOtBar(b)}</div>`, getTitle:()=>"OT / EXTRA"},
    ];

    const grid = document.getElementById("blocks");
    for(const sec of sectionDefs){
      const card = grid.querySelector(`[data-block="${blockId}"][data-role="${sec.role}"]`);
      if(!card) continue;
      const hdr = card.querySelector("h2.blockHdr");
      if(hdr) hdr.textContent = sec.getTitle();
      // Replace content after header
      const newContent = sec.render();
      const wrapper = document.createElement("div");
      wrapper.innerHTML = newContent;
      // Remove everything after the h2
      while(hdr.nextSibling) card.removeChild(hdr.nextSibling);
      while(wrapper.firstChild) card.appendChild(wrapper.firstChild);
      enhanceSelects(card);
    }

    // Update absent count in footer for all visible blocks
    const absentBar = document.getElementById("absentBar");
    if(absentBar){
      const blocksShown = (PANEL_VIEW==='all') ? blocks : blocks.filter(x=>x.id===PANEL_VIEW);
      absentBar.style.gridTemplateColumns = `repeat(${blocksShown.length}, minmax(520px, 1fr))`;
      let abHtml = "";
      for(const blk of blocksShown){
        const rr = computeRowsForBlock(iso, shift, blk);
        const cnt = (rr.ABSENT||[]).length;
        const cls = cnt === 0 ? "absentPill zero" : "absentPill";
        let otCnt = 0;
        for(const role of ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR","ABSENT","OTH"]){
          for(const r of (rr[role]||[])) if(r.isOT) otCnt++;
        }
        const otCls = otCnt === 0 ? "absentPill zero" : "absentPill otPill";
        abHtml += `<div class="absentCell"><span class="${cls}"><span class="absentCount">${cnt} ABSENT</span></span><span class="${otCls}"><span class="absentCount">${otCnt} OT</span></span></div>`;
      }
      absentBar.innerHTML = abHtml;
    }
    updateUnfilledCount();
  }catch(err){
    console.error("renderCard fallback:", err);
    renderAll();
  }
}

// ===== Row comment toggle & save (event delegation) =====
document.addEventListener("click", function(e){
  const btn = e.target.closest(".cmt-btn");
  if(btn){
    const row = btn.closest("tr").nextElementSibling;
    if(row && row.classList.contains("cmt-row")) row.classList.toggle("open");
    return;
  }
  // Close all open comment rows when clicking outside a comment row or its button
  if(!e.target.closest(".cmt-row") && !e.target.closest(".cmt-btn")){
    document.querySelectorAll(".cmt-row.open").forEach(function(r){ r.classList.remove("open"); });
  }
});
document.addEventListener("input", function(e){
  if(!e.target.dataset.cmtkey) return;
  rowComments[e.target.dataset.cmtkey] = e.target.value;
  // Update the comment button color
  const cmtRow = e.target.closest(".cmt-row");
  if(cmtRow && cmtRow.previousElementSibling){
    const btn = cmtRow.previousElementSibling.querySelector(".cmt-btn");
    if(btn) btn.classList.toggle("has-cmt", e.target.value.trim().length > 0);
  }
  scheduleAutoSave();
});

// ===== Wire up controls =====

function updatePanelViewOptions(){
  const pv = document.getElementById("panelViewSel");
  const sh = document.getElementById("shiftSel");
  if(!pv || !sh) return;
  const shift = sh.value || "DAY";
  const blocks = getBlocks(); // uses shiftSel internally
  const prev = pv.value || "all";

  // Rebuild options: All + the 3 blocks for current shift
  pv.innerHTML = "";
  const optAll = document.createElement("option");
  optAll.value = "all";
  optAll.textContent = "All 3 blocks";
  pv.appendChild(optAll);

  for(const b of blocks){
    const o = document.createElement("option");
    o.value = b.id;
    o.textContent = b.id; // keep same style as Day Shift
    pv.appendChild(o);
  }

  // Restore previous selection if valid, else All
  const valid = Array.from(pv.options).some(o=>o.value===prev);
  pv.value = valid ? prev : "all";
  PANEL_VIEW = pv.value; // keep global in sync
}

document.getElementById("shiftSel").addEventListener("change", async ()=>{
  updatePanelViewOptions();
  // Load saved edits from Firebase for this date/shift
  const iso = document.getElementById("workDate").value;
  const shift = document.getElementById("shiftSel").value;
  if(iso && shift) await loadEditsFromFirebase(iso, shift);
  startRealtimeSync(iso, shift);
  renderAll();
});
document.getElementById("panelViewSel").addEventListener("change", (e)=>{PANEL_VIEW=e.target.value; renderAll();});
// Pay period generator: PP3 starts 2026-01-10, each PP = 14 days
function generatePayPeriods(){
  const PP3_START = new Date(2026, 0, 10);
  const periods = [];
  for(let i = 0; i < 50; i++){
    const ppNum = 3 + i;
    const start = new Date(PP3_START.getTime() + i * 14 * 86400000);
    const end = new Date(start.getTime() + 13 * 86400000);
    const fmt = d => `${String(d.getMonth()+1).padStart(2,'0')}/${String(d.getDate()).padStart(2,'0')}`;
    const yr = d => String(d.getFullYear()).slice(-2);
    periods.push({ num: ppNum, start, end, label: `PP${ppNum}: ${fmt(start)}-${fmt(end)}` });
  }
  return periods;
}
const PAY_PERIODS = generatePayPeriods();

function buildDaySel(){
  const daySel = document.getElementById("daySel");
  if(!daySel) return;
  daySel.innerHTML = "";
  const ppVal = document.getElementById("ppSel").value;
  const wk = parseInt(document.getElementById("weekSel").value) || 1;
  if(!ppVal) return;
  const ppStart = new Date(ppVal + "T00:00:00");
  const DAYS = ["Saturday","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday"];
  const offset = (wk - 1) * 7;
  for(let d = 0; d < 7; d++){
    const date = new Date(ppStart.getTime() + (offset + d) * 86400000);
    const iso = toISODate(date);
    const mm = String(date.getMonth()+1).padStart(2,'0');
    const dd = String(date.getDate()).padStart(2,'0');
    const o = document.createElement("option");
    o.value = iso;
    o.textContent = `${DAYS[d]} ${mm}/${dd}`;
    daySel.appendChild(o);
  }
}

async function applyDaySelection(){
  const iso = document.getElementById("daySel").value;
  if(!iso) return;
  document.getElementById("workDate").value = iso;
  const d = new Date(iso + "T00:00:00");
  const satOff = (d.getDay() + 1) % 7;
  const sat = new Date(d.getTime() - satOff * 86400000);
  document.getElementById("weekStart").value = toISODate(sat);
  updateWorkDateLabel();
  // Load saved edits from Firebase for this date/shift
  const shift = document.getElementById("shiftSel").value;
  await loadEditsFromFirebase(iso, shift);
  startRealtimeSync(iso, shift);
  renderAll();
}

function updateWorkDateLabel(){
  const el = document.getElementById("workDate");
  const disp = document.getElementById("workDateDisplay");
  if(!el || !disp) return;
  if(!el.value){ disp.textContent=""; return; }
  const parts = el.value.split("-");
  const d = new Date(+parts[0], +parts[1]-1, +parts[2]);
  const days = ["SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"];
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  const yy = String(d.getFullYear()).slice(-2);
  disp.textContent = `— ${days[d.getDay()]} ${mm}/${dd}/${yy}`;
}

document.getElementById("dbFile").addEventListener("change", async (e)=>{
  clearErr();
  const f=e.target.files && e.target.files[0];
  if(!f) return;
  try{
    const buf = await f.arrayBuffer();
    /* Cache to localStorage as base64 */
    try {
      const bytes = new Uint8Array(buf);
      let bin = "";
      for(let i=0;i<bytes.length;i++) bin += String.fromCharCode(bytes[i]);
      localStorage.setItem("sheetops_db", btoa(bin));
    } catch(cacheErr){ console.warn("Cache save failed:", cacheErr); }
    const wb=loadWorkbook(buf);
    parseDatabase(wb);
    renderAll();
  }catch(err){
    console.error(err);
    setErr("DB load failed: "+(err && err.message ? err.message : err));
  }
});

document.getElementById("btnImport").addEventListener("click", ()=>{
  document.getElementById("teamsFile").click();
});
document.getElementById("teamsFile").addEventListener("change", async ()=>{
  const f=document.getElementById("teamsFile").files && document.getElementById("teamsFile").files[0];
  if(!f) return;
  try{
    await importTeamsWeek(f);
    renderAll();
    scheduleAutoSave();
  }catch(err){
    console.error(err);
    setErr("Teams import failed: "+(err && err.message ? err.message : err));
  }
  document.getElementById("teamsFile").value="";
});

/* === v190: Save current edits to Excel (XLSX export) === */
function buildExportRowsForCurrent(){
  const iso = document.getElementById("workDate").value;
  const shift = document.getElementById("shiftSel").value;
  const blocks = getBlocks();

  const out = [];
  for(const b of blocks){
    const ctx = ctxKey(iso, shift, b.id);
    const rowsByRole = computeRowsForBlock(iso, shift, b);

    for(const role of ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR","ABSENT","OTH"]){
      const rows = rowsByRole[role] || [];
      for(const r of rows){
        const ed = ensureEdit(ctx, r.emp);
        out.push({
          Date: iso,
          Shift: shift,
          Block: b.label,
          Role: role,
          Employee: r.isPartial ? r.emp + " (P)" : r.emp,
          Seniority: r.sen,
          Present: (ed.Present || r.present || "YES"),
          Hours: r.isPartial ? r.hours : (ed.Hours!=="" ? Number(ed.Hours) : r.hours),
          Seat: role==="OTH" ? (ed.OthType || "") : (ed.Assignment || r.assignment || ""),
          WorkedStart: r.isPartial ? (r.workedStart||"") : (ed.WorkedStart || r.workedStart || ""),
          WorkedEnd: r.isPartial ? (r.workedEnd||"") : (ed.WorkedEnd || r.workedEnd || ""),
          AbsenceReason: r.isPartial ? (ed.PartialReason || "") : (ed.AbsenceReason || ""),
          IsOT: (r.isOT ? "YES" : "NO"),
          ScheduledShift: r.shiftStr,
          IsPartial: r.isPartial ? true : false
        });
      }
    }
  }
  return out;
}

function saveXlsx(){
  try{
    const iso = document.getElementById("workDate").value || "date";
    const shift = document.getElementById("shiftSel").value || "shift";
    const blocks = getBlocks();
    const wb = XLSX.utils.book_new();

    /* ---- Styles ---- */
    const border = {
      top:    {style:"thin", color:{rgb:"444444"}},
      bottom: {style:"thin", color:{rgb:"444444"}},
      left:   {style:"thin", color:{rgb:"444444"}},
      right:  {style:"thin", color:{rgb:"444444"}}
    };
    const sBlockHdr = {font:{bold:true,sz:9,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"1E3A5F"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const sSectionHdr = {font:{bold:true,sz:8,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"2D4A6F"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const sColHdr = {font:{bold:true,sz:7,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"3B5998"}}, alignment:{vertical:"center"}, border:border};
    const sNormal = {font:{sz:8}, alignment:{vertical:"center"}, border:border};
    const sRoleCalltaker = {font:{bold:true,sz:8,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"1A5276"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const sRoleDispatcher = {font:{bold:true,sz:8,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"4A235A"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const sRolePIC = {font:{bold:true,sz:8,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"0E6655"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const sRoleSupervisor = {font:{bold:true,sz:8,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"7D6608"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const sRoleAbsent = {font:{bold:true,sz:8,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"922B21"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const sStatusShort = {font:{bold:true,sz:8,color:{rgb:"CC0000"}}, fill:{fgColor:{rgb:"FFF0F0"}}, alignment:{vertical:"center"}, border:border};
    const sStatusGood = {font:{bold:true,sz:8,color:{rgb:"806600"}}, fill:{fgColor:{rgb:"FFFDE6"}}, alignment:{vertical:"center"}, border:border};
    const sStatusOver = {font:{bold:true,sz:8,color:{rgb:"007744"}}, fill:{fgColor:{rgb:"E6FFF5"}}, alignment:{vertical:"center"}, border:border};
    const sAdeqHdr = {font:{bold:true,sz:7,color:{rgb:"333333"}}, fill:{fgColor:{rgb:"D6E4F0"}}, alignment:{vertical:"center"}, border:border};
    const sAdeqRow = {font:{sz:8,color:{rgb:"222222"}}, fill:{fgColor:{rgb:"EDF2F7"}}, alignment:{vertical:"center"}, border:border};
    const sRoleOth = {font:{bold:true,sz:8,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"6B7280"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const roleAbbr = {CALLTAKER:"CT",DISPATCHER:"DP",PIC:"PIC",SUPERVISOR:"SUP",ABSENT:"ABS",OTH:"OTH"};
    const roleHdrStyles = {CALLTAKER:sRoleCalltaker, DISPATCHER:sRoleDispatcher, PIC:sRolePIC, SUPERVISOR:sRoleSupervisor, ABSENT:sRoleAbsent, OTH:sRoleOth};
    const roleBgColors = {CALLTAKER:"E8F0FE", DISPATCHER:"F3E5F5", PIC:"E0F2F1", SUPERVISOR:"FFF8E1", ABSENT:"FDEDEC", OTH:"F3F4F6"};

    /* ---- Helper: write a value into a cell with style ---- */
    function setCell(ws, r, c, val, style){
      const ref = XLSX.utils.encode_cell({r:r, c:c});
      const cell = {v: val, t: typeof val === 'number' ? 'n' : 's'};
      if(style) cell.s = style;
      ws[ref] = cell;
    }

    /* ---- Helper: ensure sheet range covers r,c ---- */
    function expandRange(ws, r, c){
      if(!ws['!ref']){
        ws['!ref'] = XLSX.utils.encode_range({s:{r:0,c:0},e:{r:r,c:c}});
        return;
      }
      const range = XLSX.utils.decode_range(ws['!ref']);
      if(r > range.e.r) range.e.r = r;
      if(c > range.e.c) range.e.c = c;
      ws['!ref'] = XLSX.utils.encode_range(range);
    }

    const ws = {};
    const roles = ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR","ABSENT","OTH"];
    const blockCols = 6; // columns per block: Name, Role, Seat, Worked, Hrs, Present
    const totalCols = blocks.length * blockCols;
    const shiftLabel = shift === "NIGHT" ? "NIGHTS" : "DAYS";
    const dayName = dayNameFromISO(iso);
    const parts = iso.split("-");
    const dateStr = `${parts[1]}/${parts[2]}/${parts[0].slice(-2)}`;
    if(!ws['!merges']) ws['!merges'] = [];

    /* ---- Pass 1: compute section sizes per block to find max for alignment ---- */
    const allRowsByRole = {};
    const adeqRoleDefs = [{key:"CALLTAKER",label:"CT"},{key:"DISPATCHER",label:"DP"},{key:"PIC",label:"PIC"}];
    const allAdeqRows = {};
    for(const b of blocks){
      allRowsByRole[b.id] = computeRowsForBlock(iso, shift, b);
      allAdeqRows[b.id] = {};
      for(const rd of adeqRoleDefs){
        allAdeqRows[b.id][rd.key] = buildAdeqRowsForRole(iso, shift, b, rd.key);
      }
    }

    /* Staffing numbers height: header(1) + colHdr(1) + 3 roles * (subHdr(1) + rows) */
    let adeqHeight = 2; // "STAFFING NUMBERS" + column headers
    for(const rd of adeqRoleDefs){
      let maxRows = 0;
      for(const b of blocks){ maxRows = Math.max(maxRows, allAdeqRows[b.id][rd.key].length); }
      adeqHeight += 1 + maxRows; // subHdr + data rows
    }

    /* Role section heights: for each role, max across blocks of (hdr + colHdr + employees) */
    const roleSectionHeight = {};
    for(const role of roles){
      let maxH = 0;
      for(const b of blocks){
        const list = allRowsByRole[b.id][role] || [];
        if(list.length > 0) maxH = Math.max(maxH, 2 + list.length); // roleHdr + colHdr + rows
      }
      roleSectionHeight[role] = maxH;
    }

    /* ---- Pass 2: write aligned data ---- */
    let row = 0;

    /* Block headers - row 0 */
    blocks.forEach((b, bi) => {
      const cs = bi * blockCols;
      setCell(ws, row, cs, `${shiftLabel} ${b.id} ${dayName.slice(0,3).toUpperCase()} ${dateStr}`, sBlockHdr);
      for(let c=cs+1;c<cs+blockCols;c++) setCell(ws, row, c, "", sBlockHdr);
      ws['!merges'].push({s:{r:row,c:cs}, e:{r:row,c:cs+blockCols-1}});
      expandRange(ws, row, cs+blockCols-1);
    });
    row++;

    /* Staffing numbers */
    blocks.forEach((b, bi) => {
      const cs = bi * blockCols;
      setCell(ws, row, cs, "STAFFING NUMBERS", sSectionHdr);
      for(let c=cs+1;c<cs+blockCols;c++) setCell(ws, row, c, "", sSectionHdr);
      ws['!merges'].push({s:{r:row,c:cs}, e:{r:row,c:cs+blockCols-1}});
    });
    row++;

    blocks.forEach((b, bi) => {
      const cs = bi * blockCols;
      setCell(ws, row, cs, "Hr", sAdeqHdr);
      setCell(ws, row, cs+1, "Adeq", sAdeqHdr);
      setCell(ws, row, cs+2, "Sched", sAdeqHdr);
      setCell(ws, row, cs+3, "Stat", sAdeqHdr);
      for(let c=cs+4;c<cs+blockCols;c++) setCell(ws, row, c, "", sAdeqHdr);
    });
    row++;

    for(const rd of adeqRoleDefs){
      /* Sub-header row */
      const adeqSubHdr = {font:{bold:true,sz:10,color:{rgb:"1A3A5C"}}, fill:{fgColor:{rgb:"C8D8E8"}}, border:border};
      blocks.forEach((b, bi) => {
        const cs = bi * blockCols;
        setCell(ws, row, cs, rd.label, adeqSubHdr);
        for(let c=cs+1;c<cs+blockCols;c++) setCell(ws, row, c, "", adeqSubHdr);
        ws['!merges'].push({s:{r:row,c:cs}, e:{r:row,c:cs+blockCols-1}});
      });
      row++;

      /* Find max adeq rows for this role */
      let maxAdeq = 0;
      for(const b of blocks) maxAdeq = Math.max(maxAdeq, allAdeqRows[b.id][rd.key].length);

      for(let i=0; i<maxAdeq; i++){
        blocks.forEach((b, bi) => {
          const cs = bi * blockCols;
          const ar = allAdeqRows[b.id][rd.key][i];
          if(ar){
            setCell(ws, row, cs, ar.hour, sAdeqRow);
            setCell(ws, row, cs+1, ar.adeq, sAdeqRow);
            setCell(ws, row, cs+2, ar.sched, sAdeqRow);
            const stStyle = ar.stTxt && ar.stTxt.includes("SHORT") ? sStatusShort :
                            ar.stTxt && ar.stTxt.includes("OVER") ? sStatusOver :
                            (ar.stTxt && (ar.stTxt.includes("GOOD") || ar.stTxt.includes("STAFFED"))) ? sStatusGood : sAdeqRow;
            setCell(ws, row, cs+3, ar.stTxt || "", stStyle);
            for(let c=cs+4;c<cs+blockCols;c++) setCell(ws, row, c, "", sAdeqRow);
          } else {
            for(let c=cs;c<cs+blockCols;c++) setCell(ws, row, c, "", sAdeqRow);
          }
          expandRange(ws, row, cs+blockCols-1);
        });
        row++;
      }
    }

    /* Role tables - aligned */
    for(const role of roles){
      const height = roleSectionHeight[role];
      if(height === 0) continue;

      const isAbsent = (role === "ABSENT");
      const isOth = (role === "OTH");
      const rolePlural = {CALLTAKER:"CT",DISPATCHER:"DP",PIC:"PIC",SUPERVISOR:"SUP",ABSENT:"ABS",OTH:"OTH"};
      const rHdrStyle = roleHdrStyles[role] || sSectionHdr;
      const bgColor = roleBgColors[role] || "FFFFFF";
      const rowStyle = {font:{sz:8}, fill:{fgColor:{rgb:bgColor}}, alignment:{vertical:"center"}, border:border};
      const emptyStyle = {font:{sz:8}, fill:{fgColor:{rgb:bgColor}}, alignment:{vertical:"center"}, border:border};

      /* Role header row */
      blocks.forEach((b, bi) => {
        const cs = bi * blockCols;
        const list = allRowsByRole[b.id][role] || [];
        setCell(ws, row, cs, `${rolePlural[role]||role}: ${list.length}`, rHdrStyle);
        for(let c=cs+1;c<cs+blockCols;c++) setCell(ws, row, c, "", rHdrStyle);
        ws['!merges'].push({s:{r:row,c:cs}, e:{r:row,c:cs+blockCols-1}});
        expandRange(ws, row, cs+blockCols-1);
      });
      row++;

      /* Column headers row */
      blocks.forEach((b, bi) => {
        const cs = bi * blockCols;
        setCell(ws, row, cs, "Name", sColHdr);
        if(!isAbsent) setCell(ws, row, cs+1, "Rl", sColHdr);
        else setCell(ws, row, cs+1, "", sColHdr);
        setCell(ws, row, cs+2, isAbsent ? "Rsn" : (isOth ? "Rsn" : "Seat"), sColHdr);
        setCell(ws, row, cs+3, isAbsent ? "Msd" : "Wkd", sColHdr);
        setCell(ws, row, cs+4, "Hr", sColHdr);
        setCell(ws, row, cs+5, "Pr", sColHdr);
        expandRange(ws, row, cs+blockCols-1);
      });
      row++;

      /* Data rows - max across all blocks */
      let maxEmp = 0;
      for(const b of blocks) maxEmp = Math.max(maxEmp, (allRowsByRole[b.id][role]||[]).length);

      for(let i=0; i<maxEmp; i++){
        blocks.forEach((b, bi) => {
          const cs = bi * blockCols;
          const list = allRowsByRole[b.id][role] || [];
          if(i < list.length){
            const r = list[i];
            const ctx = ctxKey(iso, shift, b.id);
            const ed = ensureEdit(ctx, r.emp);
            const roleNorm = normalizeRole(ed.Role || r.role);
            const seat = ed.Assignment || r.assignment || "";
            const wStart = r.isPartial ? (r.workedStart||"") : (ed.WorkedStart || r.workedStart || "");
            const wEnd = r.isPartial ? (r.workedEnd||"") : (ed.WorkedEnd || r.workedEnd || "");
            const hrs = r.isPartial ? r.hours : (ed.Hours !== "" ? Number(ed.Hours) : r.hours);
            const present = ed.Present || r.present || "YES";
            const absReason = ed.AbsenceReason || "";

            const nameSuffix = (r.isPartial ? " (P)" : "") + (r.isOT ? " (OT)" : "");
            const othType = ed.OthType || "";
            setCell(ws, row, cs, String(r.emp).toUpperCase() + nameSuffix, rowStyle);
            setCell(ws, row, cs+1, isAbsent ? "" : (roleAbbr[roleNorm]||roleNorm), rowStyle);
            setCell(ws, row, cs+2, isAbsent ? (r.isPartial ? (ed.PartialReason||"") : absReason) : (isOth ? othType : seat), rowStyle);
            setCell(ws, row, cs+3, wStart && wEnd ? `${wStart}-${wEnd}` : "", rowStyle);
            setCell(ws, row, cs+4, hrs, rowStyle);
            setCell(ws, row, cs+5, present==="PARTIAL"?"P":(present==="YES"?"Y":"N"), rowStyle);
          } else {
            for(let c=cs;c<cs+blockCols;c++) setCell(ws, row, c, "", emptyStyle);
          }
          expandRange(ws, row, cs+blockCols-1);
        });
        row++;
      }
    }

    const totalRows = row;

    /* ---- Apply thick outer border around entire chart + between blocks ---- */
    const thickStyle = {style:"medium", color:{rgb:"000000"}};
    for(let r=0; r<totalRows; r++){
      for(let c=0; c<totalCols; c++){
        const ref = XLSX.utils.encode_cell({r:r, c:c});
        if(!ws[ref]) { ws[ref] = {v:"", t:"s", s:{border:border}}; }
        if(!ws[ref].s) ws[ref].s = {border:border};
        if(!ws[ref].s.border) ws[ref].s.border = Object.assign({}, border);
        const bdr = Object.assign({}, ws[ref].s.border);
        /* Outer edges */
        if(c === 0) bdr.left = thickStyle;
        if(c === totalCols-1) bdr.right = thickStyle;
        if(r === 0) bdr.top = thickStyle;
        if(r === totalRows-1) bdr.bottom = thickStyle;
        /* Between blocks: thick right on last col of each block, thick left on first col of next */
        for(let bi=0; bi<blocks.length; bi++){
          const lastCol = bi * blockCols + blockCols - 1;
          const firstCol = bi * blockCols;
          if(c === lastCol) bdr.right = thickStyle;
          if(c === firstCol) bdr.left = thickStyle;
        }
        ws[ref].s = Object.assign({}, ws[ref].s, {border: bdr});
      }
    }

    /* Column widths - tight for single-sheet print */
    const cols = [];
    for(let bi=0; bi<blocks.length; bi++){
      const s = bi * blockCols;
      cols[s]   = {wch:12}; // Name
      cols[s+1] = {wch:3};  // Role
      cols[s+2] = {wch:5};  // Seat/Reason
      cols[s+3] = {wch:8};  // Worked
      cols[s+4] = {wch:3};  // Hrs
      cols[s+5] = {wch:2};  // Present
    }
    ws['!cols'] = cols;

    /* Row heights - tight */
    ws['!rows'] = [];
    for(let r=0; r<totalRows; r++){
      ws['!rows'][r] = {hpt:12};
    }

    /* Page setup for letter landscape - fit to 1 page wide */
    ws['!pageSetup'] = {
      paperSize: 1,
      orientation: "landscape",
      fitToWidth: 1,
      fitToHeight: 0,
      scale: 65
    };
    ws['!margins'] = {left:0.15, right:0.15, top:0.2, bottom:0.2, header:0.1, footer:0.1};
    ws['!print'] = {fitToPage: true};

    XLSX.utils.book_append_sheet(wb, ws, "Roster");

    const safeShift = String(shift).replace(/[^\w\-]+/g,'_');
    const fname = `SheetOps_${iso}_${safeShift}.xlsx`;
    XLSX.writeFile(wb, fname);
    setErr("");
  }catch(err){
    console.error(err);
    setErr("Save failed: " + (err && err.message ? err.message : err));
  }
}

document.getElementById("btnSaveXlsx").addEventListener("click", saveXlsx);

window.addEventListener('DOMContentLoaded', ()=>{
  const today = new Date();
  const isoToday = toISODate(today);

  /* Populate pay period dropdown */
  const ppSel = document.getElementById("ppSel");
  PAY_PERIODS.forEach(pp => {
    const o = document.createElement("option");
    o.value = toISODate(pp.start);
    o.textContent = pp.label;
    ppSel.appendChild(o);
  });

  /* Auto-select current pay period (compare date strings to avoid time-of-day boundary issues) */
  const match = PAY_PERIODS.find(pp => isoToday >= toISODate(pp.start) && isoToday <= toISODate(pp.end));
  if(match) ppSel.value = toISODate(match.start);

  /* Auto-select week 1 or 2 based on today */
  if(match){
    const todayD = new Date(isoToday + "T00:00:00");
    const daysSinceStart = Math.round((todayD.getTime() - match.start.getTime()) / 86400000);
    document.getElementById("weekSel").value = daysSinceStart >= 7 ? "2" : "1";
  }

  /* Build day dropdown and select today */
  buildDaySel();
  document.getElementById("daySel").value = isoToday;

  /* PP change rebuilds day dropdown */
  ppSel.addEventListener("change", () => {
    buildDaySel();
    applyDaySelection();
  });

  /* Week change rebuilds day dropdown */
  document.getElementById("weekSel").addEventListener("change", () => {
    buildDaySel();
    applyDaySelection();
  });

  /* Day change applies selection */
  document.getElementById("daySel").addEventListener("change", () => {
    applyDaySelection();
  });

  /* Theme toggle */
  const themeBtn = document.getElementById("themeToggle");
  function applyTheme(light){
    document.body.classList.toggle("light", light);
    themeBtn.innerHTML = light ? "&#9728; Light" : "&#9789; Dark";
    localStorage.setItem("sheetops_theme", light ? "light" : "dark");
  }
  themeBtn.addEventListener("click", () => applyTheme(!document.body.classList.contains("light")));
  if(localStorage.getItem("sheetops_theme") === "light") applyTheme(true);

  /* Auto-load from Firebase (primary) or localStorage (fallback), then select today */
  (async function(){
    const firebaseLoaded = await loadFromFirebase();

    if(!firebaseLoaded){
      // Fallback to localStorage cache
      const cached = localStorage.getItem("sheetops_db");
      if(cached){
        try {
          const bin = atob(cached);
          const bytes = new Uint8Array(bin.length);
          for(let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
          const wb = XLSX.read(bytes, {type:"array"});
          parseDatabase(wb);
          console.log("SheetOps: auto-loaded database from cache (Firebase unavailable)");
        } catch(err){ console.warn("Cache load failed:", err); }
      }
    }

    // Now that DB is loaded, apply today's date selection and load edits
    await applyDaySelection();

    updatePanelViewOptions();
    const pv=document.getElementById('panelViewSel');
    if(pv){ pv.value=PANEL_VIEW; }
    renderAll();
  })();
});
</script>

<script>
/* v129: Auto-trim seat names to 6 chars (display only) */
function trimSeatText(){
  document.querySelectorAll("select.seatSel, select.seat, select.seatSelect").forEach(sel=>{
    if(!sel.value) return;
    let v = sel.value.toUpperCase().trim();
    if(v.length>6) v = v.substring(0,6);
    sel.setAttribute("data-short", v);
  });
}

window.addEventListener("load", trimSeatText);

document.addEventListener("change", e=>{
  if(e.target.matches("select.seatSel, select.seat, select.seatSelect")){
    trimSeatText();
  }
});
</script>

<script>
/* Keyboard shortcuts: Alt+1/2/3 to switch block panels, Alt+A for all */
document.addEventListener('keydown', (e)=>{
  if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  const pv = document.getElementById('panelViewSel');
  if(!pv) return;
  const opts = Array.from(pv.options).map(o=>o.value);

  if(e.altKey && e.key === '1' && opts.length > 1){ e.preventDefault(); pv.value=opts[1]; pv.dispatchEvent(new Event('change',{bubbles:true})); }
  else if(e.altKey && e.key === '2' && opts.length > 2){ e.preventDefault(); pv.value=opts[2]; pv.dispatchEvent(new Event('change',{bubbles:true})); }
  else if(e.altKey && e.key === '3' && opts.length > 3){ e.preventDefault(); pv.value=opts[3]; pv.dispatchEvent(new Event('change',{bubbles:true})); }
  else if(e.altKey && (e.key === 'a' || e.key === 'A')){ e.preventDefault(); pv.value='all'; pv.dispatchEvent(new Event('change',{bubbles:true})); }
});

/* Highlight unselected custom selects with a ring */
function markUnselected(){
  document.querySelectorAll(".customSel").forEach(wrap=>{
    const sel = wrap.querySelector("select");
    if(!sel) return;
    const v = sel.value;
    const btn = wrap.querySelector(".customSelBtn");
    if(!btn) return;
    if(!v || v === "" || v === "\u2014"){
      btn.classList.add("unselected-ring");
    } else {
      btn.classList.remove("unselected-ring");
    }
  });
  /* Also check any native selects that weren't enhanced */
  document.querySelectorAll("select.seatSel, select.roleSel, select.presentSel, select.absReasonSel, select.othTypeSel").forEach(sel=>{
    if(sel.dataset.customized === "1") return;
    const v = sel.value;
    if(!v || v === "" || v === "\u2014"){
      sel.classList.add("unselected-ring");
    } else {
      sel.classList.remove("unselected-ring");
    }
  });
}

/* Run on any select change */
document.addEventListener("change", e=>{
  if(e.target.tagName === "SELECT") setTimeout(markUnselected, 20);
});

/* MutationObserver: catches dynamically rendered selects after renderAll/innerHTML */
new MutationObserver(()=>{
  setTimeout(()=>{
    markUnselected();
    /* Auto-focus next row after re-render */
    if(window.__pendingFocus){
      const pf = window.__pendingFocus;
      window.__pendingFocus = null;
      const allOfType = Array.from(document.querySelectorAll(pf.selType + ' .customSelBtn'));
      if(allOfType[pf.idx]){
        allOfType[pf.idx].focus();
        allOfType[pf.idx].click();
      }
    }
  }, 80);
}).observe(document.body, { childList: true, subtree: true });
</script>

<script>
/* ===== Timesheet Generator ===== */
document.getElementById("btnTimesheet").addEventListener("click", generateTimesheets);

function generateTimesheets(){
  if(!BASE_EMP.length){ setErr("Load a database first."); return; }
  const ppVal = document.getElementById("ppSel").value;
  if(!ppVal){ setErr("Select a pay period."); return; }

  const ppStart = new Date(ppVal + "T00:00:00");
  const DAYNAMES = ["SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"];
  const DAYABBR = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];

  // Build 14-day date list
  const dates = [];
  for(let i=0;i<14;i++){
    const d = new Date(ppStart.getTime() + i * 86400000);
    dates.push(toISODate(d));
  }

  // For each employee, collect hours across all 14 days, both shifts, all blocks
  const empMap = new Map(); // empName -> { info, days: [{date, rows:[{in,out,total,status,elements}], dayTotal}] }

  for(const emp of BASE_EMP){
    const data = { info: emp, days: [] };
    let grandTotal = 0;

    for(const iso of dates){
      const dayRows = [];
      let dayTotal = 0;

      for(const shiftVal of ["DAY","NIGHT"]){
        const blocks = shiftVal==="NIGHT" ? [{id:"1800-2200",start:"18:00",end:"22:00"},{id:"2200-0200",start:"22:00",end:"02:00"},{id:"0200-0600",start:"02:00",end:"06:00"}]
          : [{id:"0600-1000",start:"06:00",end:"10:00"},{id:"1000-1400",start:"10:00",end:"14:00"},{id:"1400-1800",start:"14:00",end:"18:00"}];

        for(const b of blocks){
          const rbr = computeRowsForBlock(iso, shiftVal, b);
          for(const role of ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR","ABSENT","OTH"]){
            const rows = rbr[role]||[];
            for(const r of rows){
              if(r.emp !== emp.Employee) continue;
              const key = ctxKey(iso, shiftVal, b.id);
              const ed = ensureEdit(key, r.emp);
              const hrs = (ed.Hours!=="" ? Number(ed.Hours) : r.hours);
              if(hrs <= 0) continue;
              const ws = ed.WorkedStart || r.workedStart || "";
              const we = ed.WorkedEnd || r.workedEnd || "";
              const present = ed.Present || r.present || "YES";
              const isOT = r.isOT;
              const status = present==="NO" ? "AB" : "SB";
              const elements = isOT ? "OT, REG, H, CST, N, ONL, DEFAULT," : "REG, H, CST, N, ONL, DEFAULT,";

              dayRows.push({
                inTime: ws ? formatTime12(ws) : "",
                outTime: we ? formatTime12(we) : "",
                total: hrs,
                status: status,
                elements: elements,
                isOT: isOT
              });
              dayTotal += hrs;
            }
          }
        }
      }
      data.days.push({ date: iso, rows: dayRows, dayTotal: dayTotal });
      grandTotal += dayTotal;
    }
    data.grandTotal = grandTotal;
    if(grandTotal > 0) empMap.set(emp.Employee, data);
  }

  if(empMap.size === 0){ setErr("No timesheet data found for this pay period."); return; }

  // Open timesheet in new window
  const win = window.open("", "_blank");
  if(!win){ setErr("Popup blocked. Allow popups for this page."); return; }

  let html = `<!doctype html><html><head><meta charset="utf-8"><title>Timesheets - PP</title>
<style>
@media print { .no-print{display:none!important} .page-break{page-break-before:always} }
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:Arial,sans-serif;font-size:11px;color:#000;padding:20px;text-transform:uppercase}
h2{text-align:center;font-size:16px;text-decoration:underline;margin-bottom:12px}
.emp-select{margin-bottom:16px;font-size:13px;padding:6px}
.info-grid{display:grid;grid-template-columns:1fr 1fr;gap:2px 20px;margin-bottom:10px;font-size:11px}
.info-grid b{font-weight:700}
table{width:100%;border-collapse:collapse;margin-bottom:12px;font-size:10px}
th,td{border:1px solid #000;padding:3px 5px;text-align:left}
th{background:#f0f0f0;font-weight:700}
.totals-tbl td{text-align:center;font-size:10px}
.totals-tbl th{text-align:center;font-size:10px}
.summary{margin-top:16px;font-size:12px}
.summary td{padding:4px 8px}
.sig-section{margin-top:40px;font-size:11px}
.sig-line{border-bottom:1px solid #000;width:200px;display:inline-block;margin-left:4px}
.sig-row{display:flex;justify-content:space-between;margin-top:20px}
.hrs-breakdown{margin:12px 0;font-size:12px}
.hrs-breakdown td{border:1px solid #000;padding:4px 8px}
.nav-bar{position:sticky;top:0;background:#fff;padding:10px 0;border-bottom:2px solid #000;margin-bottom:20px;display:flex;gap:10px;align-items:center;z-index:10}
</style></head><body>
<div class="nav-bar no-print">
  <label><b>Employee:</b></label>
  <select id="empPicker" onchange="showEmployee(this.value)" style="padding:6px;font-size:13px">`;

  // Add employee options
  for(const [name] of empMap){
    html += `<option value="${esc(name)}">${esc(name.toUpperCase())}</option>`;
  }
  html += `</select>
  <button onclick="window.print()" style="padding:6px 16px;font-size:12px;cursor:pointer">Print</button>
</div>`;

  // Generate each employee's timesheet
  for(const [name, data] of empMap){
    const emp = data.info;
    const ppEndDate = new Date(ppStart.getTime() + 13 * 86400000);
    const todayISO = toISODate(new Date());

    html += `<div class="emp-sheet" data-emp="${esc(name)}">`;
    html += `<h2>Timesheet</h2>`;
    html += `<div class="info-grid">
      <div><b>Name:</b> ${esc(name.toUpperCase())}</div>
    </div>`;

    html += `<div><b>Timesheet Data:</b></div>`;
    html += `<table><thead><tr><th>Day</th><th>Date</th><th>In</th><th>Out</th><th>In</th><th>Out</th><th>Total</th><th>Reported Status</th><th>Elements</th></tr></thead><tbody>`;

    for(const day of data.days){
      const d = new Date(day.date + "T00:00:00");
      const dayAbbr = DAYABBR[d.getDay()];
      if(day.rows.length === 0){
        html += `<tr><td>${dayAbbr}</td><td>${day.date}</td><td></td><td></td><td></td><td></td><td>0.000</td><td>NW</td><td>CST, N, ONL, DEFAULT,</td></tr>`;
      } else {
        let firstRow = true;
        // Group rows into in/out pairs
        for(let ri=0; ri<day.rows.length; ri++){
          const r = day.rows[ri];
          html += `<tr>`;
          html += `<td>${firstRow ? dayAbbr : ""}</td>`;
          html += `<td>${day.date}</td>`;
          // First in/out pair
          html += `<td>${r.inTime||""}</td><td>${r.outTime ? "" : ""}</td>`;
          // Second in/out (for out time)
          html += `<td></td><td>${r.outTime||""}</td>`;
          html += `<td>${r.total.toFixed(3)}</td>`;
          html += `<td>${r.status}</td>`;
          html += `<td>${r.elements}</td>`;
          html += `</tr>`;
          firstRow = false;
        }
      }
    }
    html += `</tbody></table>`;

    // Total Reported Hours summary row
    html += `<div><b>Total Reported Hours:</b></div>`;
    html += `<table class="totals-tbl"><thead><tr><th>Day</th>`;
    for(const day of data.days){
      const d = new Date(day.date + "T00:00:00");
      const mm = String(d.getMonth()+1);
      const dd = String(d.getDate()).padStart(2,"0");
      const dayAbbr = DAYABBR[d.getDay()];
      html += `<th>${mm}/${dd}<br>${dayAbbr}</th>`;
    }
    html += `<th>Total</th></tr></thead><tbody><tr><td>Select valid alert program ID</td>`;
    for(const day of data.days){
      html += `<td>${day.dayTotal.toFixed(2)}</td>`;
    }
    html += `<td><b>${data.grandTotal.toFixed(2)}</b></td></tr></tbody></table>`;

    // Regular vs Overtime breakdown
    const regHours = Math.min(data.grandTotal, 80);
    const otHours = Math.max(data.grandTotal - 80, 0);
    html += `<table class="hrs-breakdown"><tr><td><b>Regular Hours:</b></td><td>${regHours.toFixed(2)}</td></tr>`;
    html += `<tr><td><b>Overtime Hours:</b></td><td>${otHours.toFixed(2)}</td></tr>`;
    html += `<tr><td><b>Total Hours:</b></td><td>${data.grandTotal.toFixed(2)}</td></tr></table>`;

    // Signature section
    html += `<div class="sig-section">
      <div>Employee Signature: <span class="sig-line"></span></div>
      <div style="margin-top:6px">Date: <span class="sig-line" style="width:120px"></span></div>
      <div class="sig-row">
        <div>Approver#1 Signature: <span class="sig-line"></span><br><span style="margin-top:6px;display:inline-block">Date: <span class="sig-line" style="width:120px"></span></span></div>
        <div>Approver#2 Signature: <span class="sig-line"></span><br><span style="margin-top:6px;display:inline-block">Date: <span class="sig-line" style="width:120px"></span></span></div>
      </div>
    </div>`;

    html += `</div><div class="page-break"></div>`;
  }

  html += `<script>
function showEmployee(name){
  document.querySelectorAll('.emp-sheet').forEach(el=>{
    el.style.display = (el.dataset.emp === name) ? 'block' : 'none';
  });
}
showEmployee(document.getElementById('empPicker').value);
<\/script></body></html>`;

  win.document.write(html);
  win.document.close();
}

function formatTime12(hhmm){
  if(!hhmm) return "";
  const [h,m] = hhmm.split(":").map(Number);
  const ampm = h >= 12 ? "PM" : "AM";
  const h12 = h === 0 ? 12 : h > 12 ? h - 12 : h;
  return h12 + ":" + String(m).padStart(2,"0") + " " + ampm;
}
</script>

</body>
</html>
