<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ShiftOps</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ccircle cx='32' cy='32' r='30' fill='%23070c16'/%3E%3Ccircle cx='32' cy='32' r='30' fill='none' stroke='%23c0c8d4' stroke-width='2'/%3E%3Ccircle cx='32' cy='32' r='22' fill='none' stroke='%23e8ecf0' stroke-width='2.5'/%3E%3Cline x1='32' y1='32' x2='32' y2='16' stroke='%23e8ecf0' stroke-width='3' stroke-linecap='round'/%3E%3Cline x1='32' y1='32' x2='44' y2='38' stroke='%23e8ecf0' stroke-width='2.5' stroke-linecap='round'/%3E%3Ccircle cx='32' cy='32' r='2.5' fill='%23e8ecf0'/%3E%3C/svg%3E"/>
<style>

:root{
  color-scheme:dark;
  --bg:#0b0f14;
  --card:#111826;
  --muted:#9aa4b2;
  --text:#e7eef8;
  --accent:#4aa3ff;
  --border:#233043;
  --ok:#3fe7b6;
  --bad:#ff6b6b;
  --warn:#ffe066;
}
body.light{
  --bg:#e8eaef;
  --card:#dde1e8;
  --muted:#4a5568;
  --text:#1a1a2e;
  --accent:#0369a1;
  --border:rgba(0,0,0,.12);
  --ok:#059669;
  --bad:#e11d48;
  --warn:#d97706;
}
*,*::before,*::after{box-sizing:border-box}
body{
  margin:0;min-height:100vh;
  font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
  color:var(--text);
  background:var(--bg);
}
body.light{
  background:var(--bg);
}
body.light header{
  background:linear-gradient(180deg, rgba(232,234,239,.98), rgba(232,234,239,.75));
  backdrop-filter:blur(10px);
}
body.light header div{ color:#000 !important; }
body.light header label{ color:#000 !important; font-weight:600 !important; }
body.light button{
  background:rgba(0,0,0,.05) !important;
  border-color:var(--border) !important;
  color:#000 !important;
}
body.light button.primary{
  border-color:rgba(3,105,161,.5) !important;
  background:rgba(3,105,161,.12) !important;
  color:#000 !important;
}
body.light .pill{
  background:rgba(0,0,0,.04) !important;
  border-color:var(--border) !important;
  color:#000 !important;
}
body.light .pill.bad{ color:#b91c1c !important; border-color:rgba(185,28,28,.3) !important; background:rgba(185,28,28,.06) !important; }
body.light .pill.good{ color:#047857 !important; border-color:rgba(4,120,87,.3) !important; background:rgba(4,120,87,.06) !important; }

/* Light mode: universal dark text */
body.light, body.light *:not(.statusShort):not(.statusStaffed):not(.statusOver):not(.adeqStatus){
  color:#000;
}
body.light .muted, body.light label, body.light .small{ color:#1a1a2e !important; }

/* Light mode: all inputs/selects/buttons */
body.light input, body.light select, body.light textarea,
body.light .customSelBtn, body.light button.secondary{
  background:var(--card) !important;
  color:#000 !important;
  border-color:var(--border) !important;
  font-weight:600 !important;
}
body.light select option{
  background:var(--card) !important;
  color:#000 !important;
}
body.light .roleSel, body.light .seatSel, body.light .presentSel, body.light .absReasonSel, body.light .othTypeSel,
body.light .inlineSel, body.light select{
  color:#000 !important;
  font-weight:700 !important;
  background:var(--card) !important;
  border-color:var(--border) !important;
  box-shadow:none !important;
  text-shadow:none !important;
  -webkit-text-fill-color:#000 !important;
}
body.light .hrsIn{ color:#000 !important; font-weight:700 !important; }
body.light .customSelDrop{
  background:var(--bg) !important;
  border-color:var(--border) !important;
  box-shadow:0 8px 24px rgba(0,0,0,.10) !important;
}
body.light .customSelOpt{ color:#1a1a2e !important; }
body.light .customSelOpt:hover{ background:rgba(0,0,0,.06) !important; }

/* Light mode: staffing numbers (adeq) */
body.light .adeqBox{
  background:var(--card) !important;
  border-color:var(--border) !important;
  box-shadow:none !important;
}
body.light .adeqBoxHead{
  background:rgba(0,0,0,.03) !important;
  border-color:var(--border) !important;
  color:#000 !important;
}
body.light .adeqBoxSub{
  color:rgba(0,0,0,.40) !important;
  border-color:var(--border) !important;
}
body.light .adeqTbl{ background:transparent !important; }
body.light .adeqTbl th{ color:#222 !important; background:rgba(0,0,0,.02) !important; }
body.light .adeqTbl td{ color:#000 !important; border-color:rgba(0,0,0,.05) !important; background:transparent !important; }
body.light .adeqTbl tr{ background:transparent !important; }
body.light .adeqSectionLabel{ color:#1a1a2e !important; }
body.light .adeqDivider{
  background:linear-gradient(to right, transparent, rgba(0,0,0,.12), transparent) !important;
}

/* Light mode: role cards */
body.light .card.boardCard{
  background:var(--card) !important;
  border-color:var(--border) !important;
  box-shadow:none !important;
}
body.light .card h2{
  background:rgba(0,0,0,.03) !important;
  color:#1a1a2e !important;
  border-color:var(--border) !important;
}
body.light .tblWrap{ background:var(--card) !important; }
body.light th{ background:rgba(0,0,0,.03) !important; color:#222 !important; border-bottom-color:rgba(0,0,0,.08) !important; }
body.light tbody tr td{ border-bottom-color:rgba(0,0,0,.06) !important; color:#1a1a2e !important; background:transparent !important; }
body.light tbody tr:hover td{ background:rgba(0,0,0,.04) !important; }
body.light .roleCard-CALLTAKER{ background:rgba(56,140,255,.08) !important; border-color:rgba(56,140,255,.15) !important; }
body.light .roleCard-CALLTAKER h2.blockHdr{ color:#1e3a8a !important; }
body.light .roleCard-DISPATCHER{ background:rgba(192,132,252,.08) !important; border-color:rgba(192,132,252,.15) !important; }
body.light .roleCard-DISPATCHER h2.blockHdr{ color:#5b21b6 !important; }
body.light .roleCard-PIC{ background:rgba(45,212,191,.08) !important; border-color:rgba(45,212,191,.15) !important; }
body.light .roleCard-PIC h2.blockHdr{ color:#115e59 !important; }
body.light .roleCard-SUPERVISOR{ background:rgba(251,191,36,.08) !important; border-color:rgba(251,191,36,.15) !important; }
body.light .roleCard-SUPERVISOR h2.blockHdr{ color:#92400e !important; }
body.light .roleCard-ABSENT{ background:rgba(251,113,133,.08) !important; border-color:rgba(251,113,133,.12) !important; }
body.light .roleCard-ABSENT h2.blockHdr{ color:#9f1239 !important; }
body.light .roleCard-OTH{ background:rgba(156,163,175,.08) !important; border-color:rgba(156,163,175,.15) !important; }
body.light .roleCard-OTH h2.blockHdr{ color:#374151 !important; }

/* Light mode: section headers */
body.light h2.blockHdr{ color:#1a1a2e !important; }

/* Light mode: roster tables */
body.light .rosterTbl th, body.light .rosterTbl thead th{ background:rgba(0,0,0,.04) !important; color:#000 !important; border-bottom-color:rgba(0,0,0,.08) !important; }
body.light .rosterTbl td{ color:#000 !important; border-color:rgba(0,0,0,.05) !important; background:transparent !important; }
body.light .nameCol{ color:#000 !important; font-weight:700 !important; }
body.light .empName{ color:#000 !important; font-weight:700 !important; }
body.light .rowPill{ background:rgba(0,0,0,.07) !important; color:#000 !important; font-weight:700 !important; }
body.light .otBadge{ color:#b45309 !important; }
body.light .swapBadge{ color:#0369a1 !important; border-color:rgba(3,105,161,.4) !important; }
body.light .hrsIn{ color:#1a1a2e !important; }

/* Light mode: error/note */
body.light .err, body.light #errTxt{ color:#b91c1c !important; }
body.light .note{ color:#92400e !important; }

/* Light mode: comment rows */
body.light .cmt-btn{ color:#111 !important; }
body.light .cmt-btn.has-cmt{ color:#d97706 !important; text-shadow:none !important; }
body.light #cmtPopup{
  background:var(--card) !important;
  border-color:var(--border) !important;
}
body.light #cmtPopup::after{ background:var(--card) !important; }
body.light #cmtPopup textarea{
  background:rgba(255,255,255,.8) !important;
  color:#1a1a2e !important;
  border-color:var(--border) !important;
}
body.light #otConfirmPopup{
  background:var(--card) !important;
  border-color:rgba(225,29,72,.3) !important;
}
body.light #otConfirmPopup .ot-confirm-title{ color:#e11d48 !important; }
body.light #otConfirmPopup .ot-yes{ color:#e11d48 !important; }

/* Light mode: staffing status */
body.light .statusShort{ color:#b91c1c !important; font-weight:900 !important; text-shadow:none !important; }
body.light .statusStaffed{ color:#b45309 !important; font-weight:900 !important; text-shadow:none !important; }
body.light .statusOver{ color:#047857 !important; font-weight:900 !important; text-shadow:none !important; }
body.light .diag{ background:rgba(232,234,239,.96) !important; border-color:var(--border) !important; }
@keyframes radarSweep{
  0%{transform:rotate(0deg)}
  100%{transform:rotate(360deg)}
}
@keyframes logoPulse{
  0%,100%{opacity:.75}
  50%{opacity:.9}
}
.radar-logo{
  animation:logoPulse 4s ease-in-out infinite;
}
a{color:inherit}
header{
  padding:14px 18px 12px;
  position:sticky; top:0; z-index:10;
  backdrop-filter:blur(10px);
  background:linear-gradient(180deg, rgba(11,15,20,.98), rgba(11,15,20,.75));
  border-bottom:1px solid var(--border);
}
h1{margin:0;font-size:32px;letter-spacing:.3px;font-weight:750;text-align:center}
.small{font-size:12px;color:var(--muted);margin-top:4px}
.controls{
  display:grid;
  grid-template-columns:repeat(6,minmax(170px,1fr));
  gap:10px;
  margin-top:12px
}
label{display:block;font-size:11px;color:var(--muted);margin:0 0 6px}
input,select,button{font:inherit}
input,select{
  width:100%;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid var(--border);
  background:#0c1320;
  color:var(--text);
  outline:none;
}
input:focus,select:focus{
  border-color:var(--accent);
  box-shadow:0 0 0 3px rgba(74,163,255,.15);
}
button{
  padding:10px 12px;
  border-radius:12px;
  border:1px solid var(--border);
  background:#0c1320;
  color:var(--text);
  cursor:pointer;
  font-weight:700;
  transition: transform .05s ease, background .2s ease, border-color .2s ease;
}
button:hover{background:rgba(255,255,255,.06); border-color:rgba(255,255,255,.18)}
button:active{transform: translateY(1px)}
button.primary{
  border-color:rgba(74,163,255,.5);
  background:var(--accent);
  color:#fff;
}
.diag{
position:fixed;bottom:0;left:0;right:0;z-index:999;
padding:8px 16px;gap:10px;align-items:center;flex-wrap:wrap;
background:rgba(11,15,20,.96);border-top:1px solid var(--border);
backdrop-filter:blur(10px)}
.pill{
  display:inline-flex;align-items:center;gap:7px;
  padding:7px 10px;
  border-radius:999px;
  border:1px solid var(--border);
  background:rgba(255,255,255,.02);
  color:var(--muted);
  font-size:12px;
}
.pill.bad{border-color:rgba(251,113,133,.45); background:rgba(251,113,133,.10); color:#ffd5dd}
.pill.good{border-color:rgba(52,211,153,.40); background:rgba(52,211,153,.10); color:#d7ffe9}
@keyframes syncPulse{0%,100%{opacity:1}50%{opacity:.5}}
#pillSync{transition:all .2s ease}
#pillSync:not(.good):not(.bad){animation:syncPulse 1s ease-in-out infinite;border-color:rgba(74,163,255,.45);background:rgba(74,163,255,.10);color:#a5d4ff}
#absentBar{
  display:grid;
  grid-template-columns:repeat(3, minmax(490px, 1fr));
  gap:14px;
  width:100%;
  padding:0 18px;
  box-sizing:border-box;
}
.absentCell{
  display:flex;justify-content:flex-start;gap:6px;
}
.absentPill{
  display:inline-flex;align-items:center;gap:6px;
  padding:5px 10px;border-radius:999px;font-size:11px;font-weight:400;
  border:1px solid var(--border);
  background:#0c1320;color:#cfe3ff;
  letter-spacing:.04em;text-transform:uppercase;
  width:auto;
}
.absentPill .absentCount{
  font-weight:400;color:var(--bad);
}
.absentPill.zero .absentCount{color:#fff;}
.absentPill.otPill .absentCount{color:#fde047;}
body.light .absentPill{background:var(--card);border-color:var(--border);color:#222;}
body.light .absentPill .absentCount{color:#b91c1c;}
body.light .absentPill.zero .absentCount{color:#222;}
body.light .absentPill.otPill .absentCount{color:#b45309;}

main{padding:14px 18px 0}
.grid{
  display:grid;
  grid-template-columns:repeat(3, minmax(490px, 1fr));
  gap:14px;
  align-items:start
}
.card{
  border-radius:14px;
  border:1px solid var(--border);
  background:var(--card);
  overflow:hidden;
}
.card h2{
  margin:0;
  padding:12px 14px;
  font-size:13px;
  letter-spacing:.35px;
  font-weight:800;
  color:var(--text);
  background:#0c1320;
  border-bottom:1px solid var(--border);
  display:flex;
  justify-content:space-between;
  align-items:center;
  border-top-left-radius:13px;
  border-top-right-radius:13px;
}
.blockHdr{ text-align:center; justify-content:center !important; }

.section{padding:12px 14px;border-bottom:1px solid var(--border)}
.boardCard .section:last-child{border-bottom:none}
.tables{display:grid;grid-template-columns:1fr;gap:10px}

table{width:100%;border-collapse:separate;border-spacing:0;font-size:12px;border:none;border-radius:0}
.tblWrap{border:1px solid var(--border);border-radius:12px;overflow:visible;background:#0c1320;}
.boardCard .tblWrap:last-child{border-bottom-color:transparent}
body.light .tblWrap{background:var(--card);}
th,td{padding:7px 8px;vertical-align:middle}
th{
  color:var(--muted);
  font-weight:700;
  text-align:left;
  background:#0c1320;
  border-bottom:1px solid var(--border);
}
tbody tr td{border-bottom:1px solid rgba(255,255,255,.06)}
tbody tr:hover td{background:rgba(255,255,255,.04)}
.roleHdr{display:flex;justify-content:space-between;align-items:center;margin:4px 0 10px}
.roleHdr b{font-size:12px;letter-spacing:.2px}
.tag{font-size:11px;color:var(--muted)}

.rowPill{
  display:inline-block;
  padding:4px 9px;
  border-radius:999px;
  border:1px solid var(--border);
  background:rgba(255,255,255,.04);
  color:var(--text);
}
.rowPill.editable{cursor:pointer}
.inlineSel, .seatSel{
  width:100%;
  padding:8px 10px;
  border-radius:12px;
  border:1px solid var(--border);
  background:#0c1320;
  color:var(--text);
}
.seatSel{max-width:140px}
.compact{white-space:nowrap}

.timeEdit{display:none;gap:6px}
.timeEdit input{
  padding:8px 10px;
  border-radius:12px;
  border:1px solid var(--border);
  background:#0c1320;
  color:var(--text);
}

.otBar{display:flex;flex-direction:column;gap:8px}
.otBarRow{display:flex;gap:8px;align-items:end}
.otBarRow .mini{flex:1 1 0;min-width:0}
.otBarRow .miniSm{flex:0 0 auto;min-width:80px}
.otBar input, .otBar select{max-width:none;width:100%;box-sizing:border-box}
.otBar button{padding:9px 12px;border-radius:12px;white-space:nowrap}



.statusBadge{
  display:inline;
  font-size:12px;
  font-weight:900;
  margin-left:4px;
}
.statusShort{color:var(--bad);}
.statusStaffed{color:var(--warn);}
.statusOver{color:var(--ok);}


/* Hrs field tuning */
td input[type="number"]{
  width:48px !important;
  min-width:48px !important;
  max-width:48px !important;
  padding:4px 6px !important;
  font-size:15px !important;
  font-weight:600;
  text-align:center;
}


/* Role field (CT/DP/PIC/SUP) tuning */
td select{
  font-size:14px !important;
}

td select.roleSel,
td select[onchange*="setRoleVal"]{
  width:70px !important;
  min-width:70px !important;
  max-width:70px !important;
  padding:4px 6px !important;
  font-weight:600;
  text-align:center;
}

/* If role is rendered as pill */
.rowPill{
  min-width:60px;
  padding:3px 6px !important;
  font-size:13px !important;
  font-weight:600;
  text-align:center;
}





/* Extra-compact Seat selector */
.seatSel{
  width:60px !important;
  min-width:60px !important;
  max-width:60px !important;
  padding:2px 4px !important;
  font-size:13px !important;
  font-weight:600;
  text-align:center;
}


/* Strip outer card for adeq — adeqBox IS the container */
.roleCard-adeq{
  border:none !important;
  background:transparent !important;
  box-shadow:none !important;
  padding:0 !important;
  overflow:visible !important;
}
.roleCard-adeq h2.blockHdr{
  background:transparent !important;
  border:none !important;
  padding:0 !important;
  height:0 !important;
  overflow:hidden !important;
  margin:0 !important;
}
.roleCard-adeq .section{
  border-bottom:none !important;
  padding:0 !important;
}
/* Adequate box — covMini style (single clean container) */
.adeqBox{margin:0;border:1px solid var(--border);border-radius:12px;overflow:hidden;background:#0c1320;}
.adeqBoxHead{padding:7px 8px;background:rgba(255,255,255,0.03);border-bottom:1px solid var(--border);
  font-size:12px;font-weight:900;color:#cfe3ff;text-align:center;letter-spacing:.06em;text-transform:uppercase;}
.adeqBoxSub{padding:5px 8px;border-bottom:1px solid var(--border);
  font-size:10px;font-weight:700;color:rgba(255,255,255,.45);text-align:center;letter-spacing:.08em;text-transform:uppercase;}
.adeqTbl{width:100%;border-collapse:collapse;border:none;border-radius:0;font-size:12px}
.adeqTbl th,.adeqTbl td{padding:7px 8px;border-bottom:1px solid var(--border);font-size:12px;text-align:center}
.adeqTbl th{color:#cfe3ff;background:rgba(255,255,255,0.03);position:static;font-weight:600;text-align:center}
.adeqTbl td{color:var(--text);text-align:center}
.adeqTbl tr:last-child td{border-bottom:none}
.adeqHour{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
.adeqSectionRow td{padding:8px 8px 4px 8px;border-bottom:none}
.adeqSectionRow td{text-align:left !important}
.adeqSectionLabel{font-weight:800;letter-spacing:.3px;font-size:12px;color:#cfe3ff}
.adeqDivider{height:1px;background:linear-gradient(to right, transparent, rgba(255,255,255,.14), transparent);margin-top:4px}
.statusPill{font-weight:900}
.statusShort{color:#ff4d4d;font-weight:900}
.statusStaffed{color:#fde047;font-weight:900}
.statusOver{color:#86efac;font-weight:900}


/* v108: stacked rows across blocks */
#blocks{display:flex;flex-direction:column;gap:10px;}
#blocks .row3{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px;}


/* v111: link each block column so top/bottom align */
#blocks{display:grid !important; grid-template-columns:repeat(3,minmax(0,1fr)) !important; gap:10px !important;}
.blockCol{display:flex; flex-direction:column; gap:10px;}


/* Status = bold colored text only (no pill) */
.statusPill{background:transparent !important;padding:0 !important;border-radius:0 !important;box-shadow:none !important;}
.statusOver{color:#86efac !important;font-weight:900 !important;}
.statusStaffed{color:#fde047 !important;font-weight:900 !important;}
.statusShort{color:#ff4d4d !important;font-weight:900 !important;}

/* Block layout */
.blocksWrap{ align-items:start !important; }
.blockColumn{ display:flex !important; flex-direction:column !important; gap:10px !important; }
.blockColumn .adeqBox{ margin-bottom:0 !important; }

/* Additional BreakOps-inherited components */
.header{display:flex;align-items:center;gap:14px;margin-bottom:14px}
.sub{color:var(--muted);margin-top:2px}

@media (max-width:1100px){.controls{grid-template-columns:1fr 1fr;}}
#workDateDisplay{ font-size:12px;font-weight:800;color:var(--accent);white-space:nowrap; }

.btn{background:transparent;border:1px solid var(--border);color:var(--text);padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:800}
.btn:hover{border-color:rgba(255,255,255,.25)}
button.secondary{background:#0c1320}
.row{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}

@media (max-width:1100px){.grid3{grid-template-columns:1fr}}
.sectionTitle{display:flex;align-items:baseline;justify-content:space-between;gap:12px;margin:18px 0 10px}
.sectionTitle h2{margin:0;font-size:16px;letter-spacing:.3px}
thead th{
  text-align:left;font-size:12px;color:var(--muted);
  background:#0c1320;
  padding:8px 10px;border-bottom:1px solid var(--border)
}
tbody td{padding:8px 10px;border-bottom:1px solid rgba(255,255,255,.06)}
tbody tr:last-child td{border-bottom:none !important}
tbody tr:nth-last-child(2) td{border-bottom:none !important}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
.statusOk{color:var(--ok);font-weight:800}
.otRow{background:rgba(255,214,0,.08)}
.otBadge{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,214,0,.35);color:#ffeaa6;font-size:12px;margin-left:6px}
.swapBadge{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid rgba(74,163,255,.45);color:#a3d4ff;font-size:11px;font-weight:700;margin-left:6px;cursor:default}

/* Swap Modal */
#swapModalBackdrop{display:none;position:fixed;inset:0;background:rgba(0,0,0,.65);z-index:10000;align-items:center;justify-content:center}
#swapModalBackdrop.open{display:flex}
#swapModalCard{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:24px 28px;width:520px;max-width:95vw;max-height:90vh;overflow-y:auto;box-shadow:0 12px 40px rgba(0,0,0,.5)}
#swapModalCard h3{margin:0 0 16px;font-size:16px;font-weight:700;color:var(--text)}
.swapRow{display:flex;align-items:center;gap:10px;margin-bottom:12px}
.swapRow label{font-size:12px;font-weight:600;min-width:90px;color:var(--muted)}
.swapRow select{flex:1;padding:8px 10px;font-size:13px;background:#0c1320;color:var(--text);border:1px solid var(--border);border-radius:8px}
.swapArrow{text-align:center;font-size:20px;margin:4px 0;color:var(--accent)}
.swapDays{margin:14px 0;display:flex;flex-wrap:wrap;gap:8px}
.swapDays label{display:flex;align-items:center;gap:5px;font-size:12px;font-weight:600;color:var(--text);cursor:pointer}
.swapDays input[type="checkbox"]{accent-color:var(--accent)}
#swapPreview{margin:12px 0;font-size:12px;max-height:180px;overflow-y:auto}
#swapPreview table{width:100%;border-collapse:collapse}
#swapPreview th,#swapPreview td{padding:5px 8px;border-bottom:1px solid var(--border);text-align:left;font-size:12px}
#swapPreview th{color:var(--muted);font-weight:700}
.swapPreviewArrow{color:var(--accent);font-weight:700}
.swapBtns{display:flex;gap:10px;margin-top:14px}
.swapBtns button{flex:1;padding:10px;border-radius:10px;border:1px solid var(--border);font-size:13px;font-weight:700;cursor:pointer}
#swapConfirmBtn{background:rgba(74,163,255,.15);border-color:rgba(74,163,255,.4);color:var(--accent)}
#swapConfirmBtn:hover{background:rgba(74,163,255,.25)}
#swapCancelBtn{background:transparent;color:var(--muted)}
#swapError{color:var(--bad);font-size:12px;margin-top:8px;min-height:18px}
.swapListTitle{font-size:13px;font-weight:700;margin:16px 0 8px;color:var(--muted);border-top:1px solid var(--border);padding-top:12px}
.swapListItem{display:flex;align-items:center;justify-content:space-between;padding:6px 10px;background:rgba(74,163,255,.06);border:1px solid rgba(74,163,255,.15);border-radius:8px;margin-bottom:6px;font-size:12px;font-weight:600}
.swapListItem .swapRemove{background:none;border:none;color:var(--bad);font-size:16px;cursor:pointer;padding:0 4px;font-weight:700}
body.light #swapModalCard{background:var(--card);border-color:var(--border)}
body.light .swapRow select{background:var(--bg);color:#000;border-color:var(--border)}

.statusBad{color:var(--bad);font-weight:800}
.pulsing{outline:3px solid rgba(255,214,0,.85); box-shadow:0 0 0 6px rgba(255,214,0,.15)}
.err{display:none;margin-top:10px;border:1px solid rgba(255,95,95,.45);background:rgba(255,95,95,.10);padding:10px 12px;border-radius:14px;color:#ffd0d0}
.note{display:none;margin-top:10px;border:1px solid rgba(255,214,0,.35);background:rgba(255,214,0,.08);padding:10px 12px;border-radius:14px;color:#ffeaa6}
a.help{color:var(--accent);text-decoration:none}

@media (max-width:1000px){.grid2{grid-template-columns:1fr}}

/* Worked time compact display */
.workedPill{
  display:inline-block;
  font-size:12px;
  line-height:1;
  padding:6px 10px;
  border:1px solid var(--border);
  border-radius:999px;
  background:rgba(255,255,255,.04);
  color:var(--text);
  cursor:default;
  user-select:none;
  min-width:64px;
  text-align:center;
}
.workedPill:hover{ background:rgba(255,255,255,.08); }
.workedEdit{
  display:none;
  align-items:center;
  gap:6px;
}
.workedEdit input[type="time"]{
  width:88px;
  padding:6px 8px;
  border-radius:10px;
  border:1px solid var(--border);
  background:#0c1320;
  color:var(--text);
}
.workedDash{opacity:.7}

/* Compact Role + Assignment pills (double-click to edit) */
.rolePill,.assignPill{
  display:inline-block;
  font-size:12px;
  line-height:1;
  padding:6px 10px;
  border:1px solid var(--border);
  border-radius:999px;
  background:rgba(255,255,255,.04);
  color:var(--text);
  user-select:none;
  min-width:52px;
  text-align:center;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  max-width:140px;
}
.assignPill{ min-width:80px; max-width:180px; text-align:left; }
.rolePill:hover,.assignPill:hover{ background:rgba(255,255,255,.10); }
.roleEdit,.assignEdit{ display:none; }
.roleEdit select,.assignEdit select{ width:100%; min-width:120px; }

/* BreakOps unified card/panel styling */
.blockCard,.panel,.cardLike,.listCard,.block,.sectionCard{
  background:var(--card) !important;
  border:1px solid var(--border) !important;
  border-radius:14px !important;
  padding:16px !important;
}
/* Controls global override */
input,select,button,textarea{
  background:#0c1320 !important;
  color:var(--text) !important;
  border:1px solid var(--border) !important;
  border-radius:12px !important;
  padding:10px 12px !important;
}
body.light input, body.light select, body.light textarea{
  background:var(--card) !important;
  color:#000 !important;
  border-color:var(--border) !important;
  -webkit-text-fill-color:#000 !important;
}
body.light input[type="time"]{
  background:var(--card) !important;
  color:#000 !important;
  -webkit-text-fill-color:#000 !important;
}
body.light select option{
  background:var(--card) !important;
  color:#000 !important;
}
body.light button{
  background:rgba(0,0,0,.06) !important;
  color:#000 !important;
  border-color:var(--border) !important;
}
body.light button.primary, body.light .primary, body.light .btnPrimary{
  background:rgba(3,105,161,.12) !important;
  border-color:rgba(3,105,161,.35) !important;
  color:#000 !important;
}
body.light .customSelBtn{
  background:var(--card) !important;
  color:#000 !important;
  border-color:var(--border) !important;
}
body.light .customSelDrop, body.light .customSelMenu{
  background:var(--bg) !important;
  border-color:var(--border) !important;
  box-shadow:0 8px 24px rgba(0,0,0,.10) !important;
}
body.light .customSelOpt{ color:#000 !important; }
body.light .customSelOpt:hover{ background:rgba(0,0,0,.08) !important; }
body.light .timeEdit{
  background:var(--card) !important;
  border-color:var(--border) !important;
  box-shadow:0 8px 20px rgba(0,0,0,.08) !important;
}
body.light .timeEdit input[type="time"]{
  background:var(--bg) !important;
  color:#000 !important;
  border-color:var(--border) !important;
  -webkit-text-fill-color:#000 !important;
}
body.light button.secondary{
  background:var(--card) !important;
  color:#000 !important;
}
button.primary,.primary,.btnPrimary{
  background:var(--accent) !important;
  border-color:rgba(74,163,255,.5) !important;
  color:#fff !important;
}
/* Pills and meta chips */
.pill,.chip,.badge{
  border:1px solid var(--border) !important;
  border-radius:999px !important;
  padding:7px 10px !important;
  color:var(--muted) !important;
  background:rgba(255,255,255,.02) !important;
}
/* Tables */
table{border:none !important;border-radius:0 !important;}
thead th{
  color:var(--muted) !important;
  background:#0c1320 !important;
  border-bottom:1px solid var(--border) !important;
}
tbody td{border-bottom:1px solid rgba(255,255,255,.06) !important;}



/* v117: Uniform board layout (rows aligned across all 3 blocks) */
main{
  overflow-x:auto !important;
}
#blocks.boardGrid{
  display:grid !important;
  grid-template-columns:repeat(3, minmax(490px, 1fr)) !important;
  gap:10px !important;
  align-items:start !important;
  justify-content:center !important;
  margin:0 auto !important;
  width:fit-content !important;
}
.boardCard{height:100%;}

/* Header text spans for alignment */
.hdrTxt{ display:inline-block; white-space:nowrap; }
.rosterTbl thead th{ overflow:visible !important; }

/* Row comments */
.cmt-btn{
  background:none;border:none;padding:0;margin:0;cursor:pointer;
  font-size:10px;opacity:.35;transition:opacity .15s;line-height:1;
  color:var(--muted);vertical-align:middle;
  width:14px;height:14px;display:inline-flex;align-items:center;justify-content:center;
  position:relative;z-index:5;
}
.cmt-btn:hover{opacity:.7}
.cmt-btn.has-cmt{opacity:1;color:#fbbf24;text-shadow:0 0 6px rgba(251,191,36,.5)}
/* Comment popup (floating, replaces cmt-row) */
#cmtPopup{
  display:none;position:fixed;z-index:9999;
  background:#141b2a;border:1px solid var(--border);
  border-radius:10px;padding:8px;width:360px;
  box-shadow:0 8px 32px rgba(0,0,0,.45);
}
#cmtPopup.open{display:block}
#cmtPopup::after{
  content:'';position:absolute;bottom:-6px;right:16px;
  width:12px;height:12px;background:#141b2a;
  border-right:1px solid var(--border);border-bottom:1px solid var(--border);
  transform:rotate(45deg);
}
#cmtPopup textarea{
  width:100%;min-height:48px;max-height:100px;
  padding:6px 8px;border-radius:8px;
  border:1px solid var(--border);
  background:#0c1320;
  color:var(--text);font:11px/1.4 inherit;
  resize:none;outline:none;display:block;
}
#cmtPopup textarea:focus{
  border-color:var(--accent);
  box-shadow:0 0 0 3px rgba(74,163,255,.12);
}
/* OT edit icon */
.ot-edit-icon{
  display:inline-flex;align-items:center;justify-content:center;
  width:16px;height:16px;margin-left:4px;cursor:pointer;
  font-size:10px;opacity:.5;transition:opacity .15s;
  vertical-align:middle;border:none;background:none;padding:0;
  color:var(--muted);
}
.ot-edit-icon:hover{opacity:1;color:#ff6b6b}
/* OT confirm popup */
#otConfirmPopup{
  display:none;position:fixed;z-index:10000;
  background:#1a2236;border:1px solid rgba(255,77,77,.35);
  border-radius:10px;padding:10px 14px;
  box-shadow:0 8px 32px rgba(0,0,0,.5);
  text-align:center;font-size:12px;color:var(--text);
}
#otConfirmPopup.open{display:block}
#otConfirmPopup .ot-confirm-title{font-weight:700;margin-bottom:8px;color:#ff6b6b}
#otConfirmPopup .ot-confirm-btns{display:flex;gap:8px;justify-content:center}
#otConfirmPopup .ot-confirm-btns button{
  padding:4px 14px;border-radius:6px;font-size:11px;font-weight:700;cursor:pointer;border:1px solid;
}
#otConfirmPopup .ot-yes{background:rgba(255,77,77,.15);border-color:rgba(255,77,77,.4);color:#ff4d4d}
#otConfirmPopup .ot-yes:hover{background:rgba(255,77,77,.3)}
#otConfirmPopup .ot-no{background:rgba(255,255,255,.06);border-color:var(--border);color:var(--muted)}
#otConfirmPopup .ot-no:hover{background:rgba(255,255,255,.12)}


/* v118: Single panel (one 4-hr block) view */
.singlePanel .boardGrid{
  grid-template-columns: 1fr !important;
}
.singlePanel .boardCard{
  max-width:none !important;
}




/* v120: Single panel truly fills the page (no max-width cap) */
.singlePanelMode{
  padding:24px !important;
}
.singlePanelMode .blocksWrap{
  display:flex !important;
  justify-content:center !important;
  width:100% !important;
  max-width:none !important;
}
.singlePanelMode .blockColumn{
  flex:1 1 auto !important;
  width:100% !important;
  max-width:none !important;
  margin:0 !important;
}
.singlePanelMode .blockCard,
.singlePanelMode .panel,
.singlePanelMode .sectionCard{
  width:100% !important;
}
/* Make cards breathe larger in single mode */
.singlePanelMode .blockCard{
  padding:22px !important;
  border-radius:22px !important;
}
/* Slightly increase typography in single mode */
.singlePanelMode h1{font-size:42px !important;}
.singlePanelMode .sub, .singlePanelMode .muted, .singlePanelMode label{font-size:14px !important;}
.singlePanelMode table{font-size:14px !important;}
.singlePanelMode th{font-size:13px !important;}
/* Enlarge interactive controls a bit */
.singlePanelMode select,
.singlePanelMode input,
.singlePanelMode button{
  font-size:14px !important;
  padding:12px 14px !important;
}


/* v121: Adequate staffing — clean compact (admin-style) */
.adeqBox,
.adeqBox *{
  text-transform: uppercase !important;
}
.adeqTbl{
  font-size:12px !important;
  border-spacing:0 !important;
}
.adeqHour{
  font-variant-numeric:tabular-nums !important;
}


/* v122: Role smaller, Seat bigger/selectable */

/* Role selector (CT/DP/PIC/SUP) */
select.roleSelect,
select.role,
.roleSelect,
.role-select{
  font-size:11px !important;
  padding:4px 6px !important;
  min-width:54px !important;
  height:26px !important;
  text-align:center !important;
  font-weight:700 !important;
}

/* Seat selector (make larger & readable when closed) */
select.seatSelect,
select.seat,
.seatSelect,
.seat-select{
  font-size:14px !important;
  padding:6px 10px !important;
  min-width:90px !important;
  height:34px !important;
  font-weight:800 !important;
  letter-spacing:.03em !important;
}


/* v124: Seat visible without click + compact Present + ALL CAPS tables + Adequate no ellipsis */

/* ALL TABLE TEXT CAPS */
table, thead th, tbody td { text-transform: uppercase !important; }

/* Seat selector: show value clearly when NOT clicked */
.seatSel{
  width:140px !important;
  min-width:140px !important;
  max-width:140px !important;
  padding:6px 10px !important;
  font-size:14px !important;
  font-weight:800 !important;
  text-align:left !important;
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
}

/* Present selector: smaller but readable (Y/N) */
.presentSel{
  width:120px !important;
  min-width:120px !important;
  max-width:120px !important;
  padding:4px 8px !important;
  font-size:13px !important;
  font-weight:800 !important;
  text-align:center !important;
}
.presentSel.partial-ring{
  box-shadow:0 0 0 3px #d4a017, 0 0 8px rgba(212,160,23,0.5);
  border-radius:4px;
  background:#3d2200 !important;
  color:#d4a017 !important;
  border-color:#d4a017 !important;
}
.customSelBtn.partial-yellow{
  background:#d4a017 !important;
  color:#fff !important;
  border-color:#b8860b !important;
  box-shadow:0 0 0 2px #d4a017 !important;
  font-size:11px !important;
}
.customSelBtn.tardy-red{
  background:#fca5a5 !important;
  color:#7f1d1d !important;
  border-color:#ef4444 !important;
  box-shadow:0 0 0 2px #ef4444 !important;
  font-size:11px !important;
}
.customSelBtn.trainer-green{
  background:#3fe7b6 !important;
  color:#064e3b !important;
  border-color:#10b981 !important;
  box-shadow:0 0 0 2px #3fe7b6 !important;
  font-size:11px !important;
}
.customSelBtn.trainee-green{
  background:#a7f3d0 !important;
  color:#064e3b !important;
  border-color:#6ee7b7 !important;
  box-shadow:0 0 0 2px #a7f3d0 !important;
  font-size:11px !important;
}
.presentSel.tardy-ring{
  box-shadow:0 0 0 3px #ef4444, 0 0 8px rgba(239,68,68,0.5);
  border-radius:4px;
  background:#3d1111 !important;
  color:#fca5a5 !important;
  border-color:#ef4444 !important;
}
.rowPill.tardy-needs-time{
  box-shadow:0 0 0 3px #ef4444, 0 0 8px rgba(239,68,68,0.5);
  background:#3d1111 !important;
  color:#fca5a5 !important;
  border-color:#ef4444 !important;
  animation: tardyPulse 1.5s ease-in-out infinite;
}
@keyframes tardyPulse{
  0%,100%{ box-shadow:0 0 0 3px #ef4444, 0 0 8px rgba(239,68,68,0.5); }
  50%{ box-shadow:0 0 0 3px #ef4444, 0 0 16px rgba(239,68,68,0.8); }
}
.presentSel.trainer-ring{
  box-shadow:0 0 0 3px #3fe7b6, 0 0 8px rgba(63,231,182,0.5);
  border-radius:4px;
  background:#0d3326 !important;
  color:#6ee7b7 !important;
  border-color:#3fe7b6 !important;
}
.presentSel.trainee-ring{
  box-shadow:0 0 0 3px #a7f3d0, 0 0 8px rgba(167,243,208,0.5);
  border-radius:4px;
  background:#112e22 !important;
  color:#a7f3d0 !important;
  border-color:#a7f3d0 !important;
}

/* Adequate box: clean word handling */
.adeqTbl{
  table-layout:auto !important;
}
.adeqTbl th,.adeqTbl td{
  white-space:nowrap !important;
  overflow:visible !important;
  text-overflow:clip !important;
}


/* v125: Seat size by role */

/* Default (CT) = compact */
.seatSel{
  width:100px !important;
  min-width:100px !important;
  max-width:100px !important;
  font-size:13px !important;
}

/* Non-CT (DP/PIC/SUP) = wider */
tr:has(.roleSelect[value]:not([value="CT"])) .seatSel,
tr:has(select[value]:not([value="CT"])) .seatSel{
  width:140px !important;
  min-width:140px !important;
  max-width:140px !important;
  font-size:14px !important;
  font-weight:800 !important;
}


/* v126: Prevent seat text cutoff for DP/PIC/SUP + make Role as small as possible */

/* Role selector tighter */
.roleSelect, select.roleSelect, .role, select.role{
  width:48px !important;
  min-width:48px !important;
  max-width:48px !important;
  padding:3px 6px !important;
  font-size:12px !important;
}

/* Seat selector default (CT) stays compact */
.seatSel{
  text-overflow:ellipsis !important;
}

/* Seat selector for DP/PIC/SUP: wide + no ellipsis */
.seatSelWide{
  width:180px !important;
  min-width:180px !important;
  max-width:180px !important;
  font-size:14px !important;
  font-weight:800 !important;
  white-space:nowrap !important;
  overflow:visible !important;
  text-overflow:clip !important;
}

/* Apply wide seat for Dispatcher/PIC/SUP tables (by table header label) */
.sectionTitle:has(+ table) { } /* noop */

/* Heuristic: make seat wide inside DISPATCHER/PIC/SUP sections */
.sectionCard[data-role="DISPATCHER"] .seatSel,
.sectionCard[data-role="PIC"] .seatSel,
.sectionCard[data-role="SUP"] .seatSel,
.blockCard[data-role="DISPATCHER"] .seatSel,
.blockCard[data-role="PIC"] .seatSel,
.blockCard[data-role="SUP"] .seatSel{
  width:180px !important;
  min-width:180px !important;
  max-width:180px !important;
  font-size:14px !important;
  font-weight:800 !important;
  white-space:nowrap !important;
  overflow:visible !important;
  text-overflow:clip !important;
}

/* Fallback: any seat select in rows where Role != CT */
tr:has(select option:checked:not([value="CT"])) .seatSel{
  width:180px !important;
  min-width:180px !important;
  max-width:180px !important;
  font-size:14px !important;
  font-weight:800 !important;
  text-overflow:clip !important;
}


/* v127: Seat bubble shows up to ~6 letters + prevent table from pushing off right */

/* Ensure everything sizes inside the card */
*, *::before, *::after { box-sizing: border-box; }
.sectionCard, .blockCard, .panel, .card, .listCard { max-width: 100% !important; overflow-x: hidden !important; }
table { width: 100% !important; max-width: 100% !important; }

/* Keep table cells from forcing horizontal overflow */
th, td {
  max-width: 1px; /* enables ellipsis in fixed-ish tables */
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Role: as small as possible */
.roleSelect, select.roleSelect, .role, select.role{
  width:44px !important;
  min-width:44px !important;
  max-width:44px !important;
  padding:3px 6px !important;
  font-size:12px !important;
}

/* Seat: sized to fit ~6 characters visibly (assuming you shortened values in DB) */
.seatSel, select.seatSel, .seatSelect, select.seatSelect, .seat, select.seat{
  width:92px !important;
  min-width:92px !important;
  max-width:92px !important;
  padding:5px 8px !important;
  font-size:13px !important;
  font-weight:800 !important;
  text-transform: uppercase !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}

/* Present selector compact */
.presentSel{
  width:120px !important;
  min-width:120px !important;
  max-width:120px !important;
  padding:4px 8px !important;
  font-size:13px !important;
  font-weight:800 !important;
  text-align:center !important;
}

/* In single-panel mode, let the card breathe but still no horizontal overflow */
.singlePanelMode .blockColumn { max-width: 100% !important; }
.singlePanelMode .blocksWrap { max-width: 100% !important; }


/* v128: Make seat selector truly compact (~6 chars wide) */

/* Force seat selector smaller */
.seatSel,
select.seatSel,
.seatSelect,
select.seatSelect,
.seat,
select.seat{
  width:70px !important;
  min-width:70px !important;
  max-width:70px !important;
  padding:4px 6px !important;
  font-size:12px !important;
  font-weight:800 !important;
  line-height:1.1 !important;
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
}

/* Also shrink wrapper cells if any */
td.seatCell,
th.seatCell{
  width:70px !important;
  max-width:70px !important;
}


/* v129: Compact seat + auto-trim display */
select.seatSel,
select.seat,
select.seatSelect{
  width:52px !important;
  min-width:52px !important;
  max-width:52px !important;
  padding:2px 4px !important;
  font-size:11px !important;
  font-weight:700 !important;
  text-align:center !important;
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
}


/* v130: Left-align seat selector text */
select.seatSel,
select.seat,
select.seatSelect{
  text-align: left !important;
  padding-left: 6px !important;
}


/* Absence reason selector (shown only in ABSENT section) */
.absReasonSel, select.absReasonSel{
  width:120px !important;
  min-width:120px !important;
  max-width:120px !important;
  padding:2px 6px !important;
  font-size:11px !important;
  font-weight:800 !important;
  text-transform: uppercase !important;
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
}

/* OTH type selector (SD/TRN/B/ADM) */
.othTypeSel, select.othTypeSel{
  width:70px !important;
  min-width:70px !important;
  max-width:70px !important;
  padding:2px 6px !important;
  font-size:11px !important;
  font-weight:800 !important;
  text-transform: uppercase !important;
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
}

/* FINAL OVERRIDE: Seat selector truly compact */
select.seatSel,
select.seat,
select.seatSelect,
.seatSel,
.seatSelect{
  width:48px !important;
  min-width:48px !important;
  max-width:48px !important;
  padding:2px 4px !important;
  font-size:11px !important;
  font-weight:700 !important;
  text-align:left !important;
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
}


/* ===== Custom Select (dropdown width = options only) ===== */
.customSel{ position:relative; display:inline-block; vertical-align:middle; }
.customSelBtn{
  display:inline-flex; align-items:center; justify-content:space-between; gap:6px;
  background:#0c1320;
  color:var(--text);
  border:1px solid var(--border);
  border-radius:12px;
  padding:4px 6px;
  font-size:12px;
  font-weight:700;
  line-height:1.1;
  cursor:pointer;
  user-select:none;
  width:auto;
}
.customSel--role .customSelBtn{min-width:36px; max-width:52px;}
.customSel--seat .customSelBtn{min-width:36px; max-width:90px;}
.customSel--present .customSelBtn{min-width:18px; max-width:28px; font-size:11px !important; font-weight:900 !important; padding:1px 3px !important; line-height:1 !important;}
.customSel--absreason .customSelBtn{min-width:50px; max-width:120px;}

.customSelBtn .lbl{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.customSelBtn .car{ opacity:.75; font-size:11px; }
.customSelMenu{
  position:absolute;
  top:calc(100% + 6px);
  left:0;
  background:#0c1320;
  border:1px solid var(--border);
  border-radius:12px;
  box-shadow:0 4px 12px rgba(0,0,0,.25);
  padding:6px;
  display:none;
  z-index:9999;
  min-width:160px;
  max-height:260px;
  overflow:auto;
}
/* Role selector: show all options without scrolling */
.customSel--role .customSelMenu{
  max-height:none;
  overflow:visible;
}
.customSelMenu.open{ display:block; }
.customSelOpt.kbHL{
  background:rgba(77,163,255,.25) !important;
  outline:2px solid rgba(77,163,255,.5);
}
body.light .customSelOpt.kbHL{
  background:rgba(30,100,200,.15) !important;
  outline:2px solid rgba(30,100,200,.3);
}
.customSelOpt{
  display:block;
  width:100%;
  text-align:left;
  padding:7px 10px;
  border-radius:10px;
  border:0;
  background:transparent;
  color:var(--text);
  font:inherit;
  cursor:pointer;
  white-space:nowrap;
}
.customSelOpt:hover{ background:rgba(255,255,255,.06); }
.customSelOpt[aria-selected="true"]{ background:rgba(77,163,255,.18); }

/* ===== Fix: controls were unclickable / time end input clipped =====
   The global td/th max-width + overflow rules can clip interactive controls.
   We keep the table from overflowing by using fixed layout + explicit column widths,
   and we allow control cells to overflow visibly.
*/
.rosterTbl{ table-layout:fixed; width:100% !important; }
.rosterTbl th, .rosterTbl td{ overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:65px !important; }
.rosterTbl th:first-child,
.rosterTbl td:first-child{
  width: 12ch !important;
  max-width: 12ch !important;
  padding-right: 6px !important;
}
.rosterTbl th.nameCol, .rosterTbl td.nameCol{ width:40%; }
.rosterTbl th.roleCol, .rosterTbl td.roleCol{ width:56px; }
.rosterTbl th.seatCol, .rosterTbl td.seatCol{ width:68px; }
.rosterTbl th.workedCol, .rosterTbl td.workedCol{ width:100px; }
.rosterTbl th.hrsCol, .rosterTbl td.hrsCol{ width:32px; max-width:32px; padding:0 !important; }
.rosterTbl th.presCol, .rosterTbl td.presCol{ width:34px !important; min-width:34px !important; padding:0 !important; }
.rosterTbl th.cmtCol, .rosterTbl td.cmtCol{ width:18px !important; max-width:18px !important; padding:0 !important; text-align:center; overflow:visible !important; position:relative; z-index:5; }

/* control cells must allow popups/inputs to be visible and clickable */
.rosterTbl td.ctrlCell, .rosterTbl th.ctrlCol{
  overflow:visible !important;
  text-overflow:clip !important;
  max-width:none !important;
}

/* ensure custom select button occupies full cell and receives clicks */
.customSel{ width:100%; }
.customSelBtn{ width:100%; pointer-events:auto; }

/* worked editor should be fully visible */
.timeEdit{ white-space:nowrap; }
.timeEdit input[type="time"]{ width:88px; }



/* ===== v140: Fix roster fit + restore Worked pill styling ===== */

/* Restore Worked pill look (it was getting overridden) */
.rosterTbl .rowPill{
  display:inline-block !important;
  padding:6px 10px !important;
  border:1px solid var(--border) !important;
  border-radius:999px !important;
  background:rgba(255,255,255,.06) !important;
  color:var(--text) !important;
  font-weight:800 !important;
  min-width:74px !important;
  text-align:center !important;
}

/* Roster table column sizing: balanced and readable */
.rosterTbl{ table-layout:fixed !important; width:100% !important; }
.rosterTbl th, .rosterTbl td{ max-width:none !important; }

/* Name: single line with ellipsis */
.rosterTbl th.nameCol, .rosterTbl td.nameCol{
  width:24% !important;
}
.rosterTbl td.nameCol{
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
  line-height:1.15 !important;
}

/* Role/Seat/Worked/Hrs/P: tighter but clickable */
.rosterTbl th.roleCol, .rosterTbl td.roleCol{ width:56px !important; }
.rosterTbl th.seatCol, .rosterTbl td.seatCol{ width:68px !important; }
.rosterTbl th.workedCol, .rosterTbl td.workedCol{ width:90px !important; }
.rosterTbl th.hrsCol, .rosterTbl td.hrsCol{ width:32px !important; max-width:32px !important; padding:0 !important; }
.rosterTbl th.presCol, .rosterTbl td.presCol{ width:34px !important; min-width:34px !important; padding:0 !important; }
.rosterTbl th.cmtCol, .rosterTbl td.cmtCol{ width:18px !important; max-width:18px !important; padding:0 !important; }

/* Make custom-select triggers fill their cells cleanly (no weird skinny menus) */
.customSelBtn{
  height:28px !important;
  border-radius:999px !important;
  padding:4px 10px !important;
}
.customSelMenu{
  padding:6px !important;
}
.customSelOpt{
  border-radius:10px !important;
  padding:8px 10px !important;
}

/* Worked editor: always show BOTH inputs when opened */
.rosterTbl .timeEdit{
  gap:6px !important;
}
.rosterTbl .timeEdit input[type="time"]{
  width:84px !important;
}

/* Mobile/narrow screens: keep it readable without squishing names to nothing */
@media (max-width: 720px){
  .rosterTbl th.nameCol, .rosterTbl td.nameCol{ width:36% !important; }
  .rosterTbl th.seatCol, .rosterTbl td.seatCol{ width:88px !important; }
  .rosterTbl th.workedCol, .rosterTbl td.workedCol{ width:100px !important; }
}


/* v142: Worked editor pops below (not to the right) */
.rosterTbl { overflow: visible !important; }
.ctrlCell.workedCol { position: relative !important; overflow: visible !important; }
.timeEdit{
  position:absolute !important;
  left:0 !important;
  top:calc(100% + 6px) !important;
  display:none;
  align-items:center;
  gap:6px;
  padding:8px 10px;
  border-radius:12px;
  border:1px solid var(--border);
  background:#0c1320;
  box-shadow:0 8px 24px rgba(0,0,0,.35);
  z-index:80;
}
.timeEdit input[type="time"]{ width:92px !important; }


/* v143: Column sizing so ROLE + SEAT show fully, and WORKED never overlaps HRS */
table.rosterTbl{
  table-layout:auto !important; /* allow columns to hug content */
  width:100% !important;
}

/* Let Name shrink to content so ROLE starts right after the name */
.rosterTbl th.nameCol, .rosterTbl td.nameCol{
  width:auto !important;
  min-width:160px !important;
}
.rosterTbl td.nameCol{
  white-space:nowrap !important;
  overflow:hidden !important;
  text-overflow:ellipsis !important;
  line-height:1.3 !important;
}

/* Fixed widths so selections show fully when NOT engaged */
.rosterTbl th.roleCol, .rosterTbl td.roleCol{
  width:92px !important;
  min-width:92px !important;
  padding-right:16px !important; /* space between ROLE and SEAT */
}
.rosterTbl th.seatCol, .rosterTbl td.seatCol{
  width:170px !important;
  min-width:170px !important;
  padding-left:0 !important;
}

.rosterTbl th.workedCol, .rosterTbl td.workedCol{
  width:120px !important;
  min-width:120px !important;
}
.rosterTbl th.hrsCol, .rosterTbl td.hrsCol{
  width:42px !important;
  min-width:42px !important;
}
.rosterTbl th.presCol, .rosterTbl td.presCol{
  width:34px !important;
  min-width:34px !important;
  padding:0 !important;
}
.rosterTbl th.cmtCol, .rosterTbl td.cmtCol{
  width:18px !important;
  max-width:18px !important;
  padding:0 !important;
}

/* Custom dropdown in roster: fill its cell, but show full selected text */
.rosterTbl .ddWrap{display:inline-block !important; width:100% !important;}
.rosterTbl .ddBtn{width:100% !important; justify-content:space-between !important;}
.rosterTbl .ddText{
  max-width:none !important;
  overflow:visible !important;
  text-overflow:clip !important;
  white-space:nowrap !important;
}

/* Worked editor popover: open BELOW worked, centered, never into HRS */
.rosterTbl td.workedCol{position:relative !important; overflow:visible !important;}
.rosterTbl .timeEdit{
  position:absolute !important;
  left:50% !important;
  transform:translateX(-50%) !important;
  top:calc(100% + 6px) !important;
  z-index:999 !important;
  background:#0c1320 !important;
  border:1px solid rgba(255,255,255,.16) !important;
  border-radius:12px !important;
  padding:8px !important;
  box-shadow:0 8px 24px rgba(0,0,0,.35) !important;
  display:none !important;
  gap:8px !important;
}
.rosterTbl .timeEdit input[type="time"]{
  width:92px !important;
  padding:8px 10px !important;
}
.rosterTbl .timeEdit.open{display:flex !important;}




/* ===== v145 FINAL ROSTER LAYOUT OVERRIDES (fix core width/spacing issues) ===== */
/* Core problem was multiple conflicting .rosterTbl width rules + global td clipping.
   These overrides are last, so they win. */

table.rosterTbl{
  table-layout: fixed !important;
  width: 100% !important;
}

.rosterTbl th, .rosterTbl td{
  max-width: none !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
}

/* Name column sizing */
.rosterTbl th.nameCol, .rosterTbl td.nameCol{ width:26% !important; }
.rosterTbl td.nameCol{
  white-space: nowrap !important;   /* single line */
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  line-height: 1.15 !important;
}

/* Put ROLE immediately after NAME, and let selections show in closed state */
/* Use percentages so NAME never collapses to 0px on narrower cards */
.rosterTbl th.nameCol, .rosterTbl td.nameCol{ width: 24% !important; }
.rosterTbl th.roleCol, .rosterTbl td.roleCol{ width: 10% !important; }
.rosterTbl th.seatCol, .rosterTbl td.seatCol{ width: 14% !important; }
.rosterTbl th.workedCol, .rosterTbl td.workedCol{ width: 11% !important; }
.rosterTbl th.hrsCol, .rosterTbl td.hrsCol{ width:32px !important; max-width:32px !important; padding:0 !important; }
.rosterTbl th.presCol, .rosterTbl td.presCol{ width:34px !important; min-width:34px !important; padding:0 !important; }
.rosterTbl th.cmtCol, .rosterTbl td.cmtCol{ width:18px !important; max-width:18px !important; padding:0 !important; }

/* Ensure controls don't get squished / keep readable */
.rosterTbl td.ctrlCell, .rosterTbl th.ctrlCol{
  padding-left: 10px !important;
  padding-right: 10px !important;
}

/* Custom dropdown closed text: show full value (no C...) inside allowed width */
.rosterTbl .ddBtn{
  width: 100% !important;
}
.rosterTbl .ddText{
  overflow: hidden !important;
  text-overflow: clip !important;   /* prefer showing full within the column */
  white-space: nowrap !important;
}

/* Worked popover: open BELOW worked pill, not sideways */
.rosterTbl td.workedCol{
  position: relative !important;
  overflow: visible !important;
}
.rosterTbl .timeEdit{
  position: absolute !important;
  left: 50% !important;
  top: calc(100% + 8px) !important;
  transform: translateX(-50%) !important;
  z-index: 9999 !important;
  display: none !important;
  gap: 8px !important;
  padding: 10px 10px !important;
  border-radius: 14px !important;
  border: 1px solid var(--border) !important;
  background: #0c1320 !important;
  box-shadow: 0 8px 24px rgba(0,0,0,.35) !important;
}
.rosterTbl .timeEdit.open{
  display: flex !important;
}
.rosterTbl .timeEdit input[type="time"]{
  width: 92px !important;
}

/* Keep dropdown menus sized to content but never clipped by table/card */
.ddMenu{
  max-width: none !important;
}


/* v148: Tight NAME so ROLE sits close (no huge blank runway) */
.rosterTable { table-layout: auto !important; width:100% !important; }
.rosterTable th.nameCol,
.rosterTable td.nameCol{
  width:1% !important;            /* shrink-to-fit */
  white-space:nowrap !important;  /* keep name compact */
  padding-right:8px !important;   /* about ~4 letters space */
}
.rosterTable th.nameCol{padding-left:12px !important;}
/* If a name is long, allow wrap only in the NAME cell by adding title tooltip via existing text (optional) */
/* Keep other cells from stretching */
.rosterTable th, .rosterTable td{ vertical-align:middle; }



/* v149: Show full selected values (no ellipsis) without needing to click */
.rosterTbl th,
.rosterTbl td{
  /* keep layout stable */
  white-space: nowrap !important;
}

/* Do NOT show "..." for selected values; clip instead */
.rosterTbl .customSelBtn .lbl,
.rosterTbl .ddText,
.rosterTbl select{
  overflow: hidden !important;
  text-overflow: clip !important;
  white-space: nowrap !important;
}

/* Give the closed dropdown a bit more room so values are readable */
.rosterTbl td.roleCol .customSelBtn,
.rosterTbl td.seatCol .customSelBtn,
.rosterTbl td.presCol .customSelBtn{
  padding-left: 10px !important;
  padding-right: 10px !important;
}

/* If any older rules force ellipsis on the buttons, override them */
.customSelBtn .lbl{ text-overflow: clip !important; }


/* ===== v150: Clickable dropdowns + show selected text (no ellipsis) ===== */
.rosterTbl td, .rosterTbl th{ position:relative; }

/* Keep cells from swallowing clicks */
.rosterTbl td{ pointer-events:auto; }

/* Ensure custom dropdown trigger is always on top and clickable */
.customSel{ position:relative; z-index:20; width:100%; }
.customSelBtn{
  position:relative;
  z-index:21;
  pointer-events:auto;
}

/* Show selected value without "C..." while keeping the row compact */
.customSelBtn .lbl{
  overflow:hidden !important;
  text-overflow:clip !important;   /* removes the "..." */
  white-space:nowrap !important;
}

/* If any global rules set pointer-events oddly, force menu + options clickable */
.customSelMenu, .customSelOpt{ pointer-events:auto; }

/* Native selects (if any remain) should also show value without ellipsis */
.rosterTbl select{
  text-overflow:clip !important;
}

/* Prevent hidden Worked editor overlay from blocking clicks */
.timeEdit{ pointer-events:none; }
.timeEdit.open{ pointer-events:auto; }



/* v152: Scoot columns slightly left (tighter NAME) */

/* === FIX: Seat dropdown always on top === */

/* Allow table + rows to show popups */
.rosterTbl,
.rosterTbl tbody,
.rosterTbl tr,
.rosterTbl td {
  overflow: visible !important;
}

/* Make seat dropdown stack above other rows */
.customSel--seat {
  position: relative !important;
  z-index: 2000 !important;
}

/* Force dropdown menu highest layer */
.customSel--seat .customSelMenu {
  position: absolute !important;
  z-index: 99999 !important;
  min-width:auto !important;
  width:auto !important;
  white-space:nowrap;
  overflow-x:hidden;
  max-height:300px !important;
  overflow-y:auto !important;
}
/* Seat dropdown options: centered */
.customSel--seat .customSelOpt{
  text-align:center !important;
  padding:8px 12px !important;
  width:auto !important;
}

/* Prevent other controls from covering it */
.customSel,
.customSelBtn {
  position: relative !important;
  z-index: 1000 !important;
}


/* === v154 FIX: Ensure dropdown menu overlays rows below (table stacking) === */
/* Give each row a stacking context so z-index can work */
.rosterTbl tbody tr{ position:relative; z-index:0; }
/* When any custom select menu or time editor is open in a row, lift that whole row above others */
.rosterTbl tbody tr:has(.customSelMenu.open){ z-index: 99998 !important; }
.rosterTbl tbody tr:has(.timeEdit.open){ z-index: 99998 !important; }
/* Keep the open menu above everything */
.customSelMenu.open{ z-index: 99999 !important; }
/* Safety: don't let other buttons sit above the menu */
.customSelBtn{ z-index: 1; }



/* === v155 FIX: Seat shows full number (CT31) + prevent ROLE/SEAT/HRS/PRESENT stacking === */

/* Give the roster table a little more breathing room for control columns */
table.rosterTbl{
  table-layout: fixed !important;
  width: 100% !important;
}

/* Rebalance column widths so controls don't get forced into tiny wrap/stack */
.rosterTbl th.nameCol,  .rosterTbl td.nameCol  { width: 32% !important; }
.rosterTbl th.roleCol,  .rosterTbl td.roleCol  { width: 8% !important; }
.rosterTbl th.seatCol,  .rosterTbl td.seatCol  { width: 12% !important; }
.rosterTbl th.workedCol,.rosterTbl td.workedCol{ width: 12% !important; }
.rosterTbl th.hrsCol,   .rosterTbl td.hrsCol   { width:32px !important; max-width:32px !important; padding:0 !important; }
.rosterTbl th.presCol,  .rosterTbl td.presCol  { width: 34px !important; min-width:34px !important; padding:0 !important; }
.rosterTbl th.cmtCol,   .rosterTbl td.cmtCol   { width: 18px !important; max-width:18px !important; padding:0 !important; }

/* Keep each control on ONE line and aligned (no vertical stacking) */
.rosterTbl td.ctrlCell{
  white-space: nowrap !important;
}
.customSelBtn{
  display:flex !important;
  flex-wrap: nowrap !important;
  align-items:center !important;
  justify-content:space-between !important;
  white-space: nowrap !important;
}

/* All custom selects: centered in cell, compact */
.customSel--role, .customSel--seat, .customSel--present, .customSel--absreason, .customSel--othtype { margin: 0 auto !important; }
.customSel--role .customSelBtn,
.customSel--seat .customSelBtn {
  justify-content: center !important;
  text-align: center !important;
  overflow: hidden !important;
  font-size: 13px !important;
  padding: 3px 5px !important;
}
.customSel--present .customSelBtn {
  justify-content: center !important;
  text-align: center !important;
  overflow: hidden !important;
  font-size: 11px !important;
  padding: 1px 3px !important;
  min-width: 18px !important;
  max-width: 28px !important;
  border-radius: 8px !important;
}
.customSel--role .customSelBtn .lbl,
.customSel--seat .customSelBtn .lbl,
.customSel--present .customSelBtn .lbl {
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
  text-align: center !important;
}


/* === v156: Tight NAME so other columns shift left === */

/* Let NAME shrink instead of reserving big space */
.rosterTbl th.nameCol,
.rosterTbl td.nameCol{
  width: 1% !important;          /* shrink-to-fit */
  min-width: 120px !important;  /* still readable */
  max-width: 180px !important;
  white-space: nowrap !important;
  padding-right: 6px !important;
}

/* Remove extra padding between NAME and ROLE */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-left: 2px !important;
}

/* Pull all control columns slightly left */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol,
.rosterTbl th.seatCol,
.rosterTbl td.seatCol,
.rosterTbl th.workedCol,
.rosterTbl td.workedCol,
.rosterTbl th.hrsCol,
.rosterTbl td.hrsCol,
.rosterTbl th.presCol,
.rosterTbl td.presCol{
  padding-left: 4px !important;
  padding-right: 4px !important;
}


/* === v157: Keep NAME readable while still shifting columns left === */
.rosterTbl th.nameCol,
.rosterTbl td.nameCol{
  width: 26% !important;         /* wider name column */
  min-width: 180px !important;
  max-width: none !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  padding-right: 2px !important;
}
.rosterTbl th.nameCol{ padding-left: 12px !important; }

/* Push ROLE right, tight against SEAT */
.rosterTbl th.roleCol, .rosterTbl td.roleCol{
  padding-left: 0 !important;
  padding-right: 2px !important;
  text-align: right !important;
}
.rosterTbl th.seatCol, .rosterTbl td.seatCol{
  padding-left: 4px !important;
  padding-right: 6px !important;
}
.rosterTbl th.workedCol, .rosterTbl td.workedCol,
.rosterTbl th.hrsCol, .rosterTbl td.hrsCol,
.rosterTbl th.presCol, .rosterTbl td.presCol{
  padding-left: 6px !important;
  padding-right: 6px !important;
}


/* ===== v158: Worked editor pops UP and is NOT transparent ===== */
.rosterTbl td.workedCol{ position: relative !important; overflow: visible !important; }

/* Popover: open ABOVE the worked pill */
.rosterTbl .timeEdit{
  position: absolute !important;
  left: 50% !important;
  bottom: calc(100% + 8px) !important;  /* pop UP */
  top: auto !important;
  transform: translateX(-50%) !important;

  z-index: 99999 !important;

  /* solid background (not see-through) */
  background: #0c1320 !important;
  opacity: 1 !important;

  border: 1px solid rgba(255,255,255,.22) !important;
  border-radius: 14px !important;
  padding: 10px 12px !important;
  box-shadow: 0 8px 24px rgba(0,0,0,.35) !important;

  display: none !important;
  gap: 8px !important;
  white-space: nowrap !important;
}

/* When opened, show it */
.rosterTbl .timeEdit.open{ display: flex !important; }

/* Make sure the inputs are readable */
.rosterTbl .timeEdit input[type="time"]{
  background: #0c1320 !important;
  color: var(--text) !important;
  border: 1px solid var(--border) !important;
  opacity: 1 !important;
}


/* === v159: Dropdown menus always visible (flip up if near bottom) === */
.customSelMenu{ z-index: 99999 !important; }
.customSelMenu.flipUp{
  top: auto !important;
  bottom: calc(100% + 6px) !important;
}
/* Raise the row/card when any custom menu is open (helps table stacking contexts) */
tr:has(.customSelMenu.open){
  position: relative !important;
  z-index: 5000 !important;
}


/* ===== v160: Wider SEAT display for DISPATCHER / PIC / SUP so selected value is readable ===== */

/* Keep CALL TAKER seat compact by default */
.rosterTbl td.seatCol .customSel--seat .customSelBtn{
  min-width: 50px !important;
  max-width: 100% !important;
  width: auto !important;
}

/* Make SEAT wider in Dispatcher/PIC/SUP sections */
.sectionCard[data-role="DISPATCHER"] td.seatCol .customSel--seat .customSelBtn,
.sectionCard[data-role="PIC"] td.seatCol .customSel--seat .customSelBtn,
.sectionCard[data-role="SUP"] td.seatCol .customSel--seat .customSelBtn,
.sectionCard[data-role="SUPERVISOR"] td.seatCol .customSel--seat .customSelBtn{
  min-width: 60px !important;
  max-width: 100% !important;
  width: auto !important;
  padding-left: 8px !important;
  padding-right: 8px !important;
}

/* Give the SEAT column itself a bit more room in those sections */
.sectionCard[data-role="DISPATCHER"] table.rosterTbl th.seatCol,
.sectionCard[data-role="DISPATCHER"] table.rosterTbl td.seatCol,
.sectionCard[data-role="PIC"] table.rosterTbl th.seatCol,
.sectionCard[data-role="PIC"] table.rosterTbl td.seatCol,
.sectionCard[data-role="SUP"] table.rosterTbl th.seatCol,
.sectionCard[data-role="SUP"] table.rosterTbl td.seatCol,
.sectionCard[data-role="SUPERVISOR"] table.rosterTbl th.seatCol,
.sectionCard[data-role="SUPERVISOR"] table.rosterTbl td.seatCol{
  width: 22% !important;
}

/* Show selected text with ellipsis if needed */
.customSel--seat .customSelBtn .lbl{
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
  max-width: 70px !important;
}


/* === v162: ABSENT REASON dropdown: no internal scroll + always on top === */

/* Let popups escape the cards too */
.card, .panel, .blockCard, .sectionCard, .listCard{
  overflow: visible !important;
}

/* Absent reason menu: show all options (no scroll), solid background */
.customSel--absreason{ position:relative !important; z-index: 9000 !important; }
.customSel--absreason .customSelMenu{
  max-height: none !important;
  overflow: visible !important;
  background: #0c1320 !important;
  border: 1px solid var(--border) !important;
  z-index: 99999 !important;
  box-shadow: 0 8px 24px rgba(0,0,0,.40) !important;
}

/* If flipped up, keep it above */
.customSel--absreason .customSelMenu.flipUp{
  top: auto !important;
  bottom: calc(100% + 8px) !important;
}

/* When an absent menu is open, lift the row extra high */
.rosterTbl tbody tr:has(.customSel--absreason .customSelMenu.open){
  position: relative !important;
  z-index: 99998 !important;
}


/* v163: Remove aggressive cut-off for SUP role selector */
.sectionCard[data-role="SUP"] table.rosterTbl th.roleCol,
.sectionCard[data-role="SUP"] table.rosterTbl td.roleCol,
.sectionCard[data-role="SUPERVISOR"] table.rosterTbl th.roleCol,
.sectionCard[data-role="SUPERVISOR"] table.rosterTbl td.roleCol{
  width: 72px !important;
  min-width: 72px !important;
}

.sectionCard[data-role="SUP"] .customSel--role .customSelBtn,
.sectionCard[data-role="SUPERVISOR"] .customSel--role .customSelBtn{
  min-width: 64px !important;
  padding-left: 10px !important;
  padding-right: 10px !important;
}

.sectionCard[data-role="SUP"] .customSel--role .customSelBtn .lbl,
.sectionCard[data-role="SUPERVISOR"] .customSel--role .customSelBtn .lbl{
  text-overflow: clip !important;
}



/* v164: STAFFING NUMBERS header — clean compact */
.adeqBoxHead{
  text-align:center !important;
  letter-spacing:.06em !important;
  background: rgba(255,255,255,0.03) !important;
  border-bottom:1px solid var(--border) !important;
  color: #cfe3ff !important;
  text-shadow: none !important;
  font-size:12px !important;
  padding:7px 8px !important;
}

/* === FINAL FIX: SUP role never clips (v168) === */

/* Widen ROLE column in Supervisor section */
.sectionCard[data-role="SUP"] .rosterTbl th.roleCol,
.sectionCard[data-role="SUP"] .rosterTbl td.roleCol,
.sectionCard[data-role="SUPERVISOR"] .rosterTbl th.roleCol,
.sectionCard[data-role="SUPERVISOR"] .rosterTbl td.roleCol{
  width: 72px !important;
  min-width: 72px !important;
}

/* Widen ROLE dropdown button in Supervisor section */
.sectionCard[data-role="SUP"] .customSel--role .customSelBtn,
.sectionCard[data-role="SUPERVISOR"] .customSel--role .customSelBtn{
  min-width: 64px !important;
  width: 64px !important;
  padding-left: 10px !important;
  padding-right: 10px !important;
}

/* Prevent label clipping */
.sectionCard[data-role="SUP"] .customSel--role .lbl,
.sectionCard[data-role="SUPERVISOR"] .customSel--role .lbl{
  overflow: visible !important;
  text-overflow: clip !important;
  white-space: nowrap !important;
}


/* === v169: SUP label fix (caret was stealing space, last letter clipped) === */

/* In Supervisor section, make the ROLE button wide enough for 3 letters + caret */
.sectionCard[data-role="SUP"] .customSel--role .customSelBtn,
.sectionCard[data-role="SUPERVISOR"] .customSel--role .customSelBtn{
  min-width: 78px !important;
  width: 78px !important;
  max-width: 78px !important;
  padding-left: 10px !important;
  padding-right: 14px !important; /* extra space so 'P' never clips */
}

/* Ensure the label can use space and doesn't get ellipsis/clip by global rules */
.sectionCard[data-role="SUP"] .customSel--role .customSelBtn .lbl,
.sectionCard[data-role="SUPERVISOR"] .customSel--role .customSelBtn .lbl{
  flex: 1 1 auto !important;
  min-width: 0 !important;
  overflow: visible !important;
  text-overflow: clip !important;
  white-space: nowrap !important;
  padding-right: 10px !important; /* space before caret */
}

/* Also widen ROLE column a touch so button isn't constrained by cell */
.sectionCard[data-role="SUP"] .rosterTbl th.roleCol,
.sectionCard[data-role="SUP"] .rosterTbl td.roleCol,
.sectionCard[data-role="SUPERVISOR"] .rosterTbl th.roleCol,
.sectionCard[data-role="SUPERVISOR"] .rosterTbl td.roleCol{
  width: 88px !important;
  min-width: 88px !important;
}


/* === v170: ROLE labels (esp SUP) must never clip anywhere === */

/* Table cell clipping rules in older blocks can chop the role button. Undo for role column cells. */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  overflow: visible !important;
  max-width: none !important;
}

/* Give role buttons enough real width for 3 letters + caret, everywhere */
.customSel--role .customSelBtn{
  min-width: 36px !important;
  width: auto !important;
  max-width: 52px !important;
  padding: 2px 4px !important;
  justify-content: center !important;
  text-align: center !important;
}

.customSel--role .customSelBtn .lbl{
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
  text-align: center !important;
  padding-right: 0 !important;
}


/* === v171: Prevent ROLE + SEAT controls from visually merging === */

/* Restore a little breathing room between ROLE and SEAT columns */
.rosterTbl th.roleCol, .rosterTbl td.roleCol{ padding-right: 10px !important; }
.rosterTbl th.seatCol, .rosterTbl td.seatCol{ padding-left: 10px !important; }

/* Add a small gap between adjacent custom selects inside the same row */
.rosterTbl td.roleCol .customSel{ margin-right: 8px !important; }
.rosterTbl td.seatCol .customSel{ margin-left: 0 !important; }

/* Make sure buttons don't spill into neighboring cells */
.rosterTbl td.roleCol .customSelBtn,
.rosterTbl td.seatCol .customSelBtn{
  width: 100% !important;
  max-width: 100% !important;
}

/* Keep the caret inside the button without overlapping edges */
.customSelBtn{
  box-sizing: border-box !important;
}


/* === v172: Scoot ROLE left so it never touches SEAT === */

/* Shift ROLE column slightly left */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-left: 2px !important;
  padding-right: 14px !important; /* bigger gap before SEAT */
}

/* Shift SEAT slightly right */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 14px !important;
}

/* Add visual gap between pills */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 10px !important;
}

/* Prevent buttons from stretching into neighbors */
.rosterTbl td.roleCol .customSelBtn,
.rosterTbl td.seatCol .customSelBtn{
  box-sizing: border-box !important;
  max-width: calc(100% - 6px) !important;
}


/* === v173: Scoot ROLE further left for more separation === */

/* Push ROLE content further left, increase gap to SEAT */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-left: 0px !important;
  padding-right: 20px !important; /* larger gap */
}

/* Push SEAT slightly right */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 18px !important;
}

/* Stronger margin between buttons */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 14px !important;
}


/* === v174: Scoot ROLE even more left (final tuning) === */

/* Maximize gap between ROLE and SEAT */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-left: 0px !important;
  padding-right: 26px !important; /* bigger gap */
}

/* Push SEAT further right */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 22px !important;
}

/* Extra margin between buttons */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 18px !important;
}


/* === v175: Scoot ROLE further left (max separation) === */

/* Increase gap between ROLE and SEAT even more */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-left: 0px !important;
  padding-right: 32px !important; /* max gap */
}

/* Push SEAT further right */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 26px !important;
}

/* Extra margin between buttons */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 22px !important;
}


/* === v176: Scoot ROLE ultra left (maximum safe spacing) === */

/* Push ROLE far left and open big gutter */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-left: 0px !important;
  padding-right: 42px !important; /* ultra gap */
}

/* Push SEAT further right */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 34px !important;
}

/* Strong margin between buttons */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 28px !important;
}


/* === v177: Lock ROLE bubble to 4-letter width (compact, no clipping) === */

/* ROLE column: fixed compact size */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  width: 56px !important;
  min-width: 56px !important;
  max-width: 56px !important;
  padding-right: 18px !important; /* keep gap to SEAT */
}

/* ROLE button: fits up to 4 letters + caret */
.customSel--role .customSelBtn{
  min-width: 36px !important;
  max-width: 52px !important;
  width: auto !important;
  padding: 2px 4px !important;
  font-size: 10px !important;
  font-weight: 700 !important;
  text-align: center !important;
  justify-content: center !important;
  overflow: hidden !important;
}

.customSel--role .customSelBtn .lbl{
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
  text-align: center !important;
}


/* === v178: Bring SEAT closer to ROLE (balanced spacing) === */

/* Reduce gap after ROLE */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-right: 10px !important; /* was 18px */
}

/* Reduce left padding on SEAT */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 8px !important; /* was much larger */
}

/* Reduce extra margin between buttons */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 6px !important;
}


/* === v179: Bring SEAT even closer to ROLE (fine tune) === */

/* Further reduce gap after ROLE */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-right: 6px !important; /* tighter */
}

/* Further reduce left padding on SEAT */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 4px !important; /* tighter */
}

/* Reduce margin between buttons more */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 3px !important;
}


/* === v180: Bring SEAT MUCH closer to ROLE (aggressive tighten) === */

/* Almost remove gap after ROLE */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-right: 2px !important;
}

/* Minimal left padding on SEAT */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 2px !important;
}

/* Nearly remove margin between buttons */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 1px !important;
}


/* === v181: ROLE → SEAT ultra-close (4x tighter) === */

/* Remove almost all gap after ROLE */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-right: 0px !important;
}

/* Remove left padding on SEAT */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 0px !important;
}

/* Eliminate margin between buttons */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 0px !important;
}

/* Slight negative nudge to pull SEAT left (safe) */
.rosterTbl td.seatCol .customSel{
  margin-left: -4px !important;
}


/* === v182: ROLE → SEAT shift ~0.5 inch left (strong offset) === */

/* Remove all padding between ROLE and SEAT */
.rosterTbl th.roleCol,
.rosterTbl td.roleCol{
  padding-right: 0px !important;
}

.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  padding-left: 0px !important;
}

/* No margins */
.rosterTbl td.roleCol .customSelBtn{
  margin-right: 0px !important;
}

/* Big left shift for SEAT (~48px ≈ half inch on most screens) */
.rosterTbl td.seatCol .customSel,
.rosterTbl td.seatCol .customSelBtn{
  margin-left: -48px !important;
}

/* Ensure no overlap clipping */
.rosterTbl td.seatCol,
.rosterTbl td.roleCol{
  overflow: visible !important;
}


/* === v183: Align SEAT column header with shifted column === */

/* Shift SEAT header left to match cells */
.rosterTbl th.seatCol{
  padding-left: 0px !important;
  margin-left: -48px !important; /* match body shift */
}

/* Keep header visible */
.rosterTbl thead th{
  overflow: visible !important;
}


/* === v184: Keep current layout working (no new UI) ===
   Replace margin-left hacks on SEAT with transform so controls don't collide/merge
   and header stays aligned. */

/* Neutralize previous margin-left shifts (if present) */
.rosterTbl td.seatCol .customSel,
.rosterTbl td.seatCol .customSelBtn{
  margin-left: 0px !important;
}

/* Apply visual shift without breaking table layout */
.rosterTbl td.seatCol .customSel,
.rosterTbl td.seatCol .customSelBtn{
  transform: translateX(-48px) !important;
}

/* Align SEAT header with the same transform */
.rosterTbl th.seatCol{
  margin-left: 0px !important;
  transform: translateX(-48px) !important;
}

/* Ensure header/cells remain clickable/visible */
.rosterTbl th.seatCol,
.rosterTbl td.seatCol{
  overflow: visible !important;
  position: relative !important;
  z-index: 2 !important;
}
.rosterTbl td.roleCol{
  position: relative !important;
  z-index: 3 !important;
}

/* Small safety gap so ROLE and shifted SEAT never visually fuse */
.rosterTbl td.roleCol .customSelBtn{ margin-right: 2px !important; }


/* === v185: Fix chopped header row by removing transforms and using real column sizing === */

/* Undo v184 transform shifts */
.rosterTbl td.seatCol .customSel,
.rosterTbl td.seatCol .customSelBtn,
.rosterTbl th.seatCol{
  transform: none !important;
}

/* Ensure header row stays intact */
.rosterTbl thead th{
  overflow: visible !important;
  text-overflow: clip !important;
  white-space: nowrap !important;
}

/* Use predictable column widths so headers line up clean */
.rosterTbl{
  table-layout: fixed !important;
}

/* NAME gets enough room, but not too much */
.rosterTbl th.nameCol, .rosterTbl td.nameCol{
  width: 140px !important;
  min-width: 140px !important;
  max-width: 140px !important;
}

/* ROLE compact (4 letters) */
.rosterTbl th.roleCol, .rosterTbl td.roleCol{
  width: 64px !important;
  min-width: 64px !important;
  max-width: 64px !important;
  padding-right: 8px !important;
}

/* SEAT reasonably wide and close to ROLE */
.rosterTbl th.seatCol, .rosterTbl td.seatCol{
  width: 68px !important;
  min-width: 68px !important;
  max-width: 68px !important;
  padding-left: 4px !important;
}

/* WORKED / HRS / PRESENT */
.rosterTbl th.workedCol, .rosterTbl td.workedCol{ width: 85px !important; }
.rosterTbl th.hrsCol, .rosterTbl td.hrsCol{ width:32px !important; max-width:32px !important; padding:0 !important; }
.rosterTbl th.presCol, .rosterTbl td.presCol{ width: 34px !important; min-width:34px !important; padding:0 !important; }
.rosterTbl th.cmtCol, .rosterTbl td.cmtCol{ width:18px !important; max-width:18px !important; padding:0 !important; }

/* Keep pills inside their cells */
.rosterTbl td.roleCol .customSelBtn,
.rosterTbl td.seatCol .customSelBtn{
  max-width: 100% !important;
}


/* === v186: Responsive columns so 3 panels fit (no chopped headers) === */

.rosterTbl{ width:100% !important; table-layout:fixed !important; }

/* Let cards shrink */
.blockCard, .sectionCard, .card{ min-width:0 !important; }

/* Responsive column widths — role hugs seat */
.rosterTbl th.nameCol,  .rosterTbl td.nameCol  { width: auto !important; min-width:0 !important; max-width:none !important; text-align:center !important; }
.rosterTbl th.roleCol,  .rosterTbl td.roleCol  { width: 56px !important; min-width:56px !important; max-width:56px !important; padding-left:0 !important; padding-right:0 !important; text-align:center !important; }
.rosterTbl th.seatCol,  .rosterTbl td.seatCol  { width: 68px !important; min-width:68px !important; max-width:68px !important; padding-left:0 !important; padding-right:0 !important; text-align:center !important; }
.rosterTbl th.workedCol,.rosterTbl td.workedCol{ width: 75px !important; min-width:75px !important; max-width:75px !important; padding-left:0 !important; padding-right:0 !important; text-align:center !important; }
.rosterTbl th.hrsCol,   .rosterTbl td.hrsCol   { width: 22px !important; min-width:22px !important; max-width:22px !important; padding-left:0 !important; padding-right:0 !important; text-align:center !important; }
.rosterTbl th.presCol,  .rosterTbl td.presCol  { width: 24px !important; min-width:24px !important; max-width:24px !important; padding-left:0 !important; padding-right:0 !important; text-align:center !important; }
.rosterTbl th.cmtCol,   .rosterTbl td.cmtCol   { width: 8px !important; min-width:8px !important; max-width:8px !important; padding:0 !important; text-align:center !important; }

/* Keep headers readable */
.rosterTbl thead th{
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  font-size: 10px !important;
}

/* === FINAL AUTHORITY: bubble sizing — wins cascade over ALL earlier rules === */
.rosterTbl .customSel--role .customSelBtn{
  min-width: 0 !important; max-width: 52px !important; width: auto !important;
  font-size: 11px !important; font-weight: 700 !important;
  padding: 2px 4px !important; text-align: center !important;
  justify-content: center !important; overflow: hidden !important;
}
.rosterTbl .customSel--role .customSelBtn .lbl{
  overflow: hidden !important; text-overflow: ellipsis !important;
  white-space: nowrap !important; text-align: center !important;
}
.rosterTbl .customSel--seat .customSelBtn{
  min-width: 0 !important; max-width: 96px !important; width: auto !important;
  font-size: 11px !important; font-weight: 700 !important;
  padding: 2px 4px !important; text-align: center !important;
  justify-content: center !important; overflow: hidden !important;
}
.rosterTbl .customSel--seat .customSelBtn .lbl{
  overflow: hidden !important; text-overflow: ellipsis !important;
  white-space: nowrap !important; text-align: center !important;
  max-width: none !important;
}
.rosterTbl .customSel--present .customSelBtn{
  min-width: 18px !important; max-width: 28px !important; width: 24px !important;
  font-size: 11px !important; font-weight: 900 !important;
  padding: 1px 3px !important; text-align: center !important;
  justify-content: center !important; overflow: visible !important;
  line-height: 1 !important;
}
.rosterTbl .customSel--present .customSelBtn .lbl{
  overflow: visible !important; text-overflow: clip !important;
  white-space: nowrap !important; text-align: center !important;
}
.rosterTbl .customSel--present .customSelBtn .car{ display: none !important; }
/* Override SUP/SUPERVISOR role button to same compact size */
.rosterTbl .sectionCard[data-role="SUP"] .customSel--role .customSelBtn,
.rosterTbl .sectionCard[data-role="SUPERVISOR"] .customSel--role .customSelBtn{
  min-width: 0 !important; max-width: 52px !important; width: auto !important;
  padding: 2px 4px !important;
}
.rosterTbl .sectionCard[data-role="SUP"] .customSel--role .customSelBtn .lbl,
.rosterTbl .sectionCard[data-role="SUPERVISOR"] .customSel--role .customSelBtn .lbl{
  overflow: hidden !important; text-overflow: ellipsis !important;
}
/* All bubbles centered in cells */
.rosterTbl .customSel{ margin: 0 auto !important; }
.rosterTbl .rowPill{ margin: 0 auto !important; }
.rosterTbl .hrsIn{ text-align: center !important; margin: 0 auto !important; display: block !important; width: 72% !important; font-size: 12px !important; }
/* Name column: left-aligned, full text visible */
.rosterTbl td.nameCol .empName{ white-space: nowrap !important; overflow: hidden !important; text-overflow: ellipsis !important; display: block !important; max-width: 100% !important; }

/* === v189: Center + widen in single-panel view (CSS-only, safe) === */

body.singlePanel #blocks{
  display: grid !important;
  grid-template-columns: minmax(490px, min(1200px, 96vw)) !important;
  justify-content: center !important;
}

body.singlePanel #blocks .boardCard{
  width: 100% !important;
  max-width: min(1200px, 96vw) !important;
  margin-left: auto !important;
  margin-right: auto !important;
}

/* Highlight ring for unselected dropdowns */
@keyframes pulseRing {
  0%   { box-shadow: 0 0 0 2px rgba(251,113,133,.6); }
  50%  { box-shadow: 0 0 0 5px rgba(251,113,133,.25); }
  100% { box-shadow: 0 0 0 2px rgba(251,113,133,.6); }
}
.unselected-ring {
  animation: pulseRing 2s ease-in-out infinite;
  border-color: rgba(251,113,133,.7) !important;
}

/* Yellow highlight on focused custom select button */
.customSelBtn:focus {
  outline: none !important;
  border-color: #ffe033 !important;
  box-shadow: 0 0 0 3px rgba(255,224,51,.45), 0 0 12px rgba(255,224,51,.25) !important;
  background: rgba(255,224,51,.12) !important;
}

/* Adeq box — clean compact override */
.adeqBox {
  background: #0c1320 !important;
}
.adeqTbl {
  background: transparent !important;
}
.adeqTbl tr {
  background: transparent !important;
}

/* Status text (clean, no pill, just colored text like admin) */
.statusOver  { color: #86efac !important; font-weight: 900 !important; font-size:12px !important; }
.statusStaffed { color: #fde047 !important; font-weight: 900 !important; font-size:12px !important; }
.statusShort { color: #ff4d4d !important; font-weight: 900 !important; font-size:12px !important; }

/* Role section labels in adeq table */
.adeqRole-CALLTAKER .adeqSectionLabel,
.adeqRole-DISPATCHER .adeqSectionLabel,
.adeqRole-PIC .adeqSectionLabel { color: #cfe3ff !important; }

/* Card backgrounds for roster tables */
.card.boardCard {
  background: var(--card) !important;
  border: 1px solid var(--border) !important;
}

/* Role-tinted cards */
.roleCard-CALLTAKER {
  background: rgba(56,140,255,.06) !important;
  border-color: rgba(56,140,255,.15) !important;
}
.roleCard-CALLTAKER h2.blockHdr { color: #fff !important; }

.roleCard-DISPATCHER {
  background: rgba(192,132,252,.06) !important;
  border-color: rgba(192,132,252,.15) !important;
}
.roleCard-DISPATCHER h2.blockHdr { color: #fff !important; }

.roleCard-PIC {
  background: rgba(45,212,191,.06) !important;
  border-color: rgba(45,212,191,.15) !important;
}
.roleCard-PIC h2.blockHdr { color: #fff !important; }

.roleCard-SUPERVISOR {
  background: rgba(251,191,36,.06) !important;
  border-color: rgba(251,191,36,.15) !important;
}
.roleCard-SUPERVISOR h2.blockHdr { color: #fff !important; }

.roleCard-ABSENT {
  background: rgba(251,113,133,.04) !important;
  border-color: rgba(251,113,133,.12) !important;
}
.roleCard-ABSENT h2.blockHdr { color: #fff !important; }

.roleCard-OTH {
  background: rgba(156,163,175,.06) !important;
  border-color: rgba(156,163,175,.15) !important;
}
.roleCard-OTH h2.blockHdr { color: #fff !important; }

/* === FINAL layout: Name left, everything else centered, no overlap === */
.rosterTbl {
  table-layout: fixed !important;
  width: 100% !important;
}
.rosterTbl th, .rosterTbl td {
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  white-space: nowrap !important;
  padding: 7px 6px !important;
  text-align: center !important;
}
/* Name column: left-aligned, single line with ellipsis */
.rosterTbl th.nameCol, .rosterTbl td.nameCol {
  text-align: left !important;
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  line-height: 1.2 !important;
}
/* Center the header text for all non-name columns */
.rosterTbl th { text-align: center !important; }
.rosterTbl th.nameCol { text-align: left !important; }

/* Controls inside cells: centered */
.rosterTbl td.ctrlCell {
  text-align: center !important;
  overflow: visible !important;
}
.rosterTbl td.ctrlCell select,
.rosterTbl td.ctrlCell input,
.rosterTbl td.ctrlCell .customSelBtn {
  text-align: center !important;
  margin: 0 auto !important;
}
/* Custom select — button stays in cell, dropdown can overflow */
.customSel { overflow: visible !important; position: relative !important; max-width: 100% !important; width: 100% !important; }
.customSelBtn {
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  max-width: 100% !important;
  width: 100% !important;
  min-width: 0 !important;
  justify-content: center !important;
  box-sizing: border-box !important;
}
/* Center all cell content */
.rosterTbl .rowPill { margin: 0 auto !important; }
.rosterTbl .hrsIn { text-align: center !important; margin: 0 auto !important; display: block !important; }
.rosterTbl .customSel { margin: 0 auto !important; }

/* Typing mode indicator for custom selects */
.customSelBtn.typing-mode {
  outline: 2px solid var(--accent) !important;
  outline-offset: -2px !important;
  background: rgba(74,163,255,.15) !important;
}
body.light .customSelBtn.typing-mode {
  outline: 2px solid var(--accent) !important;
  background: rgba(3,105,161,.1) !important;
}

/* FINAL: Name column - single line, no wrap, ellipsis when truncated */
.rosterTbl td.nameCol {
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  max-width: 180px !important;
}
.rosterTbl td.nameCol .empName {
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
  display: inline-block !important;
  max-width: 100% !important;
  vertical-align: middle !important;
}
/* OT/Partial badges inline with name */
.rosterTbl td.nameCol .otBadge {
  display: inline-block !important;
  vertical-align: middle !important;
  margin-left: 4px !important;
}
/* OT badge below name for OT-only employees */
.otNameWrap {
  display: inline-block;
  text-align: left;
}
.rosterTbl td.nameCol .otBadgeTop {
  display: block !important;
  margin-left: 0 !important;
  margin-top: 2px !important;
  border: none !important;
  border-radius: 0 !important;
  padding: 0 !important;
}

/* Login Form Styles */
#loginOverlay{
  position:fixed;
  inset:0;
  background:var(--bg);
  z-index:100000;
  display:flex;
  align-items:center;
  justify-content:center;
}
#loginOverlay.hidden{ display:none; }
.login-box{
  background:var(--card);
  border:1px solid var(--border);
  border-radius:16px;
  padding:32px 40px;
  width:100%;
  max-width:360px;
  box-shadow:0 8px 32px rgba(0,0,0,.3);
}
.login-box h2{
  margin:0 0 8px;
  font-size:24px;
  text-align:center;
  color:var(--text);
}
.login-box .subtitle{
  text-align:center;
  color:var(--muted);
  font-size:13px;
  margin-bottom:24px;
}
.login-box label{
  display:block;
  font-size:12px;
  color:var(--muted);
  margin-bottom:6px;
}
.login-box input[type="email"],
.login-box input[type="password"]{
  width:100%;
  padding:12px 14px;
  border-radius:10px;
  border:1px solid var(--border);
  background:#0c1320;
  color:var(--text);
  font-size:14px;
  margin-bottom:16px;
  outline:none;
}
.login-box input:focus{
  border-color:var(--accent);
  box-shadow:0 0 0 3px rgba(74,163,255,.15);
}
.login-box .btn-login{
  width:100%;
  padding:12px;
  border-radius:10px;
  border:none;
  background:var(--accent);
  color:#fff;
  font-size:14px;
  font-weight:700;
  cursor:pointer;
  margin-top:8px;
}
.login-box .btn-login:hover{ background:#3b8fd9; }
.login-box .btn-login:disabled{ opacity:.6; cursor:not-allowed; }
.login-box .login-error{
  background:rgba(255,95,95,.12);
  border:1px solid rgba(255,95,95,.3);
  color:#ff6b6b;
  padding:10px 12px;
  border-radius:8px;
  font-size:13px;
  margin-bottom:16px;
  display:none;
}
.login-box .login-error.show{ display:block; }
#userInfo{
  display:flex;
  align-items:center;
  gap:10px;
  font-size:12px;
  color:var(--muted);
}
#userInfo .user-email{ color:var(--text); font-weight:600; }
#btnLogout{
  padding:4px 10px;
  font-size:11px;
  border-radius:8px;
  border:1px solid var(--border);
  background:transparent;
  color:var(--text);
  cursor:pointer;
}
#btnLogout:hover{ background:rgba(255,255,255,.06); }

/* === Seat button constrained to cell width === */
.rosterTbl td.seatCol .customSel{ width:100% !important; max-width:100% !important; }
.rosterTbl td.seatCol .customSelBtn{ width:100% !important; max-width:100% !important; overflow:hidden !important; }
.rosterTbl td.seatCol .customSelBtn .lbl{ overflow:hidden !important; text-overflow:ellipsis !important; white-space:nowrap !important; display:block !important; }

</style>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-check-compat.js"></script>
<script>
  // Firebase configuration — ShiftOPS (primary)
  const firebaseConfig = {
    apiKey: "AIzaSyA6KELmSyotefK0zhahQZ0-mbYur8_nTsg",
    authDomain: "commandops-93846.firebaseapp.com",
    databaseURL: "https://commandops-93846-default-rtdb.firebaseio.com",
    projectId: "commandops-93846",
    storageBucket: "commandops-93846.firebasestorage.app",
    messagingSenderId: "262613721964",
    appId: "1:262613721964:web:478a694d357234e3be4949"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  // Firebase configuration — BreakOPS (legitimous, secondary app)
  const breakFirebaseConfig = {
    apiKey: "AIzaSyCnabvDHyrEYPjtGikTSC6eIQL2VEPWnn4",
    authDomain: "legitimous-2f2d2.firebaseapp.com",
    projectId: "legitimous-2f2d2",
    storageBucket: "legitimous-2f2d2.firebasestorage.app",
    messagingSenderId: "1097431114529",
    appId: "1:1097431114529:web:2adfdae7838b4840f0d460"
  };
  const breakApp = firebase.initializeApp(breakFirebaseConfig, "breakops");
  try {
    const breakAppCheck = firebase.appCheck(breakApp);
    breakAppCheck.activate('6LeH6GMsAAAAAIjV9DPRrmSKfvNeNHVS9LI8JQVU', true);
  } catch(e){ console.warn("BreakOPS App Check init skipped:", e); }
  const breakDb = breakApp.firestore();
  db.enablePersistence({synchronizeTabs:true}).catch(err=>{
    console.warn("Firestore persistence not enabled:", err.code);
  });
  const auth = firebase.auth();

  // Auth state listener
  let authReady = false;
  auth.onAuthStateChanged((user) => {
    authReady = true;
    const overlay = document.getElementById('loginOverlay');
    const userInfo = document.getElementById('userInfo');
    const userEmail = document.getElementById('userEmail');

    if (user) {
      // User is signed in
      overlay.classList.add('hidden');
      userInfo.style.display = 'flex';
      userEmail.textContent = user.email;
    } else {
      // User is signed out
      overlay.classList.remove('hidden');
      userInfo.style.display = 'none';
      userEmail.textContent = '';
    }
  });

  // Login form handler
  document.addEventListener('DOMContentLoaded', () => {
    const loginForm = document.getElementById('loginForm');
    const loginError = document.getElementById('loginError');
    const btnLogin = document.getElementById('btnLogin');
    const btnLogout = document.getElementById('btnLogout');

    loginForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;

      loginError.classList.remove('show');
      btnLogin.disabled = true;
      btnLogin.textContent = 'Signing in...';

      try {
        await auth.signInWithEmailAndPassword(email, password);
      } catch (err) {
        let msg = 'Sign in failed';
        if (err.code === 'auth/user-not-found') msg = 'No account found with this email';
        else if (err.code === 'auth/wrong-password') msg = 'Incorrect password';
        else if (err.code === 'auth/invalid-email') msg = 'Invalid email address';
        else if (err.code === 'auth/too-many-requests') msg = 'Too many attempts. Try again later.';
        else if (err.code === 'auth/invalid-credential') msg = 'Invalid email or password';
        loginError.textContent = msg;
        loginError.classList.add('show');
      }

      btnLogin.disabled = false;
      btnLogin.textContent = 'Sign In';
    });

    btnLogout.addEventListener('click', () => {
      auth.signOut();
    });

    // Bug report
    document.getElementById('btnBugReport').addEventListener('click', () => {
      document.getElementById('bugReportName').value = '';
      document.getElementById('bugReportDetails').value = '';
      document.getElementById('bugReportModal').style.display = 'flex';
    });
    document.getElementById('btnBugCancel').addEventListener('click', () => {
      document.getElementById('bugReportModal').style.display = 'none';
    });
    document.getElementById('bugReportModal').addEventListener('click', (e) => {
      if (e.target.id === 'bugReportModal') document.getElementById('bugReportModal').style.display = 'none';
    });
    document.getElementById('btnBugSubmit').addEventListener('click', async () => {
      const name = document.getElementById('bugReportName').value.trim();
      const details = document.getElementById('bugReportDetails').value.trim();
      if (!name || !details) { alert('Please fill in both fields.'); return; }
      try {
        await db.collection('bugReports').add({
          name: name,
          details: details,
          app: 'ShiftOps',
          reportedBy: auth.currentUser ? auth.currentUser.email : 'unknown',
          timestamp: new Date().toISOString(),
          status: 'open'
        });
        document.getElementById('bugReportModal').style.display = 'none';
        alert('Bug report submitted. Thank you!');
      } catch (err) {
        console.error('Bug report failed:', err);
        alert('Failed to submit bug report. Try again.');
      }
    });
  });
</script>

</head>
<body>

<!-- Shared comment popup -->
<div id="cmtPopup"><textarea id="cmtPopupTa" placeholder="Comment..."></textarea></div>
<!-- OT removal confirm popup -->
<div id="otConfirmPopup">
  <div class="ot-confirm-title">Remove OT?</div>
  <div class="ot-confirm-btns">
    <button class="ot-yes" id="otConfirmYes">YES</button>
    <button class="ot-no" id="otConfirmNo">NO</button>
  </div>
</div>

<!-- Shift Swap Modal -->
<div id="swapModalBackdrop">
  <div id="swapModalCard">
    <h3>Shift Swap</h3>
    <div class="swapRow">
      <label>Employee A</label>
      <select id="swapEmpA"><option value="">— select —</option></select>
    </div>
    <div class="swapArrow">&#8693;</div>
    <div class="swapRow">
      <label>Employee B</label>
      <select id="swapEmpB"><option value="">— select —</option></select>
    </div>
    <div style="font-size:12px;font-weight:600;color:var(--muted);margin:12px 0 4px">Apply to days:</div>
    <div class="swapDays" id="swapDayChecks"></div>
    <div id="swapPreview"></div>
    <div id="swapError"></div>
    <div class="swapBtns">
      <button id="swapCancelBtn" onclick="closeSwapModal()">Cancel</button>
      <button id="swapConfirmBtn" onclick="confirmSwap()">Confirm Swap</button>
    </div>
    <div id="swapActiveList"></div>
  </div>
</div>

<!-- Login Overlay -->
<div id="loginOverlay">
  <div class="login-box">
    <h2>ShiftOps</h2>
    <p class="subtitle">Sign in to continue</p>
    <div id="loginError" class="login-error"></div>
    <form id="loginForm">
      <label>Email</label>
      <input type="email" id="loginEmail" placeholder="you@example.com" required autocomplete="email"/>
      <label>Password</label>
      <input type="password" id="loginPassword" placeholder="Enter password" required autocomplete="current-password"/>
      <button type="submit" class="btn-login" id="btnLogin">Sign In</button>
    </form>
  </div>
</div>

<header>
  <div style="display:flex;align-items:center;gap:14px;margin-bottom:10px;">
    <svg class="radar-logo" width="38" height="38" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg" style="flex-shrink:0">
      <!-- outer ring -->
      <circle cx="32" cy="32" r="29" stroke="#233043" stroke-width="1.5" fill="none"/>
      <!-- range rings -->
      <circle cx="32" cy="32" r="20" stroke="#233043" stroke-width=".6" fill="none" opacity=".5"/>
      <circle cx="32" cy="32" r="11" stroke="#233043" stroke-width=".6" fill="none" opacity=".35"/>
      <!-- crosshair lines -->
      <line x1="32" y1="4" x2="32" y2="60" stroke="#233043" stroke-width=".5" opacity=".3"/>
      <line x1="4" y1="32" x2="60" y2="32" stroke="#233043" stroke-width=".5" opacity=".3"/>
      <!-- sweep beam (animated) -->
      <g style="transform-origin:32px 32px;animation:radarSweep 4s linear infinite">
        <defs>
          <linearGradient id="sweepG" x1="0" y1="0" x2="0" y2="1">
            <stop offset="0%" stop-color="#4aa3ff" stop-opacity=".6"/>
            <stop offset="100%" stop-color="#4aa3ff" stop-opacity="0"/>
          </linearGradient>
        </defs>
        <path d="M32,32 L32,3 A29,29 0 0,1 56,14 Z" fill="url(#sweepG)" opacity=".5"/>
        <line x1="32" y1="32" x2="32" y2="3" stroke="#4aa3ff" stroke-width="1" opacity=".8"/>
      </g>
      <!-- center dot -->
      <circle cx="32" cy="32" r="2" fill="#4aa3ff" opacity=".9"/>
      <!-- blips -->
      <circle cx="24" cy="20" r="1.5" fill="#4aa3ff" opacity=".5"/>
      <circle cx="44" cy="26" r="1" fill="#4aa3ff" opacity=".35"/>
      <circle cx="38" cy="42" r="1.2" fill="#4aa3ff" opacity=".4"/>
    </svg>
    <div style="display:flex;flex-direction:column;gap:1px;">
      <h1 style="text-align:left;font-size:28px;font-weight:900;letter-spacing:.04em;margin:0;">ShiftOps</h1>
      <span style="font-size:10px;letter-spacing:.18em;text-transform:uppercase;color:var(--muted);font-weight:600;">All Stations, All Shifts</span>
    </div>
    <div id="userInfo" style="margin-left:auto;display:none;align-items:center;gap:10px;">
      <span class="pill" id="pillUnfilled" style="font-size:13px;padding:6px 14px;cursor:pointer;font-weight:800;letter-spacing:0.5px;" title="Click for details">0 UNFILLED</span>
      <span class="pill good" id="pillFirebase" style="font-size:10px;padding:4px 8px;">Base: Connected</span>
      <span class="pill" id="pillSync" style="font-size:10px;padding:4px 8px;">Sync: idle</span>
      <span class="user-email" id="userEmail"></span>
      <button id="btnBugReport" type="button" title="Report a Bug" style="background:transparent;border:1px solid var(--muted);border-radius:6px;padding:4px 10px;cursor:pointer;font-size:11px;font-weight:700;color:var(--muted);display:inline-flex;align-items:center;gap:5px;transition:border-color .15s,color .15s;font-family:inherit;" onmouseenter="this.style.borderColor='#ef4444';this.style.color='#ef4444'" onmouseleave="this.style.borderColor='var(--muted)';this.style.color='var(--muted)'">&#x1fab2; REPORT BUG</button>
      <button id="btnLogout" type="button">Sign Out</button>
    </div>
    <button id="themeToggle" type="button" style="width:auto;padding:6px 14px;font-size:12px;font-weight:700;border-radius:10px;">&#9789; Dark</button>
  </div>

  <input id="weekStart" type="hidden"/>
  <input id="workDate" type="hidden"/>

  <div class="controls">
    <div>
      <select id="ppSel"></select>
    </div>
    <div>
      <select id="weekSel">
        <option value="1">Week 1</option>
        <option value="2">Week 2</option>
      </select>
    </div>
    <div>
      <select id="daySel"></select>
      <span id="workDateDisplay" style="display:none"></span>
    </div>
    <div>
      <select id="shiftSel">
        <option value="DAY">Day Shift (0600–1800)</option>
        <option value="NIGHT">Night Shift (1800–0600)</option>
      </select>
    </div>
    <div style="display:flex;gap:8px;align-items:end">
      <select id="panelViewSel">
        <option value="all">All 3 blocks</option>
      </select>
      <input id="empSearch" type="text" placeholder="Search…" style="width:140px;padding:8px 8px;font-size:12px;border:1px solid var(--border);border-radius:12px;background:#0c1320;color:var(--text);" oninput="filterByEmployee(this.value)"/>
    </div>

    <div>
      <input id="dbFile" type="file" accept=".xlsx" style="display:none"/>
      <input id="teamsFile" type="file" accept=".xlsx,.csv" style="display:none"/>
      <div style="position:relative;width:100%;">
        <button class="primary" id="btnOptionsToggle" style="padding:10px 12px;font-size:inherit;text-align:center;white-space:nowrap;width:100%;font-weight:700;letter-spacing:0.5px;border-radius:12px;">Options &#9662;</button>
        <div id="optionsMenu" style="display:none;position:absolute;top:calc(100% + 4px);right:0;background:#1e293b;border:1px solid #334155;border-radius:6px;box-shadow:0 4px 16px rgba(0,0,0,.5);z-index:9999;min-width:160px;overflow:hidden;">
          <button id="btnImport" style="display:block;width:100%;padding:10px 14px;font-size:11px;font-weight:600;text-align:left;background:none;border:none;color:#e2e8f0;cursor:pointer;border-bottom:1px solid #334155;">Import OT</button>
          <button id="btnSaveXlsx" style="display:block;width:100%;padding:10px 14px;font-size:11px;font-weight:600;text-align:left;background:none;border:none;color:#e2e8f0;cursor:pointer;border-bottom:1px solid #334155;">Save XLSX</button>
          <button id="btnTimesheet" style="display:block;width:100%;padding:10px 14px;font-size:11px;font-weight:600;text-align:left;background:none;border:none;color:#e2e8f0;cursor:pointer;border-bottom:1px solid #334155;">Timesheet</button>
          <button id="btnPrintDaily" style="display:block;width:100%;padding:10px 14px;font-size:11px;font-weight:600;text-align:left;background:none;border:none;color:#e2e8f0;cursor:pointer;border-bottom:1px solid #334155;">Print Daily</button>
          <button id="btnShiftSwap" style="display:block;width:100%;padding:10px 14px;font-size:11px;font-weight:600;text-align:left;background:none;border:none;color:#a3d4ff;cursor:pointer;border-bottom:1px solid #334155;">Shift Swap</button>
          <button id="btnBreakOPS" style="display:block;width:100%;padding:10px 14px;font-size:11px;font-weight:700;text-align:left;background:none;border:none;color:#f59e0b;cursor:pointer;">Push to BreakOPS</button>
        </div>
      </div>
      <script>
      (function(){
        const btn = document.getElementById('btnOptionsToggle');
        const menu = document.getElementById('optionsMenu');
        btn.addEventListener('click', (e) => { e.stopPropagation(); menu.style.display = menu.style.display === 'none' ? 'block' : 'none'; });
        document.addEventListener('click', () => { menu.style.display = 'none'; });
        menu.addEventListener('click', () => { menu.style.display = 'none'; });
        menu.querySelectorAll('button').forEach(b => { b.addEventListener('mouseenter', function(){ this.style.background='#334155'; }); b.addEventListener('mouseleave', function(){ this.style.background='none'; }); });
      })();
      </script>
    </div>
  </div>
</header>

<main>
  <div id="blocks" class="grid"></div>
</main>

<footer class="diag" style="display:block;">
  <div id="absentBar"></div>
  <span class="pill" id="pillXlsx" style="display:none">XLSX: …</span>
  <span class="pill" id="pillDb" style="display:none">DB: not loaded</span>
  <span class="pill" id="pillAdeq" style="display:none">Adequate: not loaded</span>
  <span class="pill" id="pillSeats" style="display:none">Seats: not loaded</span>
  <span class="pill" id="pillOt" style="display:none">Teams OT: not imported</span>
  <span class="pill err" id="pillErr" style="display:none">Error: <span id="errTxt"></span></span>
</footer>

<script>
// Keep main padding in sync with fixed footer height so content is never hidden behind it
(function(){
  const footer = document.querySelector('footer.diag');
  const main = document.querySelector('main');
  if(!footer || !main) return;
  function sync(){ main.style.paddingBottom = (footer.offsetHeight + 16) + 'px'; }
  sync();
  new ResizeObserver(sync).observe(footer);
})();

// ===== jsPDF loader =====
(function ensureJsPDF(){
  if(window.jspdf) return;
  const cdns=[
    "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.2/jspdf.umd.min.js",
    "https://cdn.jsdelivr.net/npm/jspdf@2.5.2/dist/jspdf.umd.min.js",
    "https://unpkg.com/jspdf@2.5.2/dist/jspdf.umd.min.js"
  ];
  let i=0;
  function tryNext(){
    if(window.jspdf||i>=cdns.length) return;
    const s=document.createElement("script");
    s.src=cdns[i++];
    s.onload=()=>{ console.log("jsPDF loaded"); };
    s.onerror=()=>{ tryNext(); };
    document.head.appendChild(s);
  }
  tryNext();
})();

// ===== XLSX loader =====
function setErr(msg){
  const p=document.getElementById("pillErr");
  document.getElementById("errTxt").textContent=msg;
  p.style.display="inline-flex";
}
function clearErr(){
  document.getElementById("pillErr").style.display="none";
  document.getElementById("errTxt").textContent="";
}
(function ensureXLSX(){
  const pill=document.getElementById("pillXlsx");
  const tryLocal=()=>{
    if(window.XLSX){ pill.textContent="XLSX: ready"; pill.classList.add("good"); return; }
    pill.textContent="XLSX: not loaded (CDN blocked). Put xlsx.full.min.js next to this HTML.";
    pill.classList.add("bad");
  };
  if(window.XLSX){ pill.textContent="XLSX: ready"; pill.classList.add("good"); return; }
  const s=document.createElement("script");
  s.src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js";
  s.onload=()=>{ pill.textContent="XLSX: ready"; pill.classList.add("good"); };
  s.onerror=tryLocal;
  document.head.appendChild(s);
  setTimeout(tryLocal, 1500);
})();

// ===== Helpers =====
const BLOCKS_DAY = [
  {id:"0600-1000", start:"06:00", end:"10:00"},
  {id:"1000-1400", start:"10:00", end:"14:00"},
  {id:"1400-1800", start:"14:00", end:"18:00"},
];
const BLOCKS_NIGHT = [
  {id:"1800-2200", start:"18:00", end:"22:00"},
  {id:"2200-0200", start:"22:00", end:"02:00"},
  {id:"0200-0600", start:"02:00", end:"06:00"},
];
function getBlocks(){ return document.getElementById("shiftSel").value==="NIGHT" ? BLOCKS_NIGHT : BLOCKS_DAY; }
function pad2(n){ return String(n).padStart(2,"0"); }
function toISODate(d){ return d.getFullYear()+"-"+pad2(d.getMonth()+1)+"-"+pad2(d.getDate()); }
function parseISO(s){ const [y,m,d]=s.split("-").map(Number); return new Date(y,m-1,d); }

function addDaysISO(iso, days){
  // iso: YYYY-MM-DD
  const d = parseISO(iso);
  d.setDate(d.getDate() + (days||0));
  return toISODate(d);
}

function dayNameFromISO(iso){
  const d=parseISO(iso);
  const names=["SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"];
  return names[d.getDay()];
}
function minutesOf(timeStr){
  const [h,m]=String(timeStr||"00:00").split(":").map(Number);
  return (h*60)+(m||0);
}
function overlapMinutes(aStart,aEnd,bStart,bEnd){
  const s=Math.max(aStart,bStart);
  const e=Math.min(aEnd,bEnd);
  return Math.max(0, e-s);
}
function roundQuarterHours(mins){ return Math.round((mins/60)*4)/4; }
function minToHHMM(m){
  const hh=Math.floor(m/60)%24, mm=m%60;
  return pad2(hh)+":"+pad2(mm);
}
function esc(s){
  return String(s)
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/'/g,"&#39;").replace(/"/g,"&quot;");
}
function sheetToJson(ws){ return XLSX.utils.sheet_to_json(ws,{defval:""}); }
function sheetToGrid(ws){ return XLSX.utils.sheet_to_json(ws,{header:1, defval:""}); }

// ===== Data state =====
let BASE_EMP=[];
let PANEL_VIEW = 'all'
const rowComments = {};  // key: "blockId|empName" => comment string
let ADEQ={CALLTAKER:{},DISPATCHER:{},PIC:{},SUPERVISOR:{}};
let SEATS={CALLTAKER:[],DISPATCHER:[],PIC:[],SUPERVISOR:[]};
let ABSENT_REASONS=[];

let OT_BY_CTX=new Map(); // ctxKey -> array of OT entries
let EDITS_BY_CTX=new Map(); // ctxKey -> Map(emp->edit)

// ===== Vacations (synced from rotation_plans) =====
let _vacations = [];
let _vacUnsub = null;
let _vacSaveTs = 0;

function getVacDocRef(iso){
  const d = parseISO(iso);
  const yr = d.getFullYear();
  const moIdx = d.getMonth(); // 0-based, matches rotationops convention
  return db.collection('rotation_plans').doc('rotation_' + yr + '_' + moIdx);
}

function loadVacations(iso){
  return getVacDocRef(iso).get().then(doc => {
    if(doc.exists && Array.isArray(doc.data().vacations)){
      _vacations = doc.data().vacations;
    } else {
      _vacations = [];
    }
  }).catch(e => console.warn('Failed to load vacations:', e));
}

function listenVacations(iso){
  if(_vacUnsub) _vacUnsub();
  _vacUnsub = getVacDocRef(iso).onSnapshot(doc => {
    if(!doc.exists) return;
    const data = doc.data();
    if(Array.isArray(data.vacations)){
      const incoming = JSON.stringify(data.vacations);
      if(incoming !== JSON.stringify(_vacations)){
        _vacations = data.vacations;
        renderAll();
      }
    }
  });
}

function isOnVacationDate(name, iso){
  if(!_vacations.length) return false;
  const nm = name.toUpperCase();
  const dt = parseISO(iso).getTime();
  const d = parseISO(iso);
  const yr = d.getFullYear(); const mo = d.getMonth();
  const monthEnd = new Date(yr, mo + 1, 0);
  for(const v of _vacations){
    if(v.name.toUpperCase() !== nm) continue;
    const f = v.from ? new Date(v.from + 'T00:00:00') : new Date(yr, mo, 1);
    const t = v.to ? new Date(v.to + 'T00:00:00') : monthEnd;
    if(dt >= f.getTime() && dt <= t.getTime()) return true;
  }
  return false;
}

// ===== Shift Swaps =====
let SHIFT_SWAPS = new Map(); // iso date -> array of {empA, empB, createdAt}
let swapUnsubscribe = null;

function getSwappedShift(emp, iso){
  const swaps = SHIFT_SWAPS.get(iso);
  if(!swaps) return null;
  for(const sw of swaps){
    if(sw.empA === emp) return sw.empB;
    if(sw.empB === emp) return sw.empA;
  }
  return null;
}
function isSwapped(emp, iso){
  return getSwappedShift(emp, iso) !== null;
}

function ctxKey(iso, shift, blockId){ return iso+"|"+shift+"|"+blockId; }
function editsMapFor(key){ if(!EDITS_BY_CTX.has(key)) EDITS_BY_CTX.set(key,new Map()); return EDITS_BY_CTX.get(key); }
function ensureEdit(key, emp){
  const m=editsMapFor(key);
  if(!m.has(emp)) m.set(emp,{Present:"YES",Hours:"",Role:"",Assignment:"",AbsenceReason:"",PartialReason:"",WorkedStart:"",WorkedEnd:"",OthType:""});
  return m.get(emp);
}
function getEditVal(key, emp, field){
  const m=editsMapFor(key);
  return m.has(emp) ? m.get(emp)[field] : "";
}
function normalizeRole(pos){
  const p=String(pos||"").toUpperCase().trim();
  if(p.includes("CALL") || p==="CT") return "CALLTAKER";
  if(p.includes("DISP") || p==="DP") return "DISPATCHER";
  if(p.includes("PIC")) return "PIC";
  if(p.includes("SUP")) return "SUPERVISOR";
  if(p==="OTH" || p==="OTHER") return "OTH";
  return p||"";
}

// ===== Firebase Data Loading =====
async function loadFromFirebase(){
  clearErr();
  const pDb=document.getElementById("pillDb");
  const pA=document.getElementById("pillAdeq");
  const pS=document.getElementById("pillSeats");

  pDb.textContent="DB: loading...";
  pDb.classList.remove("good","bad");

  try {
    // Fire ALL Firestore queries in parallel
    const adeqMap = [
      ["Calltaker_Adequate_Staffing", "CALLTAKER", "Calltaker Adequate staffing"],
      ["Dispatcher_Adequate_Staffing", "DISPATCHER", "Dispatcher Adequate Staffing"],
      ["PIC_Adequate_Staffing", "PIC", "PIC Adequate Staffing"],
    ];
    const seatMap = [
      ["Calltaker_Seat_Assignments", "CALLTAKER"],
      ["Dispatcher_Seat_Assignments", "DISPATCHER"],
      ["PIC_Seat_Assignments", "PIC"],
      ["Supervisor_seat_Assignments", "SUPERVISOR"],
    ];

    const [empSnap, ...otherSnaps] = await Promise.all([
      db.collection('employees').get(),
      ...adeqMap.map(([c])=> db.collection(c).get().catch(e=>{ console.warn("Failed to load "+c, e); return null; })),
      ...seatMap.map(([c])=> db.collection(c).get().catch(e=>{ console.warn("Failed to load "+c, e); return null; })),
      db.collection('Absent_Reason').get().catch(e=>{ console.warn("Failed to load Absent_Reason", e); return null; }),
    ]);

    // 1. Process employees
    BASE_EMP = empSnap.docs.map(doc => {
      const r = doc.data();
      return {
        Employee: r.Employee || doc.id,
        SENIORITY: r.SENIORITY ?? r.Seniority ?? "",
        POSITION: normalizeRole(r.POSITION ?? r.Position ?? ""),
        SATURDAY: r.SATURDAY ?? "",
        SUNDAY: r.SUNDAY ?? "",
        MONDAY: r.MONDAY ?? "",
        TUESDAY: r.TUESDAY ?? "",
        WEDNESDAY: r.WEDNESDAY ?? "",
        THURSDAY: r.THURSDAY ?? "",
        FRIDAY: r.FRIDAY ?? "",
      };
    }).filter(r=>r.Employee);

    pDb.textContent="DB: loaded ("+BASE_EMP.length+")";
    pDb.classList.toggle("good", BASE_EMP.length>0);
    if(!BASE_EMP.length) pDb.classList.add("bad");

    // 2. Process adequate staffing
    ADEQ={CALLTAKER:{},DISPATCHER:{},PIC:{},SUPERVISOR:{}};
    const dayColMap = {
      "Sun": "SUNDAY", "Mon": "MONDAY", "Tue": "TUESDAY",
      "Wed": "WEDNESDAY", "Thu": "THURSDAY", "Fri": "FRIDAY", "Sat": "SATURDAY"
    };
    let adeqLoaded = 0;
    for(let ai=0; ai<adeqMap.length; ai++){
      const [collection, role, timeField] = adeqMap[ai];
      const snap = otherSnaps[ai];
      if(!snap) continue;
      snap.docs.forEach(doc => {
        const data = doc.data();
        const timeVal = data[timeField];
        if(timeVal === "Time" || timeVal === undefined || timeVal === null) return;
        const hourKey = String(timeVal).replace(/[^0-9]/g,"").padStart(4,"0");
        if(!hourKey) return;
        for(const [colName, dayName] of Object.entries(dayColMap)){
          const val = data[colName];
          if(val !== undefined && val !== null && val !== ""){
            const num = Number(val);
            if(Number.isFinite(num)){
              if(!ADEQ[role][dayName]) ADEQ[role][dayName] = {};
              ADEQ[role][dayName][hourKey] = num;
              adeqLoaded++;
            }
          }
        }
      });
    }
    pA.textContent = adeqLoaded > 0 ? "Adequate: loaded" : "Adequate: not loaded";
    pA.classList.toggle("good", adeqLoaded > 0);
    if(adeqLoaded === 0) pA.classList.add("bad");

    // 3. Process seat assignments
    SEATS={CALLTAKER:[],DISPATCHER:[],PIC:[],SUPERVISOR:[]};
    let seatsLoaded = 0;
    for(let si=0; si<seatMap.length; si++){
      const [collection, role] = seatMap[si];
      const snap = otherSnaps[adeqMap.length + si];
      if(!snap) continue;
      const vals = snap.docs.map(doc => {
        const data = doc.data();
        return Object.values(data)[0];
      }).map(v => String(v||"").trim()).filter(Boolean);
      if(vals.length){
        SEATS[role] = vals;
        seatsLoaded += vals.length;
      }
    }

    // 4. Process absent reasons
    ABSENT_REASONS = [];
    const absSnap = otherSnaps[adeqMap.length + seatMap.length];
    if(absSnap){
      const seen = new Set();
      absSnap.docs.forEach(doc => {
        const data = doc.data();
        const reason = Object.values(data)[0];
        const s = String(reason||"").trim();
        if(s && !seen.has(s)){
          seen.add(s);
          ABSENT_REASONS.push(s);
        }
      });
    }

    // Ensure VACATION is always available as an absence reason
    if(!ABSENT_REASONS.includes("VACATION")) ABSENT_REASONS.unshift("VACATION");

    const seatsOk = Object.values(SEATS).some(arr=>Array.isArray(arr)&&arr.length);
    const absOk = (ABSENT_REASONS && ABSENT_REASONS.length);
    pS.textContent = (seatsOk ? "Seats: loaded" : "Seats: not loaded") + " · " + (absOk ? ("Absent Reasons: "+ABSENT_REASONS.length) : "Absent Reasons: not loaded");
    pS.classList.toggle("good", !!seatsOk && !!absOk);
    if(!(seatsOk && absOk)) pS.classList.add("bad");

    console.log("SheetOps: loaded from Firebase", {
      employees: BASE_EMP.length,
      adeq: adeqLoaded,
      seats: seatsLoaded,
      absReasons: ABSENT_REASONS.length,
    });
    return true;
  } catch(err){
    console.error("Firebase load error:", err);
    setErr("Firebase load failed: " + (err.message || err));
    pDb.textContent="DB: Firebase error";
    pDb.classList.add("bad");
    return false;
  }
}

// ===== Firebase Data Saving =====
async function saveEditsToFirebase(iso, shift){
  const key = iso + "|" + shift;
  const docId = iso + "_" + shift;

  // Collect all edits for this date/shift
  const allEdits = {};
  for(const [ctxKey, editsMap] of EDITS_BY_CTX.entries()){
    if(ctxKey.startsWith(key)){
      const blockId = ctxKey.split("|")[2];
      for(const [emp, edit] of editsMap.entries()){
        if(!allEdits[emp]) allEdits[emp] = {};
        const clean = {...edit};
        delete clean._userEdited;
        delete clean._vacAutoMarked;
        allEdits[emp][blockId] = clean;
      }
    }
  }

  // Collect OT entries
  const otEntries = [];
  for(const [ctxKey, otArr] of OT_BY_CTX.entries()){
    if(ctxKey.startsWith(key)){
      const blockId = ctxKey.split("|")[2];
      for(const ot of otArr){
        otEntries.push({...ot, blockId: blockId});
      }
    }
  }

  // Save to Firebase
  try {
    await db.collection('daily_edits').doc(docId).set({
      date: iso,
      shift: shift,
      edits: allEdits,
      ot: otEntries,
      comments: Object.fromEntries(Object.entries(rowComments).filter(([k,v]) => v)),
      savedAt: new Date().toISOString()
    }, {merge: true});
    console.log("Saved edits to Firebase:", docId);
    return true;
  } catch(err){
    console.error("Firebase save error:", err);
    setErr("Failed to save: " + (err.message || err));
    return false;
  }
}

async function loadEditsFromFirebase(iso, shift){
  const docId = iso + "_" + shift;
  try {
    const doc = await db.collection('daily_edits').doc(docId).get();
    if(doc.exists){
      const data = doc.data();
      // Restore edits
      if(data.edits){
        for(const [emp, blocks] of Object.entries(data.edits)){
          for(const [blockId, edit] of Object.entries(blocks)){
            const ctx = ctxKey(iso, shift, blockId);
            const m = editsMapFor(ctx);
            edit._userEdited = true; // loaded from saved data, don't override with vacation auto-mark
            m.set(emp, edit);
          }
        }
      }
      // Restore OT (clear existing entries for this date+shift first to avoid duplicates on re-load)
      if(data.ot){
        const ctxPrefix = iso + "|" + shift;
        for(const [k] of OT_BY_CTX.entries()){
          if(k.startsWith(ctxPrefix)) OT_BY_CTX.delete(k);
        }
        for(const entry of data.ot){
          const ctx = ctxKey(iso, shift, entry.blockId || "");
          if(!OT_BY_CTX.has(ctx)) OT_BY_CTX.set(ctx, []);
          OT_BY_CTX.get(ctx).push(entry);
        }
      }
      // Restore comments
      if(data.comments){
        Object.assign(rowComments, data.comments);
      }
      console.log("Loaded edits from Firebase:", docId);
      return true;
    }
  } catch(err){
    console.warn("Failed to load edits from Firebase:", err);
  }
  return false;
}

// ===== Auto-Save & Real-Time Sync =====
let autoSaveTimer = null;
let realtimeUnsubscribe = null;
let lastSavedAt = null; // track to ignore our own writes
let isSyncing = false;

function setSyncStatus(status, isGood = null) {
  const pill = document.getElementById("pillSync");
  if (!pill) return;
  pill.textContent = "Sync: " + status;
  pill.classList.remove("good", "bad");
  if (isGood === true) pill.classList.add("good");
  if (isGood === false) pill.classList.add("bad");
}

function scheduleAutoSave() {
  // Debounce: wait 1.5 seconds after last change before saving
  if (autoSaveTimer) clearTimeout(autoSaveTimer);
  setSyncStatus("pending...");

  autoSaveTimer = setTimeout(async () => {
    const iso = document.getElementById("workDate").value;
    const shift = document.getElementById("shiftSel").value;
    if (!iso || !shift) return;

    setSyncStatus("saving...");
    isSyncing = true;
    const ok = await saveEditsToFirebase(iso, shift);
    isSyncing = false;

    if (ok) {
      lastSavedAt = Date.now();
      setSyncStatus("synced", true);
    } else {
      setSyncStatus("failed", false);
    }
  }, 1500);
}

function startRealtimeSync(iso, shift) {
  // Stop any existing listener
  if (realtimeUnsubscribe) {
    realtimeUnsubscribe();
    realtimeUnsubscribe = null;
  }

  if (!iso || !shift) return;

  const docId = iso + "_" + shift;

  realtimeUnsubscribe = db.collection('daily_edits').doc(docId).onSnapshot((doc) => {
    // Skip if we're currently saving (to avoid feedback loop)
    if (isSyncing) return;

    // Skip if this is likely our own write (within 2 seconds of our save)
    if (lastSavedAt && Date.now() - lastSavedAt < 2000) return;

    if (!doc.exists) return;

    const data = doc.data();
    if (!data) return;

    console.log("Realtime update received:", docId);
    setSyncStatus("updating...");

    // Clear current edits for this date/shift and reload
    const keyPrefix = iso + "|" + shift;
    for (const [ctxKey] of EDITS_BY_CTX.entries()) {
      if (ctxKey.startsWith(keyPrefix)) {
        EDITS_BY_CTX.delete(ctxKey);
      }
    }
    for (const [ctxKey] of OT_BY_CTX.entries()) {
      if (ctxKey.startsWith(keyPrefix)) {
        OT_BY_CTX.delete(ctxKey);
      }
    }

    // Restore edits from snapshot
    if (data.edits) {
      for (const [emp, blocks] of Object.entries(data.edits)) {
        for (const [blockId, edit] of Object.entries(blocks)) {
          const ctx = ctxKey(iso, shift, blockId);
          const m = editsMapFor(ctx);
          edit._userEdited = true;
          m.set(emp, edit);
        }
      }
    }

    // Restore OT from snapshot
    if (data.ot) {
      for (const entry of data.ot) {
        const ctx = ctxKey(iso, shift, entry.blockId || "");
        if (!OT_BY_CTX.has(ctx)) OT_BY_CTX.set(ctx, []);
        OT_BY_CTX.get(ctx).push(entry);
      }
    }

    // Restore comments from snapshot
    if (data.comments) {
      // Clear existing comments for this context
      for (const key of Object.keys(rowComments)) {
        if (key.includes("|")) delete rowComments[key];
      }
      Object.assign(rowComments, data.comments);
    }

    // Re-render UI
    renderAll();
    setSyncStatus("live", true);

  }, (err) => {
    console.error("Realtime sync error:", err);
    setSyncStatus("error", false);
  });
}

// ===== Shift Swap Firestore Operations =====
async function saveShiftSwap(iso, empA, empB){
  const docRef = db.collection('shift_swaps').doc(iso);
  try {
    await db.runTransaction(async (tx) => {
      const doc = await tx.get(docRef);
      const swaps = doc.exists ? (doc.data().swaps || []) : [];
      // Prevent double-swap: neither employee can already be in a swap for this date
      for(const sw of swaps){
        if(sw.empA === empA || sw.empB === empA || sw.empA === empB || sw.empB === empB){
          throw new Error("One or both employees already have a swap for " + iso);
        }
      }
      swaps.push({empA, empB, createdAt: Date.now()});
      tx.set(docRef, {swaps}, {merge: true});
    });
    return true;
  } catch(err){
    console.error("saveShiftSwap failed:", err);
    return err.message || "Save failed";
  }
}

async function removeShiftSwap(iso, empA, empB){
  const docRef = db.collection('shift_swaps').doc(iso);
  try {
    await db.runTransaction(async (tx) => {
      const doc = await tx.get(docRef);
      if(!doc.exists) return;
      let swaps = doc.data().swaps || [];
      swaps = swaps.filter(sw => !((sw.empA===empA && sw.empB===empB)||(sw.empA===empB && sw.empB===empA)));
      tx.set(docRef, {swaps}, {merge: true});
    });
    return true;
  } catch(err){
    console.error("removeShiftSwap failed:", err);
    return false;
  }
}

async function loadShiftSwaps(iso){
  try {
    const doc = await db.collection('shift_swaps').doc(iso).get();
    if(doc.exists && doc.data().swaps){
      SHIFT_SWAPS.set(iso, doc.data().swaps);
    } else {
      SHIFT_SWAPS.set(iso, []);
    }
  } catch(err){
    console.warn("loadShiftSwaps failed:", err);
    SHIFT_SWAPS.set(iso, []);
  }
}

function startSwapSync(iso){
  if(swapUnsubscribe){ swapUnsubscribe(); swapUnsubscribe = null; }
  if(!iso) return;
  swapUnsubscribe = db.collection('shift_swaps').doc(iso).onSnapshot((doc) => {
    if(doc.exists && doc.data().swaps){
      SHIFT_SWAPS.set(iso, doc.data().swaps);
    } else {
      SHIFT_SWAPS.set(iso, []);
    }
    renderAll();
  }, (err) => {
    console.error("Swap sync error:", err);
  });
}

// ===== Shift Swap Modal Logic =====
function _swapWeekDates(){
  // Build dates for the current week (Sat-Fri based on weekStart)
  const wsVal = document.getElementById("weekStart") && document.getElementById("weekStart").value;
  if(!wsVal) return [];
  const ws = parseISO(wsVal);
  const DAYS = ["Saturday","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday"];
  const dates = [];
  for(let i=0;i<7;i++){
    const d = new Date(ws.getTime() + i*86400000);
    const iso = toISODate(d);
    const mm = String(d.getMonth()+1).padStart(2,'0');
    const dd = String(d.getDate()).padStart(2,'0');
    dates.push({iso, dayName: DAYS[i], label: DAYS[i].slice(0,3)+" "+mm+"/"+dd});
  }
  return dates;
}

function openSwapModal(){
  const bd = document.getElementById("swapModalBackdrop");
  // Populate employee dropdowns
  const names = BASE_EMP.map(e=>e.Employee).sort();
  const opts = '<option value="">— select —</option>' + names.map(n=>`<option value="${esc(n)}">${esc(n)}</option>`).join("");
  document.getElementById("swapEmpA").innerHTML = opts;
  document.getElementById("swapEmpB").innerHTML = opts;
  // Build day checkboxes for current week
  const dates = _swapWeekDates();
  const curISO = document.getElementById("workDate").value;
  let chkHtml = "";
  for(const d of dates){
    const checked = (d.iso === curISO) ? " checked" : "";
    chkHtml += `<label><input type="checkbox" value="${d.iso}" data-dayname="${d.dayName}"${checked}/> ${d.label}</label>`;
  }
  document.getElementById("swapDayChecks").innerHTML = chkHtml;
  // Wire up change events on checkboxes
  document.getElementById("swapDayChecks").querySelectorAll('input').forEach(cb => cb.addEventListener('change', updateSwapPreview));
  document.getElementById("swapPreview").innerHTML = "";
  document.getElementById("swapError").textContent = "";
  renderSwapList();
  bd.classList.add("open");
}

function closeSwapModal(){
  document.getElementById("swapModalBackdrop").classList.remove("open");
}

function renderSwapList(){
  const iso = document.getElementById("workDate").value;
  const swaps = SHIFT_SWAPS.get(iso) || [];
  const el = document.getElementById("swapActiveList");
  if(!swaps.length){ el.innerHTML = ""; return; }
  let html = '<div class="swapListTitle">Active Swaps ('+iso+')</div>';
  for(const sw of swaps){
    html += `<div class="swapListItem">
      <span>${esc(sw.empA)} &#8596; ${esc(sw.empB)}</span>
      <button class="swapRemove" onclick="confirmRemoveSwap('${esc(iso)}','${esc(sw.empA)}','${esc(sw.empB)}')" title="Remove swap">&times;</button>
    </div>`;
  }
  el.innerHTML = html;
}

function updateSwapPreview(){
  const empA = document.getElementById("swapEmpA").value;
  const empB = document.getElementById("swapEmpB").value;
  const el = document.getElementById("swapPreview");
  if(!empA || !empB){ el.innerHTML = ""; return; }
  if(empA === empB){ el.innerHTML = '<span style="color:var(--bad);font-size:12px">Cannot swap an employee with themselves.</span>'; return; }
  const recA = BASE_EMP.find(e=>e.Employee===empA);
  const recB = BASE_EMP.find(e=>e.Employee===empB);
  if(!recA || !recB){ el.innerHTML = ""; return; }
  // Get checked days
  const checks = document.getElementById("swapDayChecks").querySelectorAll('input:checked');
  if(!checks.length){ el.innerHTML = '<span style="color:var(--muted);font-size:12px">Select at least one day.</span>'; return; }
  let html = '<table><thead><tr><th>Day</th><th>'+esc(empA)+'</th><th></th><th>'+esc(empB)+'</th><th>Status</th></tr></thead><tbody>';
  for(const cb of checks){
    const iso = cb.value;
    const dayName = cb.dataset.dayname;
    const shA = String(recA[dayName]||"").trim() || "OFF";
    const shB = String(recB[dayName]||"").trim() || "OFF";
    let status = "";
    if(shA === shB) status = '<span style="color:var(--warn)">Same shift</span>';
    else {
      // Check if either already has a swap
      const existing = SHIFT_SWAPS.get(iso) || [];
      const conflict = existing.some(sw => sw.empA===empA||sw.empB===empA||sw.empA===empB||sw.empB===empB);
      status = conflict ? '<span style="color:var(--bad)">Already swapped</span>' : '<span style="color:var(--ok)">OK</span>';
    }
    html += `<tr><td>${dayName.slice(0,3)}</td><td>${esc(shA)}</td><td class="swapPreviewArrow">&#8594;</td><td>${esc(shB)}</td><td>${status}</td></tr>`;
  }
  html += '</tbody></table>';
  el.innerHTML = html;
}

async function confirmSwap(){
  const empA = document.getElementById("swapEmpA").value;
  const empB = document.getElementById("swapEmpB").value;
  const errEl = document.getElementById("swapError");
  errEl.textContent = "";
  if(!empA || !empB){ errEl.textContent = "Select both employees."; return; }
  if(empA === empB){ errEl.textContent = "Cannot swap an employee with themselves."; return; }
  const recA = BASE_EMP.find(e=>e.Employee===empA);
  const recB = BASE_EMP.find(e=>e.Employee===empB);
  if(!recA || !recB){ errEl.textContent = "Employee not found in roster."; return; }
  const checks = document.getElementById("swapDayChecks").querySelectorAll('input:checked');
  if(!checks.length){ errEl.textContent = "Select at least one day."; return; }

  const errors = [];
  let successCount = 0;
  for(const cb of checks){
    const iso = cb.value;
    const dayName = cb.dataset.dayname;
    const shA = String(recA[dayName]||"").trim();
    const shB = String(recB[dayName]||"").trim();
    if(shA === shB){
      errors.push(dayName.slice(0,3)+": Both have same shift ("+shA+")");
      continue;
    }
    // Load swaps for that date if not already loaded
    if(!SHIFT_SWAPS.has(iso)) await loadShiftSwaps(iso);
    const result = await saveShiftSwap(iso, empA, empB);
    if(result === true){
      successCount++;
      startSwapSync(iso);
    } else {
      errors.push(dayName.slice(0,3)+": "+result);
    }
  }
  if(successCount > 0){
    renderSwapList();
    updateSwapPreview();
  }
  if(errors.length){
    errEl.textContent = errors.join("; ");
  } else {
    closeSwapModal();
  }
}

async function confirmRemoveSwap(iso, empA, empB){
  await removeShiftSwap(iso, empA, empB);
  renderSwapList();
  renderAll();
}

// ===== Workbook helpers =====
function loadWorkbook(arrayBuf){ return XLSX.read(arrayBuf,{type:"array"}); }
function getSheet(wb, names){
  for(const n of names){ if(wb.Sheets[n]) return {name:n, ws:wb.Sheets[n]}; }
  const keys=Object.keys(wb.Sheets||{});
  for(const n of names){
    const k=keys.find(x=>x.toLowerCase()===String(n).toLowerCase());
    if(k) return {name:k, ws:wb.Sheets[k]};
  }
  return null;
}

// ===== Adequate parsing =====
function dayAbbrevToName(s){
  const t=String(s||"").trim().toLowerCase();
  const map={sun:"SUNDAY",mon:"MONDAY",tue:"TUESDAY",wed:"WEDNESDAY",thu:"THURSDAY",fri:"FRIDAY",sat:"SATURDAY"};
  return map[t]||"";
}
function parseAdequateSheet(wb, sheetNames, role){
  const sh=getSheet(wb, sheetNames);
  if(!sh) return 0;
  const grid=sheetToGrid(sh.ws);
  let hdrIdx=-1;
  for(let i=0;i<Math.min(grid.length,15);i++){
    const c0=String((grid[i]||[])[0]||"").trim().toLowerCase();
    if(c0==="time" || c0==="hour" || c0==="hrs"){ hdrIdx=i; break; }
  }
  if(hdrIdx<0) return 0;
  const headers=(grid[hdrIdx]||[]).map(x=>String(x||"").trim());
  const colDay=[];
  let dayCols=0;
  for(let j=1;j<headers.length;j++){
    const dn=dayAbbrevToName(headers[j]);
    colDay[j]=dn;
    if(dn){ dayCols++; if(!ADEQ[role][dn]) ADEQ[role][dn]={}; }
  }
  let written=0;
  for(let i=hdrIdx+1;i<grid.length;i++){
    const row=grid[i]||[];
    const t=row[0];
    const hourKey=String(t||"").trim();
    const hk = hourKey.replace(/[^0-9]/g,"");
    if(!hk) continue;
    const hk4 = hk.padStart(4,"0");
    for(let j=1;j<headers.length;j++){
      const dn=colDay[j];
      if(!dn) continue;
      const v=row[j];
      if(v==="" || v===null || v===undefined) continue;
      const num=Number(v);
      if(!Number.isFinite(num)) continue;
      ADEQ[role][dn][hk4]=num;
      written++;
    }
  }
  return written;
}

// ===== Seats parsing =====
function parseSeats(wb){
  let loaded=0;
  const seatMap = [
    ["Calltaker Seat Assignments","CALLTAKER"],
    ["Dispatcher Seat Assignments","DISPATCHER"],
    ["PIC Seat Assignments","PIC"],
    ["Supervisor seat Assignments","SUPERVISOR"],
    ["Supervisor Seat Assignments","SUPERVISOR"],
  ];
  for(const [sheetName, role] of seatMap){
    const sh=getSheet(wb,[sheetName]);
    if(sh){
      const vals=sheetToJson(sh.ws).map(r=>Object.values(r)[0]).map(v=>String(v||"").trim()).filter(Boolean);
      if(vals.length){ SEATS[role]=vals; loaded+=vals.length; }
    }
  }
  const p=document.getElementById("pillSeats");
  p.textContent = loaded ? ("Seats: loaded") : "Seats: not loaded";
  p.classList.toggle("good", !!loaded);
  if(!loaded) p.classList.add("bad");
}


function parseAbsentReasons(wb){
  ABSENT_REASONS=[];
  const sh=getSheet(wb, ["Absent Reason","Absence Reason","Absense Reasons","Absent Reasons","ABSENT REASON","ABSENCE REASON","ABSENSE REASONS"]);
  if(!sh) return 0;
  const grid=sheetToGrid(sh.ws);
  // take first column, skip header-ish cells, de-dupe
  const seen=new Set();
  for(let i=0;i<grid.length;i++){
    const v = (grid[i]||[])[0];
    const s = String(v||"").trim();
    if(!s) continue;
    const low=s.toLowerCase();
    if(low==="absent reason"||low==="absence reason"||low==="absense reason"||low==="reason") continue;
    if(!seen.has(s)){
      seen.add(s);
      ABSENT_REASONS.push(s);
    }
  }
  return ABSENT_REASONS.length;
}



// ===== Database parsing =====
function parseDatabase(wb){
  clearErr();
  // employees
  const empSheet = getSheet(wb, ["Employee Database"]) || {name:Object.keys(wb.Sheets)[0], ws:wb.Sheets[Object.keys(wb.Sheets)[0]]};
  const rows=sheetToJson(empSheet.ws);
  BASE_EMP = rows.map(r=>{
    const e = (r.Employee ?? r.EMPLOYEE ?? r.Name ?? r.NAME ?? "").toString().trim();
    return {
      Employee: e,
      SENIORITY: r.SENIORITY ?? r.Seniority ?? "",
      POSITION: normalizeRole(r.POSITION ?? r.Position ?? ""),
      SATURDAY: r.SATURDAY ?? "",
      SUNDAY: r.SUNDAY ?? "",
      MONDAY: r.MONDAY ?? "",
      TUESDAY: r.TUESDAY ?? "",
      WEDNESDAY: r.WEDNESDAY ?? "",
      THURSDAY: r.THURSDAY ?? "",
      FRIDAY: r.FRIDAY ?? "",
    };
  }).filter(r=>r.Employee);

  const pDb=document.getElementById("pillDb");
  pDb.textContent="DB: loaded ("+BASE_EMP.length+")";
  pDb.classList.toggle("good", BASE_EMP.length>0);
  if(!BASE_EMP.length) pDb.classList.add("bad");

  // seats
  SEATS={CALLTAKER:[],DISPATCHER:[],PIC:[],SUPERVISOR:[]};
  parseSeats(wb);
  parseAbsentReasons(wb);

  // adequate
  ADEQ={CALLTAKER:{},DISPATCHER:{},PIC:{},SUPERVISOR:{}};
  const ct=parseAdequateSheet(wb, ["Calltaker Adequate Staffing"], "CALLTAKER");
  const dp=parseAdequateSheet(wb, ["Dispatcher Adequate Staffing"], "DISPATCHER");
  const pic=parseAdequateSheet(wb, ["PIC Adequate Staffing"], "PIC");
  const sup=parseAdequateSheet(wb, ["Supervisor Adequate Staffing","SUP Adequate Staffing","Supervisors Adequate Staffing"], "SUPERVISOR");
  const pA=document.getElementById("pillAdeq");
  const ok = (ct+dp+pic+sup)>0;
  pA.textContent = ok ? "Adequate: loaded" : "Adequate: not loaded";
  pA.classList.toggle("good", ok);
  if(!ok) pA.classList.add("bad");

  // combine Seats + Absent Reasons status in one pill
  const pS=document.getElementById("pillSeats");
  const seatsOk = Object.values(SEATS).some(arr=>Array.isArray(arr)&&arr.length);
  const absOk = (ABSENT_REASONS&&ABSENT_REASONS.length);
  pS.textContent = (seatsOk? "Seats: loaded" : "Seats: not loaded") + " · " + (absOk? ("Absent Reasons: "+ABSENT_REASONS.length) : "Absent Reasons: not loaded");
  pS.classList.toggle("good", !!seatsOk && !!absOk);
  if(!(seatsOk && absOk)) pS.classList.add("bad");
}

function shiftForDay(emp, dayName, iso){
  if(iso){
    const partner = getSwappedShift(emp.Employee, iso);
    if(partner){
      const partnerRec = BASE_EMP.find(e => e.Employee === partner);
      if(partnerRec) return String(partnerRec[dayName]||"").trim();
    }
  }
  return String(emp[dayName]||"").trim();
}
function parseShiftString(s){
  const str=String(s||"").toUpperCase().replace(/\s+/g,"");
  if(!str || str==="OFF") return null;
  const parts=str.split("-");
  if(parts.length!==2) return null;
  const toMin=(token)=>{
    const m=token.match(/(\d{1,2})(?::(\d{2}))?([AP])/);
    if(!m) return null;
    let h=parseInt(m[1],10);
    const mm=m[2]?parseInt(m[2],10):0;
    const ap=m[3];
    if(ap==="A"){ if(h===12) h=0; } else { if(h!==12) h+=12; }
    return h*60+mm;
  };
  const a=toMin(parts[0]), b=toMin(parts[1]);
  if(a===null||b===null) return null;
  let start=a, end=b;
  if(end<=start) end+=1440;
  return {start,end,raw:str};
}

// ===== Block windows / hour segments =====
function blockWindowMinutes(block){
  // IMPORTANT: For NIGHT shift, blocks that start after midnight (e.g., 0200-0600)
  // belong to the NEXT calendar day in the 1800-0600 workday window.
  const isNight = (document.getElementById("shiftSel") && document.getElementById("shiftSel").value==="NIGHT");
  const nightStart = 18*60; // 1800
  let s = minutesOf(block.start);
  let e = minutesOf(block.end);
  if(e<=s) e += 1440;       // handles blocks like 2200-0200
  if(isNight && s < nightStart){
    // shift after-midnight blocks into next-day minutes so they overlap 6P-6A shifts
    s += 1440;
    e += 1440;
  }
  return {startMin:s, endMin:e};
}
function hourSegments(block){
  const isNight = (document.getElementById("shiftSel") && document.getElementById("shiftSel").value==="NIGHT");
  const nightStart = 18*60; // 1800

  // Keep the special label mapping for 2200-0200, but the minute values are already in "next-day" space.
  if(block.id==="2200-0200"){
    return [
      {label:"2200", start:1320, end:1380},
      {label:"2300", start:1380, end:1440},
      {label:"2400", start:1440, end:1500},
      {label:"0100", start:1500, end:1560},
    ];
  }

  // For NIGHT shift, blocks that begin after midnight need +1440 so overlap math works.
  let s = minutesOf(block.start);
  if(isNight && s < nightStart) s += 1440;

  const labels=[];
  for(let i=0;i<4;i++){
    const hh=((Math.floor((minutesOf(block.start)+i*60)/60))%24);
    labels.push(String(hh*100).padStart(4,"0"));
  }

  return [
    {label:labels[0], start:s, end:s+60},
    {label:labels[1], start:s+60, end:s+120},
    {label:labels[2], start:s+120, end:s+180},
    {label:labels[3], start:s+180, end:s+240},
  ];
}

// ===== Teams OT import =====
function cap(s){ s=String(s||"").trim(); if(!s) return ""; return s[0].toUpperCase()+s.slice(1); }
function lastNameKeyFromAny(member, email){
  const em=String(email||"").trim().toLowerCase();
  if(em.includes("@")){
    const local=em.split("@")[0];
    const toks=local.split(".").filter(Boolean);
    if(toks.length>=2){
      return {lastParts:[cap(toks[toks.length-1])], fi:cap((toks[0][0]||""))};
    }
  }
  const m=String(member||"").trim();
  if(!m) return {lastParts:[],fi:""};
  if(m.includes(",")){
    const [last, first]=m.split(",").map(s=>s.trim());
    const lastParts = last.split(/\s+/).filter(Boolean);
    return {lastParts:lastParts.map(cap), fi:cap((first||"")[0]||"")};
  }
  const toks=m.split(/\s+/).filter(Boolean);
  if(toks.length===1) return {lastParts:[cap(toks[0])], fi:""};
  return {lastParts:[cap(toks[toks.length-1])], fi:cap((toks[0][0]||""))};
}
function findEmpByKey(key){
  if(!key || !key.lastParts || !key.lastParts.length) return null;
  const fi=key.fi.toUpperCase();
  let best=null;
  for(const lp of key.lastParts){
    const last=lp.toUpperCase();
    for(const e of BASE_EMP){
      const up=String(e.Employee||"").trim().toUpperCase();
      if(up===last) return e;
      if(fi && up===last+fi) return e;
      if(up.startsWith(last) && !best) best=e;
    }
  }
  return best;
}
function parseTeamsFileToRows(wbOrText){
  if(typeof wbOrText === "string"){
    const lines=wbOrText.split(/\r?\n/).filter(l=>l.trim().length);
    if(lines.length<2) return [];
    const hdr=lines[0].split(",").map(h=>h.trim());
    return lines.slice(1).map(line=>{
      const cols=line.split(",");
      const o={};
      hdr.forEach((h,i)=>o[h]=cols[i]??"");
      return o;
    });
  }else{
    const wb=wbOrText;
    const sh=getSheet(wb, ["Shifts","Shift","Schedule","schedule","shifts"]) || {name:Object.keys(wb.Sheets)[0], ws:wb.Sheets[Object.keys(wb.Sheets)[0]]};
    return sheetToJson(sh.ws);
  }
}
function detectTeamsCols(row){
  const keys=Object.keys(row||{});
  const get=(cands)=>{
    for(const c of cands){
      const k=keys.find(k=>k.toLowerCase()===c.toLowerCase());
      if(k) return k;
    }
    return null;
  };
  return {
    member: get(["Member","Name","Employee","User"]),
    email: get(["Work Email","Email","User email","UserEmail","UPN"]),
    startDate: get(["Start Date","StartDate","Start date"]),
    startTime: get(["Start Time","StartTime","Start time"]),
    endDate: get(["End Date","EndDate","End date"]),
    endTime: get(["End Time","EndTime","End time"]),
    startDT: get(["Start","Start DateTime","StartDateTime"]),
    endDT: get(["End","End DateTime","EndDateTime"]),
  };
}
function parseMeansDateTime(d,t){
  if(!d && !t) return null;
  const dd = (d instanceof Date) ? d : String(d||"").trim();
  const tt = String(t||"").trim();
  let dateObj=null;
  if(dd instanceof Date) dateObj=dd;
  else if(dd){
    if(dd.includes("/")){
      const [m,da,y]=dd.split("/").map(Number);
      dateObj=new Date(y, m-1, da);
    }else if(dd.includes("-")){
      dateObj=parseISO(dd);
    }
  }
  if(!dateObj) return null;
  let hh=0, mm=0;
  if(tt){
    const m=tt.match(/(\d{1,2}):(\d{2})/);
    if(m){ hh=parseInt(m[1],10); mm=parseInt(m[2],10); }
  }
  dateObj.setHours(hh,mm,0,0);
  return dateObj;
}
function addOtToCtx(iso, shift, blockId, empName, role, wsMin, weMin){
  const key=ctxKey(iso,shift,blockId);
  if(!OT_BY_CTX.has(key)) OT_BY_CTX.set(key,[]);
  const arr=OT_BY_CTX.get(key);
  const existing=arr.find(o=>o.emp===empName);
  if(existing){
    existing.ws=Math.min(existing.ws, wsMin);
    existing.we=Math.max(existing.we, weMin);
  } else {
    arr.push({emp:empName, role, ws:wsMin, we:weMin, isOT:true});
  }
}
async function importTeamsWeek(file){
  clearErr();
  if(!window.XLSX){ setErr("XLSX not loaded."); return null; }
  if(!BASE_EMP.length){ setErr("Load Database first."); return null; }
  const ws=document.getElementById("weekStart").value;
  if(!ws){ setErr("Pick Week Start (Saturday)."); return null; }
  const weekStart=parseISO(ws);
  const weekEnd=new Date(weekStart.getTime()+6*86400000);
  // Merge: don't clear OT_BY_CTX so multiple week imports accumulate.
  // Cross-week night shift OT (e.g., 1/31 02:00 → 1/30 NIGHT) survives.
  // Page reload resets everything if a fresh start is needed.

  let text=null, wb=null;
  if(file.name.toLowerCase().endsWith(".csv")) text = await file.text();
  else wb = loadWorkbook(await file.arrayBuffer());

  const rows=parseTeamsFileToRows(text||wb);
  let total=0, imported=0, invalid=0, noMatch=0;
  const noMatchExamples=[];
  for(const r of rows){
    total++;
    const cols=detectTeamsCols(r);
    const member=r[cols.member] ?? "";
    const email=r[cols.email] ?? "";
    let start=null,end=null;
    if(cols.startDT) start = new Date(r[cols.startDT]);
    if(cols.endDT) end = new Date(r[cols.endDT]);
    if(!start && (cols.startDate||cols.startTime)) start = parseMeansDateTime(r[cols.startDate], r[cols.startTime]);
    if(!end && (cols.endDate||cols.endTime)) end = parseMeansDateTime(r[cols.endDate], r[cols.endTime]);
    if(!(start instanceof Date) || isNaN(start) || !(end instanceof Date) || isNaN(end) || end<=start){ invalid++; continue; }

    // Try email-based key first, then fall back to member-name-based key
    const keyEmail=lastNameKeyFromAny("",email);
    const keyMember=lastNameKeyFromAny(member,"");
    const emp=findEmpByKey(keyEmail) || findEmpByKey(keyMember);
    if(!emp){ noMatch++; if(noMatchExamples.length<8) noMatchExamples.push({member,email}); continue; }

    // walk days touched
    let cur=new Date(start.getFullYear(), start.getMonth(), start.getDate());
    const endDay=new Date(end.getFullYear(), end.getMonth(), end.getDate());
    while(cur<=endDay){
      if(cur<weekStart || cur>weekEnd){ cur=new Date(cur.getTime()+86400000); continue; }
      const iso=toISODate(cur);

      // minutes for THIS date (0..1440), plus allow crossing into next day by extending end
      const isStartDay = (start.getFullYear()===cur.getFullYear() && start.getMonth()===cur.getMonth() && start.getDate()===cur.getDate());
      let sMin = isStartDay
                ? (start.getHours()*60+start.getMinutes())
                : 0;
      let eMin = (end.getFullYear()===cur.getFullYear() && end.getMonth()===cur.getMonth() && end.getDate()===cur.getDate())
                ? (end.getHours()*60+end.getMinutes())
                : 1440;

      // if this is start day and end spills to next day, extend
      if(endDay>cur && (end.getHours()*60+end.getMinutes())>=0){
        // extend by full day + next-day end time
        eMin = 1440 + (end.getHours()*60+end.getMinutes());
      }

      // OT in 0000-0600 belongs to the previous day's NIGHT shift viewing context.
      // When user views "Saturday NIGHT", that covers 1800 Sat → 0600 Sun.
      // Teams exports "Sunday 02:00" but user views it under Saturday.
      // So remap: use previous day's ISO and shift minutes by +1440 to match
      // blockWindowMinutes (which puts 0200-0600 at 1560-1800 for NIGHT).
      const isPostMidnightNightOT = (isStartDay && sMin < 360 && eMin <= 360);
      if(isPostMidnightNightOT){
        const prevDate = new Date(cur.getTime() - 86400000);
        const prevIso = toISODate(prevDate);
        const sMinShifted = sMin + 1440;
        const eMinShifted = eMin + 1440;
        // Compute night block windows with +1440 for post-midnight blocks
        const nightBlockWindows = BLOCKS_NIGHT.map(b => {
          let bs = minutesOf(b.start), be = minutesOf(b.end);
          if(be <= bs) be += 1440;
          if(bs < 1080) { bs += 1440; be += 1440; }
          return {id: b.id, startMin: bs, endMin: be};
        });
        for(const nbw of nightBlockWindows){
          const ov = overlapMinutes(sMinShifted, eMinShifted, nbw.startMin, nbw.endMin);
          if(ov > 0){
            addOtToCtx(prevIso, "NIGHT", nbw.id, emp.Employee, emp.POSITION||"", sMinShifted, eMinShifted);
            imported++;
          }
        }
      } else {
        // place OT into BOTH shift sets, by overlap with each block window
        for(const sh of ["DAY","NIGHT"]){
          const blocks = (sh==="NIGHT")?BLOCKS_NIGHT:BLOCKS_DAY;
          for(const b of blocks){
            const bw=blockWindowMinutes(b);
            const ov=overlapMinutes(sMin,eMin,bw.startMin,bw.endMin);
            if(ov>0){
              addOtToCtx(iso, sh, b.id, emp.Employee, emp.POSITION||"", sMin, eMin);
              imported++;
            }
          }
        }
      }
      cur=new Date(cur.getTime()+86400000);
    }
  }
  const pill=document.getElementById("pillOt");
  pill.textContent = `Teams OT: ${imported} placed | ${total} rows | ${noMatch} no-match | ${invalid} invalid`;
  pill.classList.toggle("good", imported>0 && noMatch===0 && invalid===0);
  pill.classList.toggle("bad", (noMatch>0 || invalid>0 || imported===0));
  pill.style.cursor = (noMatch>0 || invalid>0) ? "pointer" : "default";
  pill.title = (noMatch>0 || invalid>0) ? "Click for details" : "";
  pill.onclick = (noMatch>0 || invalid>0) ? ()=>showOtImportReport(total, imported, invalid, noMatch, noMatchExamples) : null;
  if(noMatchExamples.length) console.warn("NoMatch examples:", noMatchExamples);
  return {total, imported, invalid, noMatch, noMatchExamples};
}

function showOtImportReport(total, imported, invalid, noMatch, noMatchExamples){
  let msg = `OT IMPORT REPORT\n────────────────────\n`;
  msg += `Total rows in file: ${total}\n`;
  msg += `Successfully placed: ${imported}\n`;
  msg += `Invalid (bad date/time): ${invalid}\n`;
  msg += `No match (employee not in DB): ${noMatch}\n`;
  if(noMatchExamples.length){
    msg += `\nNO-MATCH EMPLOYEES (first ${noMatchExamples.length}):\n`;
    for(const ex of noMatchExamples){
      msg += `  • ${ex.member || "(no name)"}  ${ex.email || "(no email)"}\n`;
    }
    msg += `\nThese names could not be matched to anyone in the loaded database.\nCheck spelling or ensure they exist in the DB file.`;
  }
  alert(msg);
}

function filterByEmployee(query){
  const q = query.trim().toUpperCase();
  document.querySelectorAll(".rosterTbl tbody tr").forEach(tr => {
    const nameCell = tr.querySelector(".nameCol");
    if(!nameCell) return;
    const name = nameCell.textContent.toUpperCase();
    tr.style.display = (!q || name.includes(q)) ? "" : "none";
  });
}

// ===== Rendering =====
function roleCode(role){
  if(role==="CALLTAKER") return "CT";
  if(role==="DISPATCHER") return "DP";
  if(role==="SUPERVISOR") return "SUP";
  if(role==="PIC") return "PIC";
  return role||"";
}
function blockTitle(block){
  const parts=block.id.split("-");
  const a=parts[0], b=parts[1];
  const fmt=(hhmm)=>{
    const h=parseInt(hhmm.slice(0,2),10);
    const m=hhmm.slice(2);
    const h12=((h+11)%12)+1;
    return h12+(m==="00"?"":":"+m);
  };
  return fmt(a)+"-"+fmt(b);
}
function renderStaffingTable(iso, shift, block, role){
  const segs=hourSegments(block);
  const rows=computeRowsForBlock(iso, shift, block);
  const list=rows[role]||[];
  const counts=[0,0,0,0];

  // headcount per hour segment uses workedStart/workedEnd
  for(const r of list){
    const key=ctxKey(iso,shift,block.id);
    const ed=ensureEdit(key,r.emp);
    // TRAINEE employees don't count towards staffing numbers
    if((ed.Present||r.present||"YES")==="TRAINEE") continue;
    const ws=ed.WorkedStart || r.workedStart;
    const we=ed.WorkedEnd || r.workedEnd;
    let aS=minutesOf(ws), aE=minutesOf(we);
    // handle 22-02 wrap
    if(block.id==="2200-0200" && aE<=aS) aE += 1440;

    const segsUse = (block.id==="2200-0200")
      ? [{start:1320,end:1380},{start:1380,end:1440},{start:1440,end:1500},{start:1500,end:1560}]
      : segs.map(s=>({start:s.start,end:s.end}));

    for(let i=0;i<4;i++){
      if(overlapMinutes(aS,aE,segsUse[i].start,segsUse[i].end)>0) counts[i]+=1;
    }
  }

  const d=dayNameFromISO(iso);

  function badge(adeq, sched){
    const aNum = Number(adeq);
    const sNum = Number(sched);
    if(!Number.isFinite(aNum) || !Number.isFinite(sNum)) return "";
    if(sNum < aNum) return ` <span class="statusShort">SHORT ${aNum-sNum}</span>`;
    if(sNum === aNum) return ` <span class="statusStaffed">STAFFED</span>`;
    return ` <span class="statusOver">OVER ${sNum-aNum}</span>`;
  }

  let html="<div class='tblWrap'><table><thead><tr><th class='compact'>Hr</th><th>Adeq</th><th>Sched</th></tr></thead><tbody>";
  for(let i=0;i<4;i++){
    const hk=segs[i].label;
    const lookupKey = (hk==="2400") ? "0000" : hk;
    const a=(ADEQ[role] && ADEQ[role][d] && ADEQ[role][d][lookupKey]!==undefined) ? ADEQ[role][d][lookupKey] : "";
    const b=badge(a, counts[i]);
    html += `<tr><td class='compact'>${hk}</td><td>${a!==""?a:""}</td><td>${counts[i]}${b}</td></tr>`;
  }
  html+="</tbody></table></div>";
  return html;
}

function computeRowsForBlock(iso, shift, block){
  const dname=dayNameFromISO(iso);
  const bw=blockWindowMinutes(block);
  const res={CALLTAKER:[],DISPATCHER:[],PIC:[],SUPERVISOR:[],ABSENT:[],OTH:[]};

  // scheduled
  for(const e of BASE_EMP){
    const shStr = shiftForDay(e, dname, iso);
    const sh=parseShiftString(shStr);
    if(!sh) continue;
    // overlap with this shift blocks only (DAY/NIGHT selection)
    // note: roster shiftStr may cover both; we just overlap block window
    const ov=overlapMinutes(sh.start,sh.end,bw.startMin,bw.endMin);
    if(ov<=0) continue;

    const key=ctxKey(iso,shift,block.id);
    const ed=ensureEdit(key,e.Employee);

    // Auto-mark vacation employees as absent (only if not already manually edited)
    if(ed.Present==="YES" && !ed._userEdited && isOnVacationDate(e.Employee, iso)){
      ed.Present="NO";
      ed.Hours="0";
      ed.AbsenceReason="VACATION";
      ed._vacAutoMarked=true;
    }

    const wStartMin = Math.max(bw.startMin, sh.start);
    const wEndMin = Math.min(bw.endMin, sh.end);
    const workedStart = ed.WorkedStart || minToHHMM(wStartMin%1440);
    const workedEnd = ed.WorkedEnd || minToHHMM(wEndMin%1440);
    const mins = overlapMinutes(wStartMin,wEndMin,bw.startMin,bw.endMin);
    const hours = (ed.Hours!=="" ? Number(ed.Hours) : roundQuarterHours(mins));

    const role = normalizeRole(ed.Role||e.POSITION);
    const present=(ed.Present||"YES");
    const _isSwapped = isSwapped(e.Employee, iso);
    const _swapPartner = _isSwapped ? getSwappedShift(e.Employee, iso) : null;
    const row={emp:e.Employee, sen:e.SENIORITY, shiftStr:shStr, role, present, hours, assignment:(ed.Assignment||""), workedStart, workedEnd, isOT:false, isSwapped:_isSwapped, swapPartner:_swapPartner};
    if(present==="NO") res.ABSENT.push(row);
    else if(present==="PARTIAL"){
      if(res[role]) res[role].push(row);
      // ghost ABSENT row with missed time
      const schedStart = Math.max(bw.startMin, sh.start);
      const schedEnd = Math.min(bw.endMin, sh.end);
      const schedHrs = roundQuarterHours(overlapMinutes(schedStart, schedEnd, bw.startMin, bw.endMin));
      const actualStart = minutesOf(workedStart);
      const actualEnd = minutesOf(workedEnd);
      const missedHrs = Math.max(0, schedHrs - hours);
      // determine missed time range
      let missedStart, missedEnd;
      if(actualStart > schedStart && actualEnd < schedEnd){
        missedStart = minToHHMM(schedStart%1440); missedEnd = minToHHMM(actualStart%1440);
      } else if(actualEnd < schedEnd){
        missedStart = minToHHMM(actualEnd%1440); missedEnd = minToHHMM(schedEnd%1440);
      } else if(actualStart > schedStart){
        missedStart = minToHHMM(schedStart%1440); missedEnd = minToHHMM(actualStart%1440);
      } else {
        missedStart = ""; missedEnd = "";
      }
      res.ABSENT.push({emp:e.Employee, sen:e.SENIORITY, shiftStr:shStr, role, present:"PARTIAL", hours:missedHrs, assignment:"", workedStart:missedStart, workedEnd:missedEnd, isOT:false, isPartial:true});
    }
    else if(present==="TARDY"){
      if(res[role]) res[role].push(row);
      // ghost ABSENT row: missed time = shift start → actual worked start
      const schedStart = Math.max(bw.startMin, sh.start);
      const schedEnd = Math.min(bw.endMin, sh.end);
      const schedHrs = roundQuarterHours(overlapMinutes(schedStart, schedEnd, bw.startMin, bw.endMin));
      const actualStart = minutesOf(workedStart);
      const missedHrs = Math.max(0, schedHrs - hours);
      const missedStart = minToHHMM(schedStart%1440);
      const missedEnd = minToHHMM(actualStart%1440);
      res.ABSENT.push({emp:e.Employee, sen:e.SENIORITY, shiftStr:shStr, role, present:"TARDY", hours:missedHrs, assignment:"", workedStart:missedStart, workedEnd:missedEnd, isOT:false, isPartial:true, isTardy:true});
    }
    else if(res[role]) res[role].push(row);
  }

  // OT entries for this ctx
  const key=ctxKey(iso,shift,block.id);
  const otList=OT_BY_CTX.get(key)||[];
  for(const ot of otList){
    const ed=ensureEdit(key, ot.emp);
    const role=normalizeRole(ed.Role||ot.role||"");
    const wStart = Math.max(bw.startMin, ot.ws);
    const wEnd = Math.min(bw.endMin, ot.we);
    const mins=overlapMinutes(wStart,wEnd,bw.startMin,bw.endMin);
    const hours=(ed.Hours!=="" ? Number(ed.Hours) : roundQuarterHours(mins));
    const present=(ed.Present||"YES");
    const workedStartOT = ed.WorkedStart||minToHHMM(wStart%1440);
    const workedEndOT = ed.WorkedEnd||minToHHMM(wEnd%1440);
    const row={emp:ot.emp, sen:"", shiftStr:"OT", role, present, hours, assignment:(ed.Assignment||""), workedStart:workedStartOT, workedEnd:workedEndOT, isOT:true};
    if(present==="NO") res.ABSENT.push(row);
    else if(present==="PARTIAL"){
      if(res[role]) res[role].push(row);
      const schedStartOT = Math.max(bw.startMin, ot.ws);
      const schedEndOT = Math.min(bw.endMin, ot.we);
      const schedHrsOT = roundQuarterHours(overlapMinutes(schedStartOT, schedEndOT, bw.startMin, bw.endMin));
      const actStartOT = minutesOf(workedStartOT);
      const actEndOT = minutesOf(workedEndOT);
      const missedHrsOT = Math.max(0, schedHrsOT - hours);
      let mStartOT, mEndOT;
      if(actStartOT > schedStartOT && actEndOT < schedEndOT){
        mStartOT = minToHHMM(schedStartOT%1440); mEndOT = minToHHMM(actStartOT%1440);
      } else if(actEndOT < schedEndOT){
        mStartOT = minToHHMM(actEndOT%1440); mEndOT = minToHHMM(schedEndOT%1440);
      } else if(actStartOT > schedStartOT){
        mStartOT = minToHHMM(schedStartOT%1440); mEndOT = minToHHMM(actStartOT%1440);
      } else { mStartOT = ""; mEndOT = ""; }
      res.ABSENT.push({emp:ot.emp, sen:"", shiftStr:"OT", role, present:"PARTIAL", hours:missedHrsOT, assignment:"", workedStart:mStartOT, workedEnd:mEndOT, isOT:true, isPartial:true});
    }
    else if(present==="TARDY"){
      if(res[role]) res[role].push(row);
      const schedStartOT = Math.max(bw.startMin, ot.ws);
      const schedEndOT = Math.min(bw.endMin, ot.we);
      const schedHrsOT = roundQuarterHours(overlapMinutes(schedStartOT, schedEndOT, bw.startMin, bw.endMin));
      const actStartOT = minutesOf(workedStartOT);
      const missedHrsOT = Math.max(0, schedHrsOT - hours);
      const mStartOT = minToHHMM(schedStartOT%1440);
      const mEndOT = minToHHMM(actStartOT%1440);
      res.ABSENT.push({emp:ot.emp, sen:"", shiftStr:"OT", role, present:"TARDY", hours:missedHrsOT, assignment:"", workedStart:mStartOT, workedEnd:mEndOT, isOT:true, isPartial:true, isTardy:true});
    }
    else if(res[role]) res[role].push(row);
  }
  return res;
}


function renderRoleTable(iso, shift, block, role, rows){
  const key=ctxKey(iso,shift,block.id);
  const rolePlural = {
    "CALLTAKER":"CALLTAKERS",
    "DISPATCHER":"DISPATCHERS",
    "PIC":"PICs",
    "SUPERVISOR":"SUPERVISORS",
    "ABSENT":"ABSENT",
    "OTH":"OTHER"
  };
  const roleLabel = rolePlural[role] || role;
  const count=rows.length;

  const isAbsent = (role==="ABSENT");
  const seatOpts = isAbsent ? [] : (SEATS[role]||[]);
  let html = ``;

  html += `<div class="tblWrap"><table class="rosterTbl${isAbsent ? ' rosterTbl--absent' : ''}"><thead><tr>
    <th class="nameCol">Name</th>
    ${isAbsent ? "" : '<th class="ctrlCol roleCol"><span class="hdrTxt">Role</span></th>'}
    <th class="ctrlCol seatCol"><span class="hdrTxt">${isAbsent ? "Reason" : "Seat"}</span></th>
    <th class="ctrlCol workedCol"><span class="hdrTxt">${isAbsent ? "Missed" : "Worked"}</span></th>
    <th class="ctrlCol hrsCol"><span class="hdrTxt">Hrs</span></th>
    <th class="ctrlCol presCol"><span class="hdrTxt">PRESENT</span></th>
    <th class="cmtCol"><span class="hdrTxt">Cmt</span></th>
  </tr></thead><tbody>`;

  for(const r of rows){
    const ed=ensureEdit(key,r.emp);
    const roleNorm=normalizeRole(ed.Role||r.role);
    const seat=ed.Assignment||r.assignment||"";
    const ws = (r.isPartial||r.isTardy) ? r.workedStart : (ed.WorkedStart||r.workedStart);
    const we = (r.isPartial||r.isTardy) ? r.workedEnd : (ed.WorkedEnd||r.workedEnd);
    const hrs = (r.isPartial||r.isTardy) ? r.hours : (ed.Hours!==""?Number(ed.Hours):r.hours);
    const present=ed.Present||r.present||"YES";
    const absReason = r.isTardy ? "TARDY" : (r.isPartial ? (ed.PartialReason || "") : (ed.AbsenceReason || ""));
    const cmtKey = r.isTardy ? key+'|'+r.emp+'|TARDY' : (r.isPartial ? key+'|'+r.emp+'|PARTIAL' : key+'|'+r.emp);

    const rowBg = r.isOT ? " style='background:rgba(180,180,200,0.12)'" : "";

    const thirdCol = isAbsent
      ? (r.isTardy
        ? `<span class="absTardyLabel" style="display:block;font-weight:700;color:#ef4444;text-align:center">TARDY</span>`
        : r.isPartial
        ? `<select class="absReasonSel" onchange="setPartialReason('${esc(key)}','${esc(r.emp)}', this.value)">
             <option value=""${absReason===""?" selected":""}>—</option>
             ${ABSENT_REASONS.map(x=>`<option value="${esc(x)}"${absReason===x?" selected":""}>${esc(x)}</option>`).join("")}
           </select>`
        : `<select class="absReasonSel" onchange="setAbsenceReason('${esc(key)}','${esc(r.emp)}', this.value)">
             <option value=""${absReason===""?" selected":""}>—</option>
             ${ABSENT_REASONS.map(x=>`<option value="${esc(x)}"${absReason===x?" selected":""}>${esc(x)}</option>`).join("")}
           </select>`)
      : `<select class="seatSel" onchange="setSeatVal('${esc(key)}','${esc(r.emp)}', this.value)">
           ${renderSeatOptions(seatOpts, seat)}
         </select>`;

    const swBadge = r.isSwapped ? `<span class="swapBadge" title="Swapped with ${esc(r.swapPartner||'')}">SW</span>` : "";
    html += `<tr${rowBg}>
      <td class="nameCol">${r.isOT?`<span class="otNameWrap"><span class="empName">${esc(r.emp)}</span><span class="otBadge otBadgeTop">OT<button class="ot-edit-icon" onclick="showOTConfirm(event,'${esc(key)}','${esc(r.emp)}')">&#9998;</button></span></span>`:`<span class="empName">${esc(r.emp)}</span>`}${r.isTardy?`<span class="otBadge" style="background:#ef4444">T</span>`:(r.isPartial?`<span class="otBadge" style="background:#d4a017">P</span>`:"")}${swBadge}</td>
      ${isAbsent ? "" : `<td class="ctrlCell roleCol">
        <select class="roleSel" onchange="setRoleVal('${esc(key)}','${esc(r.emp)}', this.value)">
          ${renderRoleOptions(roleNorm)}
        </select>
      </td>`}
      <td class="ctrlCell seatCol">${thirdCol}</td>
      <td class="ctrlCell workedCol">
        ${(r.isPartial||r.isTardy)
          ? `<span class="rowPill">${shortWorked(ws,we)}</span>`
          : `<span class="rowPill editable${present==="TARDY"&&!ed.WorkedStart?" tardy-needs-time":""}" onclick="openTimeEdit(this,event)">${shortWorked(ws,we)}</span>
        <span class="timeEdit">
          <input type="time" value="${esc(ws)}" data-timekey="${esc(key)}" data-timeemp="${esc(r.emp)}" data-timefield="WorkedStart" data-timeorig="${esc(ws)}"/>
          <input type="time" value="${esc(we)}" data-timekey="${esc(key)}" data-timeemp="${esc(r.emp)}" data-timefield="WorkedEnd" data-timeorig="${esc(we)}"/>
        </span>`}
      </td>
      <td class="ctrlCell hrsCol">${(r.isPartial||r.isTardy)
        ? (isAbsent ? `<span class="absHrsLabel" style="display:block;text-align:center">${hrs}</span>` : hrs)
        : `<span class="hrsIn" style="display:block;text-align:center">${hrs}</span>`}</td>
      <td class="ctrlCell presCol">
        ${(r.isPartial||r.isTardy) ? (isAbsent ? '' : `<span style="font-size:18px;color:${r.isTardy?'#ef4444':'#d4a017'};font-weight:900">${r.isTardy?'T':'P'}</span>`) : `<select class="presentSel${present==="PARTIAL"?" partial-ring":""}${present==="TARDY"?" tardy-ring":""}${present==="TRAINER"?" trainer-ring":""}${present==="TRAINEE"?" trainee-ring":""}" onchange="setPresent('${esc(key)}','${esc(r.emp)}', this.value)">
          <option value="YES"${present==="YES"?" selected":""}>YES</option>
          <option value="TRAINER"${present==="TRAINER"?" selected":""}>TRAINER</option>
          <option value="TRAINEE"${present==="TRAINEE"?" selected":""}>TRAINEE</option>
          <option value="PARTIAL"${present==="PARTIAL"?" selected":""}>PARTIAL</option>
          <option value="TARDY"${present==="TARDY"?" selected":""}>TARDY</option>
          <option value="NO"${present==="NO"?" selected":""}>NO</option>
        </select>`}
      </td>
      <td class="cmtCol"><button class="cmt-btn${(rowComments[cmtKey]||'').trim()?` has-cmt`:``}" data-cmtkey="${esc(cmtKey)}" title="Comment">&#128172;</button></td>
    </tr>`;
  }

  html += "</tbody></table></div>";
  return html;
}

function renderOthTable(iso, shift, block, rows){
  const key=ctxKey(iso,shift,block.id);
  const count=rows.length;

  let html = `<div class="tblWrap"><table class="rosterTbl"><thead><tr>
    <th class="nameCol">Name</th>
    <th class="ctrlCol roleCol"><span class="hdrTxt">Role</span></th>
    <th class="ctrlCol seatCol"><span class="hdrTxt">Reason</span></th>
    <th class="ctrlCol workedCol"><span class="hdrTxt">Worked</span></th>
    <th class="ctrlCol hrsCol"><span class="hdrTxt">Hrs</span></th>
    <th class="ctrlCol presCol"><span class="hdrTxt">PRESENT</span></th>
    <th class="cmtCol"><span class="hdrTxt">Cmt</span></th>
  </tr></thead><tbody>`;

  for(const r of rows){
    const ed=ensureEdit(key,r.emp);
    const roleNorm=normalizeRole(ed.Role||r.role);
    const ws = (r.isPartial||r.isTardy) ? r.workedStart : (ed.WorkedStart||r.workedStart);
    const we = (r.isPartial||r.isTardy) ? r.workedEnd : (ed.WorkedEnd||r.workedEnd);
    const hrs = (r.isPartial||r.isTardy) ? r.hours : (ed.Hours!==""?Number(ed.Hours):r.hours);
    const present=ed.Present||r.present||"YES";
    const othType = ed.OthType || "";
    const cmtKey = r.isTardy ? key+'|'+r.emp+'|TARDY' : (r.isPartial ? key+'|'+r.emp+'|PARTIAL' : key+'|'+r.emp);

    const rowBg = r.isOT ? " style='background:rgba(180,180,200,0.12)'" : "";
    const swBadgeOth = r.isSwapped ? `<span class="swapBadge" title="Swapped with ${esc(r.swapPartner||'')}">SW</span>` : "";

    html += `<tr${rowBg}>
      <td class="nameCol">${r.isOT?`<span class="otNameWrap"><span class="empName">${esc(r.emp)}</span><span class="otBadge otBadgeTop">OT<button class="ot-edit-icon" onclick="showOTConfirm(event,'${esc(key)}','${esc(r.emp)}')">&#9998;</button></span></span>`:`<span class="empName">${esc(r.emp)}</span>`}${r.isTardy?`<span class="otBadge" style="background:#ef4444">T</span>`:(r.isPartial?`<span class="otBadge" style="background:#d4a017">P</span>`:"")}${swBadgeOth}</td>
      <td class="ctrlCell roleCol">
        <select class="roleSel" onchange="setRoleVal('${esc(key)}','${esc(r.emp)}', this.value)">
          ${renderRoleOptions(roleNorm)}
        </select>
      </td>
      <td class="ctrlCell seatCol">
        <select class="othTypeSel" onchange="setOthType('${esc(key)}','${esc(r.emp)}', this.value)">
          <option value=""${othType===""?" selected":""}>—</option>
          <option value="SD"${othType==="SD"?" selected":""}>SD</option>
          <option value="TRN"${othType==="TRN"?" selected":""}>TRN</option>
          <option value="B"${othType==="B"?" selected":""}>B</option>
          <option value="ADM"${othType==="ADM"?" selected":""}>ADM</option>
        </select>
      </td>
      <td class="ctrlCell workedCol">
        ${(r.isPartial||r.isTardy)
          ? `<span class="rowPill">${shortWorked(ws,we)}</span>`
          : `<span class="rowPill editable${present==="TARDY"&&!ed.WorkedStart?" tardy-needs-time":""}" onclick="openTimeEdit(this,event)">${shortWorked(ws,we)}</span>
        <span class="timeEdit">
          <input type="time" value="${esc(ws)}" data-timekey="${esc(key)}" data-timeemp="${esc(r.emp)}" data-timefield="WorkedStart" data-timeorig="${esc(ws)}"/>
          <input type="time" value="${esc(we)}" data-timekey="${esc(key)}" data-timeemp="${esc(r.emp)}" data-timefield="WorkedEnd" data-timeorig="${esc(we)}"/>
        </span>`}
      </td>
      <td class="ctrlCell hrsCol"><span class="hrsIn" style="display:block;text-align:center">${hrs}</span></td>
      <td class="ctrlCell presCol">
        ${(r.isPartial||r.isTardy) ? `<span style="font-size:18px;color:${r.isTardy?'#ef4444':'#d4a017'};font-weight:900">${r.isTardy?'T':'P'}</span>` : `<select class="presentSel${present==="PARTIAL"?" partial-ring":""}${present==="TARDY"?" tardy-ring":""}${present==="TRAINER"?" trainer-ring":""}${present==="TRAINEE"?" trainee-ring":""}" onchange="setPresent('${esc(key)}','${esc(r.emp)}', this.value)">
          <option value="YES"${present==="YES"?" selected":""}>YES</option>
          <option value="TRAINER"${present==="TRAINER"?" selected":""}>TRAINER</option>
          <option value="TRAINEE"${present==="TRAINEE"?" selected":""}>TRAINEE</option>
          <option value="PARTIAL"${present==="PARTIAL"?" selected":""}>PARTIAL</option>
          <option value="TARDY"${present==="TARDY"?" selected":""}>TARDY</option>
          <option value="NO"${present==="NO"?" selected":""}>NO</option>
        </select>`}
      </td>
      <td class="cmtCol"><button class="cmt-btn${(rowComments[cmtKey]||'').trim()?` has-cmt`:``}" data-cmtkey="${esc(cmtKey)}" title="Comment">&#128172;</button></td>
    </tr>`;
  }

  html += "</tbody></table></div>";
  return html;
}

function setOthType(key, emp, val){
  const ed=ensureEdit(key,emp);
  ed.OthType=val;
  renderCard(key);
}

function renderRoleOptions(selected){
  const opts=[
    ["CALLTAKER","CT"],
    ["DISPATCHER","DP"],
    ["PIC","PIC"],
    ["SUPERVISOR","SUP"],
    ["OTH","OTH"],
  ];
  return opts.map(([v,t])=>`<option value="${v}"${v===selected?" selected":""}>${t}</option>`).join("");
}
function renderSeatOptions(opts, selected){
  const cur=String(selected||"");
  const top = `<option value=""${cur===""?" selected":""}>—</option>`;
  const sorted = (opts||[]).slice().sort((a,b)=>{
    const na=parseInt(String(a).replace(/\D/g,''),10)||0;
    const nb=parseInt(String(b).replace(/\D/g,''),10)||0;
    return na-nb || String(a).localeCompare(String(b));
  });
  const rest = sorted.map(v=>{
    const s=String(v||"");
    return `<option value="${esc(s)}"${s===cur?" selected":""}>${esc(s)}</option>`;
  }).join("");
  return top+rest;
}
function shortWorked(ws, we){
  const fmt=(t)=>{
    const [hh,mm]=String(t||"00:00").split(":");
    let h=parseInt(hh,10);
    const m=parseInt(mm||"0",10);
    const h12=((h+11)%12)+1;
    return h12+(m?":"+pad2(m):"");
  };
  return fmt(ws)+"-"+fmt(we);
}

// ===== Per-block Add OT / Extra =====
function renderAddOtBar(block){
  const empOptions = ['<option value="">Select employee…</option>'].concat(
    BASE_EMP.map(e=>`<option value="${esc(e.Employee)}">${esc(e.Employee.toUpperCase())}</option>`)
  ).join("");
  return `
    <div class="otBar">
      <div class="otBarRow">
        <div class="mini">
          <label class="tag">Add OT (from roster)</label>
          <select id="otEmp_${block.id}">${empOptions}</select>
        </div>
        <div class="mini">
          <label class="tag">Or add Extra (type name)</label>
          <input id="otExtra_${block.id}" type="text" placeholder="Extra name"/>
        </div>
      </div>
      <div class="otBarRow">
        <div class="miniSm">
          <label class="tag">Role</label>
          <select id="otRole_${block.id}">
            <option value="CALLTAKER">CT</option>
            <option value="DISPATCHER">DP</option>
            <option value="PIC">PIC</option>
            <option value="SUPERVISOR">SUP</option>
            <option value="OTH">OTH</option>
          </select>
        </div>
        <div class="miniSm">
          <label class="tag">Segment</label>
          <select id="otSeg_${block.id}">
            <option value="4/4">4/4</option>
            <option value="1/2">1/2</option>
            <option value="2/2">2/2</option>
          </select>
        </div>
        <div class="miniSm">
          <button class="primary" onclick="addOTForBlock('${block.id}')">Add</button>
        </div>
      </div>
    </div>
  `;
}

function addOTForBlock(blockId){
  clearErr();
  const iso=document.getElementById("workDate").value;
  const shift=document.getElementById("shiftSel").value;
  if(!iso){ setErr("Pick Work date."); return; }

  const empSel=document.getElementById("otEmp_"+blockId);
  const roleSel=document.getElementById("otRole_"+blockId);
  const segSel=document.getElementById("otSeg_"+blockId);
  const extra=document.getElementById("otExtra_"+blockId);

  const chosen = (extra && extra.value.trim()) ? extra.value.trim() : (empSel?empSel.value:"");
  if(!chosen){ setErr("Pick an employee or type an Extra name."); return; }

  const role=roleSel?roleSel.value:"CALLTAKER";
  const seg=segSel?segSel.value:"4/4";
  const block=(shift==="NIGHT"?BLOCKS_NIGHT:BLOCKS_DAY).find(b=>b.id===blockId);
  const bw=blockWindowMinutes(block);

  let ws=bw.startMin, we=bw.endMin;
  if(seg==="1/2"){ we = ws + 120; }
  if(seg==="2/2"){ ws = ws + 120; }

  const key=ctxKey(iso,shift,blockId);
  const arr=OT_BY_CTX.get(key)||[];
  arr.push({emp:chosen, role:role, ws:ws, we:we, isOT:true});
  OT_BY_CTX.set(key,arr);

  // reset inputs
  if(extra) extra.value="";
  if(empSel) empSel.value="";
  renderAll();
  scheduleAutoSave();
}

function removeOT(key, emp){
  const arr = OT_BY_CTX.get(key)||[];
  const idx = arr.findIndex(o=>o.emp===emp);
  if(idx>=0) arr.splice(idx,1);
  OT_BY_CTX.set(key,arr);
  renderAll();
  scheduleAutoSave();
}

// ===== Edits =====
function openTimeEdit(pillEl, ev){
  if(ev){ ev.stopPropagation(); }

  // close any other open time editors
  document.querySelectorAll('.timeEdit.open').forEach(ed=>{
    ed.classList.remove('open');
    ed.style.display='none';
    ed.style.position='';
    ed.style.left='';
    ed.style.top='';
    ed.style.bottom='';
    ed.style.transform='';
    const p = ed.parentElement && ed.parentElement.querySelector('.rowPill');
    if(p) p.style.display='inline-block';
  });

  const td=pillEl.parentElement;
  // Get pill position before hiding it
  const pillRect = pillEl.getBoundingClientRect();
  pillEl.style.display="none";
  const edit=td.querySelector(".timeEdit");
  if(!edit) return;
  // Use position:fixed so popup escapes overflow:hidden on card/tblWrap
  edit.style.setProperty('position', 'fixed', 'important');
  edit.style.setProperty('left', Math.round(pillRect.left + pillRect.width / 2) + 'px', 'important');
  edit.style.setProperty('top', Math.round(pillRect.top - 8) + 'px', 'important');
  edit.style.setProperty('bottom', 'auto', 'important');
  edit.style.setProperty('transform', 'translate(-50%, -100%)', 'important');
  edit.style.display="flex";
  edit.classList.add('open');
}
function setWorked(key, emp, field, val){
  const ed=ensureEdit(key,emp);
  ed[field]=val;

  // recalc hours based on overlap with block
  const [iso,shift,blockId]=key.split("|");
  const block=(shift==="NIGHT"?BLOCKS_NIGHT:BLOCKS_DAY).find(b=>b.id===blockId);
  const bw=blockWindowMinutes(block);
  let aS=minutesOf(ed.WorkedStart||block.start);
   let aE=minutesOf(ed.WorkedEnd||block.end);
   // For NIGHT shift, times after midnight must be treated as next-day minutes
   if(shift==="NIGHT"){
     const nightStart = 18*60;
     if(aS < nightStart) aS += 1440;
     if(aE < nightStart) aE += 1440;
   }
  if(shift==="NIGHT" && aE<=aS) aE+=1440;

  const mins=overlapMinutes(aS,aE,bw.startMin,bw.endMin);
  ed.Hours = String(roundQuarterHours(mins));

  // Auto-detect TARDY or PARTIAL: if worked hours are less than full block scheduled hours
  const fullMins=overlapMinutes(bw.startMin,bw.endMin,bw.startMin,bw.endMin);
  const becameShort = ed.Present==="YES" && roundQuarterHours(mins) < roundQuarterHours(fullMins) && roundQuarterHours(mins) > 0;
  if(becameShort){
    // Start time moved later than block start → arrived late → TARDY
    // End time moved earlier than block end → left early → PARTIAL
    if(aS > bw.startMin){
      ed.Present="TARDY";
      ed.TardyReason="TARDY";
    } else {
      ed.Present="PARTIAL";
    }
  }
  // Auto-revert to YES if hours restored to full
  if((ed.Present==="PARTIAL"||ed.Present==="TARDY") && roundQuarterHours(mins) >= roundQuarterHours(fullMins)){
    ed.Present="YES";
    ed.PartialReason="";
    ed.TardyReason="";
  }

  // If became PARTIAL (left early), cascade absent to later blocks
  if(becameShort && ed.Present==="PARTIAL") _cascadeAbsentForward(key, emp);

  renderAll(); // worked times affect staffing numbers across blocks
  scheduleAutoSave();
}
function setHours(key, emp, val){
  const ed=ensureEdit(key,emp);
  ed.Hours=String(val);
  renderCard(key);
  scheduleAutoSave();
}
// Cascade absent to all LATER blocks the employee is scheduled to work today
function _cascadeAbsentForward(key, emp){
  const [iso, shift, blockId] = key.split("|");
  const blocks = shift==="NIGHT" ? BLOCKS_NIGHT : BLOCKS_DAY;
  const curIdx = blocks.findIndex(b => b.id === blockId);
  if(curIdx < 0) return;

  // Find the employee record to check scheduled overlap
  const empRec = BASE_EMP.find(e => e.Employee === emp);
  if(!empRec) return;
  const dname = dayNameFromISO(iso);
  const shStr = shiftForDay(empRec, dname, iso);
  const sh = parseShiftString(shStr);
  if(!sh) return;

  // Mark absent in every later block they are scheduled to work
  for(let i = curIdx + 1; i < blocks.length; i++){
    const b = blocks[i];
    const bw = blockWindowMinutes(b);
    const ov = overlapMinutes(sh.start, sh.end, bw.startMin, bw.endMin);
    if(ov <= 0) continue; // not scheduled in this block

    const laterKey = ctxKey(iso, shift, b.id);
    const laterEd = ensureEdit(laterKey, emp);
    if(laterEd.Present === "NO") continue; // already absent
    laterEd.Present = "NO";
    laterEd.Hours = "0";
  }
}

function setPresent(key, emp, val){
  const ed=ensureEdit(key,emp);
  ed.Present=val;
  ed._userEdited=true;
  if(val==="NO") ed.Hours="0";
  if(val==="YES"){ ed.Hours=""; ed.AbsenceReason=""; ed.PartialReason=""; ed.TardyReason=""; }
  if(val==="TRAINER"){ ed.Hours=""; ed.AbsenceReason=""; ed.PartialReason=""; ed.TardyReason=""; }
  if(val==="TRAINEE"){ ed.Hours=""; ed.AbsenceReason=""; ed.PartialReason=""; ed.TardyReason=""; }
  if(val==="PARTIAL"){ ed.Hours=""; ed.AbsenceReason=""; ed.TardyReason=""; }
  if(val==="TARDY"){ ed.Hours=""; ed.AbsenceReason=""; ed.TardyReason="TARDY"; }

  // Cascade absence to all LATER blocks this employee works today
  if(val==="NO") _cascadeAbsentForward(key, emp);

  renderAll(); // employee moves between role card and ABSENT, affects staffing
  scheduleAutoSave();
  // If TARDY, auto-open the worked time editor so user can enter arrival time
  if(val==="TARDY"){
    requestAnimationFrame(()=>{
      const pills = document.querySelectorAll('.rowPill.editable');
      for(const p of pills){
        const te = p.parentElement && p.parentElement.querySelector('.timeEdit');
        if(!te) continue;
        const inp = te.querySelector('input[data-timeemp]');
        if(inp && inp.dataset.timeemp === emp && inp.dataset.timekey === key){
          openTimeEdit(p, null);
          break;
        }
      }
    });
  }
}
function setRoleVal(key, emp, val){
  const ed=ensureEdit(key,emp);
  ed.Role=val;
  renderAll(); // role change moves rows and affects staffing counts per role
  scheduleAutoSave();
}
function setSeatVal(key, emp, val){
  const ed=ensureEdit(key,emp);
  ed.Assignment=val;
  renderCard(key);
  scheduleAutoSave();
}
function setAbsenceReason(key, emp, val){
  const ed=ensureEdit(key,emp);
  ed.AbsenceReason=val;
  renderCard(key);
  scheduleAutoSave();
}
function setPartialReason(key, emp, val){
  const ed=ensureEdit(key,emp);
  ed.PartialReason=val;
  renderCard(key);
  scheduleAutoSave();
}

// close time editors on click outside
document.addEventListener("click",(e)=>{
  const t=e.target;
  if(t.closest(".timeEdit") || t.type==="time") return;
  if(t.closest(".rowPill.editable")) return;
  if(t.closest(".customSel") || t.closest(".customSelMenu") || t.closest(".customSelBtn")) return;
  document.querySelectorAll(".timeEdit").forEach(el=>{ el.style.display="none"; });
  // show the pill back
  document.querySelectorAll(".rowPill.editable").forEach(el=>{ el.style.display="inline-block"; });
});

// ===== Prevent arrow keys from auto-selecting in dropdowns =====
document.addEventListener("keydown", function(e){
  const sel = e.target;
  if(sel.tagName==="SELECT" && (sel.classList.contains("roleSel") || sel.classList.contains("seatSel") || sel.classList.contains("presentSel") || sel.classList.contains("absReasonSel"))){
    if(e.key==="ArrowUp" || e.key==="ArrowDown"){
      e.preventDefault();
    }
  }
  // Shift+Enter on presentSel: toggle backwards (NO→TARDY→PARTIAL→YES)
  if(sel.tagName==="SELECT" && sel.classList.contains("presentSel") && e.key==="Enter" && e.shiftKey){
    e.preventDefault();
    const order = ["YES","PARTIAL","TARDY","NO"];
    const cur = sel.value;
    const idx = order.indexOf(cur);
    const prev = order[(idx - 1 + order.length) % order.length];
    sel.value = prev;
    sel.dispatchEvent(new Event("change"));
  }
});

// ===== Hours input: commit on Enter, revert on Escape =====
document.addEventListener("keydown", function(e){
  const inp = e.target;
  if(inp.classList.contains("hrsIn")){
    if(e.key === "Enter"){
      e.preventDefault();
      inp.blur();
      setHours(inp.dataset.hrskey, inp.dataset.hrsemp, inp.value);
    } else if(e.key === "Escape"){
      inp.value = inp.dataset.hrsorig;
      inp.blur();
    }
    return;
  }
  if(inp.dataset.timekey){
    if(e.key === "Enter"){
      e.preventDefault();
      inp.blur();
      setWorked(inp.dataset.timekey, inp.dataset.timeemp, inp.dataset.timefield, inp.value);
    } else if(e.key === "Escape"){
      inp.value = inp.dataset.timeorig;
      inp.blur();
    }
  }
});
// Hours input: also commit on blur if value changed
document.addEventListener("focusout", function(e){
  const inp = e.target;
  if(inp.classList.contains("hrsIn") && inp.dataset.hrskey){
    if(inp.value !== inp.dataset.hrsorig){
      setHours(inp.dataset.hrskey, inp.dataset.hrsemp, inp.value);
    }
    return;
  }
  if(inp.dataset.timekey){
    if(inp.value !== inp.dataset.timeorig){
      setWorked(inp.dataset.timekey, inp.dataset.timeemp, inp.dataset.timefield, inp.value);
    }
  }
}, true);

// ===== Render =====

function adeqGet(role, day, hk){
  // Tolerate hour keys stored as "0000" vs "000" vs 0 vs 100, etc.
  // hk is expected like "0000","0100","1200"...
  const node = (ADEQ && ADEQ[role] && ADEQ[role][day]) ? ADEQ[role][day] : null;
  if(!node) return undefined;

  const n = parseInt(hk, 10);
  const candidates = [];
  if(hk) candidates.push(hk);
  // "2400" is displayed for midnight but DB stores "0000" — try both
  if(hk === "2400"){ candidates.push("0000"); candidates.push("0"); }
  if(Number.isFinite(n)) candidates.push(String(n));          // "0","100","200"
  if(hk && hk.length === 4) candidates.push(hk.slice(0,3));  // "000","010"
  if(hk && hk.length === 4) candidates.push(hk.replace(/^0+/, '') || "0"); // "0","100"
  // Deduplicate and return first defined
  const seen = new Set();
  for(const k of candidates){
    if(k==null) continue;
    const kk = String(k);
    if(seen.has(kk)) continue;
    seen.add(kk);
    if(Object.prototype.hasOwnProperty.call(node, kk) && node[kk]!==undefined && node[kk]!==null && node[kk]!=="" ){
      return node[kk];
    }
  }
  return undefined;
}



function buildAdeqRowsForRole(iso, shift, block, role){
  const segs=hourSegments(block);
  const rows=computeRowsForBlock(iso, shift, block);
  const list=rows[role]||[];
  const counts=[0,0,0,0];

  for(const r of list){
    const key=ctxKey(iso,shift,block.id);
    const ed=ensureEdit(key,r.emp);
    // TRAINEE employees don't count towards staffing numbers
    if((ed.Present||r.present||"YES")==="TRAINEE") continue;
    const ws=ed.WorkedStart || r.workedStart;
    const we=ed.WorkedEnd || r.workedEnd;
    let aS=minutesOf(ws), aE=minutesOf(we);
     // For NIGHT shift, after-midnight times must be treated as next-day minutes
     if(shift==="NIGHT"){
       const nightStart = 18*60;
       if(aS < nightStart) aS += 1440;
       if(aE < nightStart) aE += 1440;
       if(aE <= aS) aE += 1440;
     }else{
       if(aE <= aS) aE += 1440;
     }

    const segsUse = (block.id==="2200-0200")
      ? [{start:1320,end:1380},{start:1380,end:1440},{start:1440,end:1500},{start:1500,end:1560}]
      : segs.map(s=>({start:s.start,end:s.end}));

    for(let i=0;i<4;i++){
      if(overlapMinutes(aS,aE,segsUse[i].start,segsUse[i].end)>0) counts[i]+=1;
    }
  }

  const hours = segs.map(s => {
    const m = s.start % 1440;
    if(s.start >= 1440 && m === 0) return "2400";
    return ((Math.floor(m/60))*100).toString().padStart(4,"0");
  });
   const d0 = dayNameFromISO(iso);
   const d1 = dayNameFromISO(addDaysISO(iso, 1));
   const out=[];
   for(let i=0;i<4;i++){
     const hk=hours[i];
     // For NIGHT shift, segments after midnight belong to NEXT calendar day for ADEQ lookup.
     const segStart = segs[i] && typeof segs[i].start==='number' ? segs[i].start : 0;
     const dUse = (shift==="NIGHT" && segStart>=1440) ? d1 : d0;
     const av = adeqGet(role, dUse, hk);
     const adeq = (av!==undefined) ? Number(av) : NaN;
    const sched = counts[i]||0;

    let stTxt="", stCls="";
    if(Number.isFinite(adeq)){
      if(sched < adeq){ stTxt=`SHORT ${adeq-sched}`; stCls="statusShort"; }
      else if(sched === adeq){ stTxt="STAFFED"; stCls="statusStaffed"; }
      else { stTxt=`OVER ${sched-adeq}`; stCls="statusOver"; }
    }
    out.push({hour:hk, adeq:(Number.isFinite(adeq)?adeq:""), sched, stTxt, stCls});
  }
  return out;
}

function renderAdequateBox(iso, shift, block){
  const roleDefs=[
    {key:"CALLTAKER", label:"Calltakers"},
    {key:"DISPATCHER", label:"Dispatchers"},
    {key:"PIC", label:"PIC"},
  ];

  const sLabel = String(shift||"").toUpperCase()==="DAY" ? "DAYS" : String(shift||"").toUpperCase()==="NIGHT" ? "NIGHTS" : String(shift||"").toUpperCase();

  let body = `<tr>
    <th style="width:22%">Hour</th><th style="width:22%">Adequate</th><th style="width:22%">Scheduled</th><th style="width:34%">Status</th>
  </tr>`;

  for(const rd of roleDefs){
    body += `<tr class="adeqSectionRow adeqRole-${rd.key}"><td colspan="4">
      <div class="adeqSectionLabel">${rd.label}</div>
      <div class="adeqDivider"></div>
    </td></tr>`;

    const rows = buildAdeqRowsForRole(iso, shift, block, rd.key);
    for(const r of rows){
      body += `<tr>
        <td class="adeqHour">${r.hour}</td>
        <td class="adeqHour">${r.adeq}</td>
        <td class="adeqHour">${r.sched}</td>
        <td class="mono">${r.stTxt?`<span class="${r.stCls}">${r.stTxt}</span>`:""}</td>
      </tr>`;
    }
  }

  return `<div class="adeqBox">
    <div class="adeqBoxHead">${sLabel} ${block.id}</div>
    <div class="adeqBoxSub">STAFFING NUMBERS</div>
    <table class="adeqTbl"><thead></thead><tbody>${body}</tbody></table>
  </div>`;
}


// ===== Custom Select (dropdown width = options only) =====
let __openCustomMenu = null;

function __measureTextPx(text, font){
  // Canvas is the most reliable way to measure option text widths
  const c = __measureTextPx._c || (__measureTextPx._c=document.createElement('canvas'));
  const ctx = c.getContext('2d');
  ctx.font = font || '12px system-ui';
  return Math.ceil(ctx.measureText(text).width);
}

/* Highlight option by index via keyboard — does NOT apply value yet */
function _kbHighlightOpt(menu, opts, idx){
  opts.forEach((o,i)=>{
    o.classList.toggle('kbHL', i===idx);
  });
  opts[idx].scrollIntoView({block:'nearest'});
}

function enhanceSelects(root=document){
  const selects = root.querySelectorAll('select.roleSel, select.seatSel, select.presentSel, select.absReasonSel, select.othTypeSel');
  selects.forEach(sel=>{
    if(sel.dataset.customized === "1") return;

    // Build wrapper + button + menu
    const wrap = document.createElement('span');
    wrap.className = 'customSel';
    const cs = getComputedStyle(sel);
    // Make button compact (don't inherit 100% table-cell width)
    if(sel.classList.contains('roleSel')) wrap.classList.add('customSel--role');
    if(sel.classList.contains('seatSel')) wrap.classList.add('customSel--seat');
    if(sel.classList.contains('presentSel')) wrap.classList.add('customSel--present');
    if(sel.classList.contains('absReasonSel')) wrap.classList.add('customSel--absreason');
    if(sel.classList.contains('othTypeSel')) wrap.classList.add('customSel--othtype');
    wrap.style.width = 'auto';

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'customSelBtn';
    btn.innerHTML = `<span class="lbl"></span><span class="car">▾</span>`;

    const menu = document.createElement('div');
    menu.className = 'customSelMenu';

    // compute dropdown width based on options
    const font = `${cs.fontWeight} ${cs.fontSize} ${cs.fontFamily}`;
    let maxW = 0;
    Array.from(sel.options).forEach(o=>{
      const t = (o.textContent || '').trim();
      maxW = Math.max(maxW, __measureTextPx(t, font));
    });
    // padding + menu chrome
    const menuW = Math.max(48, maxW + 28); // 28px for paddings/caret space
    menu.style.minWidth = menuW + 'px';
    menu.style.width = menuW + 'px';

    function syncLabel(){
      const opt = sel.options[sel.selectedIndex];
      const t = opt ? (opt.textContent||'').trim() : '';
      const lbl = btn.querySelector('.lbl');
      lbl.textContent = t;

      // show full value on hover and size the CLOSED button to the selected value (capped)
      btn.title = t;

      const fontNow = `${cs.fontWeight} ${cs.fontSize} ${cs.fontFamily}`;
      const textW = __measureTextPx(t, fontNow);

      // per-select caps — keep compact so columns don't overlap
      let min = 36, max = 100;
      if(sel.classList.contains('roleSel')){ min = 48; max = 72; }
      if(sel.classList.contains('presentSel')){ min = 48; max = 72; }
      if(sel.classList.contains('seatSel')){ min = 36; max = 90; }
      if(sel.classList.contains('absReasonSel')){ min = 50; max = 120; }
      if(sel.classList.contains('othTypeSel')){ min = 36; max = 60; }

      const w = Math.max(min, Math.min(max, textW + 28)); // +padding + caret
      btn.style.width = w + 'px';

      // Colored bubble for present status
      if(sel.classList.contains('presentSel')){
        btn.classList.remove('partial-yellow','tardy-red','trainer-green','trainee-green');
        if(sel.value === 'PARTIAL') btn.classList.add('partial-yellow');
        else if(sel.value === 'TARDY') btn.classList.add('tardy-red');
        else if(sel.value === 'TRAINER') btn.classList.add('trainer-green');
        else if(sel.value === 'TRAINEE') btn.classList.add('trainee-green');
      }
    }

    function rebuildMenu(){
      menu.innerHTML = '';
      Array.from(sel.options).forEach(o=>{
        const optBtn = document.createElement('button');
        optBtn.type = 'button';
        optBtn.className = 'customSelOpt';
        optBtn.textContent = (o.textContent || '').trim();
        optBtn.setAttribute('aria-selected', o.selected ? 'true' : 'false');
        optBtn.addEventListener('click', ()=>{
          sel.value = o.value;
          // fire native change so existing logic runs (role change, seat change, etc.)
          try{
            if(typeof sel.onchange === 'function') sel.onchange.call(sel, new Event('change'));
          }catch(_e){}
          sel.dispatchEvent(new Event('change', {bubbles:true}));
          sel.dispatchEvent(new Event('input', {bubbles:true}));
          // update selected markers
          Array.from(menu.querySelectorAll('.customSelOpt')).forEach(b=>b.setAttribute('aria-selected','false'));
          optBtn.setAttribute('aria-selected','true');
          syncLabel();
          closeMenu();
        });
        menu.appendChild(optBtn);
      });
    }

    function closeMenu(){
      menu.classList.remove('open');
      menu.classList.remove('flipUp');
      menu.style.left = '';
      menu.style.top = '';
      menu.style.bottom = '';
      // drop row z-index (table stacking fix)
      const tr = wrap.closest('tr');
      if(tr){ tr.style.zIndex = ''; tr.classList.remove('rowMenuOpen'); }
      if(__openCustomMenu === menu) __openCustomMenu = null;
    }
    function openMenu(){
      if(__openCustomMenu && __openCustomMenu !== menu){
        __openCustomMenu.classList.remove('open');
        __openCustomMenu.classList.remove('flipUp');
        const prev = __openCustomMenu.closest('.customSel');
        if(prev){ const trPrev = prev.closest('tr'); if(trPrev){ trPrev.style.zIndex=''; trPrev.classList.remove('rowMenuOpen'); } }
      }
      rebuildMenu();
      syncLabel();
      btn._hlIdx = sel.selectedIndex;

      // reset positioning each time
      menu.classList.remove('flipUp');
      menu.style.left = '0px';
      menu.style.top = '';
      menu.style.bottom = '';

      menu.classList.add('open');
      __openCustomMenu = menu;
      btn.focus();

      // raise row while menu is open (helps with table stacking contexts)
      const tr = wrap.closest('tr');
      if(tr){ tr.style.zIndex = '5000'; tr.classList.add('rowMenuOpen'); }

      // measure after open
      const btnRect = btn.getBoundingClientRect();
      const menuRect = menu.getBoundingClientRect();

      // Flip UP if there's not enough room below but there is room above
      const roomBelow = window.innerHeight - menuRect.bottom;
      const roomAbove = btnRect.top;
      if(roomBelow < 8 && roomAbove > (menuRect.height + 8)){
        menu.classList.add('flipUp');
      }

      // prevent menu from going off the right edge
      const rect2 = menu.getBoundingClientRect();
      const overflowRight = rect2.right - window.innerWidth;
      if(overflowRight > 8){
        menu.style.left = `-${Math.min(overflowRight + 8, rect2.left - 8)}px`;
      }else{
        menu.style.left = '0px';
      }
    }

    menu.addEventListener('mousedown', (e)=>{ e.preventDefault(); });
    // Single click behavior depends on selector type
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      if(menu.classList.contains('open')){
        closeMenu();
      } else if(sel.classList.contains('roleSel') || sel.classList.contains('seatSel') || sel.classList.contains('presentSel') || sel.classList.contains('absReasonSel') || sel.classList.contains('othTypeSel')){
        // All selectors: open on single click
        openMenu();
      }
      // Other selectors: just focus for typing
    });
    // Double click: open the menu (for non-role selectors)
    btn.addEventListener('dblclick', (e)=>{
      e.stopPropagation();
      if(menu.classList.contains('open')) closeMenu();
      else openMenu();
    });

    /* Keyboard support for custom selects */
    /* Type preview: show what's typed + first match without committing */
    btn._typeBuffer = "";
    btn._showTypePreview = function(buf){
      const lbl = btn.querySelector('.lbl');
      if(!buf){
        syncLabel();
        btn.classList.remove('typing-mode');
        return;
      }
      btn.classList.add('typing-mode');
      // Exact match only on textContent or value
      const bufUp = buf.toUpperCase();
      const options = Array.from(sel.options);
      let matchIdx = options.findIndex(o => (o.textContent||"").trim().toUpperCase() === bufUp);
      if(matchIdx < 0) matchIdx = options.findIndex(o => (o.value||"").toUpperCase() === bufUp);

      if(matchIdx >= 0){
        const matchText = (options[matchIdx].textContent||"").trim();
        lbl.innerHTML = `<span style="color:var(--accent);font-weight:900">${matchText}</span>`;
      } else {
        lbl.innerHTML = `<span style="color:var(--bad);font-weight:900">${buf}?</span>`;
      }
    };

    btn.addEventListener('keydown', (e)=>{
      const isOpen = menu.classList.contains('open');
      if(e.key === 'Enter'){
        e.preventDefault();
        /* FIRST: Check for typed value - exact match only */
        if(btn._typeBuffer && btn._typeBuffer.length > 0){
          const typed = btn._typeBuffer.toUpperCase();
          const options = Array.from(sel.options);
          let optIdx = options.findIndex(o => (o.textContent||"").trim().toUpperCase() === typed);
          if(optIdx < 0) optIdx = options.findIndex(o => (o.value||"").toUpperCase() === typed);

          // Close menu if open
          if(isOpen) closeMenu();

          if(optIdx >= 0){
            // Calculate next field before changing DOM
            const selType = sel.classList.contains('seatSel') ? '.customSel--seat' :
                           sel.classList.contains('roleSel') ? '.customSel--role' :
                           sel.classList.contains('presentSel') ? '.customSel--present' :
                           sel.classList.contains('absReasonSel') ? '.customSel--absreason' :
                           sel.classList.contains('othTypeSel') ? '.customSel--othtype' : null;
            let nextIdx = -1;
            if(selType){
              const allOfType = Array.from(document.querySelectorAll(selType + ' .customSelBtn'));
              const idx = allOfType.indexOf(btn);
              if(idx >= 0 && idx < allOfType.length - 1) nextIdx = idx + 1;
            }

            sel.selectedIndex = optIdx;
            btn._typeBuffer = "";
            btn.classList.remove('typing-mode');
            const lbl = btn.querySelector('.lbl');
            if(lbl) lbl.textContent = (sel.options[optIdx].textContent||"").trim();

            // Schedule focus on next field
            if(selType && nextIdx >= 0){
              window.__pendingFocus = { selType: selType, idx: nextIdx };
            }

            sel.dispatchEvent(new Event('change', {bubbles:true}));
            return;
          }
          // No match - clear and stay
          btn._typeBuffer = "";
          btn.classList.remove('typing-mode');
          syncLabel();
          return;
        }
        /* SECOND: If menu open with highlighted item, click it */
        if(isOpen && btn._hlIdx >= 0){
          const opts = Array.from(menu.querySelectorAll('.customSelOpt'));
          if(opts[btn._hlIdx]){
            const selType2 = sel.classList.contains('seatSel') ? '.customSel--seat' :
                             sel.classList.contains('roleSel') ? '.customSel--role' :
                             sel.classList.contains('presentSel') ? '.customSel--present' :
                             sel.classList.contains('absReasonSel') ? '.customSel--absreason' :
                             sel.classList.contains('othTypeSel') ? '.customSel--othtype' : null;
            let nextIdx2 = -1;
            if(selType2){
              const allOfType2 = Array.from(document.querySelectorAll(selType2 + ' .customSelBtn'));
              const ci = allOfType2.indexOf(btn);
              if(ci >= 0 && ci < allOfType2.length - 1) nextIdx2 = ci + 1;
            }
            if(selType2 && nextIdx2 >= 0) window.__pendingFocus = { selType: selType2, idx: nextIdx2 };
            opts[btn._hlIdx].click();
            btn._hlIdx = -1;
            return;
          }
        }
        if(isOpen) closeMenu();
        /* Figure out which index to jump to BEFORE the DOM re-renders */
        const selType = sel.classList.contains('seatSel') ? '.customSel--seat' :
                        sel.classList.contains('roleSel') ? '.customSel--role' :
                        sel.classList.contains('presentSel') ? '.customSel--present' :
                        sel.classList.contains('absReasonSel') ? '.customSel--absreason' :
                        sel.classList.contains('othTypeSel') ? '.customSel--othtype' : null;
        let nextIdx = -1;
        if(selType){
          const allOfType = Array.from(document.querySelectorAll(selType + ' .customSelBtn'));
          const idx = allOfType.indexOf(btn);
          if(idx >= 0 && idx < allOfType.length - 1) nextIdx = idx + 1;
        }
        /* Schedule focus on next row after DOM re-renders (only if no pending match was processed) */
        if(selType && nextIdx >= 0){
          window.__pendingFocus = { selType: selType, idx: nextIdx };
        }
      } else if(e.key === ' '){
        e.preventDefault();
        if(isOpen) closeMenu(); else openMenu();
      } else if(e.key === 'Escape'){
        e.preventDefault();
        if(isOpen) closeMenu();
      } else if(e.key === 'ArrowDown' || e.key === 'ArrowRight'){
        e.preventDefault();
        if(isOpen){
          const opts = Array.from(menu.querySelectorAll('.customSelOpt'));
          if(!opts.length) return;
          if(btn._hlIdx == null) btn._hlIdx = -1;
          btn._hlIdx = Math.min(btn._hlIdx + 1, opts.length - 1);
          _kbHighlightOpt(menu, opts, btn._hlIdx);
          return;
        }
        if(sel.selectedIndex < sel.options.length - 1){
          sel.selectedIndex++;
          sel.dispatchEvent(new Event('change', {bubbles:true}));
          syncLabel();
        }
      } else if(e.key === 'ArrowUp' || e.key === 'ArrowLeft'){
        e.preventDefault();
        if(isOpen){
          const opts = Array.from(menu.querySelectorAll('.customSelOpt'));
          if(!opts.length) return;
          if(btn._hlIdx == null) btn._hlIdx = opts.length;
          btn._hlIdx = Math.max(btn._hlIdx - 1, 0);
          _kbHighlightOpt(menu, opts, btn._hlIdx);
          return;
        }
        if(sel.selectedIndex > 0){
          sel.selectedIndex--;
          sel.dispatchEvent(new Event('change', {bubbles:true}));
          syncLabel();
        }
      } else if(e.key === 'Tab'){
        if(isOpen) closeMenu();
      } else if(e.key === 'Backspace'){
        /* Allow correcting typed buffer */
        e.preventDefault();
        if(!btn._typeBuffer) btn._typeBuffer = "";
        btn._typeBuffer = btn._typeBuffer.slice(0, -1);
        btn._showTypePreview(btn._typeBuffer);
      } else if(e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey){
        /* Type-to-search: show preview but don't auto-select */
        e.preventDefault();
        if(!btn._typeBuffer) btn._typeBuffer = "";
        if(!btn._typeClear) btn._typeClear = null;
        clearTimeout(btn._typeClear);
        btn._typeBuffer += e.key.toUpperCase();
        btn._showTypePreview(btn._typeBuffer);
        btn._typeClear = setTimeout(()=>{ btn._typeBuffer = ""; btn.classList.remove('typing-mode'); btn._showTypePreview(""); }, 2000);
      }
    });

    /* On blur: discard any uncommitted type buffer and restore label */
    btn.addEventListener('blur', ()=>{
      btn._typeBuffer = "";
      btn.classList.remove('typing-mode');
      const lbl = btn.querySelector('.lbl');
      if(lbl) lbl.style.opacity = "";
      syncLabel();
    });

    // Build DOM
    sel.parentNode.insertBefore(wrap, sel);
    wrap.appendChild(btn);
    wrap.appendChild(menu);
    wrap.appendChild(sel);

    // Hide native select but keep it for value + event handlers
    sel.style.display = 'none';
    sel.tabIndex = -1;
    sel.setAttribute('aria-hidden','true');
    sel.dataset.customized = "1";

    // Keep label in sync if code changes select value
    sel.addEventListener('change', ()=>{ syncLabel(); });

    syncLabel();
  });

  // one-time outside click handler
  if(!document.body.dataset.customSelBound){
    document.body.dataset.customSelBound = "1";
    document.addEventListener('click', (e)=>{
      // close any open custom menus if click is outside
      if(__openCustomMenu && !e.target.closest('.customSel')){
        __openCustomMenu.classList.remove('open');
        __openCustomMenu.classList.remove('flipUp');
        const prev = __openCustomMenu.closest('.customSel');
        if(prev){ const trPrev = prev.closest('tr'); if(trPrev){ trPrev.style.zIndex=''; trPrev.classList.remove('rowMenuOpen'); } }
        __openCustomMenu = null;
      }
      // close worked editors if click is outside the editor/pill
      if(!e.target.closest('.timeEdit') && !e.target.closest('.rowPill')){
        document.querySelectorAll('.timeEdit.open').forEach(ed=>{
          ed.classList.remove('open');
          ed.style.display='none';
          const p = ed.parentElement && ed.parentElement.querySelector('.rowPill');
          if(p) p.style.display='inline-block';
        });
      }
    });
    document.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape' && __openCustomMenu){
        __openCustomMenu.classList.remove('open');
        __openCustomMenu.classList.remove('flipUp');
        const prev = __openCustomMenu.closest('.customSel');
        if(prev){ const trPrev = prev.closest('tr'); if(trPrev){ trPrev.style.zIndex=''; trPrev.classList.remove('rowMenuOpen'); } }
        __openCustomMenu = null;
      }
      // Arrow keys handled by btn keydown handler via _kbSelectOpt
    });
  }
}


function updateUnfilledCount(){
  const pill = document.getElementById("pillUnfilled");
  if(!pill) return;
  try{
    const iso = document.getElementById("workDate").value;
    const shift = document.getElementById("shiftSel").value;
    const blocks = getBlocks();
    const blocksShown = (PANEL_VIEW==='all') ? blocks : blocks.filter(b=>b.id===PANEL_VIEW);
    if(!iso || !BASE_EMP.length){ pill.innerHTML="0 UNFILLED"; pill.className="pill good"; return; }

    let seats=0, reasons=0;
    for(const b of blocksShown){
      const key = ctxKey(iso, shift, b.id);
      const rows = computeRowsForBlock(iso, shift, b);
      // Unfilled seats: non-absent roles with empty assignment
      for(const role of ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR"]){
        for(const r of (rows[role]||[])){
          const ed = ensureEdit(key, r.emp);
          if(!(ed.Assignment||r.assignment||"")) seats++;
        }
      }
      // Unfilled absent reasons
      for(const r of (rows.ABSENT||[])){
        if(r.isTardy) continue; // tardy reason is auto-filled
        const ed = ensureEdit(key, r.emp);
        if(r.isPartial){
          if(!(ed.PartialReason||"")) reasons++;
        } else {
          if(!(ed.AbsenceReason||"")) reasons++;
        }
      }
    }
    const total = seats + reasons;
    const parts = [];
    if(seats) parts.push(seats+" seat"+(seats>1?"s":""));
    if(reasons) parts.push(reasons+" reason"+(reasons>1?"s":""));
    pill.innerHTML = total === 0 ? "0 UNFILLED" : `<span style="color:#ff4d4d;font-weight:900">${total}</span> UNFILLED!`;
    pill.title = total === 0 ? "All fields filled" : parts.join(", ");
    pill.className = total === 0 ? "pill good" : "pill bad";
    pill._unfilledMsg = total === 0 ? "All fields filled!" : "Unfilled: " + parts.join(", ");
  }catch(e){ console.warn("updateUnfilledCount:", e); }
}

document.addEventListener("click", function(e){
  const pill = e.target.closest("#pillUnfilled");
  if(pill && pill._unfilledMsg) alert(pill._unfilledMsg);
});

function renderAll(){
  clearErr();
  try{
    const iso=document.getElementById("workDate").value;
    const shift=document.getElementById("shiftSel").value;
    const blocks=getBlocks();
    const blocksShown = (PANEL_VIEW==='all') ? blocks : blocks.filter(b=>b.id===PANEL_VIEW);
    const grid=document.getElementById("blocks");

    if(!iso || !BASE_EMP.length){
      grid.innerHTML = "";
      return;
    }

    grid.classList.add("boardGrid");
    document.body.classList.toggle('singlePanel', PANEL_VIEW!=='all');

    // Compute once per block
    const rowsByBlock = {};
    for(const b of blocks){
      rowsByBlock[b.id] = computeRowsForBlock(iso, shift, b);
    }

    const sections = [
      {title:"Adequate Staffing", role:"adeq", render:(b)=>`<div class="section">${renderAdequateBox(iso, shift, b)}</div>`, getTitle:(b)=>"STAFFING NUMBERS"},
      {title:"Calltakers", role:"CALLTAKER", render:(b)=>renderRoleTable(iso, shift, b, "CALLTAKER", rowsByBlock[b.id].CALLTAKER), getTitle:(b)=>`CALLTAKERS: ${(rowsByBlock[b.id].CALLTAKER||[]).length}`},
      {title:"Dispatchers", role:"DISPATCHER", render:(b)=>renderRoleTable(iso, shift, b, "DISPATCHER", rowsByBlock[b.id].DISPATCHER), getTitle:(b)=>`DISPATCHERS: ${(rowsByBlock[b.id].DISPATCHER||[]).length}`},
      {title:"PIC", role:"PIC", render:(b)=>renderRoleTable(iso, shift, b, "PIC", rowsByBlock[b.id].PIC), getTitle:(b)=>`PIC: ${(rowsByBlock[b.id].PIC||[]).length}`},
      {title:"SUP", role:"SUPERVISOR", render:(b)=>renderRoleTable(iso, shift, b, "SUPERVISOR", rowsByBlock[b.id].SUPERVISOR), getTitle:(b)=>`SUPERVISORS: ${(rowsByBlock[b.id].SUPERVISOR||[]).length}`},
      {title:"OUT", role:"ABSENT", render:(b)=>renderRoleTable(iso, shift, b, "ABSENT", rowsByBlock[b.id].ABSENT), getTitle:(b)=>`ABSENT: ${(rowsByBlock[b.id].ABSENT||[]).length}`},
      {title:"OTHER", role:"OTH", render:(b)=>renderOthTable(iso, shift, b, rowsByBlock[b.id].OTH), getTitle:(b)=>`OTHER: ${(rowsByBlock[b.id].OTH||[]).length}`},
      {title:"OT / Extra", role:"ot", render:(b)=>`<div class="section">${renderAddOtBar(b)}</div>`, getTitle:(b)=>"OT / EXTRA"},
    ];

    const shiftLabel = (s)=>{
      const up = String(s||"").toUpperCase();
      // normalize DAY/NIGHT into plural DAYS/NIGHTS
      if (up === "DAY") return "DAYS";
      if (up === "NIGHT") return "NIGHTS";
      if (up.endsWith("S")) return up;
      return up + "S";
    };

    const makeCell=(b, sec, colIdx, rowIdx)=>{
      const isFirst = (rowIdx === 1);
      const hdrText = isFirst ? `${shiftLabel(shift)} ${b.id}` : sec.getTitle(b);
      return `
      <div class="card boardCard roleCard-${sec.role}" data-role="${sec.role}" data-block="${b.id}" style="grid-column:${colIdx}; grid-row:${rowIdx};">
        <h2 class="blockHdr">${hdrText}</h2>
        ${sec.render(b)}
      </div>
    `;
    };

    let out="";
    blocksShown.forEach((b, bi)=>{
      const col = bi+1;
      sections.forEach((sec, si)=>{
        const row = si+1;
        out += makeCell(b, sec, col, row);
      });
    });
    grid.innerHTML = out;
    enhanceSelects(grid);

    // Update absent count bar in footer — match grid columns to blocks
    const absentBar = document.getElementById("absentBar");
    if(absentBar){
      absentBar.style.gridTemplateColumns = `repeat(${blocksShown.length}, minmax(490px, 1fr))`;
      let abHtml = "";
      for(const b of blocksShown){
        const cnt = (rowsByBlock[b.id].ABSENT||[]).length;
        const cls = cnt === 0 ? "absentPill zero" : "absentPill";
        let otCnt = 0;
        for(const role of ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR","ABSENT","OTH"]){
          for(const r of (rowsByBlock[b.id][role]||[])) if(r.isOT) otCnt++;
        }
        const otCls = otCnt === 0 ? "absentPill zero" : "absentPill otPill";
        abHtml += `<div class="absentCell"><span class="${cls}"><span class="absentCount">${cnt} ABSENT</span></span><span class="${otCls}"><span class="absentCount">${otCnt} OT</span></span></div>`;
      }
      absentBar.innerHTML = abHtml;
    }

    updateUnfilledCount();
    _applyBubbleLayout();

  }catch(err){
    console.error(err);
    setErr("Render failed: " + (err && err.message ? err.message : err));
  }
}

/* Targeted single-card re-render for fast edits */
function renderCard(ctxKeyStr){
  try{
    const [iso, shift, blockId] = ctxKeyStr.split("|");
    const blocks = getBlocks();
    const b = blocks.find(x=>x.id===blockId);
    if(!b) return renderAll();

    const rowsByBlock = computeRowsForBlock(iso, shift, b);

    const sectionDefs = [
      {role:"adeq", render:()=>`<div class="section">${renderAdequateBox(iso, shift, b)}</div>`, getTitle:()=>"STAFFING NUMBERS"},
      {role:"CALLTAKER", render:()=>renderRoleTable(iso, shift, b, "CALLTAKER", rowsByBlock.CALLTAKER), getTitle:()=>`CALLTAKERS: ${(rowsByBlock.CALLTAKER||[]).length}`},
      {role:"DISPATCHER", render:()=>renderRoleTable(iso, shift, b, "DISPATCHER", rowsByBlock.DISPATCHER), getTitle:()=>`DISPATCHERS: ${(rowsByBlock.DISPATCHER||[]).length}`},
      {role:"PIC", render:()=>renderRoleTable(iso, shift, b, "PIC", rowsByBlock.PIC), getTitle:()=>`PIC: ${(rowsByBlock.PIC||[]).length}`},
      {role:"SUPERVISOR", render:()=>renderRoleTable(iso, shift, b, "SUPERVISOR", rowsByBlock.SUPERVISOR), getTitle:()=>`SUPERVISORS: ${(rowsByBlock.SUPERVISOR||[]).length}`},
      {role:"ABSENT", render:()=>renderRoleTable(iso, shift, b, "ABSENT", rowsByBlock.ABSENT), getTitle:()=>`ABSENT: ${(rowsByBlock.ABSENT||[]).length}`},
      {role:"OTH", render:()=>renderOthTable(iso, shift, b, rowsByBlock.OTH), getTitle:()=>`OTHER: ${(rowsByBlock.OTH||[]).length}`},
      {role:"ot", render:()=>`<div class="section">${renderAddOtBar(b)}</div>`, getTitle:()=>"OT / EXTRA"},
    ];

    const grid = document.getElementById("blocks");
    for(const sec of sectionDefs){
      const card = grid.querySelector(`[data-block="${blockId}"][data-role="${sec.role}"]`);
      if(!card) continue;
      const hdr = card.querySelector("h2.blockHdr");
      if(hdr) hdr.textContent = sec.getTitle();
      // Replace content after header
      const newContent = sec.render();
      const wrapper = document.createElement("div");
      wrapper.innerHTML = newContent;
      // Remove everything after the h2
      while(hdr.nextSibling) card.removeChild(hdr.nextSibling);
      while(wrapper.firstChild) card.appendChild(wrapper.firstChild);
      enhanceSelects(card);
    }

    // Update absent count in footer for all visible blocks
    const absentBar = document.getElementById("absentBar");
    if(absentBar){
      const blocksShown = (PANEL_VIEW==='all') ? blocks : blocks.filter(x=>x.id===PANEL_VIEW);
      absentBar.style.gridTemplateColumns = `repeat(${blocksShown.length}, minmax(490px, 1fr))`;
      let abHtml = "";
      for(const blk of blocksShown){
        const rr = computeRowsForBlock(iso, shift, blk);
        const cnt = (rr.ABSENT||[]).length;
        const cls = cnt === 0 ? "absentPill zero" : "absentPill";
        let otCnt = 0;
        for(const role of ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR","ABSENT","OTH"]){
          for(const r of (rr[role]||[])) if(r.isOT) otCnt++;
        }
        const otCls = otCnt === 0 ? "absentPill zero" : "absentPill otPill";
        abHtml += `<div class="absentCell"><span class="${cls}"><span class="absentCount">${cnt} ABSENT</span></span><span class="${otCls}"><span class="absentCount">${otCnt} OT</span></span></div>`;
      }
      absentBar.innerHTML = abHtml;
    }
    updateUnfilledCount();
    _applyBubbleLayout();
  }catch(err){
    console.error("renderCard fallback:", err);
    renderAll();
  }
}

// ===== Bubble layout (locked from layout editor) =====
function _applyBubbleLayout(){
  // Helper: apply size + move to bubble, and sync dropdown menu position
  function applyRule(sel, size, move){
    document.querySelectorAll(sel).forEach(el => {
      el.style.setProperty('width', size+'px', 'important');
      el.style.setProperty('min-width', size+'px', 'important');
      el.style.setProperty('max-width', size+'px', 'important');
      if(move !== 0) el.style.setProperty('margin-left', move+'px', 'important');
      // Ensure shifted elements stay clickable above overlapping cells
      el.style.setProperty('position', 'relative', 'important');
      el.style.setProperty('z-index', '5', 'important');
      el.style.setProperty('text-align', 'center', 'important');
      // Nudge hrs text slightly right to visually center it
      if(el.classList.contains('hrsIn') || el.classList.contains('absHrsLabel'))
        el.style.setProperty('padding-left', '4px', 'important');
      // For custom selects, also shift the dropdown menu to match the button
      const wrapper = el.closest('.customSel');
      if(wrapper){
        wrapper.style.removeProperty('margin-left');
        const menu = wrapper.querySelector('.customSelMenu');
        if(menu && move !== 0) menu.style.setProperty('margin-left', move+'px', 'important');
      }
    });
  }
  // Main tables (not absent)
  const P = '.rosterTbl:not(.rosterTbl--absent)';
  applyRule(P+' td.roleCol .customSelBtn',    61, -170);
  applyRule(P+' td.seatCol .customSelBtn',    96, -155);
  applyRule(P+' td.workedCol .rowPill',       63, -265);
  applyRule(P+' td.hrsCol .hrsIn',            38, -140);
  applyRule(P+' td.presCol .customSelBtn, '+P+' td.presCol .presentSel', 62, -112);
  applyRule(P+' td.cmtCol .cmt-btn',          54, -85);
  // Absent table
  const A = '.rosterTbl--absent';
  applyRule(A+' td.seatCol .customSelBtn',    96, -195);
  applyRule(A+' td.seatCol .absTardyLabel',   96, -195);
  applyRule(A+' td.workedCol .rowPill',       70, -305);
  applyRule(A+' td.hrsCol .hrsIn',            38, -150);
  applyRule(A+' td.hrsCol .absHrsLabel',      38, -150);
  applyRule(A+' td.presCol .customSelBtn, '+A+' td.presCol .presentSel', 62, -130);
  applyRule(A+' td.cmtCol .cmt-btn',          14, -130);
  // nameCol: keep CSS defaults (overflow:hidden truncates names with ellipsis)
  // Allow overflow on all ctrl cells so shifted bubbles aren't clipped
  document.querySelectorAll('.rosterTbl td.roleCol, .rosterTbl td.seatCol, .rosterTbl td.workedCol, .rosterTbl td.hrsCol, .rosterTbl td.presCol, .rosterTbl td.cmtCol').forEach(el => {
    el.style.setProperty('overflow', 'visible', 'important');
    el.style.setProperty('position', 'relative', 'important');
  });
  // Force all header <th> cells: transparent background so shifted text
  // from adjacent cells isn't hidden, and allow overflow — only for tables with data
  document.querySelectorAll('.rosterTbl').forEach(tbl => {
    const hasRows = tbl.querySelectorAll('tbody tr').length > 0;
    tbl.querySelectorAll('thead th').forEach(el => {
      el.style.setProperty('background', 'transparent', 'important');
      if(hasRows){
        el.style.setProperty('overflow', 'visible', 'important');
        el.style.setProperty('max-width', 'none', 'important');
        el.style.setProperty('text-overflow', 'clip', 'important');
      }
    });
    // Empty tables: shrink to content so headers don't spread out
    if(!hasRows){
      tbl.style.setProperty('width', 'auto', 'important');
      tbl.style.setProperty('table-layout', 'auto', 'important');
      tbl.querySelectorAll('thead th').forEach(th => {
        th.style.setProperty('padding-left', '10px', 'important');
        th.style.setProperty('padding-right', '10px', 'important');
        th.style.setProperty('width', 'auto', 'important');
        th.style.setProperty('min-width', '0', 'important');
        th.style.setProperty('max-width', 'none', 'important');
      });
    }
  });
  // Put the header background on the <thead> row instead
  const isLight = document.body.classList.contains('light');
  document.querySelectorAll('.rosterTbl thead tr').forEach(el => {
    el.style.setProperty('background', isLight ? 'rgba(0,0,0,.03)' : '#0c1320', 'important');
  });
  // Defer header alignment to next frame
  requestAnimationFrame(()=>{
    _alignHeaders('.rosterTbl:not(.rosterTbl--absent)');
    _alignHeaders('.rosterTbl--absent');
    // Scroll main to the right so left side clips first when window is narrow
    const m = document.querySelector('main');
    if(m) m.scrollLeft = m.scrollWidth - m.clientWidth;
  });
}
// Keep main scrolled to the right on window resize
window.addEventListener('resize', function(){
  const m = document.querySelector('main');
  if(m) m.scrollLeft = m.scrollWidth - m.clientWidth;
});

// ===== Auto-align headers over bubbles =====
function _alignHeaders(tableSelector){
  document.querySelectorAll(tableSelector).forEach(tbl => {
    const dataRows = tbl.querySelectorAll('tbody tr');
    if(!dataRows.length) return;
    const cols = ['roleCol','seatCol','workedCol','hrsCol','presCol','cmtCol'];
    for(const col of cols){
      const th = tbl.querySelector('thead th.' + col);
      if(!th) continue;
      const hdrSpan = th.querySelector('.hdrTxt');
      if(!hdrSpan) continue;
      // Search rows until we find one with a bubble in this column
      let bubble = null, bubbleTd = null;
      for(const row of dataRows){
        const td = row.querySelector('td.' + col);
        if(!td) continue;
        const b = td.querySelector('.customSelBtn, .rowPill, .hrsIn, .cmt-btn, .absTardyLabel, .absHrsLabel');
        if(b){ bubble = b; bubbleTd = td; break; }
      }
      if(!bubble) continue;
      th.style.setProperty('text-align', 'left', 'important');
      th.style.setProperty('position', 'relative', 'important');
      // Reset previous positioning so measurements are clean
      hdrSpan.style.removeProperty('left');
      hdrSpan.style.setProperty('position', 'absolute', 'important');
      hdrSpan.style.setProperty('top', '8px', 'important');
      hdrSpan.style.setProperty('z-index', '2', 'important');
      // Measure bubble center relative to table left edge
      const tblRect = tbl.getBoundingClientRect();
      const bubbleRect = bubble.getBoundingClientRect();
      const bubbleCenter = bubbleRect.left + bubbleRect.width / 2 - tblRect.left;
      // Position span so its center aligns with bubble center
      const spanW = hdrSpan.getBoundingClientRect().width;
      const left = bubbleCenter - spanW / 2;
      // Position relative to the <th> cell
      const thRect = th.getBoundingClientRect();
      const thLeft = thRect.left - tblRect.left;
      hdrSpan.style.setProperty('left', Math.round(left - thLeft) + 'px', 'important');
    }
  });
}

// ===== Comment popup (floating) =====
var _cmtPopupKey = null;   // which cmtKey the popup is showing
var _cmtPopupBtn = null;   // the .cmt-btn that opened it

function openCmtPopup(btn){
  const popup = document.getElementById("cmtPopup");
  const ta = document.getElementById("cmtPopupTa");
  const key = btn.dataset.cmtkey;
  if(!key) return;

  // If clicking the same btn, close it
  if(popup.classList.contains("open") && _cmtPopupKey === key){
    closeCmtPopup(); return;
  }

  _cmtPopupKey = key;
  _cmtPopupBtn = btn;
  ta.value = rowComments[key] || "";
  ta.dataset.cmtkey = key;

  // Position above the button, anchored to the right
  const rect = btn.getBoundingClientRect();
  popup.classList.add("open");
  const pW = popup.offsetWidth;
  const pH = popup.offsetHeight;
  popup.style.left = Math.max(4, rect.right - pW + 24) + "px";
  popup.style.top  = (rect.top - pH - 8) + "px";
  ta.focus();
}

function closeCmtPopup(){
  const popup = document.getElementById("cmtPopup");
  popup.classList.remove("open");
  _cmtPopupKey = null;
  _cmtPopupBtn = null;
}

document.addEventListener("click", function(e){
  const btn = e.target.closest(".cmt-btn");
  if(btn){ openCmtPopup(btn); return; }

  // Close popups when clicking outside
  if(!e.target.closest("#cmtPopup") && !e.target.closest(".cmt-btn")){
    closeCmtPopup();
  }
  if(!e.target.closest("#otConfirmPopup") && !e.target.closest(".ot-edit-icon")){
    closeOTConfirm();
  }
});

document.addEventListener("input", function(e){
  if(e.target.id !== "cmtPopupTa") return;
  const key = e.target.dataset.cmtkey;
  if(!key) return;
  rowComments[key] = e.target.value;
  // Update the button that opened this popup
  if(_cmtPopupBtn){
    _cmtPopupBtn.classList.toggle("has-cmt", e.target.value.trim().length > 0);
  }
  scheduleAutoSave();
});

// ===== OT confirm popup =====
var _otConfirmKey = null;
var _otConfirmEmp = null;

function showOTConfirm(ev, key, emp){
  ev.stopPropagation();
  const popup = document.getElementById("otConfirmPopup");
  _otConfirmKey = key;
  _otConfirmEmp = emp;

  const rect = ev.target.getBoundingClientRect();
  popup.style.left = Math.max(4, rect.left - 20) + "px";
  popup.style.top  = (rect.bottom + 6) + "px";
  popup.classList.add("open");
}

function closeOTConfirm(){
  const popup = document.getElementById("otConfirmPopup");
  popup.classList.remove("open");
  _otConfirmKey = null;
  _otConfirmEmp = null;
}

document.getElementById("otConfirmYes").addEventListener("click", function(){
  if(_otConfirmKey && _otConfirmEmp) removeOT(_otConfirmKey, _otConfirmEmp);
  closeOTConfirm();
});
document.getElementById("otConfirmNo").addEventListener("click", function(){
  closeOTConfirm();
});

// ===== Wire up controls =====

function updatePanelViewOptions(){
  const pv = document.getElementById("panelViewSel");
  const sh = document.getElementById("shiftSel");
  if(!pv || !sh) return;
  const shift = sh.value || "DAY";
  const blocks = getBlocks(); // uses shiftSel internally
  const prev = pv.value || "all";

  // Rebuild options: All + the 3 blocks for current shift
  pv.innerHTML = "";
  const optAll = document.createElement("option");
  optAll.value = "all";
  optAll.textContent = "All 3 blocks";
  pv.appendChild(optAll);

  for(const b of blocks){
    const o = document.createElement("option");
    o.value = b.id;
    o.textContent = b.id; // keep same style as Day Shift
    pv.appendChild(o);
  }

  // Restore previous selection if valid, else All
  const valid = Array.from(pv.options).some(o=>o.value===prev);
  pv.value = valid ? prev : "all";
  PANEL_VIEW = pv.value; // keep global in sync
}

document.getElementById("shiftSel").addEventListener("change", async ()=>{
  updatePanelViewOptions();
  // Load saved edits from Firebase for this date/shift
  const iso = document.getElementById("workDate").value;
  const shift = document.getElementById("shiftSel").value;
  if(iso && shift) await loadEditsFromFirebase(iso, shift);
  startRealtimeSync(iso, shift);
  renderAll();
});
document.getElementById("panelViewSel").addEventListener("change", (e)=>{PANEL_VIEW=e.target.value; renderAll();});
// Pay period generator: PP3 starts 2026-01-10, each PP = 14 days
function generatePayPeriods(){
  const PP3_START = new Date(2026, 0, 10);
  const periods = [];
  for(let i = 0; i < 50; i++){
    const ppNum = 3 + i;
    const start = new Date(PP3_START.getTime() + i * 14 * 86400000);
    const end = new Date(start.getTime() + 13 * 86400000);
    const fmt = d => `${String(d.getMonth()+1).padStart(2,'0')}/${String(d.getDate()).padStart(2,'0')}`;
    const yr = d => String(d.getFullYear()).slice(-2);
    periods.push({ num: ppNum, start, end, label: `PP${ppNum}: ${fmt(start)}-${fmt(end)}` });
  }
  return periods;
}
const PAY_PERIODS = generatePayPeriods();

function buildDaySel(){
  const daySel = document.getElementById("daySel");
  if(!daySel) return;
  daySel.innerHTML = "";
  const ppVal = document.getElementById("ppSel").value;
  const wk = parseInt(document.getElementById("weekSel").value) || 1;
  if(!ppVal) return;
  const ppStart = new Date(ppVal + "T00:00:00");
  const DAYS = ["Saturday","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday"];
  const offset = (wk - 1) * 7;
  for(let d = 0; d < 7; d++){
    const date = new Date(ppStart.getTime() + (offset + d) * 86400000);
    const iso = toISODate(date);
    const mm = String(date.getMonth()+1).padStart(2,'0');
    const dd = String(date.getDate()).padStart(2,'0');
    const o = document.createElement("option");
    o.value = iso;
    o.textContent = `${DAYS[d]} ${mm}/${dd}`;
    daySel.appendChild(o);
  }
}

async function applyDaySelection(){
  const iso = document.getElementById("daySel").value;
  if(!iso) return;
  document.getElementById("workDate").value = iso;
  const d = new Date(iso + "T00:00:00");
  const satOff = (d.getDay() + 1) % 7;
  const sat = new Date(d.getTime() - satOff * 86400000);
  document.getElementById("weekStart").value = toISODate(sat);
  updateWorkDateLabel();
  // Load saved edits from Firebase for this date/shift
  const shift = document.getElementById("shiftSel").value;
  await loadEditsFromFirebase(iso, shift);
  await loadShiftSwaps(iso);
  await loadVacations(iso);
  startRealtimeSync(iso, shift);
  startSwapSync(iso);
  listenVacations(iso);
  renderAll();
}

function updateWorkDateLabel(){
  const el = document.getElementById("workDate");
  const disp = document.getElementById("workDateDisplay");
  if(!el || !disp) return;
  if(!el.value){ disp.textContent=""; return; }
  const parts = el.value.split("-");
  const d = new Date(+parts[0], +parts[1]-1, +parts[2]);
  const days = ["SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"];
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const dd = String(d.getDate()).padStart(2,"0");
  const yy = String(d.getFullYear()).slice(-2);
  disp.textContent = `— ${days[d.getDay()]} ${mm}/${dd}/${yy}`;
}

document.getElementById("dbFile").addEventListener("change", async (e)=>{
  clearErr();
  const f=e.target.files && e.target.files[0];
  if(!f) return;
  try{
    const buf = await f.arrayBuffer();
    /* Cache to localStorage as base64 */
    try {
      const bytes = new Uint8Array(buf);
      let bin = "";
      for(let i=0;i<bytes.length;i++) bin += String.fromCharCode(bytes[i]);
      localStorage.setItem("sheetops_db", btoa(bin));
    } catch(cacheErr){ console.warn("Cache save failed:", cacheErr); }
    const wb=loadWorkbook(buf);
    parseDatabase(wb);
    renderAll();
  }catch(err){
    console.error(err);
    setErr("DB load failed: "+(err && err.message ? err.message : err));
  }
});

document.getElementById("btnImport").addEventListener("click", ()=>{
  document.getElementById("teamsFile").click();
});
document.getElementById("teamsFile").addEventListener("change", async ()=>{
  const f=document.getElementById("teamsFile").files && document.getElementById("teamsFile").files[0];
  if(!f) return;
  try{
    await importTeamsWeek(f);
    renderAll();
    scheduleAutoSave();
  }catch(err){
    console.error(err);
    setErr("Teams import failed: "+(err && err.message ? err.message : err));
  }
  document.getElementById("teamsFile").value="";
});

/* === v190: Save current edits to Excel (XLSX export) === */
function buildExportRowsForCurrent(){
  const iso = document.getElementById("workDate").value;
  const shift = document.getElementById("shiftSel").value;
  const blocks = getBlocks();

  const out = [];
  for(const b of blocks){
    const ctx = ctxKey(iso, shift, b.id);
    const rowsByRole = computeRowsForBlock(iso, shift, b);

    for(const role of ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR","ABSENT","OTH"]){
      const rows = rowsByRole[role] || [];
      for(const r of rows){
        const ed = ensureEdit(ctx, r.emp);
        out.push({
          Date: iso,
          Shift: shift,
          Block: b.id,
          Role: role,
          Employee: r.isPartial ? r.emp + " (P)" : ((ed.Present||r.present||"YES")==="TRAINER" ? r.emp + " (TNR)" : (ed.Present||r.present||"YES")==="TRAINEE" ? r.emp + " (TNE)" : r.emp),
          Seniority: r.sen,
          Present: (ed.Present || r.present || "YES"),
          Hours: r.isPartial ? r.hours : (ed.Hours!=="" ? Number(ed.Hours) : r.hours),
          Seat: role==="OTH" ? (ed.OthType || "") : (ed.Assignment || r.assignment || ""),
          WorkedStart: r.isPartial ? (r.workedStart||"") : (ed.WorkedStart || r.workedStart || ""),
          WorkedEnd: r.isPartial ? (r.workedEnd||"") : (ed.WorkedEnd || r.workedEnd || ""),
          AbsenceReason: r.isPartial ? (ed.PartialReason || "") : (ed.AbsenceReason || ""),
          IsOT: (r.isOT ? "YES" : "NO"),
          ScheduledShift: r.shiftStr,
          IsPartial: r.isPartial ? true : false
        });
      }
    }
  }
  return out;
}

function saveXlsx(){
  try{
    const iso = document.getElementById("workDate").value || "date";
    const shift = document.getElementById("shiftSel").value || "shift";
    const blocks = getBlocks();
    const wb = XLSX.utils.book_new();

    /* ---- Styles ---- */
    const border = {
      top:    {style:"thin", color:{rgb:"444444"}},
      bottom: {style:"thin", color:{rgb:"444444"}},
      left:   {style:"thin", color:{rgb:"444444"}},
      right:  {style:"thin", color:{rgb:"444444"}}
    };
    const sBlockHdr = {font:{bold:true,sz:8,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"1E3A5F"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const sSectionHdr = {font:{bold:true,sz:7,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"2D4A6F"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const sColHdr = {font:{bold:true,sz:6,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"3B5998"}}, alignment:{vertical:"center"}, border:border};
    const sNormal = {font:{sz:7}, alignment:{vertical:"center"}, border:border};
    const sRoleCalltaker = {font:{bold:true,sz:7,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"1A5276"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const sRoleDispatcher = {font:{bold:true,sz:7,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"4A235A"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const sRolePIC = {font:{bold:true,sz:7,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"0E6655"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const sRoleSupervisor = {font:{bold:true,sz:7,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"7D6608"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const sRoleAbsent = {font:{bold:true,sz:7,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"922B21"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const sStatusShort = {font:{bold:true,sz:7,color:{rgb:"CC0000"}}, fill:{fgColor:{rgb:"FFF0F0"}}, alignment:{vertical:"center"}, border:border};
    const sStatusGood = {font:{bold:true,sz:7,color:{rgb:"806600"}}, fill:{fgColor:{rgb:"FFFDE6"}}, alignment:{vertical:"center"}, border:border};
    const sStatusOver = {font:{bold:true,sz:7,color:{rgb:"007744"}}, fill:{fgColor:{rgb:"E6FFF5"}}, alignment:{vertical:"center"}, border:border};
    const sAdeqHdr = {font:{bold:true,sz:6,color:{rgb:"333333"}}, fill:{fgColor:{rgb:"D6E4F0"}}, alignment:{vertical:"center"}, border:border};
    const sAdeqRow = {font:{sz:7,color:{rgb:"222222"}}, fill:{fgColor:{rgb:"EDF2F7"}}, alignment:{vertical:"center"}, border:border};
    const sRoleOth = {font:{bold:true,sz:7,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"6B7280"}}, alignment:{horizontal:"center",vertical:"center"}, border:border};
    const roleAbbr = {CALLTAKER:"CT",DISPATCHER:"DP",PIC:"PIC",SUPERVISOR:"SUP",ABSENT:"ABS",OTH:"OTH"};
    const roleHdrStyles = {CALLTAKER:sRoleCalltaker, DISPATCHER:sRoleDispatcher, PIC:sRolePIC, SUPERVISOR:sRoleSupervisor, ABSENT:sRoleAbsent, OTH:sRoleOth};
    const roleBgColors = {CALLTAKER:"E8F0FE", DISPATCHER:"F3E5F5", PIC:"E0F2F1", SUPERVISOR:"FFF8E1", ABSENT:"FDEDEC", OTH:"F3F4F6"};

    /* ---- Helper: write a value into a cell with style ---- */
    function setCell(ws, r, c, val, style){
      const ref = XLSX.utils.encode_cell({r:r, c:c});
      const cell = {v: val, t: typeof val === 'number' ? 'n' : 's'};
      if(style) cell.s = style;
      ws[ref] = cell;
    }

    /* ---- Helper: ensure sheet range covers r,c ---- */
    function expandRange(ws, r, c){
      if(!ws['!ref']){
        ws['!ref'] = XLSX.utils.encode_range({s:{r:0,c:0},e:{r:r,c:c}});
        return;
      }
      const range = XLSX.utils.decode_range(ws['!ref']);
      if(r > range.e.r) range.e.r = r;
      if(c > range.e.c) range.e.c = c;
      ws['!ref'] = XLSX.utils.encode_range(range);
    }

    const ws = {};
    const roles = ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR","ABSENT","OTH"];
    const blockCols = 6; // columns per block: Name, Role, Seat, Worked, Hrs, Present
    const allComments = []; // collect comments for separate sheet
    const totalCols = blocks.length * blockCols;
    const shiftLabel = shift === "NIGHT" ? "NIGHTS" : "DAYS";
    const dayName = dayNameFromISO(iso);
    const parts = iso.split("-");
    const dateStr = `${parts[1]}/${parts[2]}/${parts[0].slice(-2)}`;
    if(!ws['!merges']) ws['!merges'] = [];

    /* ---- Pass 1: compute section sizes per block to find max for alignment ---- */
    const allRowsByRole = {};
    const adeqRoleDefs = [{key:"CALLTAKER",label:"CT"},{key:"DISPATCHER",label:"DP"},{key:"PIC",label:"PIC"}];
    const allAdeqRows = {};
    for(const b of blocks){
      allRowsByRole[b.id] = computeRowsForBlock(iso, shift, b);
      allAdeqRows[b.id] = {};
      for(const rd of adeqRoleDefs){
        allAdeqRows[b.id][rd.key] = buildAdeqRowsForRole(iso, shift, b, rd.key);
      }
    }

    /* Staffing numbers height: header(1) + colHdr(1) + 3 roles * (subHdr(1) + rows) */
    let adeqHeight = 2; // "STAFFING NUMBERS" + column headers
    for(const rd of adeqRoleDefs){
      let maxRows = 0;
      for(const b of blocks){ maxRows = Math.max(maxRows, allAdeqRows[b.id][rd.key].length); }
      adeqHeight += 1 + maxRows; // subHdr + data rows
    }

    /* Role section heights: for each role, max across blocks of (hdr + colHdr + employees) */
    const roleSectionHeight = {};
    for(const role of roles){
      let maxH = 0;
      for(const b of blocks){
        const list = allRowsByRole[b.id][role] || [];
        if(list.length > 0) maxH = Math.max(maxH, 2 + list.length); // roleHdr + colHdr + rows
      }
      roleSectionHeight[role] = maxH;
    }

    /* ---- Pass 2: write aligned data ---- */
    let row = 0;

    /* Block headers - row 0 */
    blocks.forEach((b, bi) => {
      const cs = bi * blockCols;
      setCell(ws, row, cs, `${shiftLabel} ${b.id} ${dayName.slice(0,3).toUpperCase()} ${dateStr}`, sBlockHdr);
      for(let c=cs+1;c<cs+blockCols;c++) setCell(ws, row, c, "", sBlockHdr);
      ws['!merges'].push({s:{r:row,c:cs}, e:{r:row,c:cs+blockCols-1}});
      expandRange(ws, row, cs+blockCols-1);
    });
    row++;

    /* Staffing numbers */
    blocks.forEach((b, bi) => {
      const cs = bi * blockCols;
      setCell(ws, row, cs, "STAFFING NUMBERS", sSectionHdr);
      for(let c=cs+1;c<cs+blockCols;c++) setCell(ws, row, c, "", sSectionHdr);
      ws['!merges'].push({s:{r:row,c:cs}, e:{r:row,c:cs+blockCols-1}});
    });
    row++;

    blocks.forEach((b, bi) => {
      const cs = bi * blockCols;
      setCell(ws, row, cs, "Hr", sAdeqHdr);
      setCell(ws, row, cs+1, "Adeq", sAdeqHdr);
      setCell(ws, row, cs+2, "Sched", sAdeqHdr);
      setCell(ws, row, cs+3, "Stat", sAdeqHdr);
      for(let c=cs+4;c<cs+blockCols;c++) setCell(ws, row, c, "", sAdeqHdr);
    });
    row++;

    for(const rd of adeqRoleDefs){
      /* Sub-header row */
      const adeqSubHdr = {font:{bold:true,sz:7,color:{rgb:"1A3A5C"}}, fill:{fgColor:{rgb:"C8D8E8"}}, border:border};
      blocks.forEach((b, bi) => {
        const cs = bi * blockCols;
        setCell(ws, row, cs, rd.label, adeqSubHdr);
        for(let c=cs+1;c<cs+blockCols;c++) setCell(ws, row, c, "", adeqSubHdr);
        ws['!merges'].push({s:{r:row,c:cs}, e:{r:row,c:cs+blockCols-1}});
      });
      row++;

      /* Find max adeq rows for this role */
      let maxAdeq = 0;
      for(const b of blocks) maxAdeq = Math.max(maxAdeq, allAdeqRows[b.id][rd.key].length);

      for(let i=0; i<maxAdeq; i++){
        blocks.forEach((b, bi) => {
          const cs = bi * blockCols;
          const ar = allAdeqRows[b.id][rd.key][i];
          if(ar){
            setCell(ws, row, cs, ar.hour, sAdeqRow);
            setCell(ws, row, cs+1, ar.adeq, sAdeqRow);
            setCell(ws, row, cs+2, ar.sched, sAdeqRow);
            const stStyle = ar.stTxt && ar.stTxt.includes("SHORT") ? sStatusShort :
                            ar.stTxt && ar.stTxt.includes("OVER") ? sStatusOver :
                            (ar.stTxt && (ar.stTxt.includes("GOOD") || ar.stTxt.includes("STAFFED"))) ? sStatusGood : sAdeqRow;
            setCell(ws, row, cs+3, ar.stTxt || "", stStyle);
            for(let c=cs+4;c<cs+blockCols;c++) setCell(ws, row, c, "", sAdeqRow);
          } else {
            for(let c=cs;c<cs+blockCols;c++) setCell(ws, row, c, "", sAdeqRow);
          }
          expandRange(ws, row, cs+blockCols-1);
        });
        row++;
      }
    }

    /* Role tables - aligned */
    for(const role of roles){
      const height = roleSectionHeight[role];
      if(height === 0) continue;

      const isAbsent = (role === "ABSENT");
      const isOth = (role === "OTH");
      const rolePlural = {CALLTAKER:"CT",DISPATCHER:"DP",PIC:"PIC",SUPERVISOR:"SUP",ABSENT:"ABS",OTH:"OTH"};
      const rHdrStyle = roleHdrStyles[role] || sSectionHdr;
      const bgColor = roleBgColors[role] || "FFFFFF";
      const rowStyle = {font:{sz:7}, fill:{fgColor:{rgb:bgColor}}, alignment:{vertical:"center"}, border:border};
      const emptyStyle = {font:{sz:7}, fill:{fgColor:{rgb:bgColor}}, alignment:{vertical:"center"}, border:border};

      /* Role header row */
      blocks.forEach((b, bi) => {
        const cs = bi * blockCols;
        const list = allRowsByRole[b.id][role] || [];
        setCell(ws, row, cs, `${rolePlural[role]||role}: ${list.length}`, rHdrStyle);
        for(let c=cs+1;c<cs+blockCols;c++) setCell(ws, row, c, "", rHdrStyle);
        ws['!merges'].push({s:{r:row,c:cs}, e:{r:row,c:cs+blockCols-1}});
        expandRange(ws, row, cs+blockCols-1);
      });
      row++;

      /* Column headers row */
      blocks.forEach((b, bi) => {
        const cs = bi * blockCols;
        setCell(ws, row, cs, "Name", sColHdr);
        if(!isAbsent) setCell(ws, row, cs+1, "Rl", sColHdr);
        else setCell(ws, row, cs+1, "", sColHdr);
        setCell(ws, row, cs+2, isAbsent ? "Rsn" : (isOth ? "Rsn" : "Seat"), sColHdr);
        setCell(ws, row, cs+3, isAbsent ? "Msd" : "Wkd", sColHdr);
        setCell(ws, row, cs+4, "Hr", sColHdr);
        setCell(ws, row, cs+5, "Pr", sColHdr);
        expandRange(ws, row, cs+blockCols-1);
      });
      row++;

      /* Data rows - max across all blocks */
      let maxEmp = 0;
      for(const b of blocks) maxEmp = Math.max(maxEmp, (allRowsByRole[b.id][role]||[]).length);

      for(let i=0; i<maxEmp; i++){
        blocks.forEach((b, bi) => {
          const cs = bi * blockCols;
          const list = allRowsByRole[b.id][role] || [];
          if(i < list.length){
            const r = list[i];
            const ctx = ctxKey(iso, shift, b.id);
            const ed = ensureEdit(ctx, r.emp);
            const roleNorm = normalizeRole(ed.Role || r.role);
            const seat = ed.Assignment || r.assignment || "";
            const wStart = r.isPartial ? (r.workedStart||"") : (ed.WorkedStart || r.workedStart || "");
            const wEnd = r.isPartial ? (r.workedEnd||"") : (ed.WorkedEnd || r.workedEnd || "");
            const hrs = r.isPartial ? r.hours : (ed.Hours !== "" ? Number(ed.Hours) : r.hours);
            const present = ed.Present || r.present || "YES";
            const absReason = ed.AbsenceReason || "";

            const nameSuffix = (r.isTardy ? " (T)" : r.isPartial ? " (P)" : present==="TRAINER" ? " (TNR)" : present==="TRAINEE" ? " (TNE)" : "") + (r.isOT ? " (OT)" : "");
            const othType = ed.OthType || "";
            const cmtKey = r.isTardy ? ctx+'|'+r.emp+'|TARDY' : (r.isPartial ? ctx+'|'+r.emp+'|PARTIAL' : ctx+'|'+r.emp);
            const cmtText = (rowComments[cmtKey] || "").trim();
            setCell(ws, row, cs, String(r.emp).toUpperCase() + nameSuffix, rowStyle);
            setCell(ws, row, cs+1, isAbsent ? "" : (roleAbbr[roleNorm]||roleNorm), rowStyle);
            setCell(ws, row, cs+2, isAbsent ? (r.isTardy ? "TARDY" : r.isPartial ? (ed.PartialReason||"") : absReason) : (isOth ? othType : seat), rowStyle);
            setCell(ws, row, cs+3, wStart && wEnd ? `${wStart}-${wEnd}` : "", rowStyle);
            setCell(ws, row, cs+4, hrs, rowStyle);
            setCell(ws, row, cs+5, present==="TARDY"?"T":(present==="PARTIAL"?"P":(present==="TRAINER"?"TNR":(present==="TRAINEE"?"TNE":(present==="YES"?"Y":"N")))), rowStyle);
            if(cmtText) allComments.push({block:b.id, role:role, emp:String(r.emp).toUpperCase()+nameSuffix, comment:cmtText});
          } else {
            for(let c=cs;c<cs+blockCols;c++) setCell(ws, row, c, "", emptyStyle);
          }
          expandRange(ws, row, cs+blockCols-1);
        });
        row++;
      }
    }

    const totalRows = row;

    /* ---- Apply thick outer border around entire chart + between blocks ---- */
    const thickStyle = {style:"medium", color:{rgb:"000000"}};
    for(let r=0; r<totalRows; r++){
      for(let c=0; c<totalCols; c++){
        const ref = XLSX.utils.encode_cell({r:r, c:c});
        if(!ws[ref]) { ws[ref] = {v:"", t:"s", s:{border:border}}; }
        if(!ws[ref].s) ws[ref].s = {border:border};
        if(!ws[ref].s.border) ws[ref].s.border = Object.assign({}, border);
        const bdr = Object.assign({}, ws[ref].s.border);
        /* Outer edges */
        if(c === 0) bdr.left = thickStyle;
        if(c === totalCols-1) bdr.right = thickStyle;
        if(r === 0) bdr.top = thickStyle;
        if(r === totalRows-1) bdr.bottom = thickStyle;
        /* Between blocks: thick right on last col of each block, thick left on first col of next */
        for(let bi=0; bi<blocks.length; bi++){
          const lastCol = bi * blockCols + blockCols - 1;
          const firstCol = bi * blockCols;
          if(c === lastCol) bdr.right = thickStyle;
          if(c === firstCol) bdr.left = thickStyle;
        }
        ws[ref].s = Object.assign({}, ws[ref].s, {border: bdr});
      }
    }

    /* Column widths - tight for single-sheet print */
    const cols = [];
    for(let bi=0; bi<blocks.length; bi++){
      const s = bi * blockCols;
      cols[s]   = {wch:12}; // Name
      cols[s+1] = {wch:3};  // Role
      cols[s+2] = {wch:5};  // Seat/Reason
      cols[s+3] = {wch:8};  // Worked
      cols[s+4] = {wch:3};  // Hrs
      cols[s+5] = {wch:2};  // Present
    }
    ws['!cols'] = cols;

    /* Row heights - tight to fit 1 page */
    ws['!rows'] = [];
    for(let r=0; r<totalRows; r++){
      ws['!rows'][r] = {hpt:10};
    }

    /* Page setup for letter landscape - fit ALL rows+cols to exactly 1 page */
    ws['!pageSetup'] = {
      paperSize: 1,
      orientation: "landscape",
      fitToWidth: 1,
      fitToHeight: 1
    };
    ws['!margins'] = {left:0.1, right:0.1, top:0.1, bottom:0.1, header:0, footer:0};
    ws['!print'] = {fitToPage: true};

    XLSX.utils.book_append_sheet(wb, ws, "Roster");

    /* ---- Comments sheet ---- */
    if(allComments.length > 0){
      const cs2 = {};
      const cHdr = {font:{bold:true,sz:10,color:{rgb:"FFFFFF"}}, fill:{fgColor:{rgb:"1E3A5F"}}, alignment:{vertical:"center"}, border:border};
      const cTitle = {font:{bold:true,sz:12,color:{rgb:"1E3A5F"}}, alignment:{horizontal:"center",vertical:"center"}};
      const cRow = {font:{sz:10}, alignment:{vertical:"center",wrapText:true}, border:border};
      const cRowAlt = {font:{sz:10}, fill:{fgColor:{rgb:"EDF2F7"}}, alignment:{vertical:"center",wrapText:true}, border:border};

      let cr = 0;
      /* Title row */
      setCell(cs2, cr, 0, `COMMENTS — ${shiftLabel} ${dayName.slice(0,3).toUpperCase()} ${dateStr}`, cTitle);
      for(let c=1;c<=3;c++) setCell(cs2, cr, c, "", cTitle);
      if(!cs2['!merges']) cs2['!merges'] = [];
      cs2['!merges'].push({s:{r:cr,c:0}, e:{r:cr,c:3}});
      expandRange(cs2, cr, 3);
      cr++;
      cr++; // blank row

      /* Column headers */
      setCell(cs2, cr, 0, "EMPLOYEE", cHdr);
      setCell(cs2, cr, 1, "BLOCK", cHdr);
      setCell(cs2, cr, 2, "ROLE", cHdr);
      setCell(cs2, cr, 3, "COMMENT", cHdr);
      expandRange(cs2, cr, 3);
      cr++;

      /* Comment rows */
      for(let i=0; i<allComments.length; i++){
        const c = allComments[i];
        const style = (i % 2 === 0) ? cRow : cRowAlt;
        setCell(cs2, cr, 0, c.emp, style);
        setCell(cs2, cr, 1, c.block, style);
        setCell(cs2, cr, 2, c.role, style);
        setCell(cs2, cr, 3, c.comment, style);
        expandRange(cs2, cr, 3);
        cr++;
      }

      cs2['!cols'] = [{wch:20},{wch:10},{wch:12},{wch:60}];
      cs2['!rows'] = [];
      for(let r=0;r<cr;r++) cs2['!rows'][r] = {hpt: r>=3 ? 18 : 16};
      cs2['!pageSetup'] = {paperSize:1, orientation:"portrait", fitToWidth:1, fitToHeight:1};
      cs2['!margins'] = {left:0.2, right:0.2, top:0.2, bottom:0.2, header:0, footer:0};
      cs2['!print'] = {fitToPage:true};

      XLSX.utils.book_append_sheet(wb, cs2, "Comments");
    }

    const safeShift = String(shift).replace(/[^\w\-]+/g,'_');
    const fname = `SheetOps_${iso}_${safeShift}.xlsx`;
    XLSX.writeFile(wb, fname);
    clearErr();
  }catch(err){
    console.error(err);
    setErr("Save failed: " + (err && err.message ? err.message : err));
  }
}

document.getElementById("btnSaveXlsx").addEventListener("click", saveXlsx);

/* ===== Print Daily: roster page 1, comments page 2 ===== */
function printDaily(){
  try{
    if(!window.jspdf){
      setErr("Loading PDF library… click Print Daily again in a few seconds.");
      const s=document.createElement("script");
      s.src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.2/jspdf.umd.min.js";
      s.onerror=()=>{
        const s2=document.createElement("script");
        s2.src="https://cdn.jsdelivr.net/npm/jspdf@2.5.2/dist/jspdf.umd.min.js";
        document.head.appendChild(s2);
      };
      document.head.appendChild(s);
      return;
    }
    const {jsPDF} = window.jspdf;
    const iso = document.getElementById("workDate").value || "date";
    const shift = document.getElementById("shiftSel").value || "shift";
    const blocks = getBlocks();
    const shiftLabel = shift === "NIGHT" ? "NIGHTS" : "DAYS";
    const dayName = dayNameFromISO(iso);
    const pts = iso.split("-");
    const dateStr = `${pts[1]}/${pts[2]}/${pts[0].slice(-2)}`;
    const title = `${shiftLabel} ${dayName.slice(0,3).toUpperCase()} ${dateStr}`;

    const roles = ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR","ABSENT","OTH"];
    const roleAbbr = {CALLTAKER:"CT",DISPATCHER:"DP",PIC:"PIC",SUPERVISOR:"SUP",ABSENT:"ABS",OTH:"OTH"};
    const roleRGB = {CALLTAKER:[26,82,118],DISPATCHER:[74,35,90],PIC:[14,102,85],SUPERVISOR:[125,102,8],ABSENT:[146,43,33],OTH:[107,114,128]};
    const roleBgRGB = {CALLTAKER:[232,240,254],DISPATCHER:[243,229,245],PIC:[224,242,241],SUPERVISOR:[255,248,225],ABSENT:[253,237,236],OTH:[243,244,246]};
    const adeqRoleDefs = [{key:"CALLTAKER",label:"CT"},{key:"DISPATCHER",label:"DP"},{key:"PIC",label:"PIC"}];

    /* Gather all data */
    const allRowsByRole = {};
    const allAdeqRows = {};
    const pdfComments = [];
    for(const b of blocks){
      allRowsByRole[b.id] = computeRowsForBlock(iso, shift, b);
      allAdeqRows[b.id] = {};
      for(const rd of adeqRoleDefs) allAdeqRows[b.id][rd.key] = buildAdeqRowsForRole(iso, shift, b, rd.key);
    }

    /* ---- Count total rows to calculate row height ---- */
    let totalRows = 0;
    totalRows++; // block header
    totalRows++; // staffing numbers header
    totalRows++; // adeq col headers
    for(const rd of adeqRoleDefs){
      totalRows++; // adeq sub-header
      let mx=0; for(const b of blocks) mx=Math.max(mx, allAdeqRows[b.id][rd.key].length);
      totalRows += mx;
    }
    for(const role of roles){
      let hasAny=false;
      for(const b of blocks) if((allRowsByRole[b.id][role]||[]).length) hasAny=true;
      if(!hasAny) continue;
      totalRows++; // role header
      totalRows++; // col headers
      let mx=0; for(const b of blocks) mx=Math.max(mx,(allRowsByRole[b.id][role]||[]).length);
      totalRows += mx;
    }

    /* Page 1: portrait letter = 612 x 792 points */
    const doc = new jsPDF({orientation:"portrait", unit:"pt", format:"letter"});
    const pw = 612, ph = 792;
    const margin = 2;
    const usableW = pw - margin*2;
    const usableH = ph - margin*2;
    const rh = Math.floor((usableH / totalRows)*100)/100; // row height
    const nBlocks = blocks.length;
    const blockW = usableW / nBlocks;
    /* Column ratios within a block: Name(35%), Rl(6%), Seat(14%), Wkd(20%), Hr(10%), Pr(8%), pad(7%) */
    const colR = [0.35, 0.10, 0.15, 0.22, 0.10, 0.08];
    const colW = colR.map(r => blockW * r);
    const fontSize = Math.min(7, rh * 0.7);
    const fontSizeSmall = fontSize * 0.85;

    function hexToRGB(hex){ return [parseInt(hex.slice(0,2),16),parseInt(hex.slice(2,4),16),parseInt(hex.slice(4,6),16)]; }

    /* Drawing helpers */
    let y = margin;
    function drawRow(fills, texts, opts={}){
      const bold = opts.bold||false;
      const txtColor = opts.color||[0,0,0];
      const centered = opts.center||false;
      const fs = opts.fs||fontSize;
      const merge = opts.merge||false;
      for(let bi=0;bi<nBlocks;bi++){
        const bx = margin + bi*blockW;
        if(merge){
          const fill = fills[bi]||fills[0]||[255,255,255];
          doc.setFillColor(fill[0],fill[1],fill[2]);
          doc.rect(bx, y, blockW, rh, 'F');
          doc.setDrawColor(100,100,100); doc.rect(bx, y, blockW, rh, 'S');
          doc.setFontSize(fs);
          doc.setFont("helvetica", bold?"bold":"normal");
          doc.setTextColor(txtColor[0],txtColor[1],txtColor[2]);
          const txt = texts[bi]||"";
          if(centered) doc.text(txt, bx+blockW/2, y+rh*0.7, {align:"center"});
          else doc.text(txt, bx+2, y+rh*0.7);
        } else {
          let cx = bx;
          for(let ci=0;ci<6;ci++){
            const fill = Array.isArray(fills[bi]) ? (Array.isArray(fills[bi][0])?fills[bi][ci]:fills[bi]) : [255,255,255];
            doc.setFillColor(fill[0],fill[1],fill[2]);
            doc.rect(cx, y, colW[ci], rh, 'F');
            doc.setDrawColor(100,100,100); doc.rect(cx, y, colW[ci], rh, 'S');
            const txt = (texts[bi]&&texts[bi][ci])||"";
            const tc = (opts.cellColors&&opts.cellColors[bi]&&opts.cellColors[bi][ci])||txtColor;
            doc.setTextColor(tc[0],tc[1],tc[2]);
            doc.setFontSize(ci===0?fs:fontSizeSmall);
            doc.setFont("helvetica", bold?"bold":"normal");
            doc.text(String(txt), cx+1.5, y+rh*0.7);
            cx += colW[ci];
          }
        }
      }
      y += rh;
    }

    /* Block headers */
    drawRow(
      blocks.map(()=>[30,58,95]),
      blocks.map(b=>`${shiftLabel} ${b.id} ${dayName.slice(0,3).toUpperCase()} ${dateStr}`),
      {bold:true, color:[255,255,255], center:true, merge:true}
    );

    /* Staffing numbers header */
    drawRow(
      blocks.map(()=>[45,74,111]),
      blocks.map(()=>"STAFFING NUMBERS"),
      {bold:true, color:[255,255,255], center:true, merge:true}
    );

    /* Adeq column headers */
    drawRow(
      blocks.map(()=>[214,228,240]),
      blocks.map(()=>["Hr","Adeq","Sched","Stat","",""]),
      {bold:true, color:[51,51,51]}
    );

    /* Adeq rows per role */
    for(const rd of adeqRoleDefs){
      drawRow(
        blocks.map(()=>[200,216,232]),
        blocks.map(()=>rd.label),
        {bold:true, color:[26,58,92], center:true, merge:true}
      );
      let mx=0; for(const b of blocks) mx=Math.max(mx, allAdeqRows[b.id][rd.key].length);
      for(let i=0;i<mx;i++){
        const fills=[], texts=[], cellColors=[];
        for(const b of blocks){
          const ar = allAdeqRows[b.id][rd.key][i];
          const bg=[237,242,247];
          fills.push([bg,bg,bg,bg,bg,bg]);
          if(ar){
            const stC = ar.stTxt.includes("SHORT")?[204,0,0]:ar.stTxt.includes("OVER")?[0,119,68]:[128,102,0];
            texts.push([ar.hour, ar.adeq, ar.sched, ar.stTxt, "", ""]);
            cellColors.push([[34,34,34],[34,34,34],[34,34,34],stC,[34,34,34],[34,34,34]]);
          } else { texts.push(["","","","","",""]); cellColors.push(null); }
        }
        drawRow(fills, texts, {color:[34,34,34], cellColors:cellColors});
      }
    }

    /* Role tables */
    for(const role of roles){
      const isAbsent=role==="ABSENT", isOth=role==="OTH";
      let hasAny=false;
      for(const b of blocks) if((allRowsByRole[b.id][role]||[]).length) hasAny=true;
      if(!hasAny) continue;

      const rc = roleRGB[role]||[100,100,100];
      const bg = roleBgRGB[role]||[255,255,255];

      /* Role header */
      drawRow(
        blocks.map(()=>rc),
        blocks.map(b=>`${roleAbbr[role]}: ${(allRowsByRole[b.id][role]||[]).length}`),
        {bold:true, color:[255,255,255], center:true, merge:true}
      );

      /* Col headers */
      drawRow(
        blocks.map(()=>[[59,89,152],[59,89,152],[59,89,152],[59,89,152],[59,89,152],[59,89,152]]),
        blocks.map(()=>["Name", isAbsent?"":"Rl", isAbsent?"Rsn":(isOth?"Rsn":"Seat"), isAbsent?"Msd":"Wkd", "Hr", "Pr"]),
        {bold:true, color:[255,255,255]}
      );

      /* Data rows */
      let mx=0; for(const b of blocks) mx=Math.max(mx,(allRowsByRole[b.id][role]||[]).length);
      for(let i=0;i<mx;i++){
        const fills=[], texts=[];
        for(const b of blocks){
          const list=allRowsByRole[b.id][role]||[];
          fills.push([bg,bg,bg,bg,bg,bg]);
          if(i<list.length){
            const r=list[i];
            const ctx=ctxKey(iso,shift,b.id);
            const ed=ensureEdit(ctx,r.emp);
            const roleNorm=normalizeRole(ed.Role||r.role);
            const wStart=r.isPartial?(r.workedStart||""):(ed.WorkedStart||r.workedStart||"");
            const wEnd=r.isPartial?(r.workedEnd||""):(ed.WorkedEnd||r.workedEnd||"");
            const hrs=r.isPartial?r.hours:(ed.Hours!==""?Number(ed.Hours):r.hours);
            const present=ed.Present||r.present||"YES";
            const absReason=ed.AbsenceReason||"";
            const nameSuffix=(r.isTardy?" (T)":r.isPartial?" (P)":present==="TRAINER"?" (TNR)":present==="TRAINEE"?" (TNE)":"")+(r.isOT?" (OT)":"");
            const othType=ed.OthType||"";
            const cmtKey=r.isTardy?ctx+'|'+r.emp+'|TARDY':(r.isPartial?ctx+'|'+r.emp+'|PARTIAL':ctx+'|'+r.emp);
            const cmtText=(rowComments[cmtKey]||"").trim();
            if(cmtText) pdfComments.push({block:b.id, role:role, emp:String(r.emp).toUpperCase()+nameSuffix, comment:cmtText});
            const prStr=present==="TARDY"?"T":(present==="PARTIAL"?"P":(present==="TRAINER"?"TNR":(present==="TRAINEE"?"TNE":(present==="YES"?"Y":"N"))));
            const seatVal=isAbsent?(r.isTardy?"TARDY":r.isPartial?(ed.PartialReason||""):absReason):(isOth?othType:(ed.Assignment||r.assignment||""));
            const wkd=wStart&&wEnd?wStart+"-"+wEnd:"";
            texts.push([String(r.emp).toUpperCase()+nameSuffix, isAbsent?"":(roleAbbr[roleNorm]||roleNorm), seatVal, wkd, hrs, prStr]);
          } else { texts.push(["","","","","",""]); }
        }
        drawRow(fills, texts, {color:[0,0,0]});
      }
    }

    /* Fill remaining page with empty space (border) */
    if(y < ph - margin){
      doc.setFillColor(255,255,255);
      doc.rect(margin, y, usableW, ph-margin-y, 'F');
    }

    /* ---- Page 2: Comments (portrait) ---- */
    if(pdfComments.length > 0){
      doc.addPage("letter","portrait");
      const cpw=612, cph=792;
      const cm=20;
      let cy=cm;

      /* Title */
      doc.setFontSize(14);
      doc.setFont("helvetica","bold");
      doc.setTextColor(30,58,95);
      doc.text(`COMMENTS — ${title}`, cpw/2, cy+14, {align:"center"});
      cy+=28;

      /* Column widths: Employee(25%), Block(12%), Role(13%), Comment(50%) */
      const cColW = [(cpw-cm*2)*0.22, (cpw-cm*2)*0.12, (cpw-cm*2)*0.13, (cpw-cm*2)*0.53];
      const cHeaders = ["EMPLOYEE","BLOCK","ROLE","COMMENT"];
      const cRowH = 18;

      /* Header row */
      let cx2=cm;
      for(let ci=0;ci<4;ci++){
        doc.setFillColor(30,58,95);
        doc.rect(cx2, cy, cColW[ci], cRowH, 'F');
        doc.setDrawColor(100,100,100); doc.rect(cx2, cy, cColW[ci], cRowH, 'S');
        doc.setFontSize(9); doc.setFont("helvetica","bold"); doc.setTextColor(255,255,255);
        doc.text(cHeaders[ci], cx2+4, cy+13);
        cx2+=cColW[ci];
      }
      cy+=cRowH;

      /* Comment rows */
      for(let i=0;i<pdfComments.length;i++){
        const c=pdfComments[i];
        const altBg = i%2===0?[255,255,255]:[237,242,247];
        const vals=[c.emp, c.block, c.role, c.comment];
        /* Word-wrap comment to calculate row height */
        doc.setFontSize(8); doc.setFont("helvetica","normal");
        const wrapped = doc.splitTextToSize(c.comment, cColW[3]-6);
        const lineH = 10;
        const thisRowH = Math.max(cRowH, wrapped.length * lineH + 6);

        cx2=cm;
        for(let ci=0;ci<4;ci++){
          doc.setFillColor(altBg[0],altBg[1],altBg[2]);
          doc.rect(cx2, cy, cColW[ci], thisRowH, 'F');
          doc.setDrawColor(100,100,100); doc.rect(cx2, cy, cColW[ci], thisRowH, 'S');
          doc.setTextColor(0,0,0);
          doc.setFontSize(8);
          doc.setFont("helvetica", ci===0?"bold":"normal");
          if(ci===3){
            doc.text(wrapped, cx2+3, cy+lineH);
          } else {
            doc.text(String(vals[ci]), cx2+3, cy+13);
          }
          cx2+=cColW[ci];
        }
        cy+=thisRowH;
      }
    }

    /* Save / open PDF */
    const safeShift = String(shift).replace(/[^\w\-]+/g,'_');
    const pdfBlob = doc.output('blob');
    const pdfUrl = URL.createObjectURL(pdfBlob);
    const win = window.open(pdfUrl, '_blank');
    if(win){ win.onload = ()=>{ win.focus(); win.print(); }; }
    else { doc.save(`ShiftOps_${iso}_${safeShift}.pdf`); }
    clearErr();
  }catch(err){
    console.error(err);
    setErr("Print failed: " + (err && err.message ? err.message : err));
  }
}
document.getElementById("btnPrintDaily").addEventListener("click", printDaily);

// Shift Swap button + modal backdrop close
document.getElementById("btnShiftSwap").addEventListener("click", openSwapModal);
document.getElementById("swapModalBackdrop").addEventListener("click", function(e){ if(e.target===this) closeSwapModal(); });
document.getElementById("swapEmpA").addEventListener("change", updateSwapPreview);
document.getElementById("swapEmpB").addEventListener("change", updateSwapPreview);

/* ===== Supervisor List PDF ===== */
const SUP_ASSIGNMENTS = {
  "ADAMS": [
    {last:"Cruz",first:"Alma"},{last:"White",first:"Ashly"},{last:"Wheat",first:"Madison"},
    {last:"Harrison",first:"James"},{last:"Jones",first:"Beverly"},{last:"Dones",first:"Michelle"},
    {last:"Guerra",first:"Rosemary"},{last:"Brown",first:"Victoria"},{last:"Galindo",first:"Deyonia"},
    {last:"Pinnow",first:"Tiffani"},{last:"Mims",first:"Rendan"},{last:"Zamaguey",first:"Thelma"},
    {last:"Fowler",first:"Laricia"},{last:"Reynolds",first:"Elliot"}
  ],
  "AGUIRRE": [
    {last:"Olvera",first:"Juanita"},{last:"Thompkins",first:"Ishmael"},{last:"Sumner",first:"Jordan"},
    {last:"Burnham",first:"Hudson"},{last:"Danford",first:"Alexis"},
    {last:"Scroggins",first:"Jolie"},{last:"Gonzalez",first:"Stefany"},{last:"Valdez",first:"Ricky"},
    {last:"Glenn",first:"Ethan"},{last:"Lindley",first:"D"},{last:"Marzahn",first:"Jeff"},
    {last:"Santo",first:"Samantha"}
  ],
  "ALLISON": [
    {last:"Baiza",first:"Nathaly"},{last:"Clayton",first:"Patty"},{last:"Merrill",first:"Crystal"},
    {last:"Wright",first:"Molly"},{last:"Urrutia",first:"Aileen"},{last:"Glass",first:"Krista"},
    {last:"Reed",first:"Andy"},{last:"Bly",first:"Hailey"},{last:"Pope",first:"Matthew"},
    {last:"Young",first:"Laquita"},{last:"Brown",first:"Chris"},{last:"Rector",first:"Samantha"},
    {last:"Garcia",first:"Anahi"}
  ],
  "CASSELL": [
    {last:"Bryan",first:"Tim"},{last:"Dillard",first:"Alexis"},{last:"Jacobs",first:"Jason"},
    {last:"Graves",first:"Gina"},{last:"Toledo",first:"Jesse"},{last:"Smothers",first:"Amanda"},
    {last:"Ailshie",first:"Crystal"},{last:"Herrera",first:"JoCarol"},{last:"Pena",first:"Eric"},
    {last:"Horner",first:"Sydney"},{last:"Rhoades",first:"James"},{last:"Shankman",first:"Danyelle"},
    {last:"Dessellier",first:"Danielle"},{last:"Ramirez",first:"Traci"}
  ],
  "HATCHETT": [
    {last:"Rodriguez",first:"Jose"},{last:"Sierra",first:"Joe"},{last:"Renfro",first:"Liv"},
    {last:"Krock",first:"Ashley"},{last:"Daskou",first:"Rakyra"},{last:"Adamson",first:"John"},
    {last:"Petrigni",first:"Samantha"},{last:"Moning",first:"Jeannette"},{last:"Walker",first:"Jennifer"},
    {last:"Dorsey",first:"Sherri"},{last:"Allen",first:"Avery"}
  ],
  "LAZARO": [
    {last:"Garcia",first:"Fernando"},{last:"Quinones",first:"Antonio"},{last:"Sigala",first:"Araceli"},
    {last:"Leatham",first:"Laura"},{last:"Lorona",first:"Amanda"},{last:"Abram",first:"Larissa"},
    {last:"Mahle",first:"Chloe"},{last:"Thomas",first:"Tayah"},{last:"Mcknight",first:"Zina"},
    {last:"Maher",first:"Katrina"},{last:"Cox",first:"Emma"},{last:"Hall",first:"Michael Casey"},
    {last:"Grounds",first:"Anita"}
  ],
  "MARTINEZ": [
    {last:"Sanders",first:"Michelle"},{last:"Buglehall",first:"Matt"},{last:"Claudio",first:"Juan"},
    {last:"Black",first:"Kevin"},{last:"Castleman",first:"Ezra"},{last:"Jackson",first:"Lakisha"},
    {last:"Guerrero",first:"Miguel"},{last:"Hardin",first:"Brady"},{last:"Duran",first:"Carisma"},
    {last:"Dodd",first:"Angelia"},{last:"Fowler",first:"Helen"}
  ],
  "NOLAN": [
    {last:"Slack",first:"Kya"},{last:"Richardson",first:"Jasmine"},{last:"Brashear",first:"Andrea"},
    {last:"Martinez",first:"Lizette"},{last:"Moore",first:"Allyson"},{last:"Perry",first:"Kendall"},
    {last:"Warren",first:"Colton"},{last:"Hutta",first:"Monique"},{last:"Goldblatt",first:"David"}
  ],
  "PARRA": [
    {last:"Adams",first:"Stephanie"},{last:"Maguda",first:"Andy"},{last:"Robles",first:"Caleb"},
    {last:"Fuller",first:"Marcus"},{last:"Moncada",first:"Paola"},
    {last:"Charles",first:"Amy"},{last:"Pham",first:"Jualian"},{last:"Trevino",first:"Stephanie"},
    {last:"Banks",first:"Lynell"},{last:"Crossman",first:"Tanja"},{last:"Estrada",first:"Christopher"},
    {last:"Guidry",first:"Melinda"},{last:"Henas",first:"Parra"}
  ],
  "MEDRANO": [
    {last:"Perez",first:"Danielle"},{last:"Finch",first:"Martha"},{last:"Rinaldi",first:"Katie"},
    {last:"Johnson",first:"Jessica"},{last:"Curry",first:"Matt"},{last:"Wiese",first:"Tracy"},
    {last:"Gallagher",first:"Ralph"},{last:"Trejo",first:"Anna"},{last:"Martin",first:"Victoria"},
    {last:"Dougherty",first:"Shelby"},{last:"Lutton",first:"Brianna"},{last:"Sandoval",first:"Marteen"},
    {last:"Perez",first:"Johnny"},{last:"Clement",first:"Chris"}
  ]
};

function matchSupEmp(last, first){
  /* Match a supervisor-list entry to a BASE_EMP employee name */
  const ln = last.toUpperCase().replace(/\s+/g,'');
  const fi = (first||"").charAt(0).toUpperCase();
  /* Exact match first */
  let match = BASE_EMP.find(e => e.Employee.toUpperCase() === ln);
  if(match) return match.Employee;
  /* Last name + first initial (e.g. BROWNC, PEREZJ) */
  if(fi){
    match = BASE_EMP.find(e => e.Employee.toUpperCase() === ln + fi);
    if(match) return match.Employee;
  }
  /* Starts-with match (only if unique) */
  const starts = BASE_EMP.filter(e => e.Employee.toUpperCase().startsWith(ln));
  if(starts.length === 1) return starts[0].Employee;
  /* If multiple starts-with matches, use first initial to pick */
  if(starts.length > 1 && fi){
    const refined = starts.find(e => e.Employee.toUpperCase() === ln + fi);
    if(refined) return refined.Employee;
  }
  /* Fallback: return "Last, First" as-is */
  return last + ", " + first;
}

window.addEventListener('DOMContentLoaded', ()=>{
  /* Treat anything before 0600 as the previous day */
  const now = new Date();
  const today = now.getHours() < 6 ? new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1) : now;
  const isoToday = toISODate(today);

  /* Populate pay period dropdown */
  const ppSel = document.getElementById("ppSel");
  PAY_PERIODS.forEach(pp => {
    const o = document.createElement("option");
    o.value = toISODate(pp.start);
    o.textContent = pp.label;
    ppSel.appendChild(o);
  });

  /* Auto-select current pay period (compare date strings to avoid time-of-day boundary issues) */
  const match = PAY_PERIODS.find(pp => isoToday >= toISODate(pp.start) && isoToday <= toISODate(pp.end));
  if(match) ppSel.value = toISODate(match.start);

  /* Auto-select week 1 or 2 based on today */
  if(match){
    const todayD = new Date(isoToday + "T00:00:00");
    const daysSinceStart = Math.round((todayD.getTime() - match.start.getTime()) / 86400000);
    document.getElementById("weekSel").value = daysSinceStart >= 7 ? "2" : "1";
  }

  /* Build day dropdown and select today */
  buildDaySel();
  document.getElementById("daySel").value = isoToday;

  /* PP change rebuilds day dropdown */
  ppSel.addEventListener("change", () => {
    buildDaySel();
    applyDaySelection();
  });

  /* Week change rebuilds day dropdown */
  document.getElementById("weekSel").addEventListener("change", () => {
    buildDaySel();
    applyDaySelection();
  });

  /* Day change applies selection */
  document.getElementById("daySel").addEventListener("change", () => {
    applyDaySelection();
  });

  /* Theme toggle */
  const themeBtn = document.getElementById("themeToggle");
  function applyTheme(light){
    document.body.classList.toggle("light", light);
    themeBtn.innerHTML = light ? "&#9728; Light" : "&#9789; Dark";
    localStorage.setItem("sheetops_theme", light ? "light" : "dark");
  }
  themeBtn.addEventListener("click", () => { applyTheme(!document.body.classList.contains("light")); if(typeof renderAll==='function') renderAll(); });
  if(localStorage.getItem("sheetops_theme") === "light") applyTheme(true);

  /* Auto-load from Firebase (primary) or localStorage (fallback), then select today */
  (async function(){
    const firebaseLoaded = await loadFromFirebase();

    if(!firebaseLoaded){
      // Fallback to localStorage cache
      const cached = localStorage.getItem("sheetops_db");
      if(cached){
        try {
          const bin = atob(cached);
          const bytes = new Uint8Array(bin.length);
          for(let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
          const wb = XLSX.read(bytes, {type:"array"});
          parseDatabase(wb);
          console.log("SheetOps: auto-loaded database from cache (Firebase unavailable)");
        } catch(err){ console.warn("Cache load failed:", err); }
      }
    }

    // Now that DB is loaded, apply today's date selection and load edits
    await applyDaySelection();

    updatePanelViewOptions();
    const pv=document.getElementById('panelViewSel');
    if(pv){ pv.value=PANEL_VIEW; }
    renderAll();
  })();
});
</script>

<script>
/* v129: Auto-trim seat names to 6 chars (display only) */
function trimSeatText(){
  document.querySelectorAll("select.seatSel, select.seat, select.seatSelect").forEach(sel=>{
    if(!sel.value) return;
    let v = sel.value.toUpperCase().trim();
    if(v.length>6) v = v.substring(0,6);
    sel.setAttribute("data-short", v);
  });
}

window.addEventListener("load", trimSeatText);

document.addEventListener("change", e=>{
  if(e.target.matches("select.seatSel, select.seat, select.seatSelect")){
    trimSeatText();
  }
});
</script>

<script>
/* Keyboard shortcuts: Alt+1/2/3 to switch block panels, Alt+A for all */
document.addEventListener('keydown', (e)=>{
  if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  const pv = document.getElementById('panelViewSel');
  if(!pv) return;
  const opts = Array.from(pv.options).map(o=>o.value);

  if(e.altKey && e.key === '1' && opts.length > 1){ e.preventDefault(); pv.value=opts[1]; pv.dispatchEvent(new Event('change',{bubbles:true})); }
  else if(e.altKey && e.key === '2' && opts.length > 2){ e.preventDefault(); pv.value=opts[2]; pv.dispatchEvent(new Event('change',{bubbles:true})); }
  else if(e.altKey && e.key === '3' && opts.length > 3){ e.preventDefault(); pv.value=opts[3]; pv.dispatchEvent(new Event('change',{bubbles:true})); }
  else if(e.altKey && (e.key === 'a' || e.key === 'A')){ e.preventDefault(); pv.value='all'; pv.dispatchEvent(new Event('change',{bubbles:true})); }
});

/* Highlight unselected custom selects with a ring */
function markUnselected(){
  document.querySelectorAll(".customSel").forEach(wrap=>{
    const sel = wrap.querySelector("select");
    if(!sel) return;
    const v = sel.value;
    const btn = wrap.querySelector(".customSelBtn");
    if(!btn) return;
    if(!v || v === "" || v === "\u2014"){
      btn.classList.add("unselected-ring");
    } else {
      btn.classList.remove("unselected-ring");
    }
  });
  /* Also check any native selects that weren't enhanced */
  document.querySelectorAll("select.seatSel, select.roleSel, select.presentSel, select.absReasonSel, select.othTypeSel").forEach(sel=>{
    if(sel.dataset.customized === "1") return;
    const v = sel.value;
    if(!v || v === "" || v === "\u2014"){
      sel.classList.add("unselected-ring");
    } else {
      sel.classList.remove("unselected-ring");
    }
  });
}

/* Run on any select change */
document.addEventListener("change", e=>{
  if(e.target.tagName === "SELECT") setTimeout(markUnselected, 20);
});

/* MutationObserver: catches dynamically rendered selects after renderAll/innerHTML */
new MutationObserver(()=>{
  setTimeout(()=>{
    markUnselected();
    /* Auto-focus next row after re-render */
    if(window.__pendingFocus){
      const pf = window.__pendingFocus;
      window.__pendingFocus = null;
      const allOfType = Array.from(document.querySelectorAll(pf.selType + ' .customSelBtn'));
      if(allOfType[pf.idx]){
        allOfType[pf.idx].focus();
        allOfType[pf.idx].click();
      }
    }
  }, 80);
}).observe(document.body, { childList: true, subtree: true });
</script>

<script>
/* ===== Timesheet Generator ===== */
document.getElementById("btnTimesheet").addEventListener("click", generateTimesheets);

async function generateTimesheets(){
  if(!BASE_EMP.length){ setErr("Load a database first."); return; }
  const ppVal = document.getElementById("ppSel").value;
  if(!ppVal){ setErr("Select a pay period."); return; }

  const ppStart = new Date(ppVal + "T00:00:00");
  const DAYNAMES = ["SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"];
  const DAYABBR = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];

  // Build 14-day date list
  const dates = [];
  for(let i=0;i<14;i++){
    const d = new Date(ppStart.getTime() + i * 86400000);
    dates.push(toISODate(d));
  }

  // Load edits from Firebase for all 14 days, both shifts (parallel)
  const loadPromises = [];
  for(const iso of dates){
    for(const shiftVal of ["DAY","NIGHT"]){
      loadPromises.push(loadEditsFromFirebase(iso, shiftVal));
    }
  }
  await Promise.all(loadPromises);

  // For each employee, collect hours across all 14 days, both shifts, all blocks
  const empMap = new Map(); // empName -> { info, days: [{date, rows:[{in,out,total,status,elements}], dayTotal}] }

  for(const emp of BASE_EMP){
    const data = { info: emp, days: [] };
    let grandTotal = 0;
    let grandReg = 0;
    let grandOT = 0;

    for(const iso of dates){
      const dayRows = [];
      let dayTotal = 0;
      let dayReg = 0;
      let dayOT = 0;

      for(const shiftVal of ["DAY","NIGHT"]){
        const blocks = shiftVal==="NIGHT" ? [{id:"1800-2200",start:"18:00",end:"22:00"},{id:"2200-0200",start:"22:00",end:"02:00"},{id:"0200-0600",start:"02:00",end:"06:00"}]
          : [{id:"0600-1000",start:"06:00",end:"10:00"},{id:"1000-1400",start:"10:00",end:"14:00"},{id:"1400-1800",start:"14:00",end:"18:00"}];

        for(const b of blocks){
          const rbr = computeRowsForBlock(iso, shiftVal, b);
          // Check if this employee has an OT entry in this block (to avoid double counting)
          let hasOTInBlock = false;
          for(const role of ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR","OTH"]){
            for(const r of (rbr[role]||[])){ if(r.emp === emp.Employee && r.isOT) hasOTInBlock = true; }
          }
          for(const role of ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR","ABSENT","OTH"]){
            const rows = rbr[role]||[];
            for(const r of rows){
              if(r.emp !== emp.Employee) continue;
              // Skip ghost absent rows (tardy/partial missed-time phantoms)
              if(r.isPartial) continue;
              // Skip regular entry if OT exists for same block (avoid double counting)
              if(!r.isOT && hasOTInBlock) continue;
              const key = ctxKey(iso, shiftVal, b.id);
              const ed = ensureEdit(key, r.emp);
              let hrs = (ed.Hours!=="" ? Number(ed.Hours) : r.hours);
              const present = ed.Present || r.present || "YES";
              const isAbsent = present==="NO";
              const ws = ed.WorkedStart || r.workedStart || "";
              const we = ed.WorkedEnd || r.workedEnd || "";
              // If hours is 0 but employee is present with valid worked times, compute from range
              if(hrs <= 0 && !isAbsent && ws && we){
                const sMin = minutesOf(ws), eMin = minutesOf(we);
                let diff = eMin - sMin;
                if(diff <= 0) diff += 1440;
                hrs = diff / 60;
              }
              // Skip zero-hour rows unless absent (absent still needs to show on timesheet)
              if(hrs <= 0 && !isAbsent) continue;
              const isOT = r.isOT;
              const isTardy = present==="TARDY";
              const isPartialStatus = present==="PARTIAL";
              const isTrainer = present==="TRAINER";

              // For absent, compute scheduled hours from shift-block overlap times
              let absentHrs = 0;
              if(isAbsent && ws && we){
                const sMin = minutesOf(ws), eMin = minutesOf(we);
                let diff = eMin - sMin;
                if(diff <= 0) diff += 1440;
                absentHrs = diff / 60;
              }

              dayRows.push({
                inTime: isAbsent ? "" : (ws ? formatTime12(ws) : ""),
                outTime: isAbsent ? "" : (we ? formatTime12(we) : ""),
                rawIn: ws || "",
                rawOut: we || "",
                total: isAbsent ? absentHrs : hrs,
                isOT: isOT,
                isTardy: isTardy,
                isAbsent: isAbsent,
                isPartial: isPartialStatus,
                isTrainer: isTrainer
              });
              if(!isAbsent){
                dayTotal += hrs;
                if(isOT) dayOT += hrs; else dayReg += hrs;
              }
            }
          }
        }
      }
      // If employee was tardy/partial in any block, suppress cascade-absent entries for that day
      const hasTardyOrPartial = dayRows.some(r => r.isTardy || r.isPartial);
      const afterCascade = hasTardyOrPartial ? dayRows.filter(r => !r.isAbsent) : dayRows;

      // Separate into regular, OT, and absent
      const absentRows = afterCascade.filter(r => r.isAbsent);
      const otRows = afterCascade.filter(r => !r.isAbsent && r.isOT);
      const regRows = afterCascade.filter(r => !r.isAbsent && !r.isOT);

      const finalRows = [];

      // Consolidate regular rows: detect contiguous stretches, split on gaps
      if(regRows.length > 0){
        const totalReg = regRows.reduce((s, r) => s + r.total, 0);
        const anyTardy = regRows.some(r => r.isTardy);
        const anyPartial = regRows.some(r => r.isPartial);
        const anyTrainer = regRows.some(r => r.isTrainer);
        // Sort by rawIn (HH:MM 24h), then merge contiguous blocks
        const sorted = regRows.filter(r => r.rawIn && r.rawOut).slice().sort((a,b) => a.rawIn < b.rawIn ? -1 : a.rawIn > b.rawIn ? 1 : 0);
        const pairs = [];
        for(const r of sorted){
          if(pairs.length > 0 && pairs[pairs.length-1].rawOut === r.rawIn){
            pairs[pairs.length-1].rawOut = r.rawOut;
          } else {
            pairs.push({ rawIn: r.rawIn, rawOut: r.rawOut });
          }
        }
        const fmtPairs = pairs.map(p => ({ inTime: formatTime12(p.rawIn), outTime: formatTime12(p.rawOut) }));
        finalRows.push({ pairs: fmtPairs, total: totalReg, isOT:false, isTardy: anyTardy, isAbsent:false, isPartial: anyPartial, isTrainer: anyTrainer });
      }

      // Consolidate OT rows: detect contiguous stretches, split on gaps
      if(otRows.length > 0){
        const totalOT = otRows.reduce((s, r) => s + r.total, 0);
        const sortedOT = otRows.filter(r => r.rawIn && r.rawOut).slice().sort((a,b) => a.rawIn < b.rawIn ? -1 : a.rawIn > b.rawIn ? 1 : 0);
        const otPairs = [];
        for(const r of sortedOT){
          if(otPairs.length > 0 && otPairs[otPairs.length-1].rawOut === r.rawIn){
            otPairs[otPairs.length-1].rawOut = r.rawOut;
          } else {
            otPairs.push({ rawIn: r.rawIn, rawOut: r.rawOut });
          }
        }
        const fmtOTPairs = otPairs.map(p => ({ inTime: formatTime12(p.rawIn), outTime: formatTime12(p.rawOut) }));
        finalRows.push({ pairs: fmtOTPairs, total: totalOT, isOT:true, isTardy:false, isAbsent:false, isPartial:false });
      }

      // Consolidate absent rows into a single entry with missed time range
      if(absentRows.length > 0){
        const totalAbsentHrs = absentRows.reduce((sum, r) => sum + r.total, 0);
        // Find earliest scheduled start and latest scheduled end for the missed range
        let absEarliest = "", absLatest = "";
        for(const r of absentRows){
          if(r.rawIn && (!absEarliest || r.rawIn < absEarliest)) absEarliest = r.rawIn;
          if(r.rawOut && (!absLatest || r.rawOut > absLatest)) absLatest = r.rawOut;
        }
        const absPairs = (absEarliest && absLatest) ? [{ inTime: formatTime12(absEarliest), outTime: formatTime12(absLatest) }] : [];
        finalRows.push({ pairs: absPairs, total: totalAbsentHrs, isOT:false, isTardy:false, isAbsent:true, isPartial:false });
      }

      data.days.push({ date: iso, rows: finalRows, dayTotal: dayTotal, dayReg: dayReg, dayOT: dayOT });
      grandTotal += dayTotal;
      grandReg += dayReg;
      grandOT += dayOT;
    }
    data.grandTotal = grandTotal;
    data.grandReg = grandReg;
    data.grandOT = grandOT;
    const hasAnyRows = data.days.some(d => d.rows.length > 0);
    if(grandTotal > 0 || hasAnyRows) empMap.set(emp.Employee, data);
  }

  if(empMap.size === 0){ setErr("No timesheet data found for this pay period."); return; }

  // Open timesheet in new window
  const win = window.open("", "_blank");
  if(!win){ setErr("Popup blocked. Allow popups for this page."); return; }

  let html = `<!doctype html><html><head><meta charset="utf-8"><title>Timesheets - PP</title>
<style>
@media print { .no-print{display:none!important} .page-break{page-break-before:always} .emp-sheet{display:none!important} .emp-sheet.active{display:block!important} }
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:Arial,sans-serif;font-size:11px;color:#000;padding:20px;text-transform:uppercase;display:flex;flex-direction:column;align-items:center}
.disclaimer{border:3px solid red;padding:10px 28px;text-align:center;font-size:18px;font-weight:900;color:red;margin-bottom:18px;letter-spacing:1px}
.emp-sheet{width:100%;max-width:800px}
.info-grid{display:grid;grid-template-columns:1fr 1fr;gap:2px 20px;margin-bottom:10px;font-size:11px}
.info-grid b{font-weight:700}
table{width:100%;border-collapse:collapse;margin-bottom:12px;font-size:10px}
th,td{border:1px solid #000;padding:3px 5px;text-align:left}
th{background:#f0f0f0;font-weight:700}
.totals-tbl td{text-align:center;font-size:10px}
.totals-tbl th{text-align:center;font-size:10px}
.hrs-breakdown{margin:12px 0;font-size:12px}
.hrs-breakdown td{border:1px solid #000;padding:4px 8px}
.nav-bar{position:sticky;top:0;background:#fff;padding:10px 0;border-bottom:2px solid #000;margin-bottom:20px;display:flex;gap:10px;align-items:center;z-index:10;width:100%;max-width:800px}
</style></head><body>
<div class="nav-bar no-print">
  <label><b>Employee:</b></label>
  <select id="empPicker" onchange="showEmployee(this.value)" style="padding:6px;font-size:13px">`;

  // Build supervisor groups from SUP_ASSIGNMENTS matched to empMap
  const supGroups = {};
  const unmatchedNames = [];
  for(const [sup, emps] of Object.entries(SUP_ASSIGNMENTS)){
    const matched = [];
    for(const e of emps){
      const resolved = matchSupEmp(e.last, e.first);
      if(empMap.has(resolved)){
        matched.push(resolved);
      } else {
        unmatchedNames.push(sup + ": " + e.last + ", " + e.first + " → resolved as '" + resolved + "'" + (BASE_EMP.find(b=>b.Employee===resolved) ? " (in DB but not working today)" : " (NOT FOUND in DB)"));
      }
    }
    if(matched.length > 0) supGroups[sup] = matched;
  }
  if(unmatchedNames.length){
    console.warn("⚠ SUPERVISOR LIST — Unmatched employees (" + unmatchedNames.length + "):");
    unmatchedNames.forEach(u => console.warn("  " + u));
  } else {
    console.log("✓ All supervisor list employees matched.");
  }

  // Add supervisor group options
  html += `<optgroup label="── SUPERVISOR LISTS ──">`;
  for(const sup of Object.keys(supGroups)){
    html += `<option value="SUP:${esc(sup)}">${esc(sup)} EMPLOYEES (${supGroups[sup].length})</option>`;
  }
  html += `</optgroup>`;

  // Add individual employee options
  html += `<optgroup label="── INDIVIDUAL ──">`;
  for(const [name] of empMap){
    html += `<option value="${esc(name)}">${esc(name.toUpperCase())}</option>`;
  }
  html += `</optgroup>`;
  html += `</select>
  <button onclick="printCurrent()" style="padding:6px 16px;font-size:12px;cursor:pointer">Print</button>
</div>`;

  // Generate each employee's timesheet
  for(const [name, data] of empMap){
    const emp = data.info;
    const ppEndDate = new Date(ppStart.getTime() + 13 * 86400000);
    const todayISO = toISODate(new Date());

    html += `<div class="emp-sheet" data-emp="${esc(name)}">`;
    html += `<div class="disclaimer">UNOFFICIAL TIMESHEET</div>`;
    html += `<div class="info-grid">
      <div><b>Name:</b> ${esc(name.toUpperCase())}</div>
    </div>`;

    html += `<div><b>Timesheet Data:</b></div>`;
    html += `<table><thead><tr><th>Day</th><th>Date</th><th>In</th><th>Out</th><th>In</th><th>Out</th><th>Total</th></tr></thead><tbody>`;

    for(const day of data.days){
      const d = new Date(day.date + "T00:00:00");
      const dayAbbr = DAYABBR[d.getDay()];
      if(day.rows.length === 0){
        html += `<tr><td>${dayAbbr}</td><td>${day.date}</td><td></td><td></td><td></td><td></td><td>0.000</td></tr>`;
      } else {
        let firstRow = true;
        for(let ri=0; ri<day.rows.length; ri++){
          const r = day.rows[ri];
          const pairs = r.pairs || [];
          const badge = r.isAbsent ? ` <span style="color:#b91c1c;font-weight:bold;background:#fee2e2;padding:1px 5px;border-radius:3px">ABSENT ${r.total}HRS</span>` : r.isOT ? ' <span style="color:#1d4ed8;font-weight:bold;background:#dbeafe;padding:1px 5px;border-radius:3px">OT</span>' : r.isTardy ? ' <span style="color:#c2410c;font-weight:bold;background:#fff7ed;padding:1px 5px;border-radius:3px">TARDY</span>' : r.isPartial ? ' <span style="color:#a16207;font-weight:bold;background:#fefce8;padding:1px 5px;border-radius:3px">PARTIAL</span>' : '';
          const trainerBadge = r.isTrainer ? ' <span style="color:#065f46;font-weight:bold;background:#d1fae5;padding:1px 5px;border-radius:3px">TRAINER</span>' : '';
          if(pairs.length <= 1){
            // Single pair or no pairs: In1 = in, Out1 empty, In2 empty, Out2 = out (original style)
            const p = pairs[0] || {};
            html += `<tr>`;
            html += `<td>${firstRow ? dayAbbr : ""}</td>`;
            html += `<td>${day.date}${badge}${trainerBadge}</td>`;
            html += `<td>${p.inTime||""}</td><td></td>`;
            html += `<td></td><td>${p.outTime||""}</td>`;
            html += `<td>${r.isAbsent ? "0.000" : r.total.toFixed(3)}</td>`;
            html += `</tr>`;
            firstRow = false;
          } else {
            // Multiple pairs: render 2 per table row, overflow into extra rows
            for(let pi=0; pi<pairs.length; pi+=2){
              const p1 = pairs[pi];
              const p2 = pairs[pi+1] || null;
              html += `<tr>`;
              html += `<td>${firstRow ? dayAbbr : ""}</td>`;
              html += `<td>${firstRow ? day.date + badge + trainerBadge : ""}</td>`;
              html += `<td>${p1.inTime||""}</td><td>${p1.outTime||""}</td>`;
              html += `<td>${p2 ? p2.inTime : ""}</td><td>${p2 ? p2.outTime : ""}</td>`;
              // Show total only on the first row for this entry
              html += `<td>${pi===0 ? (r.isAbsent ? "0.000" : r.total.toFixed(3)) : ""}</td>`;
              html += `</tr>`;
              firstRow = false;
            }
          }
        }
      }
    }
    html += `</tbody></table>`;

    // Total Reported Hours summary row
    html += `<div><b>Total Reported Hours:</b></div>`;
    html += `<table class="totals-tbl"><thead><tr><th>Day</th>`;
    for(const day of data.days){
      const d = new Date(day.date + "T00:00:00");
      const mm = String(d.getMonth()+1);
      const dd = String(d.getDate()).padStart(2,"0");
      const dayAbbr = DAYABBR[d.getDay()];
      html += `<th>${mm}/${dd}<br>${dayAbbr}</th>`;
    }
    html += `<th>Total</th></tr></thead><tbody>`;
    html += `<tr><td>Hours Worked</td>`;
    for(const day of data.days){
      html += `<td>${day.dayReg.toFixed(2)}</td>`;
    }
    html += `<td><b>${data.grandReg.toFixed(2)}</b></td></tr>`;
    html += `<tr><td>OT Hours</td>`;
    for(const day of data.days){
      html += `<td>${day.dayOT > 0 ? day.dayOT.toFixed(2) : ""}</td>`;
    }
    html += `<td><b>${data.grandOT.toFixed(2)}</b></td></tr>`;
    html += `</tbody></table>`;

    // Total breakdown
    html += `<table class="hrs-breakdown"><tr><td><b>Regular Hours:</b></td><td>${data.grandReg.toFixed(2)}</td></tr>`;
    html += `<tr><td><b>Overtime Hours:</b></td><td>${data.grandOT.toFixed(2)}</td></tr>`;
    html += `<tr><td><b>Total Hours:</b></td><td>${data.grandTotal.toFixed(2)}</td></tr></table>`;

    html += `<div style="margin-top:24px;padding:10px 14px;border:1px solid #999;background:#f9f9f9;font-size:9px;color:#555;line-height:1.5;text-align:justify">
      <b>DISCLAIMER:</b> This document is an unofficial estimate generated for reference purposes only. Miscalculations may occur due to manual data entry errors, system limitations, or incomplete records. The viewer is responsible for independently verifying all hours, dates, and pay-related information before relying on this data. This document is not guaranteed to be 100% accurate and should not be used as an official record of hours worked. Always cross-reference with official timekeeping systems and payroll records.
    </div>`;

    html += `</div><div class="page-break"></div>`;
  }

  // Serialize empMap data for PDF generation
  const empDataJSON = JSON.stringify(Array.from(empMap.entries()).map(([name, data]) => {
    return [name, {days: data.days, grandTotal: data.grandTotal, grandReg: data.grandReg, grandOT: data.grandOT}];
  }));

  html += `<scr`+`ipt>
// Load jsPDF dynamically (avoids parser-blocking warning)
(function(){
  var cdns=[
    "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.2/jspdf.umd.min.js",
    "https://cdn.jsdelivr.net/npm/jspdf@2.5.2/dist/jspdf.umd.min.js",
    "https://unpkg.com/jspdf@2.5.2/dist/jspdf.umd.min.js"
  ];
  var i=0;
  function tryNext(){
    if(window.jspdf||i>=cdns.length) return;
    var s=document.createElement("script");
    s.src=cdns[i++];
    s.onload=function(){};
    s.onerror=function(){ tryNext(); };
    document.head.appendChild(s);
  }
  tryNext();
})();

var EMP_DATA = new Map(${empDataJSON});
var DAYABBR = ${JSON.stringify(DAYABBR)};
var SUP_GROUPS = ${JSON.stringify(supGroups)};

function getSelectedEmps(val){
  if(val.startsWith('SUP:')){
    var sup = val.slice(4);
    return SUP_GROUPS[sup] || [];
  }
  return [val];
}

function showEmployee(val){
  var emps = getSelectedEmps(val);
  document.querySelectorAll('.emp-sheet').forEach(function(el){
    el.style.display = emps.indexOf(el.dataset.emp) >= 0 ? 'block' : 'none';
  });
}

function printCurrent(){
  if(!window.jspdf){
    var s=document.createElement("script");
    s.src="https://cdn.jsdelivr.net/npm/jspdf@2.5.2/dist/jspdf.umd.min.js";
    s.onload=function(){ printCurrent(); };
    s.onerror=function(){
      var s2=document.createElement("script");
      s2.src="https://unpkg.com/jspdf@2.5.2/dist/jspdf.umd.min.js";
      s2.onload=function(){ printCurrent(); };
      s2.onerror=function(){ alert("Could not load PDF library. Check internet connection."); };
      document.head.appendChild(s2);
    };
    document.head.appendChild(s);
    return;
  }
  var val = document.getElementById('empPicker').value;
  var empList = getSelectedEmps(val);
  var validList = empList.filter(function(n){ return EMP_DATA.has(n); });
  if(validList.length === 0){ alert("No timesheet data found."); return; }

  var jsPDF = window.jspdf.jsPDF;
  var doc = new jsPDF({orientation:"portrait", unit:"pt", format:"letter"});
  var pw=612, ph=792, mx=30, my=30;
  var usableW = pw - mx*2;
  var cols = ["DAY","DATE","IN","OUT","IN","OUT","TOTAL"];
  var cw = [usableW*0.07, usableW*0.14, usableW*0.14, usableW*0.14, usableW*0.14, usableW*0.14, usableW*0.12];
  cw[6] = usableW - cw[0]-cw[1]-cw[2]-cw[3]-cw[4]-cw[5];
  var rh = 14;
  var y;

  function drawTableRow(vals, opts){
    opts = opts || {};
    var bold = opts.bold || false;
    var bg = opts.bg || null;
    var tc = opts.color || [0,0,0];
    var cx = mx;
    for(var ci=0;ci<cols.length;ci++){
      if(bg){ doc.setFillColor(bg[0],bg[1],bg[2]); doc.rect(cx, y, cw[ci], rh, "F"); }
      doc.setDrawColor(0,0,0); doc.rect(cx, y, cw[ci], rh, "S");
      doc.setFontSize(8); doc.setFont("helvetica", bold?"bold":"normal");
      doc.setTextColor(tc[0],tc[1],tc[2]);
      doc.text(String(vals[ci]||""), cx+2, y+10);
      cx += cw[ci];
    }
    y += rh;
  }

  var sCols = 16;
  var sw = usableW / sCols;
  var sRh = 13;
  function drawSummaryRow(vals, opts){
    opts = opts || {};
    var cx = mx;
    for(var ci=0; ci<vals.length; ci++){
      if(opts.bg){ doc.setFillColor(opts.bg[0],opts.bg[1],opts.bg[2]); doc.rect(cx, y, sw, sRh, "F"); }
      doc.setDrawColor(0,0,0); doc.rect(cx, y, sw, sRh, "S");
      doc.setFontSize(5.5); doc.setFont("helvetica", opts.bold?"bold":"normal");
      doc.setTextColor(0,0,0);
      doc.text(String(vals[ci]||""), cx+1, y+9);
      cx += sw;
    }
    y += sRh;
  }

  for(var ei=0; ei<validList.length; ei++){
    var name = validList[ei];
    var data = EMP_DATA.get(name);
    if(ei > 0) doc.addPage("letter","portrait");
    y = my;

    /* Disclaimer box */
    doc.setDrawColor(255,0,0);
    doc.setLineWidth(2);
    doc.rect(mx, y, usableW, 28);
    doc.setFontSize(14);
    doc.setFont("helvetica","bold");
    doc.setTextColor(255,0,0);
    doc.text("UNOFFICIAL TIMESHEET", pw/2, y+18, {align:"center"});
    y += 38;

    /* Employee name */
    doc.setFontSize(11);
    doc.setFont("helvetica","bold");
    doc.setTextColor(0,0,0);
    doc.text("NAME: " + name.toUpperCase(), mx, y+11);
    y += 22;

    drawTableRow(cols, {bold:true, bg:[240,240,240]});

    /* Data rows */
    for(var di=0; di<data.days.length; di++){
      var day = data.days[di];
      var d = new Date(day.date + "T00:00:00");
      var dayAbbr = DAYABBR[d.getDay()];
      if(day.rows.length === 0){
        drawTableRow([dayAbbr, day.date, "", "", "", "", "0.000"]);
      } else {
        var firstRow = true;
        for(var ri=0; ri<day.rows.length; ri++){
          var r = day.rows[ri];
          var pairs = r.pairs || [];
          var badge = r.isAbsent ? " [ABS]" : r.isOT ? " [OT]" : r.isTardy ? " [T]" : r.isPartial ? " [P]" : "";
          var trBadge = r.isTrainer ? " [TNR]" : "";
          if(pairs.length <= 1){
            var p = pairs[0] || {};
            var totalStr = r.isAbsent ? "0.000" : r.total.toFixed(3);
            var rowColor = r.isAbsent ? [185,28,28] : r.isOT ? [29,78,216] : [0,0,0];
            drawTableRow([
              firstRow ? dayAbbr : "",
              (firstRow ? day.date : "") + badge + trBadge,
              p.inTime || "", "",
              "", p.outTime || "",
              totalStr
            ], {color: rowColor});
            firstRow = false;
          } else {
            for(var pi=0; pi<pairs.length; pi+=2){
              var p1 = pairs[pi];
              var p2 = pairs[pi+1] || null;
              drawTableRow([
                firstRow ? dayAbbr : "",
                firstRow ? day.date + badge + trBadge : "",
                p1.inTime||"", p1.outTime||"",
                p2 ? p2.inTime : "", p2 ? p2.outTime : "",
                pi===0 ? (r.isAbsent ? "0.000" : r.total.toFixed(3)) : ""
              ]);
              firstRow = false;
            }
          }
        }
      }
    }

    y += 10;

    /* Total Reported Hours summary */
    doc.setFontSize(9);
    doc.setFont("helvetica","bold");
    doc.text("TOTAL REPORTED HOURS:", mx, y+10);
    y += 16;

    var sHdr = ["Day"];
    for(var di2=0; di2<data.days.length; di2++){
      var d2 = new Date(data.days[di2].date + "T00:00:00");
      var mm = String(d2.getMonth()+1);
      var dd = String(d2.getDate()).padStart(2,"0");
      sHdr.push(mm+"/"+dd+" "+DAYABBR[d2.getDay()]);
    }
    sHdr.push("Total");
    drawSummaryRow(sHdr, {bold:true, bg:[240,240,240]});

    var hwRow = ["Worked"];
    for(var di3=0; di3<data.days.length; di3++) hwRow.push(data.days[di3].dayReg.toFixed(2));
    hwRow.push(data.grandReg.toFixed(2));
    drawSummaryRow(hwRow);

    var otRow = ["OT"];
    for(var di4=0; di4<data.days.length; di4++) otRow.push(data.days[di4].dayOT > 0 ? data.days[di4].dayOT.toFixed(2) : "");
    otRow.push(data.grandOT.toFixed(2));
    drawSummaryRow(otRow);

    y += 10;

    /* Hours breakdown */
    var bw = usableW * 0.35;
    var bRh = 16;
    var labels = ["REGULAR HOURS:","OVERTIME HOURS:","TOTAL HOURS:"];
    var vals2 = [data.grandReg.toFixed(2), data.grandOT.toFixed(2), data.grandTotal.toFixed(2)];
    for(var bi=0; bi<3; bi++){
      doc.setDrawColor(0,0,0);
      doc.rect(mx, y, bw*0.6, bRh, "S");
      doc.rect(mx+bw*0.6, y, bw*0.4, bRh, "S");
      doc.setFontSize(9); doc.setFont("helvetica","bold"); doc.setTextColor(0,0,0);
      doc.text(labels[bi], mx+4, y+11);
      doc.setFont("helvetica","normal");
      doc.text(vals2[bi], mx+bw*0.6+4, y+11);
      y += bRh;
    }

    y += 14;

    /* Disclaimer */
    doc.setFontSize(7); doc.setFont("helvetica","normal"); doc.setTextColor(100,100,100);
    var discTxt = "DISCLAIMER: This document is an unofficial estimate generated for reference purposes only. Miscalculations may occur due to manual data entry errors, system limitations, or incomplete records. The viewer is responsible for independently verifying all hours, dates, and pay-related information before relying on this data. This document is not guaranteed to be 100% accurate and should not be used as an official record of hours worked. Always cross-reference with official timekeeping systems and payroll records.";
    var wrapped = doc.splitTextToSize(discTxt, usableW);
    doc.text(wrapped, mx, y);
  }

  /* Open PDF for printing */
  var blob = doc.output("blob");
  var url = URL.createObjectURL(blob);
  var pwin = window.open(url, "_blank");
  if(pwin){ pwin.onload = function(){ pwin.focus(); pwin.print(); }; }
  else { doc.save("Timesheet_" + val.replace("SUP:","") + ".pdf"); }
}

showEmployee(document.getElementById('empPicker').value);
<\/scr`+`ipt></body></html>`;

  win.document.write(html);
  win.document.close();
}

function formatTime12(hhmm){
  if(!hhmm) return "";
  const [h,m] = hhmm.split(":").map(Number);
  const ampm = h >= 12 ? "PM" : "AM";
  const h12 = h === 0 ? 12 : h > 12 ? h - 12 : h;
  return h12 + ":" + String(m).padStart(2,"0") + " " + ampm;
}
</script>

<script>
/* ===== BreakOPS Integration ===== */
document.getElementById("btnBreakOPS").addEventListener("click", pushToBreakOPS);

async function pushToBreakOPS(){
  const iso = document.getElementById("workDate").value;
  const shift = document.getElementById("shiftSel").value;
  if(!iso){ setErr("Select a date first."); return; }
  if(!BASE_EMP.length){ setErr("Load database first."); return; }

  if(!confirm("Push current " + shift + " shift staff (" + iso + ") to BreakOPS?\n\nThis will update positions and add OT extras in BreakOPS.")) return;

  const blocks = shift === "NIGHT" ? BLOCKS_NIGHT : BLOCKS_DAY;
  const mode = shift === "NIGHT" ? "nights" : "days";

  // Collect all people across all blocks
  const presentPeople = new Map(); // emp -> {sen, role, isOT, blocks:[]}
  const absentPeople = new Map();  // emp -> {sen}

  for(const block of blocks){
    const rows = computeRowsForBlock(iso, shift, block);
    for(const role of ["CALLTAKER","DISPATCHER","PIC","SUPERVISOR"]){
      for(const r of (rows[role]||[])){
        if(!presentPeople.has(r.emp)){
          presentPeople.set(r.emp, {sen: r.sen, role: r.role, isOT: r.isOT, blocks: [block.id]});
        } else {
          const p = presentPeople.get(r.emp);
          if(!p.blocks.includes(block.id)) p.blocks.push(block.id);
        }
      }
    }
    for(const r of (rows.ABSENT||[])){
      if(r.present === "NO" && !r.isPartial && !presentPeople.has(r.emp)){
        absentPeople.set(r.emp, {sen: r.sen});
      }
    }
  }

  // Build posOverrides map
  // Map ShiftOps roles to BreakOPS positions
  const roleMap = {CALLTAKER:"CALLTAKER", DISPATCHER:"DISPATCHER", PIC:"PIC", SUPERVISOR:"PIC"};

  // Lookup for employee data from ShiftOps
  const empLookup = new Map();
  for(const e of BASE_EMP) empLookup.set(e.Employee, e);

  try {
    // Read existing posOverrides to merge (preserve overrides for other shifts)
    // Uses breakDb (legitimous-2f2d2) — BreakOPS's Firestore, NOT shiftops
    const rosterRef = breakDb.collection("rosterConfig").doc("global");
    const rosterSnap = await rosterRef.get();
    const existing = rosterSnap.exists ? ((rosterSnap.data()||{}).posOverrides || {}) : {};

    // Update present people's positions
    for(const [emp, info] of presentPeople){
      if(info.isOT) continue; // OT people go as extras, not posOverrides
      const empData = empLookup.get(emp);
      if(!empData) continue;
      const key = emp + "||" + empData.SENIORITY;
      existing[key] = roleMap[info.role] || info.role || empData.POSITION;
    }

    // Mark absent people
    for(const [emp, info] of absentPeople){
      const empData = empLookup.get(emp);
      if(!empData) continue;
      const key = emp + "||" + empData.SENIORITY;
      existing[key] = "ABSENT";
    }

    // Write merged posOverrides to Firestore
    await rosterRef.set({ posOverrides: existing }, { merge: true });

    // Write OT people as extras to each breakScope
    const otPeople = [...presentPeople.entries()].filter(([,info]) => info.isOT);

    for(const block of blocks){
      const scopeKey = mode + "|" + iso + "|" + block.id;
      const extras = [];

      for(const [emp, info] of otPeople){
        if(!info.blocks.includes(block.id)) continue;
        const empData = empLookup.get(emp);
        extras.push({
          Employee: emp,
          Seniority: empData ? empData.SENIORITY : 0,
          DaysOff: "OT",
          Position: roleMap[info.role] || info.role || "CALLTAKER"
        });
      }

      // Write extras to breakScope (merge to preserve break selections)
      // Uses breakDb (legitimous-2f2d2) — BreakOPS's Firestore
      const scopeRef = breakDb.collection("breakScopes").doc(scopeKey);
      await scopeRef.set({ extras: extras }, { merge: true });
    }

    const totalPresent = [...presentPeople.values()].filter(p => !p.isOT).length;
    const totalOT = otPeople.length;
    const totalAbsent = absentPeople.size;
    alert("BreakOPS updated!\n\n" + totalPresent + " present, " + totalOT + " OT, " + totalAbsent + " absent.\n\nOpening BreakOPS...");

    // Open admin.html in new tab
    window.open("admin.html", "_blank");

  } catch(e){
    console.error("BreakOPS push failed:", e);
    setErr("Failed to push to BreakOPS: " + e.message);
  }
}
</script>

<!-- Bug Report Modal -->
<div id="bugReportModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:99999;">
  <div style="background:var(--bg); border:1px solid var(--border); border-radius:8px; padding:20px; min-width:360px; max-width:440px; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);">
    <h3 style="margin:0 0 15px; color:#ef4444;">&#x1fab2; REPORT A BUG</h3>
    <div style="margin-bottom:12px;">
      <label style="font-size:12px; font-weight:700; display:block; margin-bottom:6px;">YOUR NAME:</label>
      <input type="text" id="bugReportName" placeholder="Enter your name" style="width:100%; padding:8px; font-size:13px; border-radius:6px; border:1px solid var(--line); background:var(--panel); color:var(--text);" />
    </div>
    <div style="margin-bottom:15px;">
      <label style="font-size:12px; font-weight:700; display:block; margin-bottom:6px;">DETAILS:</label>
      <textarea id="bugReportDetails" placeholder="Describe the bug — what happened, what you expected, and what you were doing when it happened." style="width:100%; padding:8px; font-size:13px; border-radius:6px; border:1px solid var(--line); background:var(--panel); color:var(--text); min-height:120px; resize:vertical; font-family:inherit;"></textarea>
    </div>
    <div style="display:flex; gap:10px;">
      <button id="btnBugSubmit" style="padding:8px 16px; font-size:12px; font-weight:700; border-radius:6px; border:none; background:#ef4444; color:#fff; cursor:pointer;">SUBMIT</button>
      <button id="btnBugCancel" style="padding:8px 16px; font-size:12px; font-weight:700; border-radius:6px; border:1px solid var(--line); background:transparent; color:var(--text); cursor:pointer;">CANCEL</button>
    </div>
  </div>
</div>

</body>
</html>
