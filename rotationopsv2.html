<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RotationOps</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ccircle cx='32' cy='32' r='30' fill='%23070c16'/%3E%3Ccircle cx='32' cy='32' r='30' fill='none' stroke='%23c0c8d4' stroke-width='2'/%3E%3Cpath d='M20 16 A18 18 0 0 1 48 26' fill='none' stroke='%23e8ecf0' stroke-width='4' stroke-linecap='round'/%3E%3Cpolygon points='48,20 54,28 44,27' fill='%23e8ecf0'/%3E%3Cpath d='M44 48 A18 18 0 0 1 16 38' fill='none' stroke='%23e8ecf0' stroke-width='4' stroke-linecap='round'/%3E%3Cpolygon points='16,44 10,36 20,37' fill='%23e8ecf0'/%3E%3C/svg%3E"/>
<style>
  :root {
    --bg:#0b0f16; --panel:#111826; --panel2:#0f1622; --line:#2a3446; --text:#e6edf7;
    --muted:#a8b3c7; --btn:#1f6feb; --btn2:#233047; --danger:#d94848;
    --chip:#1a2436;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: radial-gradient(1200px 800px at 30% 10%, #172234 0%, var(--bg) 55%);
    color:var(--text);
  }
  .wrap{max-width:1500px; margin:10px auto; padding:0 10px;}
  h1{margin:0; font-size:26px; letter-spacing:.2px; font-weight:800;}
  .topbar{display:flex; gap:8px; align-items:center; padding:8px 10px; border:1px solid var(--line);
    background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
    border-radius:8px;
  }
  select, input[type="text"], input[type="date"]{
    background:var(--panel2); border:1px solid var(--line); color:var(--text);
    border-radius:8px; padding:8px 10px; outline:none; min-width: 120px; font-size:13px;
  }
  label{color:var(--muted); font-size:12px; margin-right:6px}
  .btn{background:var(--btn); color:white; border:none; padding:8px 12px; border-radius:8px;
    cursor:pointer; font-weight:700; font-size:13px; box-shadow: 0 6px 18px rgba(31,111,235,.22);
  }
  .btn.secondary{background:var(--btn2); box-shadow:none; border:1px solid var(--line);}
  .btn.danger{background:transparent; color:#ffb4b4; border:1px solid rgba(217,72,72,.6);}
  .btn:active{transform:translateY(1px)}

  .btn-copy-block:hover{background:rgba(255,255,255,.06); border-color:rgba(255,255,255,.18);}
  .btn-copy-block:active{transform:translateY(1px);}

  .layout{display:flex; flex-direction:column; gap:8px; margin-top:8px}
  .subgrid{display:grid; grid-template-columns: 1fr 1fr; gap:8px}
  @media (max-width: 980px){
    .subgrid{grid-template-columns: 1fr}
  }
  .card{background:rgba(255,255,255,.03); border:1px solid var(--line); border-radius:8px; padding:8px;}
  .card h2{margin:0 0 8px; font-size:14px; color:var(--muted); font-weight:700; letter-spacing:.25px}
  .small{font-size:11px; color:var(--muted);}

  .vac-form{display:grid; grid-template-columns: 1fr; gap:8px}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .row .grow{flex:1}
  .list{margin-top:8px; border-top:1px solid var(--line); padding-top:8px; max-height:180px; overflow:auto}
  .pill{display:flex; justify-content:space-between; align-items:center; gap:8px;
    padding:6px 8px; border:1px solid var(--line); border-radius:8px; background:var(--chip);
    margin-bottom:6px; font-size:12px;
  }
  .pill .meta{color:var(--muted); font-size:11px}
  .pill button{background:transparent; border:1px solid var(--line); color:var(--text); border-radius:6px; padding:4px 7px; cursor:pointer; font-size:11px;}

  .tabs{display:flex; gap:6px; border-bottom:1px solid var(--line); padding-bottom:8px; margin-bottom:8px}
  .tab{padding:7px 10px; border:1px solid var(--line); border-radius:8px; cursor:pointer; background:var(--panel2); color:var(--muted); font-weight:650; font-size:12px;}
  .tab.active{background:rgba(31,111,235,.18); color:var(--text); border-color: rgba(31,111,235,.5);}

  table{width:auto; border-collapse:collapse; overflow:hidden;}
  th, td{padding:3px 4px; border:1px solid var(--line); text-align:center; font-size:11px}
  th{background:rgba(255,255,255,.04); color:var(--muted); font-weight:800}

  /* Day/night shift divider — 5th child = first night column (CHANNEL + 3 day blocks + 1) */
  #dayTableWrap td:nth-child(5),
  #dayTableWrap th:nth-child(5){border-left:4px solid rgba(255,255,255,.4);}
  body.light #dayTableWrap td:nth-child(5),
  body.light #dayTableWrap th:nth-child(5){border-left:4px solid rgba(0,0,0,.3);}

  .assign-cell{border-radius:8px; padding:6px 10px; display:inline-block; min-width:110px; font-size:11px; font-weight:700; border:1px solid rgba(255,255,255,.14); text-align:center; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  .assign-cell.violation{outline:2px solid #f59e0b; outline-offset:1px; box-shadow: 0 0 6px rgba(245,158,11,.5);}
  .needed-badge{background:#dc2626!important; border:2px solid #fca5a5!important; color:#fff!important; font-weight:900!important; font-size:12px!important; letter-spacing:1px; animation:needPulse 1.2s ease-in-out infinite; text-shadow:0 1px 4px rgba(0,0,0,.5);}
  @keyframes needPulse{0%,100%{box-shadow:0 0 4px rgba(220,38,38,.4);} 50%{box-shadow:0 0 14px rgba(220,38,38,.8), 0 0 24px rgba(220,38,38,.3);}}
  @keyframes tipSlideUp{from{opacity:0; transform:translateX(-50%) translateY(20px);} to{opacity:1; transform:translateX(-50%) translateY(0);}}
  .clickable-assign{cursor:pointer; transition: transform 0.1s, box-shadow 0.1s;}
  .clickable-assign:hover{transform:scale(1.03); box-shadow: 0 2px 6px rgba(0,0,0,0.3);}
  .clickable-needed{cursor:pointer; transition: transform 0.1s, box-shadow 0.1s;}
  .clickable-needed:hover{transform:scale(1.05); box-shadow: 0 2px 8px rgba(220,38,38,0.4);}
  .clickable-absent{cursor:pointer; transition: transform 0.1s, box-shadow 0.1s;}
  .clickable-absent:hover{transform:scale(1.05); box-shadow: 0 2px 8px rgba(248,113,113,0.4);}
  .clickable-vac{cursor:pointer; transition: transform 0.1s, box-shadow 0.1s;}
  .clickable-vac:hover{transform:scale(1.05); box-shadow: 0 2px 8px rgba(125,211,252,0.4); background:rgba(125,211,252,.25) !important;}

  .actions{display:flex; gap:8px; margin-top:10px; flex-wrap:wrap}

  .two-col{display:grid; grid-template-columns: 1fr; gap:12px;}
  .stats{display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-top:12px}
  .stats .card{padding:12px}

  .toast{position:fixed; left:18px; right:18px; bottom:18px; background:#101826; border:1px solid rgba(255,255,255,.15);
    border-radius:14px; padding:12px 14px; display:none; max-width:1220px; margin:0 auto; color:#ffd6d6;}
  .toast code{color:#ffe2a8}

  .week-grid{display:grid; grid-template-columns: 110px repeat(7, 1fr); gap:6px; align-items:stretch;}
  .week-head{font-size:12px; color:var(--muted); padding:6px 8px;}
  .week-channel{font-weight:800; color:var(--muted); padding:8px;}
  .wkcell{border:1px solid var(--line); border-radius:10px; padding:8px; background:rgba(255,255,255,.02);}
  .dots{display:flex; gap:6px; flex-wrap:wrap}
  .dot{width:10px; height:10px; border-radius:999px; border:1px solid rgba(255,255,255,.2);}
  .badge{display:inline-block; padding:2px 7px; border-radius:999px; border:1px solid rgba(217,72,72,.55); color:#ffb4b4; font-size:11px; margin-left:8px;}

  .month-grid{display:grid; grid-template-columns: repeat(7, 1fr); gap:8px;}
  .mcell{border:1px solid var(--line); border-radius:12px; background:rgba(255,255,255,.02); padding:8px; min-height:86px; cursor:pointer;}
  .mdate{display:flex; justify-content:space-between; align-items:center; color:var(--muted); font-size:12px; margin-bottom:6px}
  .mblocks{display:flex; flex-wrap:wrap; gap:6px}
  .mblock{font-size:10px; padding:3px 6px; border-radius:999px; border:1px solid rgba(255,255,255,.15); color:var(--muted);}
  .mblock.bad{border-color: rgba(217,72,72,.65); color:#ffb4b4;}

  .ctlist{display:flex; flex-direction:column; gap:4px; align-items:center;}
  .ctitem{padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,.14); background:rgba(220,220,230,.15); color:rgba(255,255,255,.7); font-size:11px; font-weight:700; line-height:1.2; min-width:110px; text-align:center; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
  .ctitem.repeat{border-color: rgba(217,72,72,.9); box-shadow: 0 0 0 2px rgba(217,72,72,.45), 0 10px 26px rgba(217,72,72,.18);}

  /* Sync pill styles */
  .sync-pill{display:inline-flex; align-items:center; gap:5px; padding:4px 10px; border-radius:999px; font-size:11px; font-weight:600; border:1px solid var(--line); background:var(--chip); margin-left:auto;}
  .sync-pill.synced{border-color:rgba(52,211,153,.40); background:rgba(52,211,153,.10); color:#d7ffe9;}
  .sync-pill.error{border-color:rgba(251,113,133,.45); background:rgba(251,113,133,.10); color:#ffd5dd;}
  .sync-pill.syncing{border-color:rgba(74,163,255,.45); background:rgba(74,163,255,.10); color:#a5d4ff; animation:syncPulse 1s ease-in-out infinite;}
  @keyframes syncPulse{0%,100%{opacity:1}50%{opacity:.5}}

  /* Theme toggle */
  #btnDayPrev:hover, #btnDayNext:hover{background:rgba(255,255,255,.08); border-color:var(--text);}
  #btnDayPrev:active, #btnDayNext:active{transform:translateY(1px);}
  body.light #btnDayPrev:hover, body.light #btnDayNext:hover{background:rgba(0,0,0,.06);}
  .theme-toggle{background:transparent; border:1px solid var(--line); border-radius:8px; padding:6px 10px; cursor:pointer; color:var(--muted); font-size:12px; display:flex; align-items:center; gap:5px;}
  .theme-toggle:hover{background:rgba(255,255,255,.05); color:var(--text);}
  body.light{--bg:#f5f7fa; --panel:#ffffff; --panel2:#f0f2f5; --line:#d1d5db; --text:#1f2937; --muted:#6b7280; --chip:#e5e7eb;}
  body.light .wrap{background:transparent;}
  body.light{background:linear-gradient(180deg, #e8ecf3 0%, #f5f7fa 100%);}
  body.light .card{background:rgba(0,0,0,.02); border-color:var(--line);}
  body.light .topbar{background:linear-gradient(180deg, rgba(0,0,0,.02), rgba(0,0,0,.01));}
  body.light select, body.light input[type="text"], body.light input[type="date"]{background:#fff; border-color:var(--line); color:var(--text);}
  body.light .tab{background:#fff; color:var(--muted);}
  body.light .tab.active{background:rgba(31,111,235,.12); color:#1f6feb;}
  body.light th{background:rgba(0,0,0,.04);}
  body.light .assign-cell{border-color:rgba(0,0,0,.12);}
  body.light .pill{background:#fff; border-color:var(--line);}
  body.light .toast{background:#fff; border-color:var(--line); color:#b91c1c;}
  body.light .how-it-works-box{background:rgba(0,0,0,.04)!important; border-color:rgba(0,0,0,.12)!important; color:#374151!important;}
  body.light .stat-card{background:rgba(0,0,0,.03); border-color:rgba(0,0,0,.08);}
  body.light .stats-panel{background:rgba(0,0,0,.02);}
  body.light .sticky-col{background:rgba(255,255,255,.98)!important;}
  body.light .wide-table th.sticky-col, body.light .wide-table td.sticky-col{background:rgba(255,255,255,.98)!important;}
  body.light .mroster-table td.sticky-left{background:rgba(255,255,255,.98)!important;}
  /* Light mode: darken all text for visibility */
  body.light .assign-cell{color:#1f2937!important;}
  body.light .ctitem{background:rgba(180,180,190,.2)!important; color:#374151!important; border-color:rgba(0,0,0,.12)!important;}
  body.light .ctitem.repeat{border-color:rgba(217,72,72,.9)!important;}
  body.light .cellbtn.ct, body.light .assign-cell.ct{background:rgba(180,180,190,.2)!important; color:#374151!important; border-color:rgba(0,0,0,.12)!important;}
  body.light td b{color:#1f2937;}
  body.light .needed-badge{color:#fff!important;}
  /* Stats panel */
  .stats-panel{display:grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap:8px; padding:10px; background:rgba(255,255,255,.02); border:1px solid var(--line); border-radius:8px; margin-top:8px;}
  .stat-card{text-align:center; padding:10px; background:rgba(255,255,255,.03); border-radius:6px; border:1px solid rgba(255,255,255,.08);}
  .stat-value{font-size:24px; font-weight:800; color:#4aa3ff;}
  .stat-label{font-size:10px; color:var(--muted); text-transform:uppercase; margin-top:4px;}
  .stat-card.good .stat-value{color:#22c55e;}
  .stat-card.warn .stat-value{color:#f59e0b;}
  .stat-card.bad .stat-value{color:#ef4444;}

  /* Employee management modal */
  .modal-overlay{position:fixed; inset:0; background:rgba(0,0,0,.7); display:none; align-items:center; justify-content:center; z-index:1000;}
  .modal-overlay.show{display:flex;}
  .modal-content{background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:20px; max-width:600px; width:90%; max-height:80vh; overflow:auto;}
  .modal-header{display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;}
  .modal-header h3{margin:0; font-size:16px;}
  .modal-close{background:transparent; border:none; color:var(--muted); font-size:20px; cursor:pointer; padding:5px;}
  .emp-list{max-height:300px; overflow:auto; border:1px solid var(--line); border-radius:8px;}
  .emp-row{display:flex; justify-content:space-between; align-items:center; padding:8px 12px; border-bottom:1px solid var(--line); font-size:12px;}
  .emp-row:last-child{border-bottom:none;}
  .emp-row:hover{background:rgba(255,255,255,.03);}
  .emp-row .emp-info{display:flex; gap:12px; align-items:center;}
  .emp-row .emp-name{font-weight:700; min-width:100px;}
  .emp-row .emp-pos{color:var(--muted); font-size:11px;}
  .emp-row .emp-days{color:var(--muted); font-size:10px;}
  .emp-add-form{display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:15px; padding-top:15px; border-top:1px solid var(--line);}
  .emp-add-form input, .emp-add-form select{padding:8px; font-size:12px;}

  /* Swap history */
  .history-list{max-height:200px; overflow:auto; font-size:11px;}
  .history-item{padding:6px 8px; border-bottom:1px solid var(--line); display:flex; gap:8px; align-items:center;}
  .history-item:last-child{border-bottom:none;}
  .history-time{color:var(--muted); font-size:10px; min-width:70px;}
  .history-action{flex:1;}

  /* Mobile styles */
  @media (max-width: 768px) {
    .wrap{padding:0 5px;}
    h1{font-size:18px !important;}
    .topbar{flex-wrap:wrap; padding:6px;}
    .topbar .row{flex:1; min-width:100px;}
    .tabs{flex-wrap:wrap;}
    .tab{padding:5px 8px; font-size:11px;}
    .sync-pill{font-size:10px; padding:3px 8px;}
    .theme-toggle{padding:4px 8px; font-size:11px;}
    .assign-cell{min-width:80px; padding:4px 6px; font-size:10px;}
    .stats-panel{grid-template-columns: repeat(2, 1fr);}
    .stat-value{font-size:18px;}
    .modal-content{padding:15px; max-width:95%;}
    table{font-size:10px;}
    th, td{padding:2px 3px;}
    .btn{padding:6px 10px; font-size:12px;}
    .header-controls{flex-wrap:wrap; gap:6px !important;}
  }
  @media (max-width: 480px) {
    .topbar{flex-direction:column; align-items:stretch;}
    .topbar .row{width:100%;}
    .stats-panel{grid-template-columns: 1fr 1fr;}
    .assign-cell{min-width:60px; font-size:9px;}
    .emp-add-form{grid-template-columns: 1fr;}
  }
  .matrix-wrap{max-height:520px; overflow:auto; border-radius:12px;}
  .matrix-wrap table{min-width:980px;}
  .sticky-head thead th{position:sticky; top:0; z-index:2;}
  .sticky-col{position:sticky; left:0; z-index:3; background:rgba(15,22,34,.98);}

  .wknames{margin-top:8px; display:grid; gap:4px; font-size:11px; line-height:1.15}
  .wkline{display:flex; justify-content:space-between; gap:8px; white-space:nowrap; overflow:hidden}
  .wkline .lbl{color:var(--muted); flex:0 0 auto}
  .wkline .nm{color:var(--text); flex:1 1 auto; overflow:hidden; text-overflow:ellipsis}


  .scroll-x{overflow-x:auto; width:100%; padding-bottom:6px}
  .wide-table{border-collapse:separate; border-spacing:0; overflow:visible;}
  .wide-table th,.wide-table td{border:1px solid rgba(255,255,255,.08);}
  .wide-table th{white-space:nowrap}
  .wide-table td{min-width:70px; vertical-align:top}
  .wide-table th.sticky-col{position:sticky; left:0; z-index:4; background:rgba(15,22,34,.98);}
  .wide-table td.sticky-col{position:sticky; left:0; z-index:3; background:rgba(15,22,34,.98); white-space:nowrap;}
  .wide-table .subhead{font-size:10px; color:var(--muted); font-weight:800; text-transform:none}
  .wide-table .dayhead{font-size:11px; color:var(--muted); font-weight:900; text-align:center}
  .wide-table .assign-cell{width:70px; min-width:70px; padding:4px 5px; font-size:10px; min-height:19px}

  .mroster-scroll{overflow-x:auto; width:100%; padding-bottom:8px}
  table.mroster-table{border-collapse:separate; border-spacing:0; overflow:visible; width:max-content; min-width:100%}
  .mroster-table th,.mroster-table td{border:1px solid rgba(255,255,255,.08); padding:6px 6px}
  .mroster-table th{background:rgba(12,14,20,.92); position:sticky; top:0; z-index:4; white-space:nowrap}
  .mroster-table th.sticky-left{left:0; z-index:6}
  .mroster-table td.sticky-left{position:sticky; left:0; z-index:3; background:rgba(12,14,20,.98); white-space:nowrap}
  .cellbtn{display:inline-flex; align-items:center; justify-content:center; width:70px; min-height:38px; padding:8px 5px; border-radius:10px; border:1px solid rgba(255,255,255,.10); font-weight:900; font-size:11px; cursor:default; user-select:none}
  .cellbtn.off{background:rgba(255,255,255,.05); color:rgba(255,255,255,.55)}

/* CT buttons styling override */
.cellbtn.ct,
.assign-cell.ct {
  background: rgba(220,220,230,.15) !important;
  color: rgba(255,255,255,.7) !important;
  border-color: rgba(220,220,230,.25) !important;
  box-shadow: none !important;
}

/* Search highlight styles */
.search-match {
  outline: 3px solid #22c55e !important;
  outline-offset: 2px;
  box-shadow: 0 0 12px rgba(34, 197, 94, 0.5) !important;
}
.search-dim {
  opacity: 0.25;
}
.search-active .assign-cell:not(.search-match) {
  opacity: 0.25;
}

/* Print styles */
@media print {
  body {
    background: white !important;
    color: black !important;
    font-size: 10px !important;
  }
  .wrap {
    max-width: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
  }
  .topbar, .tabs, .actions, .btn, .card:has(h2:contains("Excluded")),
  .card:has(h2:contains("Trainees")), .card:has(h2:contains("Add New")),
  .subgrid, .toast, #monthSearch {
    display: none !important;
  }
  .card {
    border: 1px solid #ccc !important;
    background: white !important;
    page-break-inside: avoid;
    margin-bottom: 10px !important;
  }
  table {
    border: 1px solid #333 !important;
    font-size: 9px !important;
  }
  th, td {
    border: 1px solid #666 !important;
    padding: 4px !important;
    color: black !important;
  }
  th {
    background: #eee !important;
  }
  .assign-cell {
    border: 1px solid #333 !important;
    color: black !important;
    padding: 2px 4px !important;
    font-size: 8px !important;
  }
  .cellbtn {
    border: 1px solid #333 !important;
    color: black !important;
    background: #f5f5f5 !important;
  }
  .cellbtn.off {
    background: #ddd !important;
  }
  h1 {
    font-size: 16px !important;
    margin-bottom: 5px !important;
  }
  h2 {
    font-size: 12px !important;
  }
  .small {
    font-size: 8px !important;
  }
  /* Show current tab content */
  #tab_day, #tab_week, #tab_month, #tab_mroster {
    display: block !important;
  }
  #tab_day:not(.print-active),
  #tab_week:not(.print-active),
  #tab_month:not(.print-active),
  #tab_mroster:not(.print-active) {
    display: none !important;
  }
}

@keyframes spinArrows{
  0%{transform:rotate(0deg)}
  100%{transform:rotate(360deg)}
}
@keyframes logoPulse{
  0%,100%{opacity:.8}
  50%{opacity:1}
}
.rotation-logo{
  animation:logoPulse 3s ease-in-out infinite;
}
.rotation-logo .arrows{
  transform-origin:32px 32px;
  animation:spinArrows 4s linear infinite;
}

/* Login overlay */
#loginOverlay{
  position:fixed; inset:0; background:var(--bg); z-index:100000;
  display:flex; align-items:center; justify-content:center;
}
#loginOverlay.hidden{ display:none; }
.login-box{
  background:var(--panel); border:1px solid var(--line); border-radius:16px;
  padding:32px 40px; width:100%; max-width:360px; box-shadow:0 8px 32px rgba(0,0,0,.3);
}
.login-box h2{ margin:0 0 8px; font-size:24px; text-align:center; color:var(--text); }
.login-box .subtitle{ text-align:center; color:var(--muted); font-size:13px; margin-bottom:24px; }
.login-box label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
.login-box input[type="email"],
.login-box input[type="password"]{
  width:100%; padding:12px 14px; border-radius:10px; border:1px solid var(--line);
  background:var(--panel2); color:var(--text); font-size:14px; margin-bottom:16px; outline:none; box-sizing:border-box;
}
.login-box input:focus{ border-color:var(--btn); box-shadow:0 0 0 3px rgba(31,111,235,.15); }
.login-box .btn-login{
  width:100%; padding:12px; border-radius:10px; border:none; background:var(--btn);
  color:#fff; font-size:14px; font-weight:700; cursor:pointer; margin-top:8px;
}
.login-box .btn-login:hover{ background:#3b8fd9; }
.login-box .btn-login:disabled{ opacity:.6; cursor:not-allowed; }
.login-box .login-error{
  background:rgba(255,95,95,.12); border:1px solid rgba(255,95,95,.3); color:#ff6b6b;
  padding:10px 12px; border-radius:8px; font-size:13px; margin-bottom:16px; display:none;
}
.login-box .login-error.show{ display:block; }
#userInfo{ display:flex; align-items:center; gap:10px; font-size:12px; color:var(--muted); }
#userInfo .user-email{ color:var(--text); font-weight:600; }
#btnLogout{
  padding:4px 10px; border-radius:6px; border:1px solid var(--line); background:transparent;
  color:var(--muted); font-size:11px; cursor:pointer;
}
#btnLogout:hover{ background:rgba(255,255,255,.06); }

</style>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script>
  // Firebase configuration (same as ShiftOps)
  const firebaseConfig = {
    apiKey: "AIzaSyA6KELmSyotefK0zhahQZ0-mbYur8_nTsg",
    authDomain: "commandops-93846.firebaseapp.com",
    databaseURL: "https://commandops-93846-default-rtdb.firebaseio.com",
    projectId: "commandops-93846",
    storageBucket: "commandops-93846.firebasestorage.app",
    messagingSenderId: "262613721964",
    appId: "1:262613721964:web:478a694d357234e3be4949"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
  const auth = firebase.auth();

  // Auth state – resolved once onAuthStateChanged fires with a user
  let authResolve;
  let authReady = new Promise(r => { authResolve = r; });

  auth.onAuthStateChanged((user) => {
    const overlay = document.getElementById('loginOverlay');
    const userInfo = document.getElementById('userInfo');
    const userEmail = document.getElementById('userEmail');

    if (user) {
      if (overlay) overlay.classList.add('hidden');
      if (userInfo) userInfo.style.display = 'flex';
      if (userEmail) userEmail.textContent = user.email;
      authResolve();
    } else {
      if (overlay) overlay.classList.remove('hidden');
      if (userInfo) userInfo.style.display = 'none';
      if (userEmail) userEmail.textContent = '';
    }
  });

  // Login form handler
  document.addEventListener('DOMContentLoaded', () => {
    const loginForm = document.getElementById('loginForm');
    const loginError = document.getElementById('loginError');
    const btnLogin = document.getElementById('btnLogin');
    const btnLogout = document.getElementById('btnLogout');

    if (loginForm) loginForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;

      loginError.classList.remove('show');
      btnLogin.disabled = true;
      btnLogin.textContent = 'Signing in...';

      try {
        await auth.signInWithEmailAndPassword(email, password);
      } catch (err) {
        let msg = 'Sign in failed';
        if (err.code === 'auth/user-not-found') msg = 'No account found with this email';
        else if (err.code === 'auth/wrong-password') msg = 'Incorrect password';
        else if (err.code === 'auth/invalid-email') msg = 'Invalid email address';
        else if (err.code === 'auth/too-many-requests') msg = 'Too many attempts. Try again later.';
        else if (err.code === 'auth/invalid-credential') msg = 'Invalid email or password';
        loginError.textContent = msg;
        loginError.classList.add('show');
      }

      btnLogin.disabled = false;
      btnLogin.textContent = 'Sign In';
    });

    if (btnLogout) btnLogout.addEventListener('click', () => {
      auth.signOut();
    });

    // Bug report button
    const btnBug = document.getElementById('btnBugReport');
    if (btnBug) btnBug.addEventListener('click', () => {
      document.getElementById('bugReportName').value = '';
      document.getElementById('bugReportDetails').value = '';
      document.getElementById('bugReportModal').style.display = 'flex';
    });
    document.getElementById('btnBugCancel').addEventListener('click', () => {
      document.getElementById('bugReportModal').style.display = 'none';
    });
    document.getElementById('bugReportModal').addEventListener('click', (e) => {
      if (e.target.id === 'bugReportModal') document.getElementById('bugReportModal').style.display = 'none';
    });
    document.getElementById('btnBugSubmit').addEventListener('click', async () => {
      const name = document.getElementById('bugReportName').value.trim();
      const details = document.getElementById('bugReportDetails').value.trim();
      if (!name || !details) { alert('Please fill in both fields.'); return; }
      try {
        await db.collection('bugReports').add({
          name: name,
          details: details,
          app: 'RotationOps',
          reportedBy: auth.currentUser ? auth.currentUser.email : 'unknown',
          timestamp: new Date().toISOString(),
          status: 'open'
        });
        document.getElementById('bugReportModal').style.display = 'none';
        showToast('Bug report submitted. Thank you!');
      } catch (err) {
        console.error('Bug report failed:', err);
        alert('Failed to submit bug report. Try again.');
      }
    });
  });

  // ===== Firebase Sync Functions =====
  let autoSaveTimer = null;
  let realtimeUnsubscribe = null;
  let lastSavedAt = null;
  let isSyncing = false;
  let initialLoadDone = false; // blocks onSnapshot until first load completes

  function setSyncStatus(status, state = null) {
    const pill = document.getElementById("syncPill");
    if (!pill) return;
    pill.textContent = "SYNC: " + status.toUpperCase();
    pill.classList.remove("synced", "error", "syncing");
    if (state === "good") pill.classList.add("synced");
    else if (state === "bad") pill.classList.add("error");
    else if (state === "pending") pill.classList.add("syncing");
  }

  async function saveRotationToFirebase() {
    await authReady;
    if (!auth.currentUser) { console.error("SAVE: No auth user"); return false; }

    const plan = JSON.parse(localStorage.getItem("rotation_plan_v2") || "null");
    const vac = JSON.parse(localStorage.getItem("rotation_vac_ranges_v2") || "[]");
    const training = JSON.parse(localStorage.getItem("rotation_training_v2") || "[]");

    if (!plan || !plan.meta) { console.error("SAVE: No plan or plan.meta"); return false; }

    const docId = `rotation_${plan.meta.year}_${plan.meta.monthIndex}`;
    console.log("SAVE: Writing to docId:", docId);
    try {
      // Use set WITHOUT merge to fully replace the document
      await db.collection('rotation_plans').doc(docId).set({
        plan: plan,
        vacations: vac,
        trainers: training,
        savedAt: new Date().toISOString()
      });
      console.log("SAVE: SUCCESS for", docId);

      // Verify the write by reading it back from the server
      const verify = await db.collection('rotation_plans').doc(docId).get({ source: 'server' });
      if (!verify.exists) {
        console.error("SAVE: Verification FAILED — doc not found after save");
        return false;
      }
      console.log("SAVE: Verified on server ✓", docId);
      return true;
    } catch (err) {
      console.error("SAVE: Firebase error:", err);
      return false;
    }
  }

  async function loadRotationFromFirebase(year, monthIndex) {
    await authReady;
    if (!auth.currentUser) return false;

    const docId = `rotation_${year}_${monthIndex}`;
    console.log("LOAD: Reading docId:", docId);
    try {
      // Force read from server, not local cache
      const doc = await db.collection('rotation_plans').doc(docId).get({ source: 'server' });
      if (doc.exists) {
        const data = doc.data();
        console.log("LOAD: Got doc, savedAt:", data.savedAt);
        if (data.plan) localStorage.setItem("rotation_plan_v2", JSON.stringify(data.plan));
        if (data.vacations) localStorage.setItem("rotation_vac_ranges_v2", JSON.stringify(data.vacations));
        if (data.trainers) localStorage.setItem("rotation_training_v2", JSON.stringify(data.trainers));
        return true;
      }
      console.log("LOAD: Doc does not exist for", docId);
    } catch (err) {
      console.warn("LOAD: Firebase error (trying cache fallback):", err);
      // If server read fails (offline), try cache
      try {
        const doc = await db.collection('rotation_plans').doc(docId).get({ source: 'cache' });
        if (doc.exists) {
          const data = doc.data();
          if (data.plan) localStorage.setItem("rotation_plan_v2", JSON.stringify(data.plan));
          if (data.vacations) localStorage.setItem("rotation_vac_ranges_v2", JSON.stringify(data.vacations));
          if (data.trainers) localStorage.setItem("rotation_training_v2", JSON.stringify(data.trainers));
          return true;
        }
      } catch (_) {}
    }
    return false;
  }

  function scheduleAutoSave() {
    if (!initialLoadDone) return; // Don't auto-save during page load
    if (autoSaveTimer) clearTimeout(autoSaveTimer);
    setSyncStatus("PENDING...", "pending");

    autoSaveTimer = setTimeout(async () => {
      setSyncStatus("SAVING...", "pending");
      isSyncing = true;
      const ok = await saveRotationToFirebase();
      isSyncing = false;

      if (ok) {
        lastSavedAt = Date.now();
        setSyncStatus("SYNCED", "good");
      } else {
        setSyncStatus("FAILED", "bad");
      }
    }, 1500);
  }

  async function startRealtimeSync(year, monthIndex) {
    await authReady;
    if (!auth.currentUser) return;
    if (realtimeUnsubscribe) realtimeUnsubscribe();

    const docId = `rotation_${year}_${monthIndex}`;
    realtimeUnsubscribe = db.collection('rotation_plans').doc(docId).onSnapshot((doc) => {
      if (!doc.exists) return;
      if (!initialLoadDone) { console.log("REALTIME: SKIPPED (initial load not done)"); return; }
      if (isSyncing) return;
      if (lastSavedAt && (Date.now() - lastSavedAt) < 2000) return;

      const data = doc.data();
      if (!data) return;

      console.log("REALTIME: update received for", docId, "savedAt:", data.savedAt, "fromCache:", doc.metadata.fromCache);
      // Skip cached snapshots — only trust server data
      if (doc.metadata.fromCache) {
        console.log("REALTIME: SKIPPED (from cache, not server)");
        return;
      }

      // Skip if this is the same data we already have (prevents circular save loop)
      const currentPlan = JSON.parse(localStorage.getItem("rotation_plan_v2") || "null");
      if (currentPlan && currentPlan.meta && data.plan && data.plan.meta
          && JSON.stringify(currentPlan.meta) === JSON.stringify(data.plan.meta)
          && data.savedAt === (currentPlan._savedAt || "")) {
        console.log("REALTIME: SKIPPED (same data already loaded)");
        setSyncStatus("LIVE", "good");
        return;
      }

      setSyncStatus("UPDATING...", "pending");

      // Tag the plan with savedAt so we can detect duplicates
      if (data.plan) {
        data.plan._savedAt = data.savedAt;
        localStorage.setItem("rotation_plan_v2", JSON.stringify(data.plan));
      }
      if (data.vacations) localStorage.setItem("rotation_vac_ranges_v2", JSON.stringify(data.vacations));
      if (data.trainers) localStorage.setItem("rotation_training_v2", JSON.stringify(data.trainers));

      // Refresh views
      const dayKey = document.getElementById("dayPick")?.value;
      if (dayKey && typeof renderDay === "function") {
        renderDay(dayKey);
        renderWeek(dayKey);
      }
      if (typeof renderMonth === "function") renderMonth(year, monthIndex);

      setSyncStatus("LIVE", "good");
    }, (err) => {
      console.error("Realtime sync error:", err);
      setSyncStatus("ERROR", "bad");
    });
  }

  // Hook into localStorage to auto-save on changes
  const originalSetItem = localStorage.setItem;
  localStorage.setItem = function(key, value) {
    originalSetItem.call(this, key, value);
    if (key.startsWith("rotation_") && key !== "rotation_ui_v2") {
      scheduleAutoSave();
    }
  };
</script>
</head>
<body>

<!-- Login Overlay -->
<div id="loginOverlay">
  <div class="login-box">
    <h2>RotationOps</h2>
    <p class="subtitle">Sign in to continue</p>
    <div id="loginError" class="login-error"></div>
    <form id="loginForm">
      <label>Email</label>
      <input type="email" id="loginEmail" placeholder="you@example.com" required autocomplete="email"/>
      <label>Password</label>
      <input type="password" id="loginPassword" placeholder="Enter password" required autocomplete="current-password"/>
      <button type="submit" class="btn-login" id="btnLogin">Sign In</button>
    </form>
  </div>
</div>

  <div class="wrap">
    <div style="display:flex;align-items:center;gap:6px;margin-bottom:10px;" class="header-controls">
      <span id="channelFlash" style="font-size:18px;font-weight:900;color:#4aa3ff;width:38px;text-align:center;font-family:system-ui;letter-spacing:1px;display:inline-block;perspective:100px;overflow:hidden;height:24px;line-height:24px;">
        <span id="channelInner" style="display:inline-block;width:38px;text-align:center;"></span>
      </span>
      <h1 style="font-size:22px;margin:0;font-weight:800;">RotationOps</h1>
      <span id="syncPill" class="sync-pill">SYNC: OFFLINE</span>
      <button id="btnThemeToggle" class="theme-toggle" title="Toggle theme">
        <span id="themeIcon">☀️</span> <span id="themeLabel">LIGHT</span>
      </button>
      <button id="btnSwapHistory" class="btn secondary" style="font-size:11px; padding:6px 10px;">HISTORY</button>
      <div style="position:relative; display:inline-block;">
        <button id="btnFairnessStats" class="btn secondary" style="font-size:11px; padding:6px 10px;">HOW IT WORKS</button>
        <div id="fairnessPopup" style="display:none; position:absolute; top:calc(100% + 6px); right:0; z-index:999; width:560px; max-height:75vh; overflow-y:auto; background:var(--panel); border:1px solid var(--line); border-radius:10px; padding:16px; box-shadow:0 8px 30px rgba(0,0,0,.4);">
          <div id="fairnessPopupContent"></div>
        </div>
      </div>
      <div style="position:relative; display:inline-block;">
        <button id="btnTechInfo" title="Technical Details" style="width:26px;height:26px;border-radius:50%;border:1.5px solid var(--muted);background:transparent;color:var(--muted);font-size:14px;font-weight:700;font-style:italic;font-family:Georgia,serif;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;vertical-align:middle;transition:border-color .15s,color .15s;">i</button>
        <div id="techInfoPopup" style="display:none; position:absolute; top:calc(100% + 6px); right:0; z-index:999; width:480px; max-height:75vh; overflow-y:auto; background:var(--panel); border:1px solid var(--line); border-radius:10px; padding:14px 16px; box-shadow:0 8px 30px rgba(0,0,0,.4);">
          <div style="font-weight:800; font-size:13px; color:var(--text); margin-bottom:10px;">TECHNICAL DETAILS</div>
          <div style="font-size:10.5px; line-height:1.65; color:var(--muted);">

            <div style="font-weight:700; color:var(--text); margin-bottom:2px;">RANDOMIZE</div>
            <div style="margin-bottom:8px;">Runs hundreds of full-month attempts and keeps the best. Each attempt fills every 4-hour block across all 10 channels (North, East, South, West, Northwest, Central, DC1, DC2, Relief 1, Relief 2) from scratch. Avoids same-channel twice per day and back-to-back CT/Relief, but allows small exceptions for better overall balance.</div>

            <div style="font-weight:700; color:var(--text); margin-bottom:2px;">BALANCE</div>
            <div style="margin-bottom:8px;">Swaps channel assignments between two people per block if it improves distribution. Does the same for CT — moves duties from overloaded to underloaded. Every swap is validated before applying.</div>

            <div style="font-weight:700; color:var(--text); margin-bottom:2px;">CHECK VIOLATIONS</div>
            <div style="margin-bottom:8px;">Scans the full schedule for rule exceptions (same channel twice in a day, CT/Relief back-to-back). Shows total count and most-affected people.</div>

            <div style="font-weight:700; color:var(--text); margin-bottom:2px;">SCORING</div>
            <div style="margin-bottom:8px;">Each attempt is scored by channel evenness (quadratic penalty for deviation), CT balance, back-to-back fairness, and total assignment spread. Highest score wins.</div>

            <div style="font-weight:700; color:var(--text); margin-bottom:2px;">TRAINING BLOCKS</div>
            <div style="margin-bottom:8px;">Trainers can be restricted to specific 4-hour blocks. Trainees are limited to East/South/West/Central during those blocks only — outside those blocks they're treated normally.</div>

            <div style="font-weight:700; color:var(--text); margin-bottom:2px;">SPECIAL DETAIL (SD)</div>
            <div style="margin-bottom:8px;">SD-eligible employees are scheduled separately so their restricted availability doesn't affect everyone else's balance.</div>

            <div style="font-weight:700; color:var(--text); margin-bottom:2px;">7TH CHANNEL</div>
            <div style="margin-bottom:8px;">Added automatically on Friday and Saturday nights. Distributed evenly across eligible dispatchers.</div>

            <div style="font-weight:700; color:var(--text); margin-bottom:2px;">VACATION HANDLING</div>
            <div style="margin-bottom:8px;">Vacation employees are excluded from the pool for their vacation days. Fairness % is calculated only against days they actually work. They don't affect the overall fairness score. Trainees are also excluded since they can only rotate through 4 channels.</div>

            <div style="font-weight:700; color:var(--text); margin-bottom:2px;">EXPORT</div>
            <div style="margin-bottom:8px;">Export Open Shifts generates a Teams-compatible XLSX for unfilled slots. Export Totals/Excel/CSV export assignment data. Push to ShiftOps syncs the rotation into ShiftOps.</div>

            <div style="font-weight:700; color:var(--text); margin-bottom:2px;">ROSTER</div>
            <div style="margin-bottom:4px;">Full-month grid per employee split by Day/Night/Split shift. Includes cumulative channel counts. Printable per shift or all at once.</div>

          </div>
        </div>
      </div>
      <div style="position:relative; display:inline-block;">
        <button id="btnChannelTotals" class="btn secondary" style="font-size:11px; padding:6px 10px;">CHANNEL TOTALS</button>
        <div id="channelTotalsPopup" style="display:none; position:absolute; top:calc(100% + 6px); right:0; z-index:999; width:560px; max-height:75vh; overflow-y:auto; background:var(--panel); border:1px solid var(--line); border-radius:10px; padding:16px; box-shadow:0 8px 30px rgba(0,0,0,.4);">
          <div id="channelTotalsPopupContent"></div>
        </div>
      </div>
      <div style="position:relative; display:inline-block;" id="exportDropdownWrap">
        <button id="btnExportMenu" class="btn secondary" style="font-size:11px; padding:6px 10px; background:#16A34A; color:#fff;">EXPORT ▾</button>
        <div id="exportDropdown" style="display:none; position:absolute; top:calc(100% + 4px); right:0; z-index:999; min-width:170px; background:var(--panel); border:1px solid var(--line); border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,.4); overflow:hidden;">
          <button id="btnExportTotals" onmouseover="this.style.background='var(--line)'" onmouseout="this.style.background='none'" style="display:block; width:100%; text-align:left; padding:10px 14px; border:none; background:none; color:var(--fg); font-size:12px; cursor:pointer; font-family:inherit;">Export Totals</button>
          <button id="btnExportCSV" onmouseover="this.style.background='var(--line)'" onmouseout="this.style.background='none'" style="display:block; width:100%; text-align:left; padding:10px 14px; border:none; border-top:1px solid var(--line); background:none; color:var(--fg); font-size:12px; cursor:pointer; font-family:inherit;">Export Excel</button>
          <button id="btnExportMonthCSV" onmouseover="this.style.background='var(--line)'" onmouseout="this.style.background='none'" style="display:block; width:100%; text-align:left; padding:10px 14px; border:none; border-top:1px solid var(--line); background:none; color:var(--fg); font-size:12px; cursor:pointer; font-family:inherit;">Export CSV</button>
          <button id="btnPushShiftOps" onmouseover="this.style.background='var(--line)'" onmouseout="this.style.background='none'" style="display:block; width:100%; text-align:left; padding:10px 14px; border:none; border-top:2px solid var(--accent); background:none; color:var(--accent); font-size:12px; cursor:pointer; font-family:inherit; font-weight:700;">Push to ShiftOps</button>
        </div>
      </div>
      <div id="userInfo" style="margin-left:auto;display:none;">
        <span class="user-email" id="userEmail"></span>
        <button id="btnBugReport" type="button" title="Report a Bug" style="background:transparent;border:1px solid var(--muted);border-radius:6px;padding:4px 10px;cursor:pointer;font-size:11px;font-weight:700;color:var(--muted);display:inline-flex;align-items:center;gap:5px;transition:border-color .15s,color .15s;font-family:inherit;" onmouseenter="this.style.borderColor='#ef4444';this.style.color='#ef4444'" onmouseleave="this.style.borderColor='var(--muted)';this.style.color='var(--muted)'">&#x1fab2; REPORT BUG</button>
        <button id="btnLogout" type="button">Sign Out</button>
      </div>
    </div>

    <div class="topbar">
      <div class="row">
        <label for="monthSel">Month:</label>
        <select id="monthSel"></select>
      </div>
      <div class="row">
        <label for="yearSel">Year:</label>
        <select id="yearSel"></select>
      </div>
      <button class="btn" id="btnRandomizeA">RANDOMIZE</button>
      <button class="btn" id="btnBalance" style="background:#f59e0b; box-shadow:0 6px 18px rgba(245,158,11,.22);">BALANCE</button>
      <button class="btn" id="btnCheckViol" style="background:#8b5cf6; box-shadow:0 6px 18px rgba(139,92,246,.22);">CHECK VIOLATIONS</button>
    </div>

    <div class="layout">
      <div class="card">
        <input id="dayPick" type="date" style="display:none;" />
        <div style="display:flex; align-items:center; gap:12px;">
          <div style="display:flex; align-items:center; gap:6px;">
            <h2 style="margin:0; white-space:nowrap;">Day Assignments –</h2>
            <button id="btnDayPrev" style="background:none; border:1px solid var(--line); border-radius:6px; padding:4px 8px; cursor:pointer; color:var(--text); font-size:14px; line-height:1;">&#9664;</button>
            <span id="dayTitle" style="font-size:14px; font-weight:800; color:var(--text); white-space:nowrap; min-width:130px; text-align:center;"></span>
            <button id="btnDayNext" style="background:none; border:1px solid var(--line); border-radius:6px; padding:4px 8px; cursor:pointer; color:var(--text); font-size:14px; line-height:1;">&#9654;</button>
          </div>
        </div>

        <div class="tabs" style="margin-top:12px; align-items:center;">
          <div class="tab active" data-tab="day">Day</div>
          <div class="tab" data-tab="week">Week</div>
          <div class="tab" data-tab="month">Month</div>
          <div class="tab" data-tab="mroster">Roster</div>
          <div id="violationStats" style="display:none; margin-left:12px; padding:6px 10px; background:rgba(239,68,68,0.15); border:1px solid rgba(239,68,68,0.4); border-radius:8px; font-size:11px; align-items:center;">
            <span style="font-weight:700;">VIOLATIONS:</span> <span id="violationCount">0</span> <span style="color:#888;">(<span id="violationPeople">0</span>)</span><span id="violationBest" style="margin-left:6px; color:#22c55e; display:none;">BEST!</span>
          </div>
          <div class="tab" data-tab="exceptions" style="margin-left:auto;">Monthly Exceptions</div>
          <button class="btn" id="btnRemoveRot" style="background:#ef4444; font-size:11px; padding:6px 10px; box-shadow:0 4px 12px rgba(239,68,68,.22);">&#128274; REMOVE FROM ROTATION</button>
        </div>

        <div id="tab_day">
          <div style="margin-bottom:8px; display:flex; gap:12px; align-items:center;">
            <button class="btn secondary" id="btnExportNeedsDay" style="font-size:11px; padding:6px 14px; border-radius:6px; white-space:nowrap; margin-left:auto;">EXPORT OPEN SHIFTS</button>
          </div>
          <div id="dayTableWrap"></div>

        </div>

        
        <div id="tab_mroster" style="display:none">
  <div style="margin-bottom:10px; display:flex; gap:8px; flex-wrap:wrap; position:relative;">
    <div style="position:relative; display:inline-block;">
      <button id="btnPrintRoster" class="btn secondary" style="font-size:11px; padding:6px 14px; background:#4aa3ff; color:#fff; border:none; border-radius:6px; font-weight:700; cursor:pointer;">PRINT ROSTER</button>
      <div id="printRosterMenu" style="display:none; position:absolute; top:100%; left:0; margin-top:4px; background:var(--panel2); border:1px solid var(--line); border-radius:8px; box-shadow:0 4px 16px rgba(0,0,0,.4); z-index:100; min-width:160px; overflow:hidden;">
        <div class="print-roster-opt" data-mode="DAY" style="padding:10px 14px; cursor:pointer; font-size:12px; font-weight:600; border-bottom:1px solid var(--line);">Day Shift</div>
        <div class="print-roster-opt" data-mode="NIGHT" style="padding:10px 14px; cursor:pointer; font-size:12px; font-weight:600; border-bottom:1px solid var(--line);">Night Shift</div>
        <div class="print-roster-opt" data-mode="SPLIT" style="padding:10px 14px; cursor:pointer; font-size:12px; font-weight:600; border-bottom:1px solid var(--line);">Split Shift</div>
        <div class="print-roster-opt" data-mode="SD" style="padding:10px 14px; cursor:pointer; font-size:12px; font-weight:600; border-bottom:1px solid var(--line);">SD (Special Detail)</div>
        <div class="print-roster-opt" data-mode="ALL" style="padding:10px 14px; cursor:pointer; font-size:12px; font-weight:600;">All Rosters</div>
      </div>
    </div>
  </div>
  <div class="card" style="padding:12px; margin-bottom:12px">
    <h2 style="margin:0 0 8px">Day Shift – Roster</h2>
    <div id="mRosterWrapDay"></div>
  </div>

  <div class="card" style="padding:12px; margin-bottom:12px">
    <h2 style="margin:0 0 8px">Night Shift – Roster</h2>
    <div id="mRosterWrapNight"></div>
  </div>

  <div class="card" style="padding:12px">
    <h2 style="margin:0 0 8px">Split Shift – Roster</h2>
    <div id="mRosterWrapSplit"></div>
  </div>
</div>

<div id="tab_week" style="display:none">
          <div style="margin-bottom:8px; display:flex; gap:12px; align-items:center;">
            <input id="weekSearch" type="text" placeholder="SEARCH EMPLOYEE..." style="min-width:200px;" />
            <button class="btn secondary" id="btnExportNeedsWeek" style="font-size:11px; padding:6px 14px; border-radius:6px; white-space:nowrap; margin-left:auto;">EXPORT OPEN SHIFTS</button>
          </div>
          <div id="weekWrap"></div>
        </div>

        <div id="tab_month" style="display:none">
          <div class="row" style="margin-bottom:10px; gap:12px; align-items:center;">
            <input id="monthSearch" type="text" placeholder="SEARCH EMPLOYEE..." style="min-width:200px;" />
            <button class="btn secondary" id="btnExportNeeds" style="font-size:11px; padding:6px 14px; border-radius:6px; white-space:nowrap; margin-left:auto;">EXPORT OPEN SHIFTS</button>
          </div>
          <div id="monthWrap"></div>
        </div>

        <div id="tab_exceptions" style="display:none">
          <div id="exceptionsWrap"></div>
        </div>

        </div>


<div class="toast" id="toast"></div>

<!-- Swap tip bubble -->
<div id="swapTip" style="display:none; position:fixed; bottom:70px; left:50%; transform:translateX(-50%); background:rgba(31,111,235,.92); color:#fff; padding:12px 20px; border-radius:12px; font-size:13px; font-weight:600; z-index:999; box-shadow:0 8px 30px rgba(0,0,0,.4); cursor:pointer; text-align:center; max-width:400px; animation:tipSlideUp .4s ease-out;">
  Click any name to swap assignments
  <div style="font-size:10px; font-weight:400; margin-top:4px; opacity:.8;">tap to dismiss</div>
</div>

<!-- Swap Assignment Modal -->
<div id="callOffModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:9999; align-items:center; justify-content:center;">
  <div style="background:var(--bg); border:1px solid var(--border); border-radius:8px; padding:20px; min-width:320px; max-width:420px;">
    <h3 style="margin:0 0 15px;" id="callOffModalTitle">SWAP ASSIGNMENT</h3>
    <p id="callOffModalInfo" style="margin:0 0 15px; font-size:14px;"></p>
    <div style="margin-bottom:15px;">
      <label style="font-size:12px; font-weight:700; display:block; margin-bottom:6px;">SWAP WITH:</label>
      <select id="swapSelect" style="width:100%; padding:8px; font-size:13px; border-radius:6px; border:1px solid var(--line); background:var(--panel2); color:var(--text);"></select>
    </div>
    <div id="moveToSection" style="display:none; margin-bottom:15px;">
      <label style="font-size:12px; font-weight:700; display:block; margin-bottom:6px;">MOVE TO:</label>
      <select id="moveToSelect" style="width:100%; padding:8px; font-size:13px; border-radius:6px; border:1px solid var(--line); background:var(--panel2); color:var(--text);"></select>
    </div>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <button class="btn" id="btnModalSwap">SWAP</button>
      <button class="btn danger" id="btnMarkAbsent">MARK ABSENT</button>
      <button class="btn" id="btnMoveTo" style="background:#8b5cf6; display:none;">MOVE</button>
      <button class="btn danger" id="btnRemoveOT" style="display:none; background:#dc2626;">REMOVE OT</button>
      <button class="btn secondary" id="btnModalCancel">CANCEL</button>
    </div>
    <div id="callOffModalResult" style="margin-top:15px; font-size:13px;"></div>
  </div>
</div>

<!-- Assign to Empty Slot Modal -->
<div id="assignSlotModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:9999; align-items:center; justify-content:center;">
  <div style="background:var(--bg); border:1px solid var(--border); border-radius:8px; padding:20px; min-width:320px; max-width:420px;">
    <h3 style="margin:0 0 15px;" id="assignSlotModalTitle">ASSIGN TO SLOT</h3>
    <p id="assignSlotModalInfo" style="margin:0 0 15px; font-size:14px;"></p>
    <div style="margin-bottom:15px;">
      <label style="font-size:12px; font-weight:700; display:block; margin-bottom:6px;">ASSIGN FROM CT:</label>
      <select id="assignSlotSelect" style="width:100%; padding:8px; font-size:13px; border-radius:6px; border:1px solid var(--line); background:var(--panel2); color:var(--text);"></select>
    </div>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <button class="btn" id="btnAssignSlot">ASSIGN</button>
      <button class="btn secondary" id="btnAssignSlotCancel">CANCEL</button>
    </div>
  </div>
</div>

<!-- Vacation Assign Modal -->
<div id="vacAssignModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:9999; align-items:center; justify-content:center;">
  <div style="background:var(--bg); border:1px solid var(--border); border-radius:8px; padding:20px; min-width:320px; max-width:420px;">
    <h3 style="margin:0 0 15px; color:#7dd3fc;" id="vacAssignModalTitle">ASSIGN VACATION PERSON</h3>
    <p id="vacAssignModalInfo" style="margin:0 0 15px; font-size:14px;"></p>
    <div style="margin-bottom:15px;">
      <label style="font-size:12px; font-weight:700; display:block; margin-bottom:6px;">ASSIGN TO EMPTY SLOT:</label>
      <select id="vacAssignSelect" style="width:100%; padding:8px; font-size:13px; border-radius:6px; border:1px solid var(--line); background:var(--panel2); color:var(--text);"></select>
    </div>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <button class="btn" id="btnVacAssign">ASSIGN (OT)</button>
      <button class="btn secondary" id="btnVacAssignCancel">CANCEL</button>
    </div>
  </div>
</div>

<!-- Remove From Rotation Modal -->
<div id="removeRotModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:9999; align-items:center; justify-content:center;">
  <div style="background:var(--bg); border:1px solid var(--border); border-radius:8px; padding:20px; min-width:360px; max-width:480px;">
    <h3 style="margin:0 0 15px; color:#ef4444;">REMOVE FROM ROTATION</h3>
    <p style="margin:0 0 12px; font-size:12px; color:var(--muted);">Remove a dispatcher from the current month's rotation for a range of dates. Their slots will show as NEEDED so you can fill them with overtime.</p>
    <div style="margin-bottom:12px;">
      <label style="font-size:12px; font-weight:700; display:block; margin-bottom:6px;">EMPLOYEE:</label>
      <select id="removeRotPerson" style="width:100%; padding:8px; font-size:13px; border-radius:6px; border:1px solid var(--line); background:var(--panel2); color:var(--text);"></select>
    </div>
    <div style="display:flex; gap:10px; margin-bottom:12px;">
      <div style="flex:1;">
        <label style="font-size:12px; font-weight:700; display:block; margin-bottom:6px;">START DATE:</label>
        <input type="date" id="removeRotStart" style="width:100%; padding:8px; font-size:13px; border-radius:6px; border:1px solid var(--line); background:var(--panel2); color:var(--text);" />
      </div>
      <div style="flex:1;">
        <label style="font-size:12px; font-weight:700; display:block; margin-bottom:6px;">END DATE:</label>
        <input type="date" id="removeRotEnd" style="width:100%; padding:8px; font-size:13px; border-radius:6px; border:1px solid var(--line); background:var(--panel2); color:var(--text);" />
      </div>
    </div>
    <div id="removeRotPreview" style="margin-bottom:12px; padding:8px; background:rgba(239,68,68,.08); border:1px solid rgba(239,68,68,.2); border-radius:6px; font-size:11px; display:none;"></div>
    <div style="display:flex; gap:10px;">
      <button class="btn danger" id="btnRemoveRotConfirm" style="background:#ef4444;">REMOVE</button>
      <button class="btn secondary" id="btnRemoveRotCancel">CANCEL</button>
    </div>
  </div>
</div>

<!-- Bug Report Modal -->
<div id="bugReportModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:9999; align-items:center; justify-content:center;">
  <div style="background:var(--bg); border:1px solid var(--border); border-radius:8px; padding:20px; min-width:360px; max-width:440px;">
    <h3 style="margin:0 0 15px; color:#ef4444;">&#128027; REPORT A BUG</h3>
    <div style="margin-bottom:12px;">
      <label style="font-size:12px; font-weight:700; display:block; margin-bottom:6px;">YOUR NAME:</label>
      <input type="text" id="bugReportName" placeholder="Enter your name" style="width:100%; padding:8px; font-size:13px; border-radius:6px; border:1px solid var(--line); background:var(--panel2); color:var(--text);" />
    </div>
    <div style="margin-bottom:15px;">
      <label style="font-size:12px; font-weight:700; display:block; margin-bottom:6px;">DETAILS:</label>
      <textarea id="bugReportDetails" placeholder="Describe the bug — what happened, what you expected, and what you were doing when it happened." style="width:100%; padding:8px; font-size:13px; border-radius:6px; border:1px solid var(--line); background:var(--panel2); color:var(--text); min-height:120px; resize:vertical; font-family:inherit;"></textarea>
    </div>
    <div style="display:flex; gap:10px;">
      <button class="btn danger" id="btnBugSubmit" style="background:#ef4444;">SUBMIT</button>
      <button class="btn secondary" id="btnBugCancel">CANCEL</button>
    </div>
  </div>
</div>

<!-- Swap History Modal -->
<div id="historyModal" class="modal-overlay">
  <div class="modal-content">
    <div class="modal-header">
      <h3>SWAP HISTORY</h3>
      <button class="modal-close" id="btnCloseHistoryModal">&times;</button>
    </div>
    <div class="history-list" id="historyList">
      <div style="color:var(--muted); text-align:center; padding:20px;">NO SWAPS RECORDED YET</div>
    </div>
    <div style="margin-top:15px; display:flex; gap:10px;">
      <button class="btn danger" id="btnClearHistory">&#128274; CLEAR HISTORY</button>
    </div>
  </div>
</div>

<script>


// --- Guard: ensure blocksWorkedForSchedule exists (prevents undefined if any earlier script aborts) ---
if (typeof window.blocksWorkedForSchedule !== "function") {
  window.parseShiftToBlocks = window.parseShiftToBlocks || function(shiftStr){
    const ss = String(shiftStr||"").trim().toUpperCase();
    if (!ss || ss==="OFF") return new Set();
    const _sh = {"6A-2P":[6,14],"6A-6P":[6,18],"10A-6P":[10,18],"10A-10P":[10,22],"2P-10P":[14,22],"6P-2A":[18,26],"6P-6A":[18,30],"10P-6A":[22,30]};
    const rng = _sh[ss];
    if (rng) {
      const blks = (window.BLOCKS||[]);
      const out = new Set();
      for (const b of blks) { if (b.start >= rng[0] && b.end <= rng[1]) out.add(b.key); }
      return out;
    }
    try { return new Set((window.BLOCKS||[]).map(b=>b.key)); } catch(e) { return new Set(); }
  };
  window.blocksWorkedForSchedule = function(scheduleStr, shiftFilter){
    const worked = window.parseShiftToBlocks(scheduleStr);
    const ALL_KEYS = ["0600-1000","1000-1400","1400-1800","1800-2200","2200-0200","0200-0600"];
    const allowed = new Set((shiftFilter==="DAY") ? ["0600-1000","1000-1400","1400-1800"]
                      : (shiftFilter==="NIGHT") ? ["1800-2200","2200-0200","0200-0600"]
                      : ALL_KEYS);
    const out = new Set();
    for (const k of worked) if (allowed.has(k)) out.add(k);
    return out;
  };
}
// Also expose as local name if needed
const blocksWorkedForSchedule = window.blocksWorkedForSchedule;

// CT fairness globals (rebuilt each month)
let ctCapBase = 0;
let ctCapByName = new Map();

/** DATA — loaded from Firestore employees collection */
let BASE = [];

/** Derive DaysOff string from schedule (e.g. "Sat/Sun") */
function deriveDaysOff(emp) {
  const days = ["SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"];
  const labels = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
  const off = [];
  for (let i = 0; i < days.length; i++) {
    const v = String(emp[days[i]] || "").trim().toUpperCase();
    if (!v || v === "OFF") off.push(labels[i]);
  }
  return off.join("/") || "";
}

/** Load DISPATCHER employees from Firestore and populate BASE */
async function loadEmployeesFromFirestore() {
  await authReady;
  if (!auth.currentUser) return false;
  try {
    const snap = await db.collection('employees').get();
    BASE = snap.docs.map(doc => {
      const r = doc.data();
      const pos = String(r.POSITION ?? r.Position ?? "").toUpperCase();
      const emp = {
        Employee: (r.Employee || doc.id).toString().trim().toUpperCase(),
        Seniority: Number(r.SENIORITY ?? r.Seniority ?? 0),
        Position: pos,
        Present: "YES",
        MONDAY: r.MONDAY ?? "OFF",
        TUESDAY: r.TUESDAY ?? "OFF",
        WEDNESDAY: r.WEDNESDAY ?? "OFF",
        THURSDAY: r.THURSDAY ?? "OFF",
        FRIDAY: r.FRIDAY ?? "OFF",
        SATURDAY: r.SATURDAY ?? "OFF",
        SUNDAY: r.SUNDAY ?? "OFF"
      };
      emp.DaysOff = deriveDaysOff(emp);
      return emp;
    }).filter(r => r.Employee && r.Position === "DISPATCHER");
    console.log("Loaded " + BASE.length + " dispatchers from Firestore");
    return true;
  } catch (err) {
    console.error("Failed to load employees from Firestore:", err);
    return false;
  }
}


const CHANNELS = ["North","East","South","West","Northwest","Central","DC1","DC2","Relief 1","Relief 2"];
// 7th channel only active on Fri/Sat nights (2200-0300)
const SEVENTH_CHANNEL = "7th";
const SEVENTH_BLOCKS = new Set(["2200-0200","0200-0600"]); // Block(s) where 7th channel is active

// --- Special Detail (SD) settings ---
// Only these names may ever be assigned SD.
const SD_ELIGIBLE = new Set(["RAMIREZ","FOWLERL","GROUNDS","GUIDRY","BROWNC","MARZAHN","CLEMENT"]);

// Tracking + scoring maps (reinitialized each time a plan is built)
let sdWeekHours = new Map();          // weekKey -> Map(name -> SD hours)
let overflowScoreByDay = new Map();   // YYYY-MM-DD -> total overflow score for that day
let overflowMaxByWeek = new Map();    // weekKey -> max overflow score in that week
const BLOCKS = [
  {key:"0600-1000", label:"6 AM — 10 AM", start:6, end:10},
  {key:"1000-1400", label:"10 AM — 2 PM", start:10, end:14},
  {key:"1400-1800", label:"2 PM — 6 PM", start:14, end:18},
  {key:"1800-2200", label:"6 PM — 10 PM", start:18, end:22},
  {key:"2200-0200", label:"10 PM — 2 AM", start:22, end:26},
  {key:"0200-0600", label:"2 AM — 6 AM", start:26, end:30},
];


function parseShiftToBlocks(shiftStr) {
  const s = String(shiftStr||"").trim().toUpperCase();
  if (!s || s === "OFF") return new Set();
  // Use the same hour-range map as worksBlock for consistency
  const _shiftHours = {
    "6A-2P":[6,14], "6A-6P":[6,18], "10A-6P":[10,18], "10A-10P":[10,22],
    "2P-10P":[14,22], "6P-2A":[18,26], "6P-6A":[18,30], "10P-6A":[22,30]
  };
  const rng = _shiftHours[s];
  if (rng) {
    const out = new Set();
    for (const b of BLOCKS) { if (b.start >= rng[0] && b.end <= rng[1]) out.add(b.key); }
    return out;
  }
  return new Set(BLOCKS.map(b=>b.key));
}

function blocksWorkedForScheduleCanonical(scheduleStr, shiftFilter) {
  const worked = parseShiftToBlocks(scheduleStr);
  const allowed = new Set((shiftFilter==="DAY") ? ["0600-1000","1000-1400","1400-1800"]
                    : (shiftFilter==="NIGHT") ? ["1800-2200","2200-0200","0200-0600"]
                    : BLOCKS.map(b=>b.key));
  const out = new Set();
  for (const k of worked) if (allowed.has(k)) out.add(k);
  return out;
}
// Preferred name used across the app
// Backward-compatible name used in some views
// Shift code -> hours (used for scheduled-hours reporting)
const SHIFT_HOURS = {
  "6A-2P": 8, "6A-6P": 12,
  "10A-6P": 8, "10A-10P": 12,
  "2P-10P": 8,
  "6P-2A": 8, "6P-6A": 12,
  "10P-6A": 8,
  "OFF": 0, "": 0
};

function scheduledWeeklyHoursByName(name) {
  const nm = String(name || "").trim().toUpperCase();
  if (!nm) return 0;
  const base = normalizeBase();
  const row = base.find(r => String(r.Employee||"").trim().toUpperCase() === nm);
  if (!row) return 0;
  let tot = 0;
  const days = ["SATURDAY","SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY"];
  for (const d of days) {
    const v = String(row[d] || "").trim().toUpperCase();
    tot += (SHIFT_HOURS[v] ?? 0);
  }
  return tot;
}
const STORAGE = {
  plan: "rotation_plan_v2",
  vac: "rotation_vac_ranges_v2",
  hires: "rotation_new_hires_v2",
  training: "rotation_training_v2",
  ui: "rotation_ui_v2",
  employees: "rotation_employees_v2",
  swapHistory: "rotation_swap_history_v2",
  theme: "rotation_theme_v2"
};

function showToast(msg) {
  const t = document.getElementById("toast");
  t.style.display = "block";
  t.innerHTML = msg;
  clearTimeout(showToast._tm);
  showToast._tm = setTimeout(()=>t.style.display="none", 9000);
}
function safeParseJSON(str, fallback) { try { return JSON.parse(str); } catch(e) { return fallback; } }
function loadJSON(key, fallback) {
  const raw = localStorage.getItem(key);
  if (!raw) return fallback;
  const val = safeParseJSON(raw, null);
  if (val === null || val === undefined) { localStorage.removeItem(key); return fallback; }
  return val;
}
function saveJSON(key, value) { localStorage.setItem(key, JSON.stringify(value)); }
function pad2(n) { return String(n).padStart(2,"0"); }
function ymd(d) { return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }
// Operational day: before 0500 counts as previous calendar day (night shift runs to 0600)
function operationalToday() {
  const now = new Date();
  if (now.getHours() < 6) {
    now.setDate(now.getDate() - 1);
  }
  return ymd(now);
}
function parseYMD(s) {
  if (!s) return null;
  const [y,m,d] = s.split("-").map(Number);
  if (!y||!m||!d) return null;
  return new Date(y, m-1, d, 12,0,0,0);
}
function dayName(d) { return ["SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"][d.getDay()]; }

function weekKeyFromDate(dateObj) {
  // Week starts on Saturday
  const d = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate(), 12,0,0,0);
  const dow = d.getDay(); // 0 Sun ... 6 Sat
  const offsetToSat = (dow - 6 + 7) % 7;
  const start = new Date(d.getFullYear(), d.getMonth(), d.getDate() - offsetToSat, 12,0,0,0);
  return ymd(start); // key by week start date
}
function monthName(i) { return ["January","February","March","April","May","June","July","August","September","October","November","December"][i]; }
function escapeHtml(s) { return String(s).replace(/[&<>"']/g, m => ({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"}[m])); }

function normalizeBase() {
  const b = Array.isArray(BASE) ? BASE : [];
  return b.filter(x => {
    const p = String(x.Present || "").trim().toUpperCase();
    return (p === "YES" || p === "Y" || p === "TRUE" || p === "1");
  });
}
function getNewHires() {
  const hires = loadJSON(STORAGE.hires, []);
  return Array.isArray(hires) ? hires : [];
}
function getVacRanges() {
  const v = loadJSON(STORAGE.vac, []);
  return Array.isArray(v) ? v : [];
}
function getTrainerRanges() {
  const t = loadJSON(STORAGE.training, []);
  if (!Array.isArray(t)) return [];
  // Support old format (plain strings) and new format (objects with name, from, to, blocks)
  return t.map(item => {
    if (typeof item === 'string') return { name: item.trim().toUpperCase(), from: '', to: '', blocks: [] };
    return { name: String(item.name||'').trim().toUpperCase(), from: item.from||'', to: item.to||'', blocks: Array.isArray(item.blocks) ? item.blocks : [] };
  }).filter(r => r.name);
}
function getTrainees() {
  // Returns just the names for backward compatibility
  return getTrainerRanges().map(r => r.name);
}
function isTrainee(name, dayKey, blockKey) {
  const ranges = getTrainerRanges();
  const nm = String(name || "").trim().toUpperCase();
  const dateObj = dayKey ? parseYMD(dayKey) : null;
  const dt = dateObj ? dateObj.getTime() : null;
  return ranges.some(r => {
    if (!r || !r.name) return false;
    if (r.name.toUpperCase() !== nm) return false;
    // If no dates specified, always applies
    if (!r.from && !r.to) { /* date matches */ }
    else if (!dt) { /* no date to check, matches */ }
    else {
      const fromT = r.from ? new Date(r.from + "T00:00:00").getTime() : -Infinity;
      const toT = r.to ? new Date(r.to + "T23:59:59").getTime() : Infinity;
      if (dt < fromT || dt > toT) return false;
    }
    // Block check: if trainer has specific blocks and blockKey is provided, must match
    if (blockKey && r.blocks && r.blocks.length > 0) {
      return r.blocks.includes(blockKey);
    }
    return true;
  });
}
// Global trainee channel restriction check for use in all balancing passes
// Only restricts during actual training blocks (uses blockKey so non-training blocks are unrestricted)
const _TRAINEE_OK_CHANNELS = new Set(["EAST","SOUTH","WEST","CENTRAL"]);
function traineeBlocked(name, dayKey, blockKey, channelUpper) {
  if (!isTrainee(name, dayKey, blockKey)) return false;
  return !_TRAINEE_OK_CHANNELS.has(String(channelUpper).toUpperCase());
}

function isExcluded(name, dateObj) {
  const ranges = getVacRanges();
  const nm = String(name||"").trim().toUpperCase();
  const dt = dateObj ? dateObj.getTime() : null;
  return ranges.some(r => {
    if (!r || !r.name) return false;
    if (String(r.name).trim().toUpperCase() !== nm) return false;
    if (!r.from && !r.to) return true; // month-wide
    const f = r.from ? parseYMD(r.from) : null;
    const t = r.to ? parseYMD(r.to) : null;
    const ft = f ? f.getTime() : -Infinity;
    const tt = t ? t.getTime() : Infinity;
    return dt !== null && dt >= ft && dt <= tt;
  });
}

function buildDispatcherPoolForDate(dateObj) {
  const base = normalizeBase();
  const hires = getNewHires().map(n => String(n).trim()).filter(Boolean);
  const dispatchers = base.filter(r => String(r.Position||"").toUpperCase()==="DISPATCHER")
    .map(r => ({ name: String(r.Employee||"").trim(), seniority: Number(r.Seniority||0), sched: r }))
    .filter(r => r.name);

  const hireObjs = hires
    .filter(n => dispatchers.every(d => d.name.toUpperCase() !== n.toUpperCase()))
    .map(n => ({ name:n, seniority:0, sched:null, isHire:true }));

  return dispatchers.concat(hireObjs).filter(d => !isExcluded(d.name, dateObj));
}

function worksBlock(disp, dateObj, block) {
  if (disp.isHire && !disp.sched) return false; // new hires must be scheduled before being assigned
  const sched = disp.sched || {};
  const dn = dayName(dateObj);
  const val = String(sched[dn] || "").toUpperCase().trim();
  if (!val || val==="OFF") return false;
  const map = {
    "6A-2P":[6,14],
    "6A-6P":[6,18],
    "10A-6P":[10,18],
    "10A-10P":[10,22],
    "2P-10P":[14,22],
    "6P-2A":[18,26],
    "6P-6A":[18,30],
    "10P-6A":[22,30],
  };
  const rng = map[val];
  if (!rng) return false;
  const [s,e] = rng;
  return (block.start >= s && block.end <= e);
}

function is12HrShift(disp, dateObj) {
  if (disp.isHire && !disp.sched) return false;
  const sched = disp.sched || {};
  const dn = dayName(dateObj);
  const val = String(sched[dn] || "").toUpperCase().trim();
  return val === "6A-6P" || val === "10A-10P" || val === "6P-6A";
}

function shuffle(arr) {
  const a = arr.slice();
  for (let i=a.length-1; i>0; i--) {
    const j = Math.floor(Math.random()*(i+1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function loadPlan() {
  const p = loadJSON(STORAGE.plan, null);
  return (p && typeof p==="object") ? p : null;
}
function savePlan(p) { saveJSON(STORAGE.plan, p); }

function buildEmptyPlan(year, monthIndex) {
  // reset per-month helper maps
  overflowScoreByDay = new Map();
  overflowMaxByWeek = new Map();
  sdWeekHours = new Map();

  const plan = { meta: {year, monthIndex, created: Date.now()}, days: {} };
  const daysInMonth = new Date(year, monthIndex+1, 0).getDate();

  // CT cap pre-scan totals
  let totalCTSlotsMonth = 0;
  let workedBlocksByName = new Map();

  // --- Pre-pass: compute where CT overflow is highest (per day, per week) ---
  for (let day=1; day<=daysInMonth; day++) {
    const dateObj = new Date(year, monthIndex, day, 12,0,0,0);
    const dayKey = ymd(dateObj);
    const wk = weekKeyFromDate(dateObj);
    const poolAll = buildDispatcherPoolForDate(dateObj);
    let score = 0;
    for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
      const available = poolAll.filter(d => worksBlock(d, dateObj, b));
      const overflowSlots = Math.max(0, available.length - 10);
      score += overflowSlots;
      totalCTSlotsMonth += overflowSlots;
      for (const d of available) workedBlocksByName.set(d.name, (workedBlocksByName.get(d.name)||0) + 1);
    }
    overflowScoreByDay.set(dayKey, score);
    const prevMax = overflowMaxByWeek.get(wk) || 0;
    if (score > prevMax) overflowMaxByWeek.set(wk, score);
  }

  // --- Compute hard monthly CT caps (as even as possible) ---
  const activeNames = Array.from(workedBlocksByName.keys());
  const activeCount = Math.max(1, activeNames.length);
  // CT hard cap (fixed)
  ctCapBase = 10;
  ctCapByName = new Map(activeNames.map(n => [n, ctCapBase]));

  for (let day=1; day<=daysInMonth; day++) {
    const d = new Date(year, monthIndex, day, 12,0,0,0);
    const key = ymd(d);
    plan.days[key] = {};
    for (const b of BLOCKS) plan.days[key][b.key] = { assignments:{}, sd:[], ct:[], filled:0, needed:10 };
  }
  return plan;
}

function randomizeMonth(year, monthIndex) {
  const plan = buildEmptyPlan(year, monthIndex);

  // Track last channel (prevents immediate back-to-back repeats)
  const lastAssign = new Map();
  function forbiddenBackToBack(prev, next) {
    // DC1/DC2 never back-to-back
    if ((prev==="DC1" && next==="DC2") || (prev==="DC2" && next==="DC1")) return true;
    return false;
  }


  // Track per-person channel cycle (prevents repeating a channel until they've hit all 10)
  // name -> Set(channels used in current cycle)
  const channelCycle = new Map();

  // Light balancing helper (keeps total assignments per person more even)
  const channelCounts = new Map();

  // CT fairness tracking (per month + per week + back-to-back exception)
  const ctWeekCounts = new Map();   // weekKey -> Map(name -> ctCountThisWeek)
  const ctMonthCounts = new Map();  // name -> ctCountThisMonth
  const lastCTAt = new Map();       // name -> {dayKey, blockIdx} for back-to-back rule
  const reliefWeekCounts = new Map(); // weekKey -> Map(name -> reliefBlocksThisWeek)
  const dcWeekCounts = new Map(); // weekKey -> Map(name -> dcBlocksThisWeek)
  const WEEKLY_CT_CAP = 2;    // Max 2 CT blocks per person per work week (8 hrs)
  const WEEKLY_RELIEF_CAP = 2; // Max 2 Relief blocks per person per work week (8 hrs)
  const WEEKLY_DC_CAP = 2;    // Max 2 DC blocks per person per work week (8 hrs)
  const primChWeekCounts = new Map(); // weekKey -> Map("NAME|CHANNEL" -> count)
  const WEEKLY_PRIMARY_CH_CAP = 2; // Max 2 of any SPECIFIC primary channel per person per work week

  // Violation fairness: track violations per person (max 1 per person if possible)
  const violationCount = new Map();  // name -> number of violations this month
  function hasViolation(name) { return (violationCount.get(String(name).toUpperCase()) || 0) > 0; }
  function addViolation(name) {
    const n = String(name).toUpperCase();
    violationCount.set(n, (violationCount.get(n) || 0) + 1);
  }

  // Track people assigned R1/R2 who work next block - they get GUARANTEED channel priority
  // This prevents Relief->CT violations when Pass 4 must fill R1/R2 with someone working next block
  const mustGetChannelNextBlock = new Set(); // names that MUST get a channel (not CT) next block

  // ctCapByName is global (rebuilt in buildEmptyPlan)
  const ctOverCapUsedByWeek = new Map(); // weekKey -> Set(names who used 1 over-cap allowance)
  const lastCTGlobalIdx = new Map();     // name -> global block index of last CT (for back-to-back rule)

  const daysInMonth = new Date(year, monthIndex+1, 0).getDate();

  // ========== SD PRE-ASSIGNMENT (32 hrs/WEEK = 8 blocks/WEEK per person) ==========
  // Pre-assign SD to SD-eligible employees before filling channels
  // Each SD person gets 32 hrs (8 blocks) of SD per WEEK, rest goes to channels.
  // Track: sdPreAssigned[weekKey][dayKey][blockKey] = [names assigned to SD]
  const sdPreAssigned = new Map(); // weekKey -> Map(dayKey -> Map(blockKey -> [names]))
  const sdRemainingBlocks = new Map(); // weekKey -> Map(name -> remaining channel blocks to fill)

  // Group days by week and find days with most dispatchers for SD priority
  const weekDays = new Map(); // weekKey -> [{dayKey, dateObj, dispatcherCount}]
  for (let day=1; day<=daysInMonth; day++) {
    const dateObj = new Date(year, monthIndex, day, 12,0,0,0);
    const dayKey = ymd(dateObj);
    const wk = weekKeyFromDate(dateObj);
    if (!weekDays.has(wk)) weekDays.set(wk, []);

    // Count total dispatcher availability for this day
    const poolAll = buildDispatcherPoolForDate(dateObj);
    let totalAvail = 0;
    for (const b of BLOCKS) {
      const available = poolAll.filter(d => worksBlock(d, dateObj, b));
      totalAvail += available.length;
    }
    weekDays.get(wk).push({dayKey, dateObj, dispatcherCount: totalAvail});
  }

  // Monthly SD cap: 32 blocks (128 hrs) per month — ensures totals stay at 32
  const SD_MONTHLY_CAP = 32;
  const sdMonthlyCount = new Map(); // name -> total SD blocks this month
  for (const sdName of SD_ELIGIBLE) sdMonthlyCount.set(sdName, 0);

  // For each week, pre-assign SD (8 blocks = 32 hrs per FULL WEEK, pro-rated for partial weeks)
  for (const [wk, days] of weekDays.entries()) {
    // Sort days by dispatcher count descending (prioritize days with most dispatchers)
    days.sort((a, b) => b.dispatcherCount - a.dispatcherCount);

    sdPreAssigned.set(wk, new Map());
    sdRemainingBlocks.set(wk, new Map());
    const sdMap = sdPreAssigned.get(wk);

    // Pro-rate SD cap for partial weeks:
    // A full week (7 days, ~5 working days) = 8 blocks cap
    // Partial weeks get proportional cap based on actual days in this month-week
    const daysInThisWeek = days.length;
    // Full week has ~5 working days (Mon-Fri from Sat-Fri week). Scale 8 blocks by ratio.
    // Use 5 as the baseline for a full working week
    const sdWeeklyCap = Math.min(8, Math.round(8 * daysInThisWeek / 5));

    // Track blocks assigned per SD employee this week
    const sdBlocksThisWeek = new Map(); // name -> blocks assigned this week

    // For each SD-eligible employee, initialize to 0
    for (const sdName of SD_ELIGIBLE) {
      sdBlocksThisWeek.set(sdName, 0);
      sdRemainingBlocks.get(wk).set(sdName, 0); // will calculate after
    }

    // Distribute SD assignments across the week
    for (const {dayKey, dateObj} of days) {
      if (!sdMap.has(dayKey)) sdMap.set(dayKey, new Map());
      const dayMap = sdMap.get(dayKey);

      const poolAll = buildDispatcherPoolForDate(dateObj);

      for (const b of BLOCKS) {
        if (!dayMap.has(b.key)) dayMap.set(b.key, []);

        // Find SD-eligible people working this block who haven't hit weekly or monthly cap
        for (const sdName of SD_ELIGIBLE) {
          const weeklyBlocks = sdBlocksThisWeek.get(sdName) || 0;
          if (weeklyBlocks >= sdWeeklyCap) continue; // CAP: pro-rated per week
          const monthlyBlocks = sdMonthlyCount.get(sdName) || 0;
          if (monthlyBlocks >= SD_MONTHLY_CAP) continue; // HARD CAP: 32 blocks per month

          // Check if this person works this block
          const disp = poolAll.find(d => String(d.name).toUpperCase() === sdName);
          if (!disp) continue;
          if (!worksBlock(disp, dateObj, b)) continue;

          // Assign to SD
          dayMap.get(b.key).push(sdName);
          sdBlocksThisWeek.set(sdName, weeklyBlocks + 1);
          sdMonthlyCount.set(sdName, monthlyBlocks + 1);
        }
      }
    }

    // Calculate remaining channel blocks for each SD employee
    // (Total scheduled blocks - SD blocks = remaining for channels)
    for (const sdName of SD_ELIGIBLE) {
      let totalScheduledBlocks = 0;
      for (const {dayKey, dateObj} of days) {
        const poolAll = buildDispatcherPoolForDate(dateObj);
        const disp = poolAll.find(d => String(d.name).toUpperCase() === sdName);
        if (!disp) continue;
        for (const b of BLOCKS) {
          if (worksBlock(disp, dateObj, b)) totalScheduledBlocks++;
        }
      }
      const sdBlocks = sdBlocksThisWeek.get(sdName) || 0;
      const remainingBlocks = Math.max(0, totalScheduledBlocks - sdBlocks);
      sdRemainingBlocks.get(wk).set(sdName, remainingBlocks);
    }
  }
  // ========== END SD PRE-ASSIGNMENT ==========

// Weekly quota targets (after SD):
// - 24 hrs (6 blocks) from N/E/S/W/C/NW
// - 8 hrs (2 blocks) from CT or R1/R2
// - 8 hrs (2 blocks) from DC1/DC2
const PRIMARY_SET = new Set(["NORTH","EAST","SOUTH","WEST","CENTRAL","NORTHWEST"]);
const DC_SET = new Set(["DC1","DC2"]);
const CTR_SET = new Set(["CT","R1","R2"]);

// wk -> Map(name -> {primary:int, ctr:int, dc:int})
const weekNeeds = new Map();
function getNeeds(wkKey, name){
  if (!weekNeeds.has(wkKey)) weekNeeds.set(wkKey, new Map());
  const m = weekNeeds.get(wkKey);
  if (!m.has(name)) m.set(name, {primary:6, ctr:2, dc:2}); // default 40hr week (10 blocks)
  return m.get(name);
}

// Keep channel chunks up to 8 hours (2 blocks) when possible
const sameChanStreak = new Map(); // name -> {ch, len}
// Hard constraint: never more than 8 hours (2 blocks) in CT/R1/R2 bucket back-to-back
const ctrStreakLen = new Map(); // name -> consecutive blocks in {CT,R1,R2}

// Back-to-back same-channel allowed for primary geographic channels (max 2 consecutive blocks)
// Distributed evenly: track how many b2b pairs each person gets this month
const b2bMonthCount = new Map(); // name -> number of back-to-back pairs this month

function isAllowedPrimaryB2B(name, ch) {
  const CH = String(ch).toUpperCase();
  if (!PRIMARY_SET.has(CH)) return false;
  const streak = sameChanStreak.get(name);
  if (streak && streak.ch === CH && streak.len >= 2) return false; // max 2 consecutive
  return true;
}

function updateStreaks(name, assignedChannel){
  // same channel streak
  const prev = sameChanStreak.get(name);
  // Track b2b pair BEFORE updating streak (if same primary channel, it's a new b2b pair)
  if (prev && prev.ch === assignedChannel && PRIMARY_SET.has(assignedChannel)) {
    b2bMonthCount.set(name, (b2bMonthCount.get(name) || 0) + 1);
  }
  if (prev && prev.ch === assignedChannel) sameChanStreak.set(name, {ch: assignedChannel, len: Math.min(2, prev.len+1)});
  else sameChanStreak.set(name, {ch: assignedChannel, len: 1});

  // CT-bucket streak
  if (CTR_SET.has(assignedChannel)) ctrStreakLen.set(name, (ctrStreakLen.get(name)||0)+1);
  else ctrStreakLen.set(name, 0);
}



  // Track which channels each person has already worked TODAY (to prevent same channel twice in same day)
  const dayChannelsWorked = new Map(); // dayKey -> Map(name -> Set of channels)

  for (let day=1; day<=daysInMonth; day++) {
    const dateObj = new Date(year, monthIndex, day, 12,0,0,0);
    const dayKey = ymd(dateObj);
        const wk = weekKeyFromDate(dateObj);
    if (!ctWeekCounts.has(wk)) ctWeekCounts.set(wk, new Map());
    if (!reliefWeekCounts.has(wk)) reliefWeekCounts.set(wk, new Map());
    const rwmap = reliefWeekCounts.get(wk);
    if (!dcWeekCounts.has(wk)) dcWeekCounts.set(wk, new Map());
    const dwmap = dcWeekCounts.get(wk);
    if (!primChWeekCounts.has(wk)) primChWeekCounts.set(wk, new Map());
    const pcwmap = primChWeekCounts.get(wk);

    // Initialize daily channel tracking for this day
    if (!dayChannelsWorked.has(dayKey)) dayChannelsWorked.set(dayKey, new Map());
    const todayChannels = dayChannelsWorked.get(dayKey); // Map(name -> Set of channels)

const poolAll = buildDispatcherPoolForDate(dateObj);

    for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
      const available = poolAll.filter(d => worksBlock(d, dateObj, b));
      const shuffled = shuffle(available);

      // Balance: prefer people with fewer total assignments so far
      // HIGHEST PRIORITY: People who were just on CT/R1/R2 must get a channel to avoid back-to-back
      shuffled.sort((a,b2)=>{
        // ABSOLUTE PRIORITY: People marked as must-get-channel (from Pass 4 R1/R2 assignment)
        const aMustGet = mustGetChannelNextBlock.has(a.name);
        const bMustGet = mustGetChannelNextBlock.has(b2.name);
        if (aMustGet && !bMustGet) return -1; // a goes first (GUARANTEED)
        if (bMustGet && !aMustGet) return 1;  // b goes first (GUARANTEED)

        // Check if either person was just on CT/R1/R2 (needs priority for channel)
        const lastA = lastAssign.get(a.name);
        const lastB = lastAssign.get(b2.name);
        const ctrNames = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
        const aWasOnCTR = lastA && ctrNames.has(String(lastA).toUpperCase());
        const bWasOnCTR = lastB && ctrNames.has(String(lastB).toUpperCase());

        // SECOND: People who were just on CT/R1/R2 get top priority for channels
        if (aWasOnCTR && !bWasOnCTR) return -1; // a goes first
        if (bWasOnCTR && !aWasOnCTR) return 1;  // b goes first

        const ma = channelCounts.get(a.name) || new Map();
        const mb = channelCounts.get(b2.name) || new Map();
        const ta = Array.from(ma.values()).reduce((s,v)=>s+v,0);
        const tb = Array.from(mb.values()).reduce((s,v)=>s+v,0);

        // CT fairness: if someone has already been sent to CT more often, pull them onto a channel first
        const wmap = ctWeekCounts.get(wk) || new Map();
        const cwa = wmap.get(a.name) || 0;
        const cwb = wmap.get(b2.name) || 0;

        const cma = ctMonthCounts.get(a.name) || 0;
        const cmb = ctMonthCounts.get(b2.name) || 0;

        // Priority order:
        // 1) Higher CT this week gets channel priority (reduces repeat CT in the same week)
        // 2) Higher CT this month gets channel priority (evens CT across the month)
        if (cwa !== cwb) return cwb - cwa;
        if (cma !== cmb) return cmb - cma;
        return 0;
      });

      const assignments = {};
      const usedNames = new Set();

      // ========== ADD PRE-ASSIGNED SD TO THIS BLOCK ==========
      // Get pre-assigned SD for this block and add to usedNames
      const sdForBlock = [];
      const wkSdMap = sdPreAssigned.get(wk);
      if (wkSdMap && wkSdMap.has(dayKey)) {
        const dayMap = wkSdMap.get(dayKey);
        if (dayMap && dayMap.has(b.key)) {
          for (const sdName of dayMap.get(b.key)) {
            sdForBlock.push(sdName);
            usedNames.add(sdName); // Exclude from channel assignment this block
          }
        }
      }
      // ========== END PRE-ASSIGNED SD ==========

      // Check if an SD employee still has remaining channel blocks to fill
      // If so, prioritize them for primary channels (N,E,S,W,NW,C) and one DC
      const sdRemainingMap = sdRemainingBlocks.get(wk) || new Map();
      function isSDEmployeeNeedingChannel(name) {
        const nm = String(name).toUpperCase();
        return SD_ELIGIBLE.has(nm) && (sdRemainingMap.get(nm) || 0) > 0 && !usedNames.has(nm);
      }

      // Training restriction: trainees can only be assigned to E, S, W, C
      const TRAINEE_ALLOWED_CHANNELS = new Set(["EAST","SOUTH","WEST","CENTRAL"]);
      function canTraineeWork(candName, channelUpper, blockKey) {
        if (!isTrainee(candName, dayKey, blockKey)) return true; // Only restrict during training blocks
        return TRAINEE_ALLOWED_CHANNELS.has(channelUpper);
      }

      // ========== B2B PRE-ASSIGNMENT ==========
      // Before main channel loop, pre-assign b2b for primary channels when it helps fairness.
      // Without this, candidates get consumed by earlier channels before their b2b channel is processed.
      const b2bProtected = new Set(); // Declared outside block so swap sections can see it
      {
        const b2bCandidates = [];
        for (const cand of shuffled) {
          if (usedNames.has(cand.name)) continue;
          const last = lastAssign.get(cand.name);
          if (!last) continue;
          const lastUpper = String(last).toUpperCase();
          if (!PRIMARY_SET.has(lastUpper)) continue;
          if (!isAllowedPrimaryB2B(cand.name, last)) continue;
          if (!canTraineeWork(cand.name, lastUpper, b.key)) continue;

          // Find matching channel key in CHANNELS
          const matchCh = CHANNELS.find(c => String(c).toUpperCase() === lastUpper);
          if (!matchCh) continue;

          // B2b fairness: don't give too many b2b to one person
          // Compute average across ALL available people (not just those with b2b entries)
          const myB2B = b2bMonthCount.get(cand.name) || 0;
          let b2bTotal = 0;
          for (const [, v] of b2bMonthCount) b2bTotal += v;
          const totalPeople = shuffled.length || 1;
          const avgB2B = b2bTotal / totalPeople;
          if (myB2B > avgB2B + 0.5) continue; // Only if at or near the true average

          // Compute channel deficit for sorting (prefer people who need this channel more)
          const m = channelCounts.get(cand.name) || new Map();
          const myCount = m.get(matchCh) || 0;
          let chSum = 0, chCnt = 0;
          for (const [, cm] of channelCounts) { chSum += (cm.get(matchCh) || 0); chCnt++; }
          const chAvg = chCnt > 0 ? chSum / chCnt : 0;
          const deficit = chAvg - myCount;
          b2bCandidates.push({ name: cand.name, channel: matchCh, channelUpper: lastUpper, deficit, myB2B });
        }

        // Sort: biggest deficit first, then fewest b2b
        b2bCandidates.sort((a, b) => {
          if (b.deficit !== a.deficit) return b.deficit - a.deficit;
          return a.myB2B - b.myB2B;
        });

        const b2bUsedChannels = new Set();
        const B2B_MAX_PER_BLOCK = 3; // Limit to avoid starving CT swap targets
        for (const bc of b2bCandidates) {
          if (b2bProtected.size >= B2B_MAX_PER_BLOCK) break;
          if (usedNames.has(bc.name)) continue;
          if (b2bUsedChannels.has(bc.channel)) continue;

          const ch = bc.channel;
          const CH = bc.channelUpper;
          const bucket = "primary";

          assignments[ch] = bc.name;
          usedNames.add(bc.name);
          lastAssign.set(bc.name, ch);

          if (!todayChannels.has(bc.name)) todayChannels.set(bc.name, new Set());
          todayChannels.get(bc.name).add(CH);

          if (!channelCycle.has(bc.name)) channelCycle.set(bc.name, new Set());
          const cyc = channelCycle.get(bc.name);
          if (cyc.size >= CHANNELS.length) cyc.clear();
          cyc.add(ch);

          if (!channelCounts.has(bc.name)) channelCounts.set(bc.name, new Map());
          const m = channelCounts.get(bc.name);
          m.set(ch, (m.get(ch) || 0) + 1);

          updateStreaks(bc.name, CH);

          const nd = getNeeds(wk, bc.name);
          if (nd[bucket] > 0) nd[bucket]--;

          // SD remaining tracking
          const pickUpper = String(bc.name).toUpperCase();
          if (SD_ELIGIBLE.has(pickUpper) && sdRemainingMap && sdRemainingMap.has(pickUpper)) {
            const rem = sdRemainingMap.get(pickUpper) || 0;
            if (rem > 0) sdRemainingMap.set(pickUpper, rem - 1);
          }

          mustGetChannelNextBlock.delete(bc.name);
          b2bUsedChannels.add(ch);
          b2bProtected.add(bc.name);
        }
      }
      // ========== END B2B PRE-ASSIGNMENT ==========

      for (const ch of CHANNELS) {
  // Skip channels already filled by b2b pre-assignment
  if (assignments[ch]) {
    // Still need to clear mustGetChannelNextBlock for anyone who got their channel
    continue;
  }
  let pick = null;
  const CH = String(ch).toUpperCase();

  // Determine which quota bucket this channel satisfies
  const bucket = DC_SET.has(CH) ? "dc" : (PRIMARY_SET.has(CH) ? "primary" : (CTR_SET.has(CH) ? "ctr" : "primary"));

  // Compute average assignment count for this channel across all dispatchers
  let chAvgCount = 0;
  if (channelCounts.size > 0) {
    let sum = 0, cnt = 0;
    for (const [nm, m] of channelCounts) {
      sum += (m.get(ch) || 0);
      cnt++;
    }
    chAvgCount = cnt > 0 ? sum / cnt : 0;
  }

  function candScore(cand){
    const needs = getNeeds(wk, cand.name);
    const needVal = needs[bucket] || 0;

    const last = lastAssign.get(cand.name);
    const lastUpper = last ? String(last).toUpperCase() : "";
    const streak = sameChanStreak.get(cand.name);
    // Back-to-back bonus for primary channels: prefer people with fewer b2b pairs (even distribution)
    let sameBonus = 0;
    if (last && lastUpper===CH && PRIMARY_SET.has(CH) && streak && streak.len < 2) {
      const myB2B = b2bMonthCount.get(cand.name) || 0;
      let b2bTotal = 0;
      for (const [, v] of b2bMonthCount) b2bTotal += v;
      const b2bAvgAll = shuffled.length > 0 ? b2bTotal / shuffled.length : 0;
      sameBonus = myB2B <= b2bAvgAll ? 300 : -500; // Strong: reward below-avg b2b, heavily penalize above-avg
    }

    const m = channelCounts.get(cand.name) || new Map();
    const total = Array.from(m.values()).reduce((s,v)=>s+v,0);

    // Relief grouping: strongly prefer back-to-back Relief (R→R pairs)
    // If assigning R1/R2 and candidate was just on R1/R2, massive bonus to keep them grouped
    let ctrPriorityBonus = 0;
    const wasRelief = lastUpper === "RELIEF 1" || lastUpper === "RELIEF 2" || lastUpper === "R1" || lastUpper === "R2";
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && wasRelief) {
      // They were just on Relief — group them back-to-back for an 8hr Relief block
      ctrPriorityBonus = 8000;
    }

    // SD employee priority: give big bonus for primary channels (N,E,S,W,NW,C) and DC1/DC2
    // Their remaining 8 hrs should go to these channels
    let sdBonus = 0;
    if (isSDEmployeeNeedingChannel(cand.name)) {
      if (PRIMARY_SET.has(CH) || DC_SET.has(CH)) {
        sdBonus = 200; // High priority for SD employees to get primary/DC channels
      } else {
        sdBonus = -100; // Discourage R1/R2 for SD employees
      }
    }

    // R1/R2 penalty: If assigning R1 or R2, heavily penalize people who work the next block
    // This prevents R1/R2 -> CT violations
    let r1r2Penalty = 0;
    if (CH === "RELIEF 1" || CH === "RELIEF 2") {
      const nextBlockIdx = bi + 1;
      if (nextBlockIdx < BLOCKS.length) {
        // Check if this person works the next block today
        if (worksBlock(cand, dateObj, BLOCKS[nextBlockIdx])) {
          r1r2Penalty = -500; // Heavy penalty - prefer someone whose shift ends
        }
      }
      // Also check if they work the first block of the next day
      if (bi === BLOCKS.length - 1) {
        const nextDay = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate() + 1, 12, 0, 0, 0);
        if (worksBlock(cand, nextDay, BLOCKS[0])) {
          r1r2Penalty = -500; // Heavy penalty for cross-day continuation
        }
      }
    }

    // CT/Relief inverse balance: high CT → prefer Relief, high Relief → prefer CT
    // Combined CT+R total should be balanced, so if one is high the other should be low
    let ctReliefInverseBonus = 0;
    const myCT = ctMonthCounts.get(cand.name) || 0;
    const myRelief = (m.get("Relief 1") || 0) + (m.get("Relief 2") || 0);
    // Compute averages
    let avgCT = 0, avgRelief = 0, pCount = 0;
    for (const [nm, cnt] of ctMonthCounts) { avgCT += cnt; pCount++; }
    if (pCount > 0) avgCT /= pCount;
    if (channelCounts.size > 0) {
      let rSum = 0;
      for (const [, cm] of channelCounts) rSum += (cm.get("Relief 1") || 0) + (cm.get("Relief 2") || 0);
      avgRelief = rSum / channelCounts.size;
    }
    if (CH === "RELIEF 1" || CH === "RELIEF 2") {
      // Assigning Relief: bonus if person has high CT (they need more Relief to compensate)
      if (myCT > avgCT) ctReliefInverseBonus = (myCT - avgCT) * 120;
      // Penalty if person already has high Relief
      if (myRelief > avgRelief) ctReliefInverseBonus -= (myRelief - avgRelief) * 120;
    }

    // Channel balance: steep quadratic penalty for being above average, strong bonus for below
    // Fairness-first: 1 above = -400, 2 above = -1600, 3 above = -3600
    const myChCount = (channelCounts.get(cand.name) || new Map()).get(ch) || 0;
    const chDelta = myChCount - chAvgCount;
    const chBalancePenalty = chDelta > 0
      ? -(chDelta * chDelta * 400)   // steep quadratic penalty for max fairness
      : (Math.abs(chDelta) * 150);   // strong linear bonus to pull up under-assigned

    // Minimum floor bonus: strongly prefer channels where person has < 2 assignments
    // Massive bonus at 0 to avoid anyone ending up with only 1 of a channel
    let minFloorBonus = 0;
    if (PRIMARY_SET.has(CH) && myChCount < 2) {
      minFloorBonus = (2 - myChCount) * 800; // +1600 at 0, +800 at 1
    } else if (PRIMARY_SET.has(CH) && myChCount < 3) {
      minFloorBonus = 400; // strong bonus to reach 3
    }

    // Weekly primary channel variety: penalize repeating same primary within a week
    let weeklyPrimPenalty = 0;
    if (PRIMARY_SET.has(CH)) {
      const wkCount = pcwmap.get(`${cand.name}|${CH}`) || 0;
      if (wkCount >= 1) weeklyPrimPenalty = -wkCount * 500; // strong penalty for repeats
    }

    // Big push to satisfy weekly quotas, then prefer 8-hour chunks, then keep totals even
    return (needVal*100) + sameBonus + sdBonus + r1r2Penalty + ctrPriorityBonus + chBalancePenalty + minFloorBonus + ctReliefInverseBonus + weeklyPrimPenalty - (total*0.25);
  }

  // Helper: check if candidate works next block (for R1/R2 restriction)
  function worksNextBlock(cand) {
    const nextBlockIdx = bi + 1;
    if (nextBlockIdx < BLOCKS.length) {
      if (worksBlock(cand, dateObj, BLOCKS[nextBlockIdx])) return true;
    }
    if (bi === BLOCKS.length - 1) {
      const nextDay = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate() + 1, 12, 0, 0, 0);
      if (worksBlock(cand, nextDay, BLOCKS[0])) return true;
    }
    return false;
  }

  // Pass 1: STRICT – quota-driven + no immediate repeat + respect channel cycle + respect CT-bucket streak rule
  let best = null, bestScore = -1e9;
  for (const cand of shuffled) {
    if (usedNames.has(cand.name)) continue;

    // Training restriction: trainees can only work E, S, W, C
    if (!canTraineeWork(cand.name, CH, b.key)) continue;

    // R1/R2 restriction: In Pass 1, skip people who work next block
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;
    // Relief weekly cap: max 2 Relief blocks per person per work week
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && (rwmap.get(cand.name) || 0) >= WEEKLY_RELIEF_CAP) continue;
    if ((CH === "DC1" || CH === "DC2") && (dwmap.get(cand.name) || 0) >= WEEKLY_DC_CAP) continue;
    if (PRIMARY_SET.has(CH) && (pcwmap.get(`${cand.name}|${CH}`) || 0) >= WEEKLY_PRIMARY_CH_CAP) continue;

    // Same-day channel restriction: don't assign same channel twice in one day
    // Exception: allow back-to-back for primary geographic channels (max 2 consecutive)
    const candDayChannels = todayChannels.get(cand.name);
    if (candDayChannels && candDayChannels.has(CH)) {
      const lastCh = lastAssign.get(cand.name);
      if (!(lastCh && String(lastCh).toUpperCase() === CH && isAllowedPrimaryB2B(cand.name, CH))) continue;
    }

    // init/roll cycle
    if (!channelCycle.has(cand.name)) channelCycle.set(cand.name, new Set());
    const cyc = channelCycle.get(cand.name);
    if (cyc.size >= CHANNELS.length) cyc.clear();

    const last = lastAssign.get(cand.name);
    if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) continue;
    if (last && String(last).toUpperCase() === CH && !isAllowedPrimaryB2B(cand.name, CH)) continue;
    // Allow b2b for primary channels even if channel is in cycle
    if (cyc.has(ch) && !(last && String(last).toUpperCase() === CH && isAllowedPrimaryB2B(cand.name, CH))) continue;

    // (CT/Relief back-to-back now allowed — weekly caps enforce limits)

    const sc = candScore(cand);
    if (sc > bestScore) { bestScore=sc; best=cand; }
  }
  pick = best;

  // Pass 2: RELAX cycle (if staffing is too tight) – still enforce CT-bucket streak
  if (!pick) {
    best = null; bestScore = -1e9;
    for (const cand of shuffled) {
      if (usedNames.has(cand.name)) continue;

      // Training restriction: trainees can only work E, S, W, C
      if (!canTraineeWork(cand.name, CH, b.key)) continue;

      // R1/R2 restriction: In Pass 2, still skip people who work next block
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;
      // Relief weekly cap: max 2 Relief blocks per person per work week
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && (rwmap.get(cand.name) || 0) >= WEEKLY_RELIEF_CAP) continue;
    if ((CH === "DC1" || CH === "DC2") && (dwmap.get(cand.name) || 0) >= WEEKLY_DC_CAP) continue;
    if (PRIMARY_SET.has(CH) && (pcwmap.get(`${cand.name}|${CH}`) || 0) >= WEEKLY_PRIMARY_CH_CAP) continue;

      // Same-day channel restriction: don't assign same channel twice in one day
      // Exception: allow back-to-back for primary geographic channels (max 2 consecutive)
      const candDayChannels = todayChannels.get(cand.name);
      if (candDayChannels && candDayChannels.has(CH)) {
        const lastCh = lastAssign.get(cand.name);
        if (!(lastCh && String(lastCh).toUpperCase() === CH && isAllowedPrimaryB2B(cand.name, CH))) continue;
      }

      const last = lastAssign.get(cand.name);
      if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) continue;
      if (last && String(last).toUpperCase() === CH && !isAllowedPrimaryB2B(cand.name, CH)) continue;

      const sc = candScore(cand) - 15; // slight penalty vs strict
      if (sc > bestScore) { bestScore=sc; best=cand; }
    }
    pick = best;
  }

  // Pass 3: LAST RESORT – any available person (still enforce CT-bucket streak)
  if (!pick) {
    for (const cand of shuffled) {
      if (usedNames.has(cand.name)) continue;
      // Training restriction: trainees can only work E, S, W, C
      if (!canTraineeWork(cand.name, CH, b.key)) continue;
      // R1/R2 restriction: CRITICAL - still skip people who work next block even in Pass 3
      // This prevents Relief->CT back-to-back violations
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;
      // Relief weekly cap: max 2 Relief blocks per person per work week
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && (rwmap.get(cand.name) || 0) >= WEEKLY_RELIEF_CAP) continue;
    if ((CH === "DC1" || CH === "DC2") && (dwmap.get(cand.name) || 0) >= WEEKLY_DC_CAP) continue;
    if (PRIMARY_SET.has(CH) && (pcwmap.get(`${cand.name}|${CH}`) || 0) >= WEEKLY_PRIMARY_CH_CAP) continue;
      // Same-day channel restriction: don't assign same channel twice in one day
      // Exception: allow back-to-back for primary geographic channels (max 2 consecutive)
      const candDayChannels = todayChannels.get(cand.name);
      if (candDayChannels && candDayChannels.has(CH)) {
        const lastCh = lastAssign.get(cand.name);
        if (!(lastCh && String(lastCh).toUpperCase() === CH && isAllowedPrimaryB2B(cand.name, CH))) continue;
      }
      // Check forbiddenBackToBack even in Pass 3
      const last = lastAssign.get(cand.name);
      if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) continue;
      pick = cand; break;
    }
  }

  // If no pick found, skip this channel but continue with others
  // (Especially important for R1/R2 which may be skipped to prevent violations)
  if (!pick) continue;

  assignments[ch] = pick.name;
  usedNames.add(pick.name);
  lastAssign.set(pick.name, ch);

  // Track channel worked today (to prevent same channel twice in one day)
  if (!todayChannels.has(pick.name)) todayChannels.set(pick.name, new Set());
  todayChannels.get(pick.name).add(CH);

  // update cycle tracking
  if (!channelCycle.has(pick.name)) channelCycle.set(pick.name, new Set());
  const cyc = channelCycle.get(pick.name);
  if (cyc.size >= CHANNELS.length) cyc.clear();
  cyc.add(ch);

  // decrement weekly need if still owed
  const nd = getNeeds(wk, pick.name);
  if (nd[bucket] > 0) nd[bucket] -= 1;

  // update streaks
  updateStreaks(pick.name, String(ch).toUpperCase());

  // Track Relief weekly count
  if (CH === "RELIEF 1" || CH === "RELIEF 2") {
    rwmap.set(pick.name, (rwmap.get(pick.name) || 0) + 1);
  }
  // Track DC weekly count
  if (CH === "DC1" || CH === "DC2") {
    dwmap.set(pick.name, (dwmap.get(pick.name) || 0) + 1);
  }
  // Track primary channel weekly count
  if (PRIMARY_SET.has(CH)) {
    const pcKey = `${pick.name}|${CH}`;
    pcwmap.set(pcKey, (pcwmap.get(pcKey) || 0) + 1);
  }

  // update balancing counts
  if (!channelCounts.has(pick.name)) channelCounts.set(pick.name, new Map());
  const m = channelCounts.get(pick.name);
  m.set(ch, (m.get(ch)||0)+1);

  // Track SD employee channel usage (decrement remaining blocks)
  const pickUpper = String(pick.name).toUpperCase();
  if (SD_ELIGIBLE.has(pickUpper) && sdRemainingMap.has(pickUpper)) {
    const rem = sdRemainingMap.get(pickUpper) || 0;
    if (rem > 0) sdRemainingMap.set(pickUpper, rem - 1);
  }

  // Remove from must-get-channel list (they got their channel)
  mustGetChannelNextBlock.delete(pick.name);

  // If R1/R2 assigned and they work next block, they MUST get a channel next block
  // (This applies to Pass 1-3 as well, not just Pass 4)
  if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(pick)) {
    mustGetChannelNextBlock.add(pick.name);
  }
}

// ========== PASS 4: FILL ANY EMPTY CHANNELS ==========
// Multiple sub-passes with decreasing strictness to minimize violations
for (const ch of CHANNELS) {
  if (assignments[ch]) continue; // Already filled

  const CH = String(ch).toUpperCase();
  let pick = null;

  // Pass 4a: All checks - ideal candidate
  for (const cand of shuffled) {
    if (usedNames.has(cand.name)) continue;
    if (!canTraineeWork(cand.name, CH, b.key)) continue;
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;
    // Relief weekly cap
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && (rwmap.get(cand.name) || 0) >= WEEKLY_RELIEF_CAP) continue;
    if ((CH === "DC1" || CH === "DC2") && (dwmap.get(cand.name) || 0) >= WEEKLY_DC_CAP) continue;
    if (PRIMARY_SET.has(CH) && (pcwmap.get(`${cand.name}|${CH}`) || 0) >= WEEKLY_PRIMARY_CH_CAP) continue;
    const last = lastAssign.get(cand.name);
    if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) continue;
    const candDayChannels = todayChannels.get(cand.name);
    if (candDayChannels && candDayChannels.has(CH)) {
      if (!(last && String(last).toUpperCase() === CH && isAllowedPrimaryB2B(cand.name, CH))) continue;
    }
    pick = cand;
    break;
  }

  // Pass 4b: Skip worksNextBlock, keep forbiddenBackToBack and same-day
  // For R1/R2, prefer people without violations (they'll likely get a Relief->CT violation)
  if (!pick) {
    const candidates4b = shuffled.filter(cand => {
      if (usedNames.has(cand.name)) return false;
      if (!canTraineeWork(cand.name, CH, b.key)) return false;
      // Relief weekly cap
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && (rwmap.get(cand.name) || 0) >= WEEKLY_RELIEF_CAP) return false;
      if ((CH === "DC1" || CH === "DC2") && (dwmap.get(cand.name) || 0) >= WEEKLY_DC_CAP) return false;
      if (PRIMARY_SET.has(CH) && (pcwmap.get(`${cand.name}|${CH}`) || 0) >= WEEKLY_PRIMARY_CH_CAP) return false;
      const last = lastAssign.get(cand.name);
      if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) return false;
      const candDayChannels = todayChannels.get(cand.name);
      if (candDayChannels && candDayChannels.has(CH)) {
        if (!(last && String(last).toUpperCase() === CH && isAllowedPrimaryB2B(cand.name, CH))) return false;
      }
      return true;
    });
    // Sort: people without violations first (for R1/R2 that may cause violation)
    if ((CH === "RELIEF 1" || CH === "RELIEF 2")) {
      candidates4b.sort((a, b) => (violationCount.get(a.name.toUpperCase())||0) - (violationCount.get(b.name.toUpperCase())||0));
    }
    if (candidates4b.length > 0) pick = candidates4b[0];
  }

  // Pass 4c: Skip worksNextBlock and same-day, KEEP forbiddenBackToBack (most important)
  if (!pick) {
    const candidates4c = shuffled.filter(cand => {
      if (usedNames.has(cand.name)) return false;
      if (!canTraineeWork(cand.name, CH, b.key)) return false;
      // Relief weekly cap
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && (rwmap.get(cand.name) || 0) >= WEEKLY_RELIEF_CAP) return false;
      if ((CH === "DC1" || CH === "DC2") && (dwmap.get(cand.name) || 0) >= WEEKLY_DC_CAP) return false;
      if (PRIMARY_SET.has(CH) && (pcwmap.get(`${cand.name}|${CH}`) || 0) >= WEEKLY_PRIMARY_CH_CAP) return false;
      const last = lastAssign.get(cand.name);
      if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) return false;
      return true;
    });
    // Sort: people without violations first
    if ((CH === "RELIEF 1" || CH === "RELIEF 2")) {
      candidates4c.sort((a, b) => (violationCount.get(a.name.toUpperCase())||0) - (violationCount.get(b.name.toUpperCase())||0));
    }
    if (candidates4c.length > 0) pick = candidates4c[0];
  }

  // Pass 4d: Last resort - anyone available (channel MUST be filled)
  // Even here, prefer people without violations
  if (!pick) {
    const candidates4d = shuffled.filter(cand => {
      if (usedNames.has(cand.name)) return false;
      if (!canTraineeWork(cand.name, CH, b.key)) return false;
      return true;
    });
    candidates4d.sort((a, b) => (violationCount.get(a.name.toUpperCase())||0) - (violationCount.get(b.name.toUpperCase())||0));
    if (candidates4d.length > 0) pick = candidates4d[0];
  }

  if (pick) {
    assignments[ch] = pick.name;
    usedNames.add(pick.name);
    lastAssign.set(pick.name, ch);

    if (!todayChannels.has(pick.name)) todayChannels.set(pick.name, new Set());
    todayChannels.get(pick.name).add(CH);

    if (!channelCycle.has(pick.name)) channelCycle.set(pick.name, new Set());
    channelCycle.get(pick.name).add(ch);

    if (!channelCounts.has(pick.name)) channelCounts.set(pick.name, new Map());
    const m = channelCounts.get(pick.name);
    m.set(ch, (m.get(ch)||0)+1);

    updateStreaks(pick.name, CH);

    // Track Relief weekly count
    if (CH === "RELIEF 1" || CH === "RELIEF 2") {
      rwmap.set(pick.name, (rwmap.get(pick.name) || 0) + 1);
    }
    // Track DC weekly count
    if (CH === "DC1" || CH === "DC2") {
      dwmap.set(pick.name, (dwmap.get(pick.name) || 0) + 1);
    }
    // Track primary channel weekly count
    if (PRIMARY_SET.has(CH)) {
      const pcKey = `${pick.name}|${CH}`;
      pcwmap.set(pcKey, (pcwmap.get(pcKey) || 0) + 1);
    }

    // Remove from must-get-channel list if they were in it (they got a channel now)
    mustGetChannelNextBlock.delete(pick.name);

    // If R1/R2 assigned to someone who works next block, they MUST get a channel next block
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(pick)) {
      mustGetChannelNextBlock.add(pick.name);
    }
  }
}
// ========== END PASS 4 ==========

const filled = Object.keys(assignments).length;

      // ========== 7TH CHANNEL (Fri/Sat nights 2200-0300) ==========
      // On Friday (day 5) and Saturday (day 6), add an additional "7th" dispatcher channel
      const dayOfWeek = dateObj.getDay(); // 0=Sun, 5=Fri, 6=Sat
      const isFriOrSat = (dayOfWeek === 5 || dayOfWeek === 6);
      const is7thBlock = SEVENTH_BLOCKS.has(b.key);

      if (isFriOrSat && is7thBlock && filled >= 10) {
        // Find someone for 7th channel from remaining available
        const remaining7th = shuffled.filter(c => !usedNames.has(c.name) && !isTrainee(c.name, dayKey, b.key));

        // Sort by fewest total assignments (fairness)
        remaining7th.sort((a,b2)=>{
          const ma = channelCounts.get(a.name) || new Map();
          const mb = channelCounts.get(b2.name) || new Map();
          const ta = Array.from(ma.values()).reduce((s,v)=>s+v,0);
          const tb = Array.from(mb.values()).reduce((s,v)=>s+v,0);
          return ta - tb;
        });

        if (remaining7th.length > 0) {
          const pick7 = remaining7th[0];
          assignments[SEVENTH_CHANNEL] = pick7.name;
          usedNames.add(pick7.name);
          lastAssign.set(pick7.name, SEVENTH_CHANNEL);

          // Track 7th channel worked today (to prevent same channel twice in one day)
          if (!todayChannels.has(pick7.name)) todayChannels.set(pick7.name, new Set());
          todayChannels.get(pick7.name).add("7TH");

          // Update balancing counts for 7th
          if (!channelCounts.has(pick7.name)) channelCounts.set(pick7.name, new Map());
          const m7 = channelCounts.get(pick7.name);
          m7.set(SEVENTH_CHANNEL, (m7.get(SEVENTH_CHANNEL)||0)+1);
        }
      }
      // ========== END 7TH CHANNEL ==========

      // SD (Special Detail): Use pre-assigned SD from earlier calculation
      // SD is now assigned FIRST (32 hrs mandatory/week) before channels are filled
      const sd = sdForBlock.slice(); // Copy pre-assigned SD for this block

      // CT overflow: show as a vertical list later; CT does NOT count as a channel in cycle tracking
      const ct = [];


if (available.length > 10) {
  // CT overflow with HARD monthly caps:
  // - We try to keep CT split as evenly as possible across the month.
  // - If CT is unavoidable after caps are hit, we allow a controlled "repeat":
  //     * MAX once per week per person
  //     * MUST be back-to-back (consecutive 4-hr blocks)
    const wmap = ctWeekCounts.get(wk) || new Map();
  const globalIdx = (day-1) * BLOCKS.length + bi;

  function capFor(name){
    // HARD CAP: nobody can be assigned to CT more than 10 times per month
    return 10;
  }
  function canTakeChannel(name, ch){
    const last = lastAssign.get(name);
    if (last && forbiddenBackToBack(last, ch)) return false;
    const lastUpper = last ? String(last).toUpperCase() : "";
    const chUpper = String(ch).toUpperCase();
    if (last && lastUpper === chUpper && !isAllowedPrimaryB2B(name, ch)) return false;
    // Also check daily same-channel restriction (with b2b exception)
    const candDayChannels = todayChannels.get(name);
    if (candDayChannels && candDayChannels.has(chUpper)) {
      if (!(last && lastUpper === chUpper && isAllowedPrimaryB2B(name, ch))) return false;
    }
    return true;
  }
  function atOrOverCap(name){
    return (ctMonthCounts.get(name) || 0) >= capFor(name);
  }

  // CRITICAL: First, ensure anyone in mustGetChannelNextBlock gets a channel (to avoid Relief->CT)
  // These people were on R1/R2 last block and MUST get a channel now
  let remaining = shuffled.filter(c => !usedNames.has(c.name));

  const mustGetPeople = remaining.filter(c => mustGetChannelNextBlock.has(c.name));
  for (const cand of mustGetPeople) {
    // Try to swap them into any channel
    for (const ch of CHANNELS) {
      const cur = assignments[ch];
      if (!cur) continue; // Empty channel - shouldn't happen but skip
      if (!canTakeChannel(cand.name, ch)) continue;
      if (!canTraineeWork(cand.name, String(ch).toUpperCase(), b.key)) continue;

      // Check if current holder can go to CT (not on CTR recently)
      const holderLast = lastAssign.get(cur);
      const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
      const ctrSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
      if (ctrSet.has(holderLastUpper)) continue; // Holder can't go to CT
      if (mustGetChannelNextBlock.has(cur)) continue; // Holder also needs a channel
      if (b2bProtected.has(cur)) continue; // Don't undo b2b pre-assignments

      // Swap: cand gets channel, cur goes to CT pool
      assignments[ch] = cand.name;
      usedNames.add(cand.name);
      usedNames.delete(cur);
      lastAssign.set(cand.name, ch);

      const chUpper = String(ch).toUpperCase();
      if (!todayChannels.has(cand.name)) todayChannels.set(cand.name, new Set());
      todayChannels.get(cand.name).add(chUpper);

      if (!channelCounts.has(cand.name)) channelCounts.set(cand.name, new Map());
      channelCounts.get(cand.name).set(ch, (channelCounts.get(cand.name).get(ch)||0)+1);

      mustGetChannelNextBlock.delete(cand.name); // They got their channel
      break;
    }
    remaining = shuffled.filter(c => !usedNames.has(c.name));
  }

  // If someone is capped, try to swap them into a channel (so they don't land in CT),
  // pushing a non-capped person into overflow instead.
  remaining = shuffled.filter(c => !usedNames.has(c.name));

  const cappedNow = remaining.filter(c => atOrOverCap(c.name));
  for (const cand of cappedNow) {
    let swapped = false;

    for (const ch of CHANNELS) {
      const cur = assignments[ch];
      if (!cur) continue;

      // only swap out someone who is NOT capped
      if (atOrOverCap(cur)) continue;
      if (b2bProtected.has(cur)) continue; // Don't undo b2b pre-assignments
      if (!canTakeChannel(cand.name, ch)) continue;
      if (!canTraineeWork(cand.name, String(ch).toUpperCase(), b.key)) continue;

      // swap
      assignments[ch] = cand.name;
      usedNames.add(cand.name);
      usedNames.delete(cur);

      // keep lastAssign consistent for cand
      lastAssign.set(cand.name, ch);

      // Track swapped-in channel worked today
      const swapCH = String(ch).toUpperCase();
      if (!todayChannels.has(cand.name)) todayChannels.set(cand.name, new Set());
      todayChannels.get(cand.name).add(swapCH);

      // update balancing counts for cand
      if (!channelCounts.has(cand.name)) channelCounts.set(cand.name, new Map());
      const mm = channelCounts.get(cand.name);
      mm.set(ch, (mm.get(ch) || 0) + 1);

      swapped = true;
      break;
    }

    if (swapped) {
      remaining = shuffled.filter(c => !usedNames.has(c.name));
    }
  }

  // Now assign CT STRICTLY under the hard cap.
  // Weekly hard cap: max 2 CT blocks per person per work week
  remaining = shuffled.filter(c => !usedNames.has(c.name));

  // Sort priority: CT grouping (back-to-back) > under caps > lowest CT counts
  remaining.sort((a,b2)=>{
    // TOP PRIORITY: group CT back-to-back (person was just on CT last block)
    const lastA = lastAssign.get(a.name);
    const lastB = lastAssign.get(b2.name);
    const aWasCT = lastA && String(lastA).toUpperCase() === "CT";
    const bWasCT = lastB && String(lastB).toUpperCase() === "CT";
    if (aWasCT !== bWasCT) return aWasCT ? -1 : 1; // Was-on-CT goes first

    const ca = ctMonthCounts.get(a.name)||0;
    const cb = ctMonthCounts.get(b2.name)||0;
    const oa = ca >= capFor(a.name);
    const ob = cb >= capFor(b2.name);

    // Weekly CT counts for spreading across month
    const wca = wmap.get(a.name)||0;
    const wcb = wmap.get(b2.name)||0;
    const woa = wca >= WEEKLY_CT_CAP;
    const wob = wcb >= WEEKLY_CT_CAP;

    // Priority: under monthly cap first
    if (oa !== ob) return oa ? 1 : -1;
    // Then prefer under weekly cap (spread CT across weeks)
    if (woa !== wob) return woa ? 1 : -1;

    // CT/Relief inverse balance: prefer people with high Relief for CT (and vice versa)
    const mA = channelCounts.get(a.name) || new Map();
    const mB = channelCounts.get(b2.name) || new Map();
    const rA = (mA.get("Relief 1") || 0) + (mA.get("Relief 2") || 0);
    const rB = (mB.get("Relief 1") || 0) + (mB.get("Relief 2") || 0);
    const balA = ca - rA;
    const balB = cb - rB;
    if (balA !== balB) return balA - balB;

    // Then prefer lowest weekly CT (spread within week)
    if (wca !== wcb) return wca - wcb;
    // Then prefer lowest monthly CT
    if (ca !== cb) return ca - cb;
    return 0;
  });

  for (const cand of remaining) {
    const name = cand.name;
    // Training restriction: trainees should not be assigned to CT (date-only, all blocks)
    if (isTrainee(name, dayKey, b.key)) { continue; }

    // 12hr shift restriction: max 1 CT per day for 12-hour shift employees
    if (is12HrShift(cand, dateObj)) {
      const candDayCh = todayChannels.get(name);
      if (candDayCh && candDayCh.has("CT")) continue;
    }

    // CT/Relief back-to-back is now allowed (weekly caps enforce limits)

    const needs = getNeeds(wk, name);
    // Weekly mix rule: CT counts toward the CT/R1/R2 bucket (2 blocks / 8 hrs target)
    if ((needs.ctr || 0) <= 0) { continue; }

    const cur = ctMonthCounts.get(name) || 0;
    const cap = capFor(name);

    if (cur >= cap) {
      continue;
    }

    // Hard weekly CT cap: max 2 CT blocks per person per work week
    const weekCt = wmap.get(name)||0;
    if (weekCt >= WEEKLY_CT_CAP) {
      continue; // Skip - already at weekly CT cap
    }

    ct.push(name);
    // decrement weekly CT/R bucket need
    if ((needs.ctr||0) > 0) needs.ctr -= 1;
    updateStreaks(name, "CT");
    lastAssign.set(name, "CT"); // Track CT assignment for back-to-back prevention

    // Track CT in daily channels to prevent same-day repeat
    if (!todayChannels.has(name)) todayChannels.set(name, new Set());
    todayChannels.get(name).add("CT");

    wmap.set(name, (wmap.get(name) || 0) + 1);
    ctMonthCounts.set(name, cur + 1);
    lastCTAt.set(name, {dayKey, blockIdx: bi});
    lastCTGlobalIdx.set(name, globalIdx);
  }

  ctWeekCounts.set(wk, wmap);
}

// SAFETY NET: Anyone who is available but wasn't assigned to a channel or CT
// For people who were on CT/R1/R2, we MUST get them a channel to avoid back-to-back
const unassigned = available.filter(d => !usedNames.has(d.name));
const ctrNames = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);

for (const u of unassigned) {
  if (ct.includes(u.name)) continue;

  const lastCh = lastAssign.get(u.name);
  const lastUpper = lastCh ? String(lastCh).toUpperCase() : "";
  const wasOnCTR = ctrNames.has(lastUpper);

  // Also check if they had any CTR today (not just last block)
  const uDayChans = todayChannels.get(u.name);
  const hadCTRToday = uDayChans && (uDayChans.has("CT") || uDayChans.has("RELIEF 1") || uDayChans.has("RELIEF 2"));

  if (wasOnCTR || hadCTRToday) {
    // They were on CT/R1/R2 - MUST get a channel, not CT
    // Try to find an empty channel first
    let foundChannel = false;
    for (const ch of CHANNELS) {
      if (assignments[ch]) continue; // Already filled
      const chUpper = String(ch).toUpperCase();
      if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue; // Can't do R1/R2
      // Check daily same-channel restriction
      const uDayChannels = todayChannels.get(u.name);
      if (uDayChannels && uDayChannels.has(chUpper)) continue;
      if (!canTraineeWork(u.name, chUpper, b.key)) continue;
      if (!forbiddenBackToBack(lastUpper, chUpper)) {
        assignments[ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, ch);
        // Track channel worked today
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(chUpper);
        foundChannel = true;
        break;
      }
    }

    // If no empty channel, SWAP with someone who CAN go to CT (prefer no violations)
    if (!foundChannel) {
      const swapCands1 = [];
      for (const ch of CHANNELS) {
        const currentHolder = assignments[ch];
        if (!currentHolder) continue;
        if (b2bProtected.has(currentHolder)) continue; // Don't undo b2b pre-assignments
        if (isTrainee(currentHolder, dayKey, b.key)) continue; // Don't push trainee to CT during training blocks
        const chUpper = String(ch).toUpperCase();
        if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue;
        if (traineeBlocked(u.name, dayKey, null, chUpper)) continue; // Don't put trainee in disallowed channel
        if (forbiddenBackToBack(lastUpper, chUpper)) continue;
        const uDayChannels = todayChannels.get(u.name);
        if (uDayChannels && uDayChannels.has(chUpper)) continue;
        if (!canTraineeWork(u.name, chUpper, b.key)) continue;

        const holderLast = lastAssign.get(currentHolder);
        const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
        const holderWasOnCTR = ctrNames.has(holderLastUpper);
        const holderDayChannels = todayChannels.get(currentHolder);
        const holderHadCTToday = holderDayChannels && holderDayChannels.has("CT");
        const holderCTCount = ctMonthCounts.get(currentHolder) || 0;
        const holderAtCap = holderCTCount >= 10;

        if (!holderWasOnCTR && !holderHadCTToday && !holderAtCap) {
          const holderViol = violationCount.get(currentHolder.toUpperCase()) || 0;
          const holderWeekCT = (ctWeekCounts.get(wk) || new Map()).get(currentHolder) || 0;
          if (holderWeekCT < WEEKLY_CT_CAP) { // Hard filter: only under weekly cap
            swapCands1.push({ ch, chUpper, currentHolder, holderCTCount, holderViol, holderWeekCT });
          }
        }
      }
      // Sort: no violations first, then lowest CT
      swapCands1.sort((a, b) => {
        if (a.holderViol !== b.holderViol) return a.holderViol - b.holderViol;
        return a.holderCTCount - b.holderCTCount;
      });
      if (swapCands1.length > 0) {
        const best = swapCands1[0];
        assignments[best.ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, best.ch);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(best.chUpper);

        ct.push(best.currentHolder);
        lastAssign.set(best.currentHolder, "CT");
        updateStreaks(best.currentHolder, "CT");
        if (!todayChannels.has(best.currentHolder)) todayChannels.set(best.currentHolder, new Set());
        todayChannels.get(best.currentHolder).add("CT");
        ctMonthCounts.set(best.currentHolder, best.holderCTCount + 1);
        const wkMap = ctWeekCounts.get(wk) || new Map();
        wkMap.set(best.currentHolder, (wkMap.get(best.currentHolder) || 0) + 1);
        ctWeekCounts.set(wk, wkMap);

        foundChannel = true;
      }
    }

    // If still no channel, try harder to swap - find ANY channel holder who can go to CT (prefer no violations)
    if (!foundChannel) {
      const swapCands2 = [];
      for (const ch of CHANNELS) {
        const currentHolder = assignments[ch];
        if (!currentHolder) continue;
        if (b2bProtected.has(currentHolder)) continue; // Don't undo b2b pre-assignments
        if (isTrainee(currentHolder, dayKey, b.key)) continue; // Don't push trainee to CT during training blocks
        const chUpper = String(ch).toUpperCase();
        if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue;
        if (traineeBlocked(u.name, dayKey, null, chUpper)) continue; // Don't put trainee in disallowed channel
        if (forbiddenBackToBack(lastUpper, chUpper)) continue;
        const uDayChannels = todayChannels.get(u.name);
        if (uDayChannels && uDayChannels.has(chUpper)) continue;
        if (!canTraineeWork(u.name, chUpper, b.key)) continue;

        const holderLast = lastAssign.get(currentHolder);
        const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
        const holderWasOnCTR = ctrNames.has(holderLastUpper);
        const holderDayChannels = todayChannels.get(currentHolder);
        const holderHadCTRToday = holderDayChannels && (holderDayChannels.has("CT") || holderDayChannels.has("RELIEF 1") || holderDayChannels.has("RELIEF 2"));
        const holderCTCount2 = ctMonthCounts.get(currentHolder) || 0;
        const holderAtCap2 = holderCTCount2 >= 10;

        if (!holderWasOnCTR && !holderHadCTRToday && !holderAtCap2) {
          const holderViol = violationCount.get(currentHolder.toUpperCase()) || 0;
          const holderWeekCT2 = (ctWeekCounts.get(wk) || new Map()).get(currentHolder) || 0;
          if (holderWeekCT2 < WEEKLY_CT_CAP) { // Hard filter: only under weekly cap
            swapCands2.push({ ch, chUpper, currentHolder, holderCTCount2, holderViol, holderWeekCT2 });
          }
        }
      }
      // Sort: no violations first, then lowest CT
      swapCands2.sort((a, b) => {
        if (a.holderViol !== b.holderViol) return a.holderViol - b.holderViol;
        return a.holderCTCount2 - b.holderCTCount2;
      });
      if (swapCands2.length > 0) {
        const best = swapCands2[0];
        assignments[best.ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, best.ch);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(best.chUpper);

        ct.push(best.currentHolder);
        lastAssign.set(best.currentHolder, "CT");
        updateStreaks(best.currentHolder, "CT");
        if (!todayChannels.has(best.currentHolder)) todayChannels.set(best.currentHolder, new Set());
        todayChannels.get(best.currentHolder).add("CT");
        ctMonthCounts.set(best.currentHolder, best.holderCTCount2 + 1);
        const wkMap2 = ctWeekCounts.get(wk) || new Map();
        wkMap2.set(best.currentHolder, (wkMap2.get(best.currentHolder) || 0) + 1);
        ctWeekCounts.set(wk, wkMap2);

        foundChannel = true;
      }
    }

    // THIRD ATTEMPT: Allow swapping with someone OVER cap (uneven CT is better than violation)
    // Sort by CT count to prefer swapping with lowest CT person even if over cap
    if (!foundChannel) {
      const swapCandidates = [];
      for (const ch of CHANNELS) {
        const currentHolder = assignments[ch];
        if (!currentHolder) continue;
        if (b2bProtected.has(currentHolder)) continue; // Don't undo b2b pre-assignments
        if (isTrainee(currentHolder, dayKey, b.key)) continue; // Don't push trainee to CT during training blocks
        const chUpper = String(ch).toUpperCase();
        if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue;
        if (traineeBlocked(u.name, dayKey, null, chUpper)) continue; // Don't put trainee in disallowed channel
        if (forbiddenBackToBack(lastUpper, chUpper)) continue;
        const uDayChannels = todayChannels.get(u.name);
        if (uDayChannels && uDayChannels.has(chUpper)) continue;

        const holderLast = lastAssign.get(currentHolder);
        const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
        const holderWasOnCTR = ctrNames.has(holderLastUpper);
        const holderDayChannels = todayChannels.get(currentHolder);
        const holderHadCTRToday = holderDayChannels && (holderDayChannels.has("CT") || holderDayChannels.has("RELIEF 1") || holderDayChannels.has("RELIEF 2"));

        // Allow over-cap, but skip if they were on CTR or had CTR today (would cause violation)
        if (!holderWasOnCTR && !holderHadCTRToday) {
          const holderCT = ctMonthCounts.get(currentHolder) || 0;
          const holderWeekCT3 = (ctWeekCounts.get(wk) || new Map()).get(currentHolder) || 0;
          swapCandidates.push({ ch, chUpper, currentHolder, holderCT, holderWeekCT3 });
        }
      }

      // Sort by: 1) under weekly cap first, 2) no violations, 3) lowest CT count
      swapCandidates.sort((a, b) => {
        const aOver = a.holderWeekCT3 >= WEEKLY_CT_CAP ? 1 : 0;
        const bOver = b.holderWeekCT3 >= WEEKLY_CT_CAP ? 1 : 0;
        if (aOver !== bOver) return aOver - bOver;
        const aViol = violationCount.get(a.currentHolder.toUpperCase()) || 0;
        const bViol = violationCount.get(b.currentHolder.toUpperCase()) || 0;
        if (aViol !== bViol) return aViol - bViol; // Prefer no violations
        return a.holderCT - b.holderCT;
      });

      if (swapCandidates.length > 0) {
        const best = swapCandidates[0];
        assignments[best.ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, best.ch);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(best.chUpper);

        ct.push(best.currentHolder);
        lastAssign.set(best.currentHolder, "CT");
        updateStreaks(best.currentHolder, "CT");
        if (!todayChannels.has(best.currentHolder)) todayChannels.set(best.currentHolder, new Set());
        todayChannels.get(best.currentHolder).add("CT");
        ctMonthCounts.set(best.currentHolder, best.holderCT + 1);
        const wkMap3 = ctWeekCounts.get(wk) || new Map();
        wkMap3.set(best.currentHolder, (wkMap3.get(best.currentHolder) || 0) + 1);
        ctWeekCounts.set(wk, wkMap3);

        foundChannel = true;
      }
    }

    // Last resort: if still no channel, assign CT (violation is unavoidable)
    // But skip trainees — they must stay on allowed channels, not CT
    if (!foundChannel && !isTrainee(u.name, dayKey, b.key)) {
      ct.push(u.name);
      lastAssign.set(u.name, "CT");
      updateStreaks(u.name, "CT");
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add("CT");
      // UPDATE CT COUNTS
      ctMonthCounts.set(u.name, (ctMonthCounts.get(u.name) || 0) + 1);
      const wkMapLR = ctWeekCounts.get(wk) || new Map();
      wkMapLR.set(u.name, (wkMapLR.get(u.name) || 0) + 1);
      ctWeekCounts.set(wk, wkMapLR);
      // TRACK VIOLATION (Relief->CT back-to-back)
      addViolation(u.name);
    }
  } else if (!isTrainee(u.name, dayKey, b.key)) {
    // They weren't on CT/R1/R2 - check if they already had any CTR today
    const uDayChannels = todayChannels.get(u.name);
    const uHadCTRToday = uDayChannels && (uDayChannels.has("CT") || uDayChannels.has("RELIEF 1") || uDayChannels.has("RELIEF 2"));
    // Also check if they're at or over monthly CT cap or weekly CT cap
    const uCTCount = ctMonthCounts.get(u.name) || 0;
    const uWeekCT = (ctWeekCounts.get(wk) || new Map()).get(u.name) || 0;
    if (!uHadCTRToday && uCTCount < 10 && uWeekCT < WEEKLY_CT_CAP) {
      ct.push(u.name);
      lastAssign.set(u.name, "CT");
      updateStreaks(u.name, "CT");
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add("CT");
      // UPDATE CT COUNTS
      ctMonthCounts.set(u.name, uCTCount + 1);
      const wkMapElse = ctWeekCounts.get(wk) || new Map();
      wkMapElse.set(u.name, (wkMapElse.get(u.name) || 0) + 1);
      ctWeekCounts.set(wk, wkMapElse);
    }
    // If they already had CTR today or at cap, force CT anyway — unassigned is never acceptable
    if (!ct.includes(u.name) && !usedNames.has(u.name)) {
      ct.push(u.name);
      lastAssign.set(u.name, "CT");
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add("CT");
      ctMonthCounts.set(u.name, (ctMonthCounts.get(u.name) || 0) + 1);
      const wkMapForce = ctWeekCounts.get(wk) || new Map();
      wkMapForce.set(u.name, (wkMapForce.get(u.name) || 0) + 1);
      ctWeekCounts.set(wk, wkMapForce);
    }
  }
}

// TRAINEE RESCUE: Get unassigned trainees into allowed channels (E/S/W/C) via swap
const traineeUnassigned = available.filter(d => !usedNames.has(d.name) && !ct.includes(d.name) && !sd.includes(d.name) && isTrainee(d.name, dayKey, b.key));
for (const u of traineeUnassigned) {
  const _traineeAllowed = ["East","South","West","Central"];
  let placed = false;
  // Try empty allowed channel first
  for (const ch of _traineeAllowed) {
    if (!assignments[ch]) {
      assignments[ch] = u.name;
      usedNames.add(u.name);
      lastAssign.set(u.name, ch);
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add(ch.toUpperCase());
      placed = true;
      break;
    }
  }
  // If no empty slot, swap with a non-trainee on an allowed channel (prefer under weekly CT cap)
  if (!placed) {
    const _trSwapCands = [];
    for (const ch of _traineeAllowed) {
      const holder = assignments[ch];
      if (!holder) continue;
      if (isTrainee(holder, dayKey, b.key)) continue;
      const hWkCT = (ctWeekCounts.get(wk) || new Map()).get(holder) || 0;
      _trSwapCands.push({ ch, holder, hWkCT });
    }
    _trSwapCands.sort((a, b2) => a.hWkCT - b2.hWkCT); // lowest weekly CT first
    if (_trSwapCands.length > 0) {
      const pick = _trSwapCands[0];
      assignments[pick.ch] = u.name;
      usedNames.add(u.name);
      lastAssign.set(u.name, pick.ch);
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add(pick.ch.toUpperCase());
      ct.push(pick.holder);
      lastAssign.set(pick.holder, "CT");
      if (!todayChannels.has(pick.holder)) todayChannels.set(pick.holder, new Set());
      todayChannels.get(pick.holder).add("CT");
      ctMonthCounts.set(pick.holder, (ctMonthCounts.get(pick.holder) || 0) + 1);
      const wkMapTR = ctWeekCounts.get(wk) || new Map();
      wkMapTR.set(pick.holder, (wkMapTR.get(pick.holder) || 0) + 1);
      ctWeekCounts.set(wk, wkMapTR);
      placed = true;
    }
  }
}

// FINAL SWEEP: Catch anyone still not assigned (edge cases) — force to CT
const finalUnassigned = available.filter(d => !usedNames.has(d.name) && !ct.includes(d.name) && !sd.includes(d.name));
for (const u of finalUnassigned) {
  // Trainee restriction: never push trainee to CT — try allowed channel or leave unassigned
  if (isTrainee(u.name, dayKey, b.key)) {
    const _tOk = ["East","South","West","Central"];
    let _tPlaced = false;
    // Try empty allowed channel
    for (const _tCh of _tOk) {
      if (!assignments[_tCh]) {
        assignments[_tCh] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, _tCh);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(_tCh.toUpperCase());
        _tPlaced = true;
        break;
      }
    }
    // Try swapping with a non-trainee holder in an allowed channel (prefer under weekly CT cap)
    if (!_tPlaced) {
      const _tSwapCands = [];
      for (const _tCh of _tOk) {
        const _tH = assignments[_tCh];
        if (!_tH) continue;
        if (isTrainee(_tH, dayKey, b.key)) continue;
        const _tHwk = (ctWeekCounts.get(wk) || new Map()).get(_tH) || 0;
        _tSwapCands.push({ ch: _tCh, holder: _tH, wkCT: _tHwk });
      }
      _tSwapCands.sort((a, b2) => a.wkCT - b2.wkCT);
      if (_tSwapCands.length > 0) {
        const _tPick = _tSwapCands[0];
        assignments[_tPick.ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, _tPick.ch);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(_tPick.ch.toUpperCase());
        ct.push(_tPick.holder);
        lastAssign.set(_tPick.holder, "CT");
        if (!todayChannels.has(_tPick.holder)) todayChannels.set(_tPick.holder, new Set());
        todayChannels.get(_tPick.holder).add("CT");
        ctMonthCounts.set(_tPick.holder, (ctMonthCounts.get(_tPick.holder) || 0) + 1);
        const _twk = ctWeekCounts.get(wk) || new Map();
        _twk.set(_tPick.holder, (_twk.get(_tPick.holder) || 0) + 1);
        ctWeekCounts.set(wk, _twk);
        _tPlaced = true;
      }
    }
    continue; // never push trainee to CT
  }
  // 12hr shift: max 1 CT per day — skip if already had CT today
  if (is12HrShift(u, dateObj)) {
    const uDayCh = todayChannels.get(u.name);
    if (uDayCh && uDayCh.has("CT")) continue;
  }
  ct.push(u.name);
  lastAssign.set(u.name, "CT");
  if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
  todayChannels.get(u.name).add("CT");
  ctMonthCounts.set(u.name, (ctMonthCounts.get(u.name) || 0) + 1);
  const wkMapFinal = ctWeekCounts.get(wk) || new Map();
  wkMapFinal.set(u.name, (wkMapFinal.get(u.name) || 0) + 1);
  ctWeekCounts.set(wk, wkMapFinal);
}

      plan.days[dayKey][b.key] = { assignments, sd, ct, filled, needed: 10 };
    }
  }

  // ========== POST-PROCESSING: CHANNEL REBALANCING PASS ==========
  // Scan for per-channel imbalances and swap assignments to even them out.
  // Goal: every person should have a roughly equal count of each primary channel.
  const _ctrChSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2","DC1","DC2"]);
  // Only rebalance primary channels (N,S,E,W,NW,C)
  const rebalanceChannels = CHANNELS.filter(ch => !_ctrChSet.has(ch.toUpperCase()));

  // Build per-person channel counts from the final plan
  const finalCounts = new Map(); // name -> Map(channel -> count)
  const allAssignments = []; // [{dayKey, blockKey, channel, name}]
  {

    for (let day = 1; day <= daysInMonth; day++) {
      const dObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
      const dk = ymd(dObj);
      const dayData = plan.days[dk];
      if (!dayData) continue;
      for (const bk of BLOCKS) {
        const bd = dayData[bk.key];
        if (!bd || !bd.assignments) continue;
        for (const [ch, nm] of Object.entries(bd.assignments)) {
          if (!nm) continue;
          if (!finalCounts.has(nm)) finalCounts.set(nm, new Map());
          finalCounts.get(nm).set(ch, (finalCounts.get(nm).get(ch)||0) + 1);
          allAssignments.push({dayKey: dk, blockKey: bk.key, channel: ch, name: nm});
        }
      }
    }

    // Helper: get all channels a person works on a given day (for same-day-twice check)
    function _rebalDayChannels(personName, dayKey, excludeBlockKey) {
      const chs = new Set();
      const dayData = plan.days[dayKey];
      if (!dayData) return chs;
      for (const bk of BLOCKS) {
        if (bk.key === excludeBlockKey) continue;
        const bd = dayData[bk.key];
        if (!bd) continue;
        for (const [ch, nm] of Object.entries(bd.assignments || {})) {
          if (nm && String(nm).toUpperCase() === String(personName).toUpperCase()) chs.add(ch.toUpperCase());
        }
      }
      return chs;
    }

    // Run up to 10 rebalancing rounds
    for (let round = 0; round < 10; round++) {
      let swapped = false;
      const people = Array.from(finalCounts.keys());

      // Build swap candidates: pairs where one person has more of a channel than the other
      const swapCandidates = [];
      for (let i = 0; i < people.length; i++) {
        for (let j = i+1; j < people.length; j++) {
          const a = people[i], b = people[j];
          const ma = finalCounts.get(a), mb = finalCounts.get(b);
          for (const ch of rebalanceChannels) {
            const ca = ma.get(ch)||0, cb = mb.get(ch)||0;
            const diff = Math.abs(ca - cb);
            if (diff >= 2) {
              swapCandidates.push({a, b, ch, ca, cb, diff});
            }
          }
        }
      }
      // Sort by biggest imbalance first
      swapCandidates.sort((x,y) => y.diff - x.diff);

      for (const {a, b, ch, ca, cb} of swapCandidates) {
        // Determine who has more and who has less
        const over = ca > cb ? a : b;
        const under = ca > cb ? b : a;

        // Find a block where 'over' is on 'ch' and 'under' is on a different primary channel
        for (const entry of allAssignments) {
          if (entry.name !== over || entry.channel !== ch) continue;
          const dk = entry.dayKey, bk = entry.blockKey;
          const bd = plan.days[dk] && plan.days[dk][bk];
          if (!bd || !bd.assignments) continue;

          // Find what 'under' is assigned to in this same block
          let underCh = null;
          for (const [c2, nm2] of Object.entries(bd.assignments)) {
            if (nm2 === under) { underCh = c2; break; }
          }
          if (!underCh) continue; // 'under' doesn't work this block
          if (_ctrChSet.has(underCh.toUpperCase())) continue; // Don't swap CTR/DC channels
          if (underCh === ch) continue; // Same channel, no point

          // Re-check current counts to ensure swap still helps
          const overCounts = finalCounts.get(over);
          const underCounts = finalCounts.get(under);
          const overOnCh = overCounts.get(ch)||0;
          const underOnCh = underCounts.get(ch)||0;
          const overOnUnderCh = overCounts.get(underCh)||0;
          const underOnUnderCh = underCounts.get(underCh)||0;

          // Only swap if it reduces the spread for both channels
          if (overOnCh - underOnCh < 2) continue; // No longer imbalanced enough
          if (underOnUnderCh - overOnUnderCh < -1) continue; // Would create reverse imbalance

          // Safety: check same-channel-twice-in-day for both parties
          const overOtherChs = _rebalDayChannels(over, dk, bk);
          if (overOtherChs.has(underCh.toUpperCase())) continue; // 'over' already has underCh elsewhere today

          const underOtherChs = _rebalDayChannels(under, dk, bk);
          if (underOtherChs.has(ch.toUpperCase())) continue; // 'under' already has ch elsewhere today

          // Trainee restriction: don't swap trainee into restricted channel
          if (traineeBlocked(under, dk, bk, ch.toUpperCase())) continue;
          if (traineeBlocked(over, dk, bk, underCh.toUpperCase())) continue;

          // Perform the swap
          bd.assignments[ch] = under;
          bd.assignments[underCh] = over;

          // Update finalCounts
          overCounts.set(ch, (overCounts.get(ch)||0) - 1);
          overCounts.set(underCh, (overCounts.get(underCh)||0) + 1);
          underCounts.set(ch, (underCounts.get(ch)||0) + 1);
          underCounts.set(underCh, (underCounts.get(underCh)||0) - 1);

          // Update allAssignments entries
          entry.name = under;
          for (const e2 of allAssignments) {
            if (e2.dayKey === dk && e2.blockKey === bk && e2.name === under && e2.channel === underCh) {
              e2.name = over;
              break;
            }
          }

          swapped = true;
          break; // Move to next imbalance pair
        }
      }
      if (!swapped) break; // No more swaps possible
    }

    // --- Phase 2: Fine-tuning pass (diff >= 1, both parties must move toward average) ---
    // Compute per-channel averages across all people
    const chAvgs = new Map();
    for (const ch of rebalanceChannels) {
      let sum = 0, cnt = 0;
      for (const [nm, m] of finalCounts) {
        sum += (m.get(ch) || 0);
        cnt++;
      }
      chAvgs.set(ch, cnt > 0 ? sum / cnt : 0);
    }

    for (let round = 0; round < 10; round++) {
      let swapped = false;
      const people = Array.from(finalCounts.keys());

      const fineCandidates = [];
      for (let i = 0; i < people.length; i++) {
        for (let j = i + 1; j < people.length; j++) {
          const a = people[i], b = people[j];
          const ma = finalCounts.get(a), mb = finalCounts.get(b);
          for (const ch of rebalanceChannels) {
            const ca = ma.get(ch) || 0, cb = mb.get(ch) || 0;
            const avg = chAvgs.get(ch) || 0;
            // One must be above avg and the other below (or at) avg, with diff >= 1
            if (ca > cb && ca > avg && cb < avg) {
              fineCandidates.push({ over: a, under: b, ch, overCount: ca, underCount: cb, diff: ca - cb });
            } else if (cb > ca && cb > avg && ca < avg) {
              fineCandidates.push({ over: b, under: a, ch, overCount: cb, underCount: ca, diff: cb - ca });
            }
          }
        }
      }
      // Sort by biggest gap first
      fineCandidates.sort((a, b) => b.diff - a.diff);

      for (const { over, under, ch } of fineCandidates) {
        const overCounts = finalCounts.get(over);
        const underCounts = finalCounts.get(under);
        const overOnCh = overCounts.get(ch) || 0;
        const underOnCh = underCounts.get(ch) || 0;
        const avg = chAvgs.get(ch) || 0;
        if (overOnCh <= avg || underOnCh >= avg) continue; // No longer straddles average

        for (const entry of allAssignments) {
          if (entry.name !== over || entry.channel !== ch) continue;
          const dk = entry.dayKey, bk = entry.blockKey;
          const bd = plan.days[dk] && plan.days[dk][bk];
          if (!bd || !bd.assignments) continue;

          let underCh = null;
          for (const [c2, nm2] of Object.entries(bd.assignments)) {
            if (nm2 === under) { underCh = c2; break; }
          }
          if (!underCh) continue;
          if (_ctrChSet.has(underCh.toUpperCase())) continue;
          if (underCh === ch) continue;

          // Verify both channels improve: over loses ch (good), under gains ch (good),
          // but also check the swap channel doesn't create a worse imbalance
          const overOnUnderCh = overCounts.get(underCh) || 0;
          const underOnUnderCh = underCounts.get(underCh) || 0;
          const underChAvg = chAvgs.get(underCh) || 0;
          // Don't swap if it would push 'under' further above average on underCh
          // or push 'over' further above average on underCh
          if (overOnUnderCh + 1 > underChAvg + 1.5) continue;
          if (underOnUnderCh - 1 < underChAvg - 1.5) continue;

          // Same-day-channel-twice safety
          const overOtherChs = _rebalDayChannels(over, dk, bk);
          if (overOtherChs.has(underCh.toUpperCase())) continue;
          const underOtherChs = _rebalDayChannels(under, dk, bk);
          if (underOtherChs.has(ch.toUpperCase())) continue;

          // Trainee restriction
          if (traineeBlocked(under, dk, bk, ch.toUpperCase())) continue;
          if (traineeBlocked(over, dk, bk, underCh.toUpperCase())) continue;

          // Perform the swap
          bd.assignments[ch] = under;
          bd.assignments[underCh] = over;

          overCounts.set(ch, (overCounts.get(ch) || 0) - 1);
          overCounts.set(underCh, (overCounts.get(underCh) || 0) + 1);
          underCounts.set(ch, (underCounts.get(ch) || 0) + 1);
          underCounts.set(underCh, (underCounts.get(underCh) || 0) - 1);

          entry.name = under;
          for (const e2 of allAssignments) {
            if (e2.dayKey === dk && e2.blockKey === bk && e2.name === under && e2.channel === underCh) {
              e2.name = over;
              break;
            }
          }

          swapped = true;
          break;
        }
      }
      if (!swapped) break;
    }

    // --- Phase 3: Minimum floor enforcement (no one should have only 0 or 1 of any primary channel) ---
    const HARD_FLOOR = 2; // absolute minimum per channel

    // Build a lookup: for each person, which blocks do they appear in?
    const personBlocks = new Map(); // name -> [{dayKey, blockKey, channel}]
    for (const entry of allAssignments) {
      if (!personBlocks.has(entry.name)) personBlocks.set(entry.name, []);
      personBlocks.get(entry.name).push(entry);
    }

    for (let round = 0; round < 30; round++) {
      let swapped = false;
      const people = Array.from(finalCounts.keys());

      // Find people below the floor on any primary channel
      const deficits = [];
      for (const person of people) {
        const m = finalCounts.get(person);
        let totalPrimary = 0;
        for (const ch of rebalanceChannels) totalPrimary += (m.get(ch) || 0);
        // Skip people who don't have enough total primary blocks to meet floor across all channels
        // (e.g. SD people with only ~8 blocks can't have 2 of each of 6 channels = 12 needed)
        if (totalPrimary < HARD_FLOOR * rebalanceChannels.length) continue;

        for (const ch of rebalanceChannels) {
          const cnt = m.get(ch) || 0;
          if (cnt < HARD_FLOOR) {
            deficits.push({ person, ch, count: cnt, deficit: HARD_FLOOR - cnt });
          }
        }
      }
      if (deficits.length === 0) break;
      deficits.sort((a, b) => b.deficit - a.deficit); // worst deficits first

      for (const { person: under, ch } of deficits) {
        const underCounts = finalCounts.get(under);
        if ((underCounts.get(ch) || 0) >= HARD_FLOOR) continue;

        // Scan blocks where 'under' works — find a block-mate who has 'ch' and can donate
        const underBlocks = personBlocks.get(under) || [];
        let didSwap = false;

        for (const uEntry of underBlocks) {
          if (_ctrChSet.has(uEntry.channel.toUpperCase())) continue;
          if (uEntry.channel === ch) continue;

          const dk = uEntry.dayKey, bk = uEntry.blockKey;
          const bd = plan.days[dk] && plan.days[dk][bk];
          if (!bd || !bd.assignments) continue;

          if (bd.assignments[uEntry.channel] !== under) continue;

          const donor = bd.assignments[ch];
          if (!donor || donor === under) continue;

          const donorCounts = finalCounts.get(donor);
          if (!donorCounts) continue;
          // Donor must have at least 3 of this channel (keeps them at 2+ after giving one)
          if ((donorCounts.get(ch) || 0) < 3) continue;

          const underCh = uEntry.channel;

          // Under must keep at least 2 of the channel they're giving up
          if ((underCounts.get(underCh) || 0) < 3) continue;

          // Don't push donor too far above avg on the channel they receive
          const donorOnUnderCh = donorCounts.get(underCh) || 0;
          const ucAvg = chAvgs.get(underCh) || 0;
          if (donorOnUnderCh + 1 > ucAvg + 3) continue;

          // Same-day-channel-twice safety
          const donorOtherChs = _rebalDayChannels(donor, dk, bk);
          if (donorOtherChs.has(underCh.toUpperCase())) continue;
          const underOtherChs = _rebalDayChannels(under, dk, bk);
          if (underOtherChs.has(ch.toUpperCase())) continue;

          // Trainee restriction
          if (traineeBlocked(under, dk, bk, ch.toUpperCase())) continue;
          if (traineeBlocked(donor, dk, bk, underCh.toUpperCase())) continue;

          bd.assignments[ch] = under;
          bd.assignments[underCh] = donor;

          donorCounts.set(ch, (donorCounts.get(ch) || 0) - 1);
          donorCounts.set(underCh, (donorCounts.get(underCh) || 0) + 1);
          underCounts.set(ch, (underCounts.get(ch) || 0) + 1);
          underCounts.set(underCh, (underCounts.get(underCh) || 0) - 1);

          uEntry.channel = ch;
          for (const e2 of allAssignments) {
            if (e2.dayKey === dk && e2.blockKey === bk && e2.name === donor && e2.channel === ch) {
              e2.channel = underCh;
              break;
            }
          }

          swapped = true;
          didSwap = true;
          break;
        }
      }
      if (!swapped) break;
    }

    // --- Phase 4: Emergency floor — aggressively fix anyone still at 0 or 1 ---
    // Relaxes constraints: donor only needs > 2, under can give up down to 2
    for (let round = 0; round < 30; round++) {
      let swapped = false;
      const people = Array.from(finalCounts.keys());

      const deficits = [];
      for (const person of people) {
        const m = finalCounts.get(person);
        let totalPrimary = 0;
        for (const ch of rebalanceChannels) totalPrimary += (m.get(ch) || 0);
        if (totalPrimary < HARD_FLOOR * rebalanceChannels.length) continue;

        for (const ch of rebalanceChannels) {
          const cnt = m.get(ch) || 0;
          if (cnt < HARD_FLOOR) {
            deficits.push({ person, ch, count: cnt, deficit: HARD_FLOOR - cnt });
          }
        }
      }
      if (deficits.length === 0) break;
      deficits.sort((a, b) => b.deficit - a.deficit);

      for (const { person: under, ch } of deficits) {
        const underCounts = finalCounts.get(under);
        if ((underCounts.get(ch) || 0) >= HARD_FLOOR) continue;

        const underBlocks = personBlocks.get(under) || [];
        let didSwap = false;

        for (const uEntry of underBlocks) {
          if (_ctrChSet.has(uEntry.channel.toUpperCase())) continue;
          if (uEntry.channel === ch) continue;

          const dk = uEntry.dayKey, bk = uEntry.blockKey;
          const bd = plan.days[dk] && plan.days[dk][bk];
          if (!bd || !bd.assignments) continue;
          if (bd.assignments[uEntry.channel] !== under) continue;

          const donor = bd.assignments[ch];
          if (!donor || donor === under) continue;

          const donorCounts = finalCounts.get(donor);
          if (!donorCounts) continue;
          // Relaxed: donor just needs > 2 (keeps them at 2 after giving)
          if ((donorCounts.get(ch) || 0) <= 2) continue;

          const underCh = uEntry.channel;
          // Relaxed: under just needs > 1 (keeps them at 1 after giving — not ideal but fixes a 0)
          if ((underCounts.get(underCh) || 0) <= 1) continue;

          // Same-day-channel-twice safety
          const donorOtherChs = _rebalDayChannels(donor, dk, bk);
          if (donorOtherChs.has(underCh.toUpperCase())) continue;
          const underOtherChs = _rebalDayChannels(under, dk, bk);
          if (underOtherChs.has(ch.toUpperCase())) continue;

          // Trainee restriction
          if (traineeBlocked(under, dk, bk, ch.toUpperCase())) continue;
          if (traineeBlocked(donor, dk, bk, underCh.toUpperCase())) continue;

          bd.assignments[ch] = under;
          bd.assignments[underCh] = donor;

          donorCounts.set(ch, (donorCounts.get(ch) || 0) - 1);
          donorCounts.set(underCh, (donorCounts.get(underCh) || 0) + 1);
          underCounts.set(ch, (underCounts.get(ch) || 0) + 1);
          underCounts.set(underCh, (underCounts.get(underCh) || 0) - 1);

          uEntry.channel = ch;
          for (const e2 of allAssignments) {
            if (e2.dayKey === dk && e2.blockKey === bk && e2.name === donor && e2.channel === ch) {
              e2.channel = underCh;
              break;
            }
          }

          swapped = true;
          didSwap = true;
          break;
        }
      }
      if (!swapped) break;
    }
  }
  // ========== END CHANNEL REBALANCING PASS ==========

  // NOTE: Per-shift balancing moved to run AFTER CT/grouped/SD passes (see below)


  // ========== SD PEOPLE: USE THEIR FEW CHANNEL BLOCKS TO MAXIMIZE BALANCE ==========
  // SD-eligible people only get ~2 channel blocks per week. Reassign those blocks
  // to whichever primary channel is most underrepresented globally.
  {
    const sdPrimaryChannels = rebalanceChannels; // N,E,S,W,NW,C
    const sdCtrExclude = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2","DC1","DC2"]);

    // Collect SD people's channel assignments
    const sdChAssignments = []; // [{dayKey, blockKey, channel, name}]
    for (const entry of allAssignments) {
      if (!SD_ELIGIBLE.has(entry.name.toUpperCase())) continue;
      if (sdCtrExclude.has(entry.channel.toUpperCase())) continue;
      sdChAssignments.push(entry);
    }

    if (sdChAssignments.length > 0) {
      // Helper: compute global average count per primary channel (across ALL people)
      function _globalChAvg(ch) {
        let sum = 0, cnt = 0;
        for (const [, m] of finalCounts) { sum += (m.get(ch) || 0); cnt++; }
        return cnt > 0 ? sum / cnt : 0;
      }

      // Helper: find which primary channel has the biggest deficit globally
      // (lowest count relative to average)
      function _mostNeededChannel(excludeChannels) {
        let bestCh = null, bestDeficit = -Infinity;
        for (const ch of sdPrimaryChannels) {
          if (excludeChannels && excludeChannels.has(ch.toUpperCase())) continue;
          const avg = _globalChAvg(ch);
          // Sum up how much everyone is below average on this channel
          let totalDeficit = 0;
          for (const [, m] of finalCounts) {
            const c = m.get(ch) || 0;
            if (c < avg) totalDeficit += (avg - c);
          }
          if (totalDeficit > bestDeficit) { bestDeficit = totalDeficit; bestCh = ch; }
        }
        return bestCh;
      }

      // Helper: day channels for person (for same-day-twice safety)
      function _sdDayChannels(personName, dayKey, excludeBlockKey) {
        const chs = new Set();
        const dayData = plan.days[dayKey];
        if (!dayData) return chs;
        for (const bk of BLOCKS) {
          if (bk.key === excludeBlockKey) continue;
          const bd = dayData[bk.key];
          if (!bd) continue;
          for (const [ch, nm] of Object.entries(bd.assignments || {})) {
            if (nm && String(nm).toUpperCase() === String(personName).toUpperCase()) chs.add(ch.toUpperCase());
          }
        }
        return chs;
      }

      // For each SD person's channel assignment, try to swap it to the most-needed channel
      for (let round = 0; round < 5; round++) {
        let swapped = false;

        for (const entry of sdChAssignments) {
          const dk = entry.dayKey, bk = entry.blockKey;
          const bd = plan.days[dk] && plan.days[dk][bk];
          if (!bd || !bd.assignments) continue;
          const sdName = entry.name;
          const currentCh = entry.channel;

          // Skip if this assignment no longer matches the plan (already swapped)
          if (bd.assignments[currentCh] !== sdName) continue;

          // Find the most-needed channel globally
          const sdDayChs = _sdDayChannels(sdName, dk, bk);
          const needCh = _mostNeededChannel(sdDayChs); // exclude channels SD person already has today
          if (!needCh || needCh === currentCh) continue;

          // Check if someone else in this block has the needed channel and can swap
          const otherName = bd.assignments[needCh];
          if (!otherName) continue;
          if (SD_ELIGIBLE.has(String(otherName).toUpperCase())) continue; // don't swap between SD people

          // Safety: other person can't already have currentCh today
          const otherDayChs = _sdDayChannels(otherName, dk, bk);
          if (otherDayChs.has(currentCh.toUpperCase())) continue;

          // Safety: SD person can't already have needCh today (already excluded above)
          // Safety: don't drop other person's count of needCh below 2
          const otherCounts = finalCounts.get(otherName);
          if (otherCounts && (otherCounts.get(needCh) || 0) <= 2) continue;

          // Trainee restriction
          if (traineeBlocked(sdName, dk, bk, needCh.toUpperCase())) continue;
          if (traineeBlocked(otherName, dk, bk, currentCh.toUpperCase())) continue;

          // Perform the swap
          bd.assignments[currentCh] = otherName;
          bd.assignments[needCh] = sdName;

          // Update finalCounts
          const sdCounts = finalCounts.get(sdName);
          if (sdCounts) {
            sdCounts.set(currentCh, (sdCounts.get(currentCh) || 0) - 1);
            sdCounts.set(needCh, (sdCounts.get(needCh) || 0) + 1);
          }
          if (otherCounts) {
            otherCounts.set(needCh, (otherCounts.get(needCh) || 0) - 1);
            otherCounts.set(currentCh, (otherCounts.get(currentCh) || 0) + 1);
          }

          // Update allAssignments tracking
          entry.channel = needCh;
          for (const e2 of allAssignments) {
            if (e2.dayKey === dk && e2.blockKey === bk && e2.name === otherName && e2.channel === needCh) {
              e2.channel = currentCh;
              break;
            }
          }

          swapped = true;
        }
        if (!swapped) break;
      }
    }
  }
  // ========== END SD BALANCING ==========

  // ========== GROUPED CHANNEL BALANCING PASS (R1/R2 and DC1/DC2) ==========
  // R1 & R2 are functionally identical, as are DC1 & DC2.
  // Balance the combined total of each group across all dispatchers.
  {
    const ctrUpper = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
    const dcUpper = new Set(["DC1","DC2"]);

    // Helper: get all channels a person is assigned on a given day
    function _personDayChannels(personName, dayKey) {
      const channels = new Set();
      const dayData = plan.days[dayKey];
      if (!dayData) return channels;
      for (const bk of BLOCKS) {
        const bd = dayData[bk.key];
        if (!bd) continue;
        for (const [ch, nm] of Object.entries(bd.assignments || {})) {
          if (nm && String(nm).toUpperCase() === String(personName).toUpperCase()) channels.add(ch.toUpperCase());
        }
        for (const nm of (bd.ct || [])) {
          if (String(nm).toUpperCase() === String(personName).toUpperCase()) channels.add("CT");
        }
      }
      return channels;
    }

    // Helper: count how many CT, Relief, DC, or specific primary channel blocks a person has in a given week
    function _countWeeklyInPlan(personName, dayKey, type) {
      // type: "CT", "RELIEF", "DC", or a specific primary channel name (e.g. "NORTH")
      const nmUp = String(personName).toUpperCase();
      const dObj = new Date(dayKey + "T12:00:00");
      const targetWk = weekKeyFromDate(dObj);
      let count = 0;
      for (let d = 1; d <= daysInMonth; d++) {
        const dd = new Date(year, monthIndex, d, 12, 0, 0, 0);
        if (weekKeyFromDate(dd) !== targetWk) continue;
        const dk2 = ymd(dd);
        const dayData2 = plan.days[dk2];
        if (!dayData2) continue;
        for (const bk of BLOCKS) {
          const bd2 = dayData2[bk.key];
          if (!bd2) continue;
          if (type === "CT") {
            for (const nm of (bd2.ct || [])) {
              if (String(nm).toUpperCase() === nmUp) count++;
            }
          } else {
            for (const [ch, nm] of Object.entries(bd2.assignments || {})) {
              if (!nm) continue;
              const chUp = ch.toUpperCase();
              if (type === "RELIEF" && (chUp === "RELIEF 1" || chUp === "RELIEF 2") && String(nm).toUpperCase() === nmUp) count++;
              if (type === "DC" && (chUp === "DC1" || chUp === "DC2") && String(nm).toUpperCase() === nmUp) count++;
              if (type !== "RELIEF" && type !== "DC" && chUp === type && String(nm).toUpperCase() === nmUp) count++;
            }
          }
        }
      }
      return count;
    }

    // Helper: check if swapping would create a back-to-back violation for a person
    // Covers DC1/DC2 back-to-back (CT/Relief back-to-back is allowed)
    function _wouldCauseBackToBack(personName, dayKey, blockKey, newChannel) {
      const chUpper = String(newChannel).toUpperCase();
      const dayData = plan.days[dayKey];
      if (!dayData) return false;
      const bIdx = BLOCKS.findIndex(b => b.key === blockKey);
      if (bIdx < 0) return false;

      function _checkAdjacentBlock(adjBd) {
        if (!adjBd) return false;
        for (const [ch, nm] of Object.entries(adjBd.assignments || {})) {
          if (!nm || String(nm).toUpperCase() !== String(personName).toUpperCase()) continue;
          const adjUpper = ch.toUpperCase();
          // DC1/DC2 back-to-back
          if (dcUpper.has(chUpper) && dcUpper.has(adjUpper)) return true;
        }
        // (CT/Relief back-to-back is allowed — weekly caps enforce limits)
        return false;
      }

      if (bIdx > 0 && _checkAdjacentBlock(dayData[BLOCKS[bIdx - 1].key])) return true;
      if (bIdx < BLOCKS.length - 1 && _checkAdjacentBlock(dayData[BLOCKS[bIdx + 1].key])) return true;
      return false;
    }

    // Generic balancing function for a channel group
    function _balanceGroup(groupChannels, noSwapWith) {
      // Build per-person combined counts and index group assignments
      const grpCounts = new Map(); // name -> combined count
      const grpAssignments = []; // [{dayKey, blockKey, channel, name}]
      const allNames = new Set();

      for (let day = 1; day <= daysInMonth; day++) {
        const dObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
        const dk = ymd(dObj);
        const dayData = plan.days[dk];
        if (!dayData) continue;
        for (const bk of BLOCKS) {
          const bd = dayData[bk.key];
          if (!bd || !bd.assignments) continue;
          for (const [ch, nm] of Object.entries(bd.assignments)) {
            if (!nm) continue;
            allNames.add(nm);
            if (groupChannels.has(ch)) {
              grpCounts.set(nm, (grpCounts.get(nm) || 0) + 1);
              grpAssignments.push({ dayKey: dk, blockKey: bk.key, channel: ch, name: nm });
            }
          }
        }
      }

      // Initialize people with 0 group assignments
      for (const nm of allNames) {
        if (!grpCounts.has(nm)) grpCounts.set(nm, 0);
      }

      // Run up to 5 rebalancing rounds
      for (let round = 0; round < 5; round++) {
        let swappedAny = false;
        const people = Array.from(grpCounts.keys());
        if (people.length < 2) break;

        // Find over/under pairs sorted by biggest gap
        const pairs = [];
        for (let i = 0; i < people.length; i++) {
          for (let j = i + 1; j < people.length; j++) {
            const ca = grpCounts.get(people[i]) || 0;
            const cb = grpCounts.get(people[j]) || 0;
            const diff = Math.abs(ca - cb);
            if (diff >= 2) {
              pairs.push({ over: ca > cb ? people[i] : people[j], under: ca > cb ? people[j] : people[i], diff });
            }
          }
        }
        pairs.sort((a, b) => b.diff - a.diff);

        for (const { over, under } of pairs) {
          const overCount = grpCounts.get(over) || 0;
          const underCount = grpCounts.get(under) || 0;
          if (overCount - underCount < 2) continue;

          for (const gEntry of grpAssignments) {
            if (gEntry.name !== over) continue;
            const dk = gEntry.dayKey, bk = gEntry.blockKey;
            const bd = plan.days[dk] && plan.days[dk][bk];
            if (!bd || !bd.assignments) continue;

            // Verify 'over' is still on this channel
            if (bd.assignments[gEntry.channel] !== over) continue;

            // Find what 'under' is assigned to in this same block
            let underCh = null;
            for (const [c2, nm2] of Object.entries(bd.assignments)) {
              if (nm2 === under) { underCh = c2; break; }
            }
            if (!underCh) continue;
            if (groupChannels.has(underCh)) continue; // Both in same group — no point
            if (noSwapWith.has(underCh.toUpperCase())) continue; // Don't swap with excluded channels

            // Check same-channel-twice-in-day for 'under' getting the group channel
            const underDayCh = _personDayChannels(under, dk);
            if (underDayCh.has(gEntry.channel.toUpperCase())) continue;

            // Check same-channel-twice for 'over' getting underCh
            const overDayCh = _personDayChannels(over, dk);
            overDayCh.delete(gEntry.channel.toUpperCase());
            if (overDayCh.has(underCh.toUpperCase())) continue;

            // Check back-to-back for both parties
            if (_wouldCauseBackToBack(under, dk, bk, gEntry.channel)) continue;
            if (_wouldCauseBackToBack(over, dk, bk, underCh)) continue;

            // Trainee restriction
            if (traineeBlocked(under, dk, bk, gEntry.channel.toUpperCase())) continue;
            if (traineeBlocked(over, dk, bk, underCh.toUpperCase())) continue;

            // Weekly Relief cap: if 'under' is getting a Relief channel, check cap
            const _gChUp = gEntry.channel.toUpperCase();
            if ((_gChUp === "RELIEF 1" || _gChUp === "RELIEF 2") && _countWeeklyInPlan(under, dk, "RELIEF") >= 2) continue;
            // Weekly DC cap: if 'under' is getting a DC channel, check cap
            if ((_gChUp === "DC1" || _gChUp === "DC2") && _countWeeklyInPlan(under, dk, "DC") >= 2) continue;
            // Weekly primary channel cap: if swapping into a specific primary, check cap
            if (PRIMARY_SET.has(_gChUp) && _countWeeklyInPlan(under, dk, _gChUp) >= 2) continue;
            if (PRIMARY_SET.has(underCh.toUpperCase()) && _countWeeklyInPlan(over, dk, underCh.toUpperCase()) >= 2) continue;

            // Perform the swap
            bd.assignments[gEntry.channel] = under;
            bd.assignments[underCh] = over;

            grpCounts.set(over, (grpCounts.get(over) || 0) - 1);
            grpCounts.set(under, (grpCounts.get(under) || 0) + 1);
            gEntry.name = under;

            swappedAny = true;
            break;
          }
        }

        if (!swappedAny) break;
      }
    }

    // Balance R1/R2 combined — don't swap with CT or DC channels
    _balanceGroup(new Set(["Relief 1","Relief 2"]), new Set(["CT","RELIEF 1","RELIEF 2","R1","R2","DC1","DC2"]));

    // Balance DC1/DC2 combined — don't swap with CT or R channels
    _balanceGroup(new Set(["DC1","DC2"]), new Set(["CT","RELIEF 1","RELIEF 2","R1","R2","DC1","DC2"]));
  }
  // ========== END GROUPED CHANNEL BALANCING PASS ==========

  // ========== CT BALANCING PASS ==========
  // Swap-based CT balancing: 6 sub-passes (3 BTB levels × 2 threshold levels)
  {
    const DAY_BLK_SET2 = new Set(["0600-1000","1000-1400","1400-1800"]);
    const ctrAdj = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);

    // Reclassify people into shift groups
    const pShift2 = new Map();
    for (const entry of allAssignments) {
      if (!pShift2.has(entry.name)) pShift2.set(entry.name, { day: false, night: false });
      const s = pShift2.get(entry.name);
      if (DAY_BLK_SET2.has(entry.blockKey)) s.day = true; else s.night = true;
    }
    const dayPpl2 = new Set(), nightPpl2 = new Set(), splitPpl2 = new Set();
    for (const [name, s] of pShift2) {
      if (SD_ELIGIBLE.has(name.toUpperCase())) continue;
      if (s.day && s.night) splitPpl2.add(name);
      else if (s.day) dayPpl2.add(name);
      else nightPpl2.add(name);
    }

    function _balanceCT(groupPeople) {
      if (groupPeople.size < 2) return;

      // 6 sub-passes: 3 back-to-back levels × 2 threshold levels
      // Back-to-back: 0=Strict (CT+R1/R2), 1=Relaxed (CT only), 2=None
      // Thresholds: 0=Tight (over>ceil, under<floor), 1=Wide (over>floor, under<ceil)
      for (let btbLevel = 0; btbLevel < 3; btbLevel++) {
        for (let threshLevel = 0; threshLevel < 2; threshLevel++) {

        // Rebuild CT counts and entries from current plan state each sub-pass
        const ctCounts = new Map();
        for (const name of groupPeople) ctCounts.set(name, 0);
        const ctEntries = [];
        for (let day = 1; day <= daysInMonth; day++) {
          const dObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
          const dk = ymd(dObj);
          const dayData = plan.days[dk];
          if (!dayData) continue;
          for (const bk of BLOCKS) {
            const bd = dayData[bk.key];
            if (!bd || !bd.ct) continue;
            for (let ci = 0; ci < bd.ct.length; ci++) {
              const nm = bd.ct[ci];
              if (groupPeople.has(nm)) {
                ctCounts.set(nm, (ctCounts.get(nm) || 0) + 1);
                ctEntries.push({ dayKey: dk, blockKey: bk.key, ctIndex: ci, name: nm });
              }
            }
          }
        }

        const avgCT = [...ctCounts.values()].reduce((a, b) => a + b, 0) / groupPeople.size;
        const ceilCT = Math.ceil(avgCT);
        const floorCT = Math.floor(avgCT);

        // Early exit if already balanced (spread <= 1)
        const ctVals = [...ctCounts.values()];
        if (ctVals.length > 0 && Math.max(...ctVals) - Math.min(...ctVals) <= 1) return;

        // Tight: only extreme outliers. Wide: anyone above floor gives to anyone below ceil.
        const overThresh = threshLevel === 0 ? ceilCT : floorCT;
        const underThresh = threshLevel === 0 ? floorCT : ceilCT;

        for (let round = 0; round < 100; round++) {
          let swapped = false;
          ctEntries.sort((a, b) => (ctCounts.get(b.name) || 0) - (ctCounts.get(a.name) || 0));

          for (const entry of ctEntries) {
            const overName = entry.name;
            const overCT = ctCounts.get(overName) || 0;
            if (overCT <= overThresh) continue;

            const dk = entry.dayKey, bk = entry.blockKey;
            const bd = plan.days[dk] && plan.days[dk][bk];
            if (!bd || !bd.ct) continue;
            if (bd.ct[entry.ctIndex] !== overName) continue;

            // Over-CT person must have a channel assignment in this block
            let overHasChannel = false;
            for (const [, anm] of Object.entries(bd.assignments || {})) {
              if (anm === overName) { overHasChannel = true; break; }
            }
            if (!overHasChannel) continue;

            let bestUnder = null, bestUnderCT = Infinity;
            const bIdx = BLOCKS.findIndex(b => b.key === bk);
            for (const [ch, nm] of Object.entries(bd.assignments || {})) {
              if (!nm || nm === overName || !groupPeople.has(nm)) continue;
              if (bd.ct.includes(nm)) continue;
              if (isTrainee(nm, dk, bk)) continue; // Trainees can't be moved to CT during training blocks
              const uCT = ctCounts.get(nm) || 0;
              if (uCT >= underThresh) continue;

              // Back-to-back check depends on btbLevel
              if (btbLevel <= 1) {
                let btbConflict = false;
                for (const adjOff of [-1, 1]) {
                  const adjIdx = bIdx + adjOff;
                  if (adjIdx < 0 || adjIdx >= BLOCKS.length) continue;
                  const adjBd = plan.days[dk] && plan.days[dk][BLOCKS[adjIdx].key];
                  if (!adjBd) continue;
                  if (btbLevel === 0) {
                    // Strict: also check R1/R2 in adjacent channel assignments
                    for (const [ach, anm] of Object.entries(adjBd.assignments || {})) {
                      if (anm === nm && ctrAdj.has(ach.toUpperCase())) { btbConflict = true; break; }
                    }
                  }
                  // btbLevel 0 and 1: check CT in adjacent blocks
                  if (!btbConflict && adjBd.ct) {
                    for (const cnm of adjBd.ct) {
                      if (cnm === nm) { btbConflict = true; break; }
                    }
                  }
                  if (btbConflict) break;
                }
                if (btbConflict) continue;
              }
              // btbLevel 2: no back-to-back check at all

              // Weekly CT cap: don't give CT to someone already at 2 this week
              if (_countWeeklyInPlan(nm, dk, "CT") >= 2) continue;

              if (uCT < bestUnderCT) { bestUnderCT = uCT; bestUnder = nm; }
            }

            if (bestUnder) {
              bd.ct[entry.ctIndex] = bestUnder;
              ctCounts.set(overName, overCT - 1);
              ctCounts.set(bestUnder, bestUnderCT + 1);
              entry.name = bestUnder;
              swapped = true;
            }
          }

          if (!swapped) break;
        }
        }
      }
    }

    _balanceCT(dayPpl2);
    _balanceCT(nightPpl2);
    _balanceCT(splitPpl2);
  }
  // ========== END CT BALANCING ==========

  // ========== PER-SHIFT AGGRESSIVE BALANCING (Day, Night, Split) ==========
  // Moved to run LAST among primary-channel passes so SD/grouped/CT can't undo it.
  {
    const DAY_BLK_SET = new Set(["0600-1000","1000-1400","1400-1800"]);
    const ctrExclude = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2","DC1","DC2"]);

    const personShiftType = new Map();
    for (const entry of allAssignments) {
      if (!personShiftType.has(entry.name)) personShiftType.set(entry.name, { day: false, night: false });
      const s = personShiftType.get(entry.name);
      if (DAY_BLK_SET.has(entry.blockKey)) s.day = true; else s.night = true;
    }
    const dayOnlyPeople = new Set(), nightOnlyPeople = new Set(), splitPeople = new Set();
    for (const [name, s] of personShiftType) {
      if (SD_ELIGIBLE.has(name.toUpperCase())) continue;
      if (s.day && s.night) splitPeople.add(name);
      else if (s.day) dayOnlyPeople.add(name);
      else nightOnlyPeople.add(name);
    }

    // Smart same-day check: allows valid primary B2B pairs (consecutive blocks, max 2/day)
    const _primarySet = new Set(["NORTH","SOUTH","EAST","WEST","NORTHWEST","CENTRAL"]);
    function _wouldViolateSameDay(personName, dayKey, blockKey, newChannel) {
      const chUpper = String(newChannel).toUpperCase();
      const dayData = plan.days[dayKey];
      if (!dayData) return false;
      const bIdx = BLOCKS.findIndex(b => b.key === blockKey);
      if (bIdx < 0) return false;
      let existingCount = 0, hasAdjacentMatch = false;
      for (let bi = 0; bi < BLOCKS.length; bi++) {
        if (BLOCKS[bi].key === blockKey) continue;
        const bd = dayData[BLOCKS[bi].key];
        if (!bd || !bd.assignments) continue;
        for (const [ch, nm] of Object.entries(bd.assignments)) {
          if (nm === personName && ch.toUpperCase() === chUpper) {
            existingCount++;
            if (Math.abs(bi - bIdx) === 1) hasAdjacentMatch = true;
          }
        }
      }
      if (existingCount === 0) return false;
      if (_primarySet.has(chUpper) && hasAdjacentMatch && existingCount < 2) return false;
      return true;
    }

    function _balanceShiftGroup(groupName, groupPeople) {
      if (groupPeople.size < 2) return;

      // Rebuild counts from CURRENT plan state (after SD/grouped/CT passes)
      const grpCounts = new Map();
      const grpAssignments = [];
      for (const dk of Object.keys(plan.days)) {
        const dayData = plan.days[dk];
        for (const bk of BLOCKS) {
          const bd = dayData[bk.key];
          if (!bd || !bd.assignments) continue;
          for (const [ch, nm] of Object.entries(bd.assignments)) {
            if (!nm || !groupPeople.has(nm)) continue;
            if (!grpCounts.has(nm)) grpCounts.set(nm, new Map());
            grpCounts.get(nm).set(ch, (grpCounts.get(nm).get(ch) || 0) + 1);
            grpAssignments.push({ dayKey: dk, blockKey: bk.key, channel: ch, name: nm });
          }
        }
      }

      const grpPrimary = rebalanceChannels;
      const grpAvgs = new Map();

      function _grpSwap(personA, chA, personB, chB, dk, bk, bd, entryToUpdate) {
        bd.assignments[chA] = personB;
        bd.assignments[chB] = personA;
        const cA = grpCounts.get(personA), cB = grpCounts.get(personB);
        cA.set(chA, (cA.get(chA) || 0) - 1); cA.set(chB, (cA.get(chB) || 0) + 1);
        cB.set(chB, (cB.get(chB) || 0) - 1); cB.set(chA, (cB.get(chA) || 0) + 1);
        const fA = finalCounts.get(personA), fB = finalCounts.get(personB);
        if (fA) { fA.set(chA, (fA.get(chA) || 0) - 1); fA.set(chB, (fA.get(chB) || 0) + 1); }
        if (fB) { fB.set(chB, (fB.get(chB) || 0) - 1); fB.set(chA, (fB.get(chA) || 0) + 1); }
        if (entryToUpdate) entryToUpdate.channel = chB;
        for (const e2 of grpAssignments) {
          if (e2.dayKey === dk && e2.blockKey === bk && e2.name === personB && e2.channel === chB) {
            e2.channel = chA; break;
          }
        }
      }

      const grpFloors = new Map();
      const grpCeils = new Map();
      function _recomputeFloorCeil() {
        for (const ch of grpPrimary) {
          let sum = 0;
          for (const [, m] of grpCounts) sum += (m.get(ch) || 0);
          const avg = sum / groupPeople.size;
          grpAvgs.set(ch, avg);
          grpFloors.set(ch, Math.floor(avg));
          grpCeils.set(ch, Math.ceil(avg));
        }
      }
      _recomputeFloorCeil();

      // 6 passes: pairwise(strict/relaxed), ceiling(strict), floor(strict), ceiling(relaxed), floor(relaxed)
      for (let pass = 0; pass < 6; pass++) {
        const minDiff = pass === 0 ? 3 : 2;
        for (let round = 0; round < 80; round++) {
          let swapped = false;
          _recomputeFloorCeil();

          if (pass <= 1) {
            const candidates = [];
            const people = Array.from(groupPeople);
            for (let i = 0; i < people.length; i++) {
              for (let j = i + 1; j < people.length; j++) {
                const a = people[i], b = people[j];
                const ma = grpCounts.get(a), mb = grpCounts.get(b);
                for (const ch of grpPrimary) {
                  const ca = (ma.get(ch) || 0), cb = (mb.get(ch) || 0);
                  const diff = Math.abs(ca - cb);
                  if (diff >= minDiff) {
                    const over = ca > cb ? a : b, under = ca > cb ? b : a;
                    candidates.push({ over, under, ch, diff });
                  }
                }
              }
            }
            candidates.sort((a, b) => b.diff - a.diff);
            for (const { over, under, ch } of candidates) {
              const overC = grpCounts.get(over), underC = grpCounts.get(under);
              if ((overC.get(ch) || 0) - (underC.get(ch) || 0) < minDiff) continue;
              for (const entry of grpAssignments) {
                if (entry.name !== over || entry.channel !== ch) continue;
                const dk = entry.dayKey, bk = entry.blockKey;
                const bd = plan.days[dk] && plan.days[dk][bk];
                if (!bd || !bd.assignments || bd.assignments[ch] !== over) continue;
                let underCh = null;
                for (const [c2, nm2] of Object.entries(bd.assignments)) {
                  if (nm2 === under) { underCh = c2; break; }
                }
                if (!underCh || ctrExclude.has(underCh.toUpperCase()) || underCh === ch) continue;
                if ((underC.get(underCh) || 0) <= (grpFloors.get(underCh) || 2)) continue;
                if ((overC.get(ch) || 0) <= (grpFloors.get(ch) || 2)) continue;
                if (_wouldViolateSameDay(over, dk, bk, underCh)) continue;
                if (_wouldViolateSameDay(under, dk, bk, ch)) continue;
                if (traineeBlocked(over, dk, bk, underCh.toUpperCase())) continue;
                if (traineeBlocked(under, dk, bk, ch.toUpperCase())) continue;
                _grpSwap(over, ch, under, underCh, dk, bk, bd, entry);
                swapped = true;
                break;
              }
            }
          } else if (pass === 2 || pass === 4) {
            const ceilRelaxed = pass === 4;
            for (const person of groupPeople) {
              const pc = grpCounts.get(person);
              for (const ch of grpPrimary) {
                const dynCeil = grpCeils.get(ch) || 4;
                if ((pc.get(ch) || 0) <= dynCeil) continue;
                let didSwap = false;
                for (const entry of grpAssignments) {
                  if (entry.name !== person || entry.channel !== ch) continue;
                  const dk = entry.dayKey, bk = entry.blockKey;
                  const bd = plan.days[dk] && plan.days[dk][bk];
                  if (!bd || !bd.assignments || bd.assignments[ch] !== person) continue;
                  for (const [c2, nm2] of Object.entries(bd.assignments)) {
                    if (!nm2 || nm2 === person || c2 === ch) continue;
                    if (ctrExclude.has(c2.toUpperCase())) continue;
                    if (!groupPeople.has(nm2)) continue;
                    const otherC = grpCounts.get(nm2);
                    const personOnC2 = pc.get(c2) || 0;
                    if (!ceilRelaxed) {
                      const avgC2 = grpAvgs.get(c2) || 0;
                      if (personOnC2 >= avgC2) continue;
                    }
                    if ((otherC.get(c2) || 0) <= (ceilRelaxed ? 1 : 2)) continue;
                    if (_wouldViolateSameDay(person, dk, bk, c2)) continue;
                    if (_wouldViolateSameDay(nm2, dk, bk, ch)) continue;
                    if (traineeBlocked(person, dk, bk, c2.toUpperCase())) continue;
                    if (traineeBlocked(nm2, dk, bk, ch.toUpperCase())) continue;
                    _grpSwap(person, ch, nm2, c2, dk, bk, bd, entry);
                    swapped = true; didSwap = true; break;
                  }
                  if (didSwap) break;
                }
              }
            }
          } else {
            const floorRelaxed = pass === 5;
            for (const under of groupPeople) {
              const underC = grpCounts.get(under);
              for (const ch of grpPrimary) {
                const dynFloor = grpFloors.get(ch) || 2;
                if ((underC.get(ch) || 0) >= dynFloor) continue;
                for (const uEntry of grpAssignments) {
                  if (uEntry.name !== under) continue;
                  if (ctrExclude.has(uEntry.channel.toUpperCase())) continue;
                  if (uEntry.channel === ch) continue;
                  const dk = uEntry.dayKey, bk = uEntry.blockKey;
                  const bd = plan.days[dk] && plan.days[dk][bk];
                  if (!bd || !bd.assignments || bd.assignments[uEntry.channel] !== under) continue;
                  const donor = bd.assignments[ch];
                  if (!donor || !groupPeople.has(donor)) continue;
                  const donorC = grpCounts.get(donor);
                  if ((donorC.get(ch) || 0) <= (floorRelaxed ? 1 : 2)) continue;
                  const underCh = uEntry.channel;
                  if ((underC.get(underCh) || 0) <= (floorRelaxed ? 0 : 1)) continue;
                  if (_wouldViolateSameDay(donor, dk, bk, underCh)) continue;
                  if (_wouldViolateSameDay(under, dk, bk, ch)) continue;
                  if (traineeBlocked(under, dk, bk, ch.toUpperCase())) continue;
                  if (traineeBlocked(donor, dk, bk, uEntry.channel.toUpperCase())) continue;
                  _grpSwap(under, uEntry.channel, donor, ch, dk, bk, bd, uEntry);
                  swapped = true; break;
                }
              }
            }
          }
          if (!swapped) break;
        }
      }

      // EXTREME OUTLIER PASS: ceil(avg) enforcement with 2 sub-passes (partner-floor 1 then 0)
      for (let extremeMode = 0; extremeMode < 2; extremeMode++) {
        const partnerFloor = extremeMode === 0 ? 1 : 0;
        const extremeSkip = new Set();
        for (let eRound = 0; eRound < 200; eRound++) {
          _recomputeFloorCeil();
          let worstPerson = null, worstCh = null, worstExcess = 0;
          for (const person of groupPeople) {
            const pc = grpCounts.get(person);
            for (const ch of grpPrimary) {
              const count = pc.get(ch) || 0;
              const dynCeil = grpCeils.get(ch) || 4;
              const excess = count - dynCeil;
              if (excess > 0 && excess > worstExcess && !extremeSkip.has(person + "|" + ch)) {
                worstExcess = excess; worstPerson = person; worstCh = ch;
              }
            }
          }
          if (!worstPerson) break;
          let fixed = false;
          for (const entry of grpAssignments) {
            if (entry.name !== worstPerson || entry.channel !== worstCh) continue;
            const dk = entry.dayKey, bk = entry.blockKey;
            const bd = plan.days[dk] && plan.days[dk][bk];
            if (!bd || !bd.assignments || bd.assignments[worstCh] !== worstPerson) continue;
            let bestPartner = null, bestPartnerCh = null, bestScore = -Infinity;
            for (const [c2, nm2] of Object.entries(bd.assignments)) {
              if (!nm2 || nm2 === worstPerson || c2 === worstCh) continue;
              if (ctrExclude.has(c2.toUpperCase())) continue;
              if (!groupPeople.has(nm2)) continue;
              const pC = grpCounts.get(nm2);
              if ((pC.get(c2) || 0) <= partnerFloor) continue;
              if (_wouldViolateSameDay(worstPerson, dk, bk, c2)) continue;
              if (_wouldViolateSameDay(nm2, dk, bk, worstCh)) continue;
              if (traineeBlocked(worstPerson, dk, bk, c2.toUpperCase())) continue;
              if (traineeBlocked(nm2, dk, bk, worstCh.toUpperCase())) continue;
              const score = ((grpAvgs.get(worstCh) || 0) - (pC.get(worstCh) || 0))
                          + ((pC.get(c2) || 0) - (grpAvgs.get(c2) || 0));
              if (score > bestScore) { bestScore = score; bestPartner = nm2; bestPartnerCh = c2; }
            }
            if (bestPartner) {
              _grpSwap(worstPerson, worstCh, bestPartner, bestPartnerCh, dk, bk, bd, entry);
              fixed = true; break;
            }
          }
          if (!fixed) extremeSkip.add(worstPerson + "|" + worstCh);
        }
      }

      // FLOOR OUTLIER PASS: floor(avg) enforcement with 2 sub-passes (donor-floor 2 then 1)
      for (let floorMode = 0; floorMode < 2; floorMode++) {
        const donorFloor = floorMode === 0 ? 2 : 1;
        const floorSkip = new Set();
        for (let fRound = 0; fRound < 200; fRound++) {
          _recomputeFloorCeil();
          let worstPerson = null, worstCh = null, worstDeficit = 0;
          for (const person of groupPeople) {
            const pc = grpCounts.get(person);
            for (const ch of grpPrimary) {
              const deficit = (grpFloors.get(ch) || 2) - (pc.get(ch) || 0);
              if (deficit > 0 && deficit > worstDeficit && !floorSkip.has(person + "|" + ch)) {
                worstDeficit = deficit; worstPerson = person; worstCh = ch;
              }
            }
          }
          if (!worstPerson) break;
          let fixed = false;
          for (const entry of grpAssignments) {
            if (entry.name !== worstPerson) continue;
            if (ctrExclude.has(entry.channel.toUpperCase())) continue;
            if (entry.channel === worstCh) continue;
            const surplusCh = entry.channel;
            if ((grpCounts.get(worstPerson).get(surplusCh) || 0) <= (grpFloors.get(surplusCh) || 2)) continue;
            const dk = entry.dayKey, bk = entry.blockKey;
            const bd = plan.days[dk] && plan.days[dk][bk];
            if (!bd || !bd.assignments || bd.assignments[surplusCh] !== worstPerson) continue;
            const donor = bd.assignments[worstCh];
            if (!donor || !groupPeople.has(donor) || donor === worstPerson) continue;
            const donorC = grpCounts.get(donor);
            if ((donorC.get(worstCh) || 0) <= donorFloor) continue;
            if (_wouldViolateSameDay(worstPerson, dk, bk, worstCh)) continue;
            if (_wouldViolateSameDay(donor, dk, bk, surplusCh)) continue;
            if (traineeBlocked(worstPerson, dk, bk, worstCh.toUpperCase())) continue;
            if (traineeBlocked(donor, dk, bk, surplusCh.toUpperCase())) continue;
            _grpSwap(worstPerson, surplusCh, donor, worstCh, dk, bk, bd, entry);
            fixed = true; break;
          }
          if (!fixed) floorSkip.add(worstPerson + "|" + worstCh);
        }
      }
    }

    _balanceShiftGroup("DAY", dayOnlyPeople);
    _balanceShiftGroup("NIGHT", nightOnlyPeople);
    _balanceShiftGroup("SPLIT", splitPeople);
  }
  // ========== END PER-SHIFT BALANCING ==========

  // ========== B2B EVENING PASS ==========
  // Scan for back-to-back same-primary-channel pairs and even them out across people.
  {
    const _b2bPrimary = new Set(["NORTH","EAST","SOUTH","WEST","NORTHWEST","CENTRAL"]);
    const _b2bCtrExclude = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2","DC1","DC2"]);

    // Rebuild channel counts from current plan state (finalCounts may be stale after convergence loop)
    const _b2bChCounts = new Map();
    for (const dk of Object.keys(plan.days)) {
      const dayData = plan.days[dk];
      for (const bk of BLOCKS) {
        const bd = dayData[bk.key];
        if (!bd || !bd.assignments) continue;
        for (const [ch, nm] of Object.entries(bd.assignments)) {
          if (!nm) continue;
          if (!_b2bChCounts.has(nm)) _b2bChCounts.set(nm, new Map());
          const m = _b2bChCounts.get(nm);
          m.set(ch.toUpperCase(), (m.get(ch.toUpperCase()) || 0) + 1);
        }
      }
    }

    // Count B2B pairs per person and collect B2B entries
    function _countB2B() {
      const b2bCounts = new Map(); // name -> count of B2B pairs
      const b2bEntries = []; // [{name, dayKey, blockKey, channel, blockIdx, pairBlockKey}]
      for (let day = 1; day <= daysInMonth; day++) {
        const dObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
        const dk = ymd(dObj);
        const dayData = plan.days[dk];
        if (!dayData) continue;
        // Build per-person ordered assignments for this day
        const personBlocks = new Map(); // name -> [{blockIdx, channel, blockKey}]
        for (let bi = 0; bi < BLOCKS.length; bi++) {
          const bd = dayData[BLOCKS[bi].key];
          if (!bd || !bd.assignments) continue;
          for (const [ch, nm] of Object.entries(bd.assignments)) {
            if (!nm) continue;
            if (!personBlocks.has(nm)) personBlocks.set(nm, []);
            personBlocks.get(nm).push({ blockIdx: bi, channel: ch.toUpperCase(), blockKey: BLOCKS[bi].key, origCh: ch });
          }
        }
        for (const [nm, blocks] of personBlocks) {
          if (SD_ELIGIBLE.has(nm.toUpperCase())) continue;
          blocks.sort((a, b) => a.blockIdx - b.blockIdx);
          for (let i = 1; i < blocks.length; i++) {
            const prev = blocks[i - 1], curr = blocks[i];
            if (curr.blockIdx === prev.blockIdx + 1 && curr.channel === prev.channel && _b2bPrimary.has(curr.channel)) {
              b2bCounts.set(nm, (b2bCounts.get(nm) || 0) + 1);
              // Record the second block of the pair (this is the one we'd swap away)
              b2bEntries.push({ name: nm, dayKey: dk, blockKey: curr.blockKey, channel: curr.origCh, blockIdx: curr.blockIdx, pairBlockKey: prev.blockKey });
            }
          }
        }
      }
      // Ensure everyone has an entry
      for (const [nm] of _b2bChCounts) {
        if (SD_ELIGIBLE.has(nm.toUpperCase())) continue;
        if (!b2bCounts.has(nm)) b2bCounts.set(nm, 0);
      }
      return { b2bCounts, b2bEntries };
    }

    // Helper: would assigning personName to channel in blockKey create a B2B pair?
    function _wouldCreateB2B(personName, dayKey, blockKey, channel) {
      const chUp = String(channel).toUpperCase();
      if (!_b2bPrimary.has(chUp)) return false;
      const dayData = plan.days[dayKey];
      if (!dayData) return false;
      const bIdx = BLOCKS.findIndex(b => b.key === blockKey);
      if (bIdx < 0) return false;
      for (const adj of [bIdx - 1, bIdx + 1]) {
        if (adj < 0 || adj >= BLOCKS.length) continue;
        const adjBd = dayData[BLOCKS[adj].key];
        if (!adjBd || !adjBd.assignments) continue;
        for (const [ch, nm] of Object.entries(adjBd.assignments)) {
          if (nm === personName && ch.toUpperCase() === chUp) return true;
        }
      }
      return false;
    }

    // Helper: would assigning personName to channel create a same-channel non-adjacent violation?
    function _wouldViolateSameDayNonAdj(personName, dayKey, blockKey, channel) {
      const chUp = String(channel).toUpperCase();
      const dayData = plan.days[dayKey];
      if (!dayData) return false;
      const bIdx = BLOCKS.findIndex(b => b.key === blockKey);
      if (bIdx < 0) return false;
      for (let bi = 0; bi < BLOCKS.length; bi++) {
        if (BLOCKS[bi].key === blockKey) continue;
        const bd = dayData[BLOCKS[bi].key];
        if (!bd || !bd.assignments) continue;
        for (const [ch, nm] of Object.entries(bd.assignments)) {
          if (nm === personName && ch.toUpperCase() === chUp) {
            if (Math.abs(bi - bIdx) === 1) continue; // Adjacent is OK (B2B, handled separately)
            return true; // Non-adjacent same channel = violation
          }
        }
      }
      return false;
    }

    // Hard B2B cap: break B2B pairs until everyone has <= 1
    for (let b2bRound = 0; b2bRound < 100; b2bRound++) {
      const { b2bCounts, b2bEntries } = _countB2B();
      if (b2bEntries.length === 0) break;

      const vals = [...b2bCounts.values()];
      const maxB2B = Math.max(...vals);
      if (maxB2B <= 1) break; // Hard cap achieved: everyone has <= 1 B2B

      // Sort entries so we process the most over-B2B people first
      b2bEntries.sort((a, b) => (b2bCounts.get(b.name) || 0) - (b2bCounts.get(a.name) || 0));

      let swapped = false;
      for (const entry of b2bEntries) {
        const overB2B = b2bCounts.get(entry.name) || 0;
        if (overB2B <= 1) continue; // Already at or below cap

        const dk = entry.dayKey, bk = entry.blockKey;
        const bd = plan.days[dk] && plan.days[dk][bk];
        if (!bd || !bd.assignments) continue;
        if (bd.assignments[entry.channel] !== entry.name) continue; // Already moved

        // Find a swap partner in the same block on a different primary channel
        for (const [c2, nm2] of Object.entries(bd.assignments)) {
          if (!nm2 || nm2 === entry.name || c2 === entry.channel) continue;
          if (_b2bCtrExclude.has(c2.toUpperCase())) continue;
          if (SD_ELIGIBLE.has(nm2.toUpperCase())) continue;

          // Don't create a new B2B for the swap partner
          if (_wouldCreateB2B(nm2, dk, bk, entry.channel)) continue;
          // Don't create a new B2B for the over-person with the new channel
          if (_wouldCreateB2B(entry.name, dk, bk, c2)) continue;

          // Safety: no same-channel non-adjacent violations
          if (_wouldViolateSameDayNonAdj(entry.name, dk, bk, c2)) continue;
          if (_wouldViolateSameDayNonAdj(nm2, dk, bk, entry.channel)) continue;

          // Safety: don't drop either person below 1 on their channel
          const donorCounts = _b2bChCounts.get(nm2);
          if (donorCounts && (donorCounts.get(c2.toUpperCase()) || 0) <= 1) continue;
          const overCounts = _b2bChCounts.get(entry.name);
          if (overCounts && (overCounts.get(entry.channel.toUpperCase()) || 0) <= 1) continue;

          // Trainee restriction
          if (traineeBlocked(nm2, dk, bk, entry.channel.toUpperCase())) continue;
          if (traineeBlocked(entry.name, dk, bk, c2.toUpperCase())) continue;

          // Perform swap
          bd.assignments[entry.channel] = nm2;
          bd.assignments[c2] = entry.name;

          // Update _b2bChCounts
          if (overCounts) {
            overCounts.set(entry.channel.toUpperCase(), (overCounts.get(entry.channel.toUpperCase()) || 0) - 1);
            overCounts.set(c2.toUpperCase(), (overCounts.get(c2.toUpperCase()) || 0) + 1);
          }
          if (donorCounts) {
            donorCounts.set(c2.toUpperCase(), (donorCounts.get(c2.toUpperCase()) || 0) - 1);
            donorCounts.set(entry.channel.toUpperCase(), (donorCounts.get(entry.channel.toUpperCase()) || 0) + 1);
          }

          swapped = true;
          break;
        }
        if (swapped) break;
      }
      if (!swapped) break;
    }
  }
  // ========== END B2B EVENING PASS ==========

  // ========== VIOLATION REPAIR PASS ==========
  const ctrSet2 = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
  const MAX_REPAIR_ROUNDS = 3;

  // Helper: scan all violations for the current plan state
  function _scanViolations() {
    const vFound = new Map(); // name -> count
    const vList = []; // detailed list for repair

    for (let day = 1; day <= daysInMonth; day++) {
      const dateObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
      const dk = ymd(dateObj);
      const dayData = plan.days[dk];
      if (!dayData) continue;

      const personAssignments = new Map(); // name -> [{blockIdx, channel, blockKey}]

      for (let bi = 0; bi < BLOCKS.length; bi++) {
        const b = BLOCKS[bi];
        const blockData = dayData[b.key];
        if (!blockData) continue;

        for (const [ch, name] of Object.entries(blockData.assignments || {})) {
          if (!name) continue;
          const nameUpper = String(name).toUpperCase();
          if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
          personAssignments.get(nameUpper).push({ blockIdx: bi, channel: ch.toUpperCase(), blockKey: b.key, origChannel: ch, origName: String(name) });
        }
        for (const name of (blockData.ct || [])) {
          const nameUpper = String(name).toUpperCase();
          if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
          personAssignments.get(nameUpper).push({ blockIdx: bi, channel: "CT", blockKey: b.key, origChannel: "CT", isCt: true, origName: String(name) });
        }
      }

      for (const [name, assignments] of personAssignments) {
        assignments.sort((a, b) => a.blockIdx - b.blockIdx);
        const dayChannels = new Map();

        for (let i = 0; i < assignments.length; i++) {
          const curr = assignments[i];
          const chUpper = curr.channel;

          // Same channel twice in day (except SD, weekly-capped channels, and allowed primary b2b)
          const _weeklyCapped = new Set(["CT","RELIEF 1","RELIEF 2","DC1","DC2"]);
          if (dayChannels.has(chUpper) && chUpper !== "SD" && !_weeklyCapped.has(chUpper)) {
            const _primB2B = new Set(["NORTH","SOUTH","EAST","WEST","NORTHWEST","CENTRAL","CT","RELIEF 1","RELIEF 2"]);
            const isAllowedB2B = _primB2B.has(chUpper) && i > 0 &&
              assignments[i-1].channel === chUpper && assignments[i-1].blockIdx === curr.blockIdx - 1 &&
              (dayChannels.get(chUpper) || 0) < 2;
            if (!isAllowedB2B) {
              vFound.set(name, (vFound.get(name) || 0) + 1);
              vList.push({ name, origName: curr.origName, dayKey: dk, blockKey: curr.blockKey, channel: curr.origChannel, type: "same-channel", blockIdx: curr.blockIdx, isCt: !!curr.isCt });
            }
          }
          dayChannels.set(chUpper, (dayChannels.get(chUpper) || 0) + 1);
        }
      }
    }

    // Weekly CT/Relief/DC/Primary cap violations: max 2 each per person per work week
    const _wkCtrMap = new Map(); // name -> Map<weekKey, {ct, relief, dc, primCh: Map(ch->count)}>
    const _primNames = new Set(["NORTH","EAST","SOUTH","WEST","CENTRAL","NORTHWEST"]);
    for (let day = 1; day <= daysInMonth; day++) {
      const dateObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
      const dk = ymd(dateObj);
      const wkKey = weekKeyFromDate(dateObj);
      const dayData = plan.days[dk];
      if (!dayData) continue;
      for (let bi = 0; bi < BLOCKS.length; bi++) {
        const bd = dayData[BLOCKS[bi].key];
        if (!bd) continue;
        for (const nm of (bd.ct || [])) {
          const n = String(nm).toUpperCase();
          if (!_wkCtrMap.has(n)) _wkCtrMap.set(n, new Map());
          const wm = _wkCtrMap.get(n);
          if (!wm.has(wkKey)) wm.set(wkKey, {ct:0, relief:0, dc:0, primCh: new Map()});
          wm.get(wkKey).ct++;
        }
        for (const [ch, nm] of Object.entries(bd.assignments || {})) {
          if (!nm) continue;
          const chUp = ch.toUpperCase();
          const n = String(nm).toUpperCase();
          if (!_wkCtrMap.has(n)) _wkCtrMap.set(n, new Map());
          const wm = _wkCtrMap.get(n);
          if (!wm.has(wkKey)) wm.set(wkKey, {ct:0, relief:0, dc:0, primCh: new Map()});
          const bucket = wm.get(wkKey);
          if (chUp === "RELIEF 1" || chUp === "RELIEF 2") {
            bucket.relief++;
          } else if (chUp === "DC1" || chUp === "DC2") {
            bucket.dc++;
          } else if (_primNames.has(chUp)) {
            bucket.primCh.set(chUp, (bucket.primCh.get(chUp) || 0) + 1);
          }
        }
      }
    }
    for (const [name, weeks] of _wkCtrMap) {
      for (const [wk, counts] of weeks) {
        if (counts.ct > 2) {
          vFound.set(name, (vFound.get(name) || 0) + (counts.ct - 2));
          vList.push({ name, origName: name, dayKey: wk, blockKey: BLOCKS[0].key, channel: "CT", type: "ct-weekly-max", blockIdx: 0, isCt: true });
        }
        if (counts.relief > 2) {
          vFound.set(name, (vFound.get(name) || 0) + (counts.relief - 2));
          vList.push({ name, origName: name, dayKey: wk, blockKey: BLOCKS[0].key, channel: "Relief", type: "relief-weekly-max", blockIdx: 0, isCt: false });
        }
        if (counts.dc > 2) {
          vFound.set(name, (vFound.get(name) || 0) + (counts.dc - 2));
          vList.push({ name, origName: name, dayKey: wk, blockKey: BLOCKS[0].key, channel: "DC", type: "dc-weekly-max", blockIdx: 0, isCt: false });
        }
        for (const [pCh, pCount] of counts.primCh) {
          if (pCount > 2) {
            vFound.set(name, (vFound.get(name) || 0) + (pCount - 2));
            vList.push({ name, origName: name, dayKey: wk, blockKey: BLOCKS[0].key, channel: pCh, type: "primary-ch-weekly-max", blockIdx: 0, isCt: false });
          }
        }
      }
    }

    let total = 0;
    for (const c of vFound.values()) total += c;
    return { vFound, vList, total };
  }

  // Helper: check if a person has a violation in a specific block/day after a hypothetical swap
  function _wouldCreateViolation(personName, dayKey, blockIdx, newChannel) {
    const nameUpper = String(personName).toUpperCase();
    const chUpper = String(newChannel).toUpperCase();
    const dayData = plan.days[dayKey];
    if (!dayData) return false;

    // Gather this person's assignments for the day (excluding the block being swapped)
    const otherAssignments = [];
    for (let bi = 0; bi < BLOCKS.length; bi++) {
      if (bi === blockIdx) continue;
      const b = BLOCKS[bi];
      const bd = dayData[b.key];
      if (!bd) continue;
      for (const [ch, nm] of Object.entries(bd.assignments || {})) {
        if (nm && String(nm).toUpperCase() === nameUpper) {
          otherAssignments.push({ blockIdx: bi, channel: ch.toUpperCase() });
        }
      }
      for (const nm of (bd.ct || [])) {
        if (String(nm).toUpperCase() === nameUpper) {
          otherAssignments.push({ blockIdx: bi, channel: "CT" });
        }
      }
    }

    // Add the proposed new assignment
    otherAssignments.push({ blockIdx, channel: chUpper });
    otherAssignments.sort((a, b) => a.blockIdx - b.blockIdx);

    // Check same-channel-twice (allow primary b2b: consecutive, max 2)
    const _primB2B = new Set(["NORTH","SOUTH","EAST","WEST","NORTHWEST","CENTRAL","CT","RELIEF 1","RELIEF 2"]);
    const chCounts = new Map();
    for (let j = 0; j < otherAssignments.length; j++) {
      const a = otherAssignments[j];
      if (a.channel !== "SD") {
        if (chCounts.has(a.channel)) {
          // Allow if primary b2b: consecutive blocks and count < 2
          const isB2B = _primB2B.has(a.channel) && j > 0 &&
            otherAssignments[j-1].channel === a.channel &&
            otherAssignments[j-1].blockIdx === a.blockIdx - 1 &&
            (chCounts.get(a.channel) || 0) < 2;
          if (!isB2B) return true;
        }
        chCounts.set(a.channel, (chCounts.get(a.channel) || 0) + 1);
      }
    }

    return false;
  }

  for (let repairRound = 0; repairRound < MAX_REPAIR_ROUNDS; repairRound++) {
    const scan = _scanViolations();
    if (scan.total === 0) break; // No violations — done!

    let repairsThisRound = 0;

    for (const v of scan.vList) {
      const dayData = plan.days[v.dayKey];
      if (!dayData) continue;
      const blockData = dayData[v.blockKey];
      if (!blockData) continue;

      if (v.isCt) continue; // Skip CT array entries — harder to swap safely

      const offenderNameUpper = v.name; // uppercase for comparisons
      const offenderOrigName = v.origName; // original case for plan writes
      const offenderChannel = v.channel;

      // Verify offender is still on this channel (earlier repair may have moved them)
      if (String(blockData.assignments?.[offenderChannel] || "").toUpperCase() !== offenderNameUpper) continue;

      // Find someone else in the same block on a different, non-conflicting channel to swap with
      const candidates = Object.entries(blockData.assignments || {}).filter(([ch, nm]) => {
        if (!nm) return false;
        if (ch === offenderChannel) return false; // same channel
        if (String(nm).toUpperCase() === offenderNameUpper) return false; // same person
        return true;
      });

      let swapped = false;
      for (const [candChannel, candName] of candidates) {
        // Would the swap create a violation for the candidate?
        if (_wouldCreateViolation(candName, v.dayKey, v.blockIdx, offenderChannel)) continue;
        // Would the swap create a violation for the offender?
        if (_wouldCreateViolation(offenderOrigName, v.dayKey, v.blockIdx, candChannel)) continue;

        // Perform the swap
        blockData.assignments[offenderChannel] = candName;
        blockData.assignments[candChannel] = offenderOrigName;
        repairsThisRound++;
        swapped = true;
        break;
      }
    }

    if (repairsThisRound === 0) break; // No more repairs possible
  }

  // Final violation count after repairs
  const finalScan = _scanViolations();

  // ========== TRAINEE CORRECTION PASS ==========
  // After ALL balancing, scan every block and fix any trainee still on a disallowed channel or CT
  {
    const _tcOkSet = new Set(["EAST","SOUTH","WEST","CENTRAL"]);
    const _tcAllowed = ["East","South","West","Central"];
    for (let _tcDay = 1; _tcDay <= daysInMonth; _tcDay++) {
      const _tcDate = new Date(year, monthIndex, _tcDay, 12, 0, 0, 0);
      const _tcDk = ymd(_tcDate);
      const _tcDayData = plan.days[_tcDk];
      if (!_tcDayData) continue;
      for (const _tcBlk of BLOCKS) {
        const _tcBd = _tcDayData[_tcBlk.key];
        if (!_tcBd) continue;

        // Fix trainees in disallowed channel assignments
        for (const [ch, nm] of Object.entries(_tcBd.assignments || {})) {
          if (!nm) continue;
          if (!isTrainee(nm, _tcDk, _tcBlk.key)) continue;
          if (_tcOkSet.has(ch.toUpperCase())) continue; // Already on allowed channel
          // Trainee on disallowed channel — try to swap with non-trainee on allowed channel
          let _tcFixed = false;
          for (const _tcCh of _tcAllowed) {
            const _tcHolder = _tcBd.assignments[_tcCh];
            if (!_tcHolder) {
              // Empty allowed slot — just move
              _tcBd.assignments[_tcCh] = nm;
              _tcBd.assignments[ch] = null;
              _tcFixed = true;
              break;
            }
            if (isTrainee(_tcHolder, _tcDk, _tcBlk.key)) continue;
            // Swap trainee into allowed channel, push holder to disallowed
            _tcBd.assignments[_tcCh] = nm;
            _tcBd.assignments[ch] = _tcHolder;
            _tcFixed = true;
            break;
          }
          if (!_tcFixed) {
            // Last resort: move trainee to CT-free — put in empty allowed or leave (don't push to CT)
            _tcBd.assignments[ch] = null;
            // Try one more time for any empty allowed slot
            for (const _tcCh of _tcAllowed) {
              if (!_tcBd.assignments[_tcCh]) {
                _tcBd.assignments[_tcCh] = nm;
                break;
              }
            }
          }
        }

        // Fix trainees in CT — move to allowed channel if possible
        if (_tcBd.ct && _tcBd.ct.length > 0) {
          for (let _ci = _tcBd.ct.length - 1; _ci >= 0; _ci--) {
            const _ctName = _tcBd.ct[_ci];
            if (!isTrainee(_ctName, _tcDk, _tcBlk.key)) continue;
            // Trainee on CT — try empty allowed channel
            let _ctFixed = false;
            for (const _tcCh of _tcAllowed) {
              if (!_tcBd.assignments[_tcCh]) {
                _tcBd.assignments[_tcCh] = _ctName;
                _tcBd.ct.splice(_ci, 1);
                _ctFixed = true;
                break;
              }
            }
            if (!_ctFixed) {
              // Swap with non-trainee on allowed channel → push them to CT
              for (const _tcCh of _tcAllowed) {
                const _tcHolder = _tcBd.assignments[_tcCh];
                if (!_tcHolder) continue;
                if (isTrainee(_tcHolder, _tcDk, _tcBlk.key)) continue;
                _tcBd.assignments[_tcCh] = _ctName;
                _tcBd.ct[_ci] = _tcHolder;
                _ctFixed = true;
                break;
              }
            }
          }
        }
      }
    }
  }
  // ========== END TRAINEE CORRECTION PASS ==========

  savePlan(plan);

  // Compute worst-case AND sum of primary channel SPREADs (max-min per channel) for non-SD people
  const _primUpper = new Set(rebalanceChannels.map(ch => ch.toUpperCase()));
  let _maxPrimCount = 0; // worst spread across all primary channels
  let _sumPrimSpreads = 0; // sum of all primary channel spreads
  for (const pch of _primUpper) {
    let minC = Infinity, maxC = 0;
    for (const [name, m] of finalCounts) {
      if (SD_ELIGIBLE.has(name.toUpperCase())) continue;
      const c = m.get(pch) || 0;
      if (c < minC) minC = c;
      if (c > maxC) maxC = c;
    }
    if (minC === Infinity) minC = 0;
    const spread = maxC - minC;
    _sumPrimSpreads += spread;
    if (spread > _maxPrimCount) _maxPrimCount = spread;
  }

  // CT spread (max-min) across all non-SD people
  let _maxCTCount = 0;
  let _minCTCount = Infinity;
  const _ctMap = new Map();
  for (const dk of Object.keys(plan.days)) {
    const dayData = plan.days[dk];
    for (const bk of BLOCKS) {
      const bd = dayData[bk.key];
      if (!bd || !bd.ct) continue;
      for (const nm of bd.ct) {
        if (SD_ELIGIBLE.has(String(nm).toUpperCase())) continue;
        _ctMap.set(nm, (_ctMap.get(nm) || 0) + 1);
      }
    }
  }
  // Ensure everyone who isn't SD is in the CT map (some may have 0)
  for (const [nm] of finalCounts) {
    if (SD_ELIGIBLE.has(nm.toUpperCase())) continue;
    if (!_ctMap.has(nm)) _ctMap.set(nm, 0);
  }
  for (const [, count] of _ctMap) {
    if (count > _maxCTCount) _maxCTCount = count;
    if (count < _minCTCount) _minCTCount = count;
  }
  if (_minCTCount === Infinity) _minCTCount = 0;
  const _ctSpread = _maxCTCount - _minCTCount;

  // DC spread (max-min of DC1+DC2 total) across all non-SD people
  const _dcMap = new Map(); // name -> DC1+DC2 total
  for (const [nm, m] of finalCounts) {
    if (SD_ELIGIBLE.has(nm.toUpperCase())) continue;
    const dc1 = m.get("DC1") || 0;
    const dc2 = m.get("DC2") || 0;
    _dcMap.set(nm, dc1 + dc2);
  }
  let _maxDC = 0, _minDC = Infinity;
  for (const [, count] of _dcMap) {
    if (count > _maxDC) _maxDC = count;
    if (count < _minDC) _minDC = count;
  }
  if (_minDC === Infinity) _minDC = 0;
  const _dcSpread = _maxDC - _minDC;

  // B2B spread (max-min of B2B pair count) across all non-SD people
  const _b2bPrimFinal = new Set(["NORTH","EAST","SOUTH","WEST","NORTHWEST","CENTRAL"]);
  const _b2bMap = new Map(); // name -> B2B pair count
  for (let day = 1; day <= daysInMonth; day++) {
    const dObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
    const dk = ymd(dObj);
    const dayData = plan.days[dk];
    if (!dayData) continue;
    const personBlocks = new Map();
    for (let bi = 0; bi < BLOCKS.length; bi++) {
      const bd = dayData[BLOCKS[bi].key];
      if (!bd || !bd.assignments) continue;
      for (const [ch, nm] of Object.entries(bd.assignments)) {
        if (!nm) continue;
        if (!personBlocks.has(nm)) personBlocks.set(nm, []);
        personBlocks.get(nm).push({ blockIdx: bi, channel: ch.toUpperCase() });
      }
    }
    for (const [nm, blocks] of personBlocks) {
      if (SD_ELIGIBLE.has(nm.toUpperCase())) continue;
      blocks.sort((a, b) => a.blockIdx - b.blockIdx);
      for (let i = 1; i < blocks.length; i++) {
        if (blocks[i].blockIdx === blocks[i-1].blockIdx + 1 &&
            blocks[i].channel === blocks[i-1].channel &&
            _b2bPrimFinal.has(blocks[i].channel)) {
          _b2bMap.set(nm, (_b2bMap.get(nm) || 0) + 1);
        }
      }
    }
  }
  for (const [nm] of finalCounts) {
    if (SD_ELIGIBLE.has(nm.toUpperCase())) continue;
    if (!_b2bMap.has(nm)) _b2bMap.set(nm, 0);
  }
  let _maxB2B = 0, _minB2B = Infinity;
  for (const [, count] of _b2bMap) {
    if (count > _maxB2B) _maxB2B = count;
    if (count < _minB2B) _minB2B = count;
  }
  if (_minB2B === Infinity) _minB2B = 0;
  const _b2bSpread = _maxB2B - _minB2B;

  // TOTAL spread (max-min of total assignments per person, per shift group — worst of all groups)
  const _totalCounts = new Map();
  const _totalDayBlks = new Set(["0600-1000","1000-1400","1400-1800"]);
  const _totalShift = new Map();
  for (const dk of Object.keys(plan.days)) {
    const dayData = plan.days[dk];
    for (const bk of BLOCKS) {
      const bd = dayData[bk.key];
      if (!bd) continue;
      if (bd.assignments) {
        for (const [, nm] of Object.entries(bd.assignments)) {
          if (!nm || SD_ELIGIBLE.has(nm.toUpperCase())) continue;
          _totalCounts.set(nm, (_totalCounts.get(nm) || 0) + 1);
          if (!_totalShift.has(nm)) _totalShift.set(nm, { day: false, night: false });
          const s = _totalShift.get(nm);
          if (_totalDayBlks.has(bk.key)) s.day = true; else s.night = true;
        }
      }
      if (bd.ct) {
        for (const nm of bd.ct) {
          if (!nm || SD_ELIGIBLE.has(nm.toUpperCase())) continue;
          _totalCounts.set(nm, (_totalCounts.get(nm) || 0) + 1);
        }
      }
    }
  }
  const _totByShift = { day: [], night: [], split: [] };
  for (const [nm, t] of _totalCounts) {
    const s = _totalShift.get(nm);
    if (!s) { _totByShift.day.push(t); continue; }
    if (s.day && s.night) _totByShift.split.push(t);
    else if (s.day) _totByShift.day.push(t);
    else _totByShift.night.push(t);
  }
  let _totalSpread = 0;
  for (const arr of [_totByShift.day, _totByShift.night, _totByShift.split]) {
    if (arr.length < 2) continue;
    const sp = Math.max(...arr) - Math.min(...arr);
    if (sp > _totalSpread) _totalSpread = sp;
  }

  // Store violation stats for display
  window.lastRandomizeStats = {
    totalViolations: finalScan.total,
    uniquePeopleWithViolations: finalScan.vFound.size,
    violationsByPerson: Object.fromEntries(finalScan.vFound),
    maxPrimaryCount: _maxPrimCount,
    maxCTCount: _maxCTCount,
    sumPrimarySpreads: _sumPrimSpreads,
    ctSpread: _ctSpread,
    dcSpread: _dcSpread,
    b2bSpread: _b2bSpread,
    totalSpread: _totalSpread
  };

  return plan;
}

/* OPTION B REMOVED */
function randomizeMonthB(year, monthIndex) { return randomizeMonth(year, monthIndex); }
/*
  const plan = buildEmptyPlan(year, monthIndex);

  // Track last channel (prevents immediate back-to-back repeats)
  const lastAssign = new Map();
  function forbiddenBackToBack(prev, next) {
    // DC1/DC2 never back-to-back
    if ((prev==="DC1" && next==="DC2") || (prev==="DC2" && next==="DC1")) return true;
    return false;
  }


  // Track per-person channel cycle (prevents repeating a channel until they've hit all 10)
  // name -> Set(channels used in current cycle)
  const channelCycle = new Map();

  // Light balancing helper (keeps total assignments per person more even)
  const channelCounts = new Map();

  // CT fairness tracking (per month + per week + back-to-back exception)
  const ctWeekCounts = new Map();   // weekKey -> Map(name -> ctCountThisWeek)
  const ctMonthCounts = new Map();  // name -> ctCountThisMonth
  const lastCTAt = new Map();       // name -> {dayKey, blockIdx} for back-to-back rule

  // Violation fairness: track violations per person (max 1 per person if possible)
  const violationCount = new Map();  // name -> number of violations this month
  function hasViolation(name) { return (violationCount.get(String(name).toUpperCase()) || 0) > 0; }
  function addViolation(name) {
    const n = String(name).toUpperCase();
    violationCount.set(n, (violationCount.get(n) || 0) + 1);
  }

  // Track people assigned R1/R2 who work next block - they get GUARANTEED channel priority
  // This prevents Relief->CT violations when Pass 4 must fill R1/R2 with someone working next block
  const mustGetChannelNextBlock = new Set(); // names that MUST get a channel (not CT) next block

  // ctCapByName is global (rebuilt in buildEmptyPlan)
  const ctOverCapUsedByWeek = new Map(); // weekKey -> Set(names who used 1 over-cap allowance)
  const lastCTGlobalIdx = new Map();     // name -> global block index of last CT (for back-to-back rule)

  const daysInMonth = new Date(year, monthIndex+1, 0).getDate();

  // ========== SD PRE-ASSIGNMENT (32 hrs/WEEK = 8 blocks/WEEK per person) ==========
  // Pre-assign SD to SD-eligible employees before filling channels
  // Each SD person gets 32 hrs (8 blocks) of SD per WEEK, rest goes to channels.
  // Track: sdPreAssigned[weekKey][dayKey][blockKey] = [names assigned to SD]
  const sdPreAssigned = new Map(); // weekKey -> Map(dayKey -> Map(blockKey -> [names]))
  const sdRemainingBlocks = new Map(); // weekKey -> Map(name -> remaining channel blocks to fill)

  // Group days by week and find days with most dispatchers for SD priority
  const weekDays = new Map(); // weekKey -> [{dayKey, dateObj, dispatcherCount}]
  for (let day=1; day<=daysInMonth; day++) {
    const dateObj = new Date(year, monthIndex, day, 12,0,0,0);
    const dayKey = ymd(dateObj);
    const wk = weekKeyFromDate(dateObj);
    if (!weekDays.has(wk)) weekDays.set(wk, []);

    // Count total dispatcher availability for this day
    const poolAll = buildDispatcherPoolForDate(dateObj);
    let totalAvail = 0;
    for (const b of BLOCKS) {
      const available = poolAll.filter(d => worksBlock(d, dateObj, b));
      totalAvail += available.length;
    }
    weekDays.get(wk).push({dayKey, dateObj, dispatcherCount: totalAvail});
  }

  // Monthly SD cap: 32 blocks (128 hrs) per month — ensures totals stay at 32
  const SD_MONTHLY_CAP = 32;
  const sdMonthlyCount = new Map(); // name -> total SD blocks this month
  for (const sdName of SD_ELIGIBLE) sdMonthlyCount.set(sdName, 0);

  // For each week, pre-assign SD (8 blocks = 32 hrs per FULL WEEK, pro-rated for partial weeks)
  for (const [wk, days] of weekDays.entries()) {
    // Sort days by dispatcher count descending (prioritize days with most dispatchers)
    days.sort((a, b) => b.dispatcherCount - a.dispatcherCount);

    sdPreAssigned.set(wk, new Map());
    sdRemainingBlocks.set(wk, new Map());
    const sdMap = sdPreAssigned.get(wk);

    // Pro-rate SD cap for partial weeks:
    // A full week (7 days, ~5 working days) = 8 blocks cap
    // Partial weeks get proportional cap based on actual days in this month-week
    const daysInThisWeek = days.length;
    // Full week has ~5 working days (Mon-Fri from Sat-Fri week). Scale 8 blocks by ratio.
    // Use 5 as the baseline for a full working week
    const sdWeeklyCap = Math.min(8, Math.round(8 * daysInThisWeek / 5));

    // Track blocks assigned per SD employee this week
    const sdBlocksThisWeek = new Map(); // name -> blocks assigned this week

    // For each SD-eligible employee, initialize to 0
    for (const sdName of SD_ELIGIBLE) {
      sdBlocksThisWeek.set(sdName, 0);
      sdRemainingBlocks.get(wk).set(sdName, 0); // will calculate after
    }

    // Distribute SD assignments across the week
    for (const {dayKey, dateObj} of days) {
      if (!sdMap.has(dayKey)) sdMap.set(dayKey, new Map());
      const dayMap = sdMap.get(dayKey);

      const poolAll = buildDispatcherPoolForDate(dateObj);

      for (const b of BLOCKS) {
        if (!dayMap.has(b.key)) dayMap.set(b.key, []);

        // Find SD-eligible people working this block who haven't hit weekly or monthly cap
        for (const sdName of SD_ELIGIBLE) {
          const weeklyBlocks = sdBlocksThisWeek.get(sdName) || 0;
          if (weeklyBlocks >= sdWeeklyCap) continue; // CAP: pro-rated per week
          const monthlyBlocks = sdMonthlyCount.get(sdName) || 0;
          if (monthlyBlocks >= SD_MONTHLY_CAP) continue; // HARD CAP: 32 blocks per month

          // Check if this person works this block
          const disp = poolAll.find(d => String(d.name).toUpperCase() === sdName);
          if (!disp) continue;
          if (!worksBlock(disp, dateObj, b)) continue;

          // Assign to SD
          dayMap.get(b.key).push(sdName);
          sdBlocksThisWeek.set(sdName, weeklyBlocks + 1);
          sdMonthlyCount.set(sdName, monthlyBlocks + 1);
        }
      }
    }

    // Calculate remaining channel blocks for each SD employee
    // (Total scheduled blocks - SD blocks = remaining for channels)
    for (const sdName of SD_ELIGIBLE) {
      let totalScheduledBlocks = 0;
      for (const {dayKey, dateObj} of days) {
        const poolAll = buildDispatcherPoolForDate(dateObj);
        const disp = poolAll.find(d => String(d.name).toUpperCase() === sdName);
        if (!disp) continue;
        for (const b of BLOCKS) {
          if (worksBlock(disp, dateObj, b)) totalScheduledBlocks++;
        }
      }
      const sdBlocks = sdBlocksThisWeek.get(sdName) || 0;
      const remainingBlocks = Math.max(0, totalScheduledBlocks - sdBlocks);
      sdRemainingBlocks.get(wk).set(sdName, remainingBlocks);
    }
  }
  // ========== END SD PRE-ASSIGNMENT ==========

// Weekly quota targets (after SD):
// - 24 hrs (6 blocks) from N/E/S/W/C/NW
// - 8 hrs (2 blocks) from CT or R1/R2
// - 8 hrs (2 blocks) from DC1/DC2
const PRIMARY_SET = new Set(["NORTH","EAST","SOUTH","WEST","CENTRAL","NORTHWEST"]);
const DC_SET = new Set(["DC1","DC2"]);
const CTR_SET = new Set(["CT","R1","R2"]);

// wk -> Map(name -> {primary:int, ctr:int, dc:int})
const weekNeeds = new Map();
function getNeeds(wkKey, name){
  if (!weekNeeds.has(wkKey)) weekNeeds.set(wkKey, new Map());
  const m = weekNeeds.get(wkKey);
  if (!m.has(name)) m.set(name, {primary:6, ctr:2, dc:2}); // default 40hr week (10 blocks)
  return m.get(name);
}

// Keep channel chunks up to 8 hours (2 blocks) when possible
const sameChanStreak = new Map(); // name -> {ch, len}
// Hard constraint: never more than 8 hours (2 blocks) in CT/R1/R2 bucket back-to-back
const ctrStreakLen = new Map(); // name -> consecutive blocks in {CT,R1,R2}

// Back-to-back same-channel allowed for primary geographic channels (max 2 consecutive blocks)
// Distributed evenly: track how many b2b pairs each person gets this month
const b2bMonthCount = new Map(); // name -> number of back-to-back pairs this month

function isAllowedPrimaryB2B(name, ch) {
  const CH = String(ch).toUpperCase();
  if (!PRIMARY_SET.has(CH)) return false;
  const streak = sameChanStreak.get(name);
  if (streak && streak.ch === CH && streak.len >= 2) return false; // max 2 consecutive
  return true;
}

function updateStreaks(name, assignedChannel){
  // same channel streak
  const prev = sameChanStreak.get(name);
  // Track b2b pair BEFORE updating streak (if same primary channel, it's a new b2b pair)
  if (prev && prev.ch === assignedChannel && PRIMARY_SET.has(assignedChannel)) {
    b2bMonthCount.set(name, (b2bMonthCount.get(name) || 0) + 1);
  }
  if (prev && prev.ch === assignedChannel) sameChanStreak.set(name, {ch: assignedChannel, len: Math.min(2, prev.len+1)});
  else sameChanStreak.set(name, {ch: assignedChannel, len: 1});

  // CT-bucket streak
  if (CTR_SET.has(assignedChannel)) ctrStreakLen.set(name, (ctrStreakLen.get(name)||0)+1);
  else ctrStreakLen.set(name, 0);
}



  // Track which channels each person has already worked TODAY (to prevent same channel twice in same day)
  const dayChannelsWorked = new Map(); // dayKey -> Map(name -> Set of channels)

  for (let day=1; day<=daysInMonth; day++) {
    const dateObj = new Date(year, monthIndex, day, 12,0,0,0);
    const dayKey = ymd(dateObj);
        const wk = weekKeyFromDate(dateObj);
    if (!ctWeekCounts.has(wk)) ctWeekCounts.set(wk, new Map());
    if (!reliefWeekCounts.has(wk)) reliefWeekCounts.set(wk, new Map());
    const rwmap = reliefWeekCounts.get(wk);
    if (!dcWeekCounts.has(wk)) dcWeekCounts.set(wk, new Map());
    const dwmap = dcWeekCounts.get(wk);
    if (!primChWeekCounts.has(wk)) primChWeekCounts.set(wk, new Map());
    const pcwmap = primChWeekCounts.get(wk);

    // Initialize daily channel tracking for this day
    if (!dayChannelsWorked.has(dayKey)) dayChannelsWorked.set(dayKey, new Map());
    const todayChannels = dayChannelsWorked.get(dayKey); // Map(name -> Set of channels)

const poolAll = buildDispatcherPoolForDate(dateObj);

    for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
      const available = poolAll.filter(d => worksBlock(d, dateObj, b));
      const shuffled = shuffle(available);

      // Balance: prefer people with fewer total assignments so far
      // HIGHEST PRIORITY: People who were just on CT/R1/R2 must get a channel to avoid back-to-back
      shuffled.sort((a,b2)=>{
        // ABSOLUTE PRIORITY: People marked as must-get-channel (from Pass 4 R1/R2 assignment)
        const aMustGet = mustGetChannelNextBlock.has(a.name);
        const bMustGet = mustGetChannelNextBlock.has(b2.name);
        if (aMustGet && !bMustGet) return -1; // a goes first (GUARANTEED)
        if (bMustGet && !aMustGet) return 1;  // b goes first (GUARANTEED)

        // Check if either person was just on CT/R1/R2 (needs priority for channel)
        const lastA = lastAssign.get(a.name);
        const lastB = lastAssign.get(b2.name);
        const ctrNames = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
        const aWasOnCTR = lastA && ctrNames.has(String(lastA).toUpperCase());
        const bWasOnCTR = lastB && ctrNames.has(String(lastB).toUpperCase());

        // SECOND: People who were just on CT/R1/R2 get top priority for channels
        if (aWasOnCTR && !bWasOnCTR) return -1; // a goes first
        if (bWasOnCTR && !aWasOnCTR) return 1;  // b goes first

        const ma = channelCounts.get(a.name) || new Map();
        const mb = channelCounts.get(b2.name) || new Map();
        const ta = Array.from(ma.values()).reduce((s,v)=>s+v,0);
        const tb = Array.from(mb.values()).reduce((s,v)=>s+v,0);

        // CT fairness: if someone has already been sent to CT more often, pull them onto a channel first
        const wmap = ctWeekCounts.get(wk) || new Map();
        const cwa = wmap.get(a.name) || 0;
        const cwb = wmap.get(b2.name) || 0;

        const cma = ctMonthCounts.get(a.name) || 0;
        const cmb = ctMonthCounts.get(b2.name) || 0;

        // Priority order:
        // 1) Higher CT this week gets channel priority (reduces repeat CT in the same week)
        // 2) Higher CT this month gets channel priority (evens CT across the month)
        if (cwa !== cwb) return cwb - cwa;
        if (cma !== cmb) return cmb - cma;
        return 0;
      });

      const assignments = {};
      const usedNames = new Set();

      // ========== ADD PRE-ASSIGNED SD TO THIS BLOCK ==========
      // Get pre-assigned SD for this block and add to usedNames
      const sdForBlock = [];
      const wkSdMap = sdPreAssigned.get(wk);
      if (wkSdMap && wkSdMap.has(dayKey)) {
        const dayMap = wkSdMap.get(dayKey);
        if (dayMap && dayMap.has(b.key)) {
          for (const sdName of dayMap.get(b.key)) {
            sdForBlock.push(sdName);
            usedNames.add(sdName); // Exclude from channel assignment this block
          }
        }
      }
      // ========== END PRE-ASSIGNED SD ==========

      // Check if an SD employee still has remaining channel blocks to fill
      // If so, prioritize them for primary channels (N,E,S,W,NW,C) and one DC
      const sdRemainingMap = sdRemainingBlocks.get(wk) || new Map();
      function isSDEmployeeNeedingChannel(name) {
        const nm = String(name).toUpperCase();
        return SD_ELIGIBLE.has(nm) && (sdRemainingMap.get(nm) || 0) > 0 && !usedNames.has(nm);
      }

      // Training restriction: trainees can only be assigned to E, S, W, C
      const TRAINEE_ALLOWED_CHANNELS = new Set(["EAST","SOUTH","WEST","CENTRAL"]);
      function canTraineeWork(candName, channelUpper, blockKey) {
        if (!isTrainee(candName, dayKey, blockKey)) return true; // Only restrict during training blocks
        return TRAINEE_ALLOWED_CHANNELS.has(channelUpper);
      }

      // ========== B2B PRE-ASSIGNMENT ==========
      // Before main channel loop, pre-assign b2b for primary channels when it helps fairness.
      // Without this, candidates get consumed by earlier channels before their b2b channel is processed.
      const b2bProtected = new Set(); // Declared outside block so swap sections can see it
      {
        const b2bCandidates = [];
        for (const cand of shuffled) {
          if (usedNames.has(cand.name)) continue;
          const last = lastAssign.get(cand.name);
          if (!last) continue;
          const lastUpper = String(last).toUpperCase();
          if (!PRIMARY_SET.has(lastUpper)) continue;
          if (!isAllowedPrimaryB2B(cand.name, last)) continue;
          if (!canTraineeWork(cand.name, lastUpper, b.key)) continue;

          // Find matching channel key in CHANNELS
          const matchCh = CHANNELS.find(c => String(c).toUpperCase() === lastUpper);
          if (!matchCh) continue;

          // B2b fairness: don't give too many b2b to one person
          // Compute average across ALL available people (not just those with b2b entries)
          const myB2B = b2bMonthCount.get(cand.name) || 0;
          let b2bTotal = 0;
          for (const [, v] of b2bMonthCount) b2bTotal += v;
          const totalPeople = shuffled.length || 1;
          const avgB2B = b2bTotal / totalPeople;
          if (myB2B > avgB2B + 0.5) continue; // Only if at or near the true average

          // Compute channel deficit for sorting (prefer people who need this channel more)
          const m = channelCounts.get(cand.name) || new Map();
          const myCount = m.get(matchCh) || 0;
          let chSum = 0, chCnt = 0;
          for (const [, cm] of channelCounts) { chSum += (cm.get(matchCh) || 0); chCnt++; }
          const chAvg = chCnt > 0 ? chSum / chCnt : 0;
          const deficit = chAvg - myCount;
          b2bCandidates.push({ name: cand.name, channel: matchCh, channelUpper: lastUpper, deficit, myB2B });
        }

        // Sort: biggest deficit first, then fewest b2b
        b2bCandidates.sort((a, b) => {
          if (b.deficit !== a.deficit) return b.deficit - a.deficit;
          return a.myB2B - b.myB2B;
        });

        const b2bUsedChannels = new Set();
        const B2B_MAX_PER_BLOCK = 3; // Limit to avoid starving CT swap targets
        for (const bc of b2bCandidates) {
          if (b2bProtected.size >= B2B_MAX_PER_BLOCK) break;
          if (usedNames.has(bc.name)) continue;
          if (b2bUsedChannels.has(bc.channel)) continue;

          const ch = bc.channel;
          const CH = bc.channelUpper;
          const bucket = "primary";

          assignments[ch] = bc.name;
          usedNames.add(bc.name);
          lastAssign.set(bc.name, ch);

          if (!todayChannels.has(bc.name)) todayChannels.set(bc.name, new Set());
          todayChannels.get(bc.name).add(CH);

          if (!channelCycle.has(bc.name)) channelCycle.set(bc.name, new Set());
          const cyc = channelCycle.get(bc.name);
          if (cyc.size >= CHANNELS.length) cyc.clear();
          cyc.add(ch);

          if (!channelCounts.has(bc.name)) channelCounts.set(bc.name, new Map());
          const m = channelCounts.get(bc.name);
          m.set(ch, (m.get(ch) || 0) + 1);

          updateStreaks(bc.name, CH);

          const nd = getNeeds(wk, bc.name);
          if (nd[bucket] > 0) nd[bucket]--;

          // SD remaining tracking
          const pickUpper = String(bc.name).toUpperCase();
          if (SD_ELIGIBLE.has(pickUpper) && sdRemainingMap && sdRemainingMap.has(pickUpper)) {
            const rem = sdRemainingMap.get(pickUpper) || 0;
            if (rem > 0) sdRemainingMap.set(pickUpper, rem - 1);
          }

          mustGetChannelNextBlock.delete(bc.name);
          b2bUsedChannels.add(ch);
          b2bProtected.add(bc.name);
        }
      }
      // ========== END B2B PRE-ASSIGNMENT ==========

      for (const ch of CHANNELS) {
  // Skip channels already filled by b2b pre-assignment
  if (assignments[ch]) {
    // Still need to clear mustGetChannelNextBlock for anyone who got their channel
    continue;
  }
  let pick = null;
  const CH = String(ch).toUpperCase();

  // Determine which quota bucket this channel satisfies
  const bucket = DC_SET.has(CH) ? "dc" : (PRIMARY_SET.has(CH) ? "primary" : (CTR_SET.has(CH) ? "ctr" : "primary"));

  // Compute average assignment count for this channel across all dispatchers
  let chAvgCount = 0;
  if (channelCounts.size > 0) {
    let sum = 0, cnt = 0;
    for (const [nm, m] of channelCounts) {
      sum += (m.get(ch) || 0);
      cnt++;
    }
    chAvgCount = cnt > 0 ? sum / cnt : 0;
  }

  function candScore(cand){
    const needs = getNeeds(wk, cand.name);
    const needVal = needs[bucket] || 0;

    const last = lastAssign.get(cand.name);
    const lastUpper = last ? String(last).toUpperCase() : "";
    const streak = sameChanStreak.get(cand.name);
    // Back-to-back bonus for primary channels: prefer people with fewer b2b pairs (even distribution)
    let sameBonus = 0;
    if (last && lastUpper===CH && PRIMARY_SET.has(CH) && streak && streak.len < 2) {
      const myB2B = b2bMonthCount.get(cand.name) || 0;
      let b2bTotal = 0;
      for (const [, v] of b2bMonthCount) b2bTotal += v;
      const b2bAvgAll = shuffled.length > 0 ? b2bTotal / shuffled.length : 0;
      sameBonus = myB2B <= b2bAvgAll ? 300 : -500; // Strong: reward below-avg b2b, heavily penalize above-avg
    }

    const m = channelCounts.get(cand.name) || new Map();
    const total = Array.from(m.values()).reduce((s,v)=>s+v,0);

    // Relief grouping: strongly prefer back-to-back Relief (R→R pairs)
    // If assigning R1/R2 and candidate was just on R1/R2, massive bonus to keep them grouped
    let ctrPriorityBonus = 0;
    const wasRelief = lastUpper === "RELIEF 1" || lastUpper === "RELIEF 2" || lastUpper === "R1" || lastUpper === "R2";
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && wasRelief) {
      // They were just on Relief — group them back-to-back for an 8hr Relief block
      ctrPriorityBonus = 8000;
    }

    // SD employee priority: give big bonus for primary channels (N,E,S,W,NW,C) and DC1/DC2
    // Their remaining 8 hrs should go to these channels
    let sdBonus = 0;
    if (isSDEmployeeNeedingChannel(cand.name)) {
      if (PRIMARY_SET.has(CH) || DC_SET.has(CH)) {
        sdBonus = 200; // High priority for SD employees to get primary/DC channels
      } else {
        sdBonus = -100; // Discourage R1/R2 for SD employees
      }
    }

    // R1/R2 penalty: If assigning R1 or R2, heavily penalize people who work the next block
    // This prevents R1/R2 -> CT violations
    let r1r2Penalty = 0;
    if (CH === "RELIEF 1" || CH === "RELIEF 2") {
      const nextBlockIdx = bi + 1;
      if (nextBlockIdx < BLOCKS.length) {
        // Check if this person works the next block today
        if (worksBlock(cand, dateObj, BLOCKS[nextBlockIdx])) {
          r1r2Penalty = -500; // Heavy penalty - prefer someone whose shift ends
        }
      }
      // Also check if they work the first block of the next day
      if (bi === BLOCKS.length - 1) {
        const nextDay = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate() + 1, 12, 0, 0, 0);
        if (worksBlock(cand, nextDay, BLOCKS[0])) {
          r1r2Penalty = -500; // Heavy penalty for cross-day continuation
        }
      }
    }

    // CT/Relief inverse balance: high CT → prefer Relief, high Relief → prefer CT
    let ctReliefInverseBonus = 0;
    const myCT = ctMonthCounts.get(cand.name) || 0;
    const myRelief = (m.get("Relief 1") || 0) + (m.get("Relief 2") || 0);
    let avgCT = 0, avgRelief = 0, pCount = 0;
    for (const [nm, cnt] of ctMonthCounts) { avgCT += cnt; pCount++; }
    if (pCount > 0) avgCT /= pCount;
    if (channelCounts.size > 0) {
      let rSum = 0;
      for (const [, cm] of channelCounts) rSum += (cm.get("Relief 1") || 0) + (cm.get("Relief 2") || 0);
      avgRelief = rSum / channelCounts.size;
    }
    if (CH === "RELIEF 1" || CH === "RELIEF 2") {
      if (myCT > avgCT) ctReliefInverseBonus = (myCT - avgCT) * 120;
      if (myRelief > avgRelief) ctReliefInverseBonus -= (myRelief - avgRelief) * 120;
    }

    // Channel balance: steep quadratic penalty for being above average, strong bonus for below
    // Fairness-first: 1 above = -400, 2 above = -1600, 3 above = -3600
    const myChCount = (channelCounts.get(cand.name) || new Map()).get(ch) || 0;
    const chDelta = myChCount - chAvgCount;
    const chBalancePenalty = chDelta > 0
      ? -(chDelta * chDelta * 400)   // steep quadratic penalty for max fairness
      : (Math.abs(chDelta) * 150);   // strong linear bonus to pull up under-assigned

    // Minimum floor bonus: strongly prefer channels where person has < 2 assignments
    let minFloorBonus = 0;
    if (PRIMARY_SET.has(CH) && myChCount < 2) {
      minFloorBonus = (2 - myChCount) * 800; // +1600 at 0, +800 at 1
    } else if (PRIMARY_SET.has(CH) && myChCount < 3) {
      minFloorBonus = 400; // strong bonus to reach 3
    }

    // Big push to satisfy weekly quotas, then channel balance, then keep totals even
    return (needVal*100) + sameBonus + sdBonus + r1r2Penalty + ctrPriorityBonus + chBalancePenalty + minFloorBonus + ctReliefInverseBonus - (total*0.25);
  }

  // Helper: check if candidate works next block (for R1/R2 restriction)
  function worksNextBlock(cand) {
    const nextBlockIdx = bi + 1;
    if (nextBlockIdx < BLOCKS.length) {
      if (worksBlock(cand, dateObj, BLOCKS[nextBlockIdx])) return true;
    }
    if (bi === BLOCKS.length - 1) {
      const nextDay = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate() + 1, 12, 0, 0, 0);
      if (worksBlock(cand, nextDay, BLOCKS[0])) return true;
    }
    return false;
  }

  // Pass 1: STRICT – quota-driven + no immediate repeat + respect channel cycle + respect CT-bucket streak rule
  let best = null, bestScore = -1e9;
  for (const cand of shuffled) {
    if (usedNames.has(cand.name)) continue;

    // Training restriction: trainees can only work E, S, W, C
    if (!canTraineeWork(cand.name, CH, b.key)) continue;

    // R1/R2 restriction: In Pass 1, skip people who work next block
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;
    // Relief weekly cap: max 2 Relief blocks per person per work week
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && (rwmap.get(cand.name) || 0) >= WEEKLY_RELIEF_CAP) continue;
    if ((CH === "DC1" || CH === "DC2") && (dwmap.get(cand.name) || 0) >= WEEKLY_DC_CAP) continue;
    if (PRIMARY_SET.has(CH) && (pcwmap.get(`${cand.name}|${CH}`) || 0) >= WEEKLY_PRIMARY_CH_CAP) continue;

    // Same-day channel restriction: don't assign same channel twice in one day
    // Exception: allow back-to-back for primary geographic channels (max 2 consecutive)
    const candDayChannels = todayChannels.get(cand.name);
    if (candDayChannels && candDayChannels.has(CH)) {
      const lastCh = lastAssign.get(cand.name);
      if (!(lastCh && String(lastCh).toUpperCase() === CH && isAllowedPrimaryB2B(cand.name, CH))) continue;
    }

    // init/roll cycle
    if (!channelCycle.has(cand.name)) channelCycle.set(cand.name, new Set());
    const cyc = channelCycle.get(cand.name);
    if (cyc.size >= CHANNELS.length) cyc.clear();

    const last = lastAssign.get(cand.name);
    if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) continue;
    if (last && String(last).toUpperCase() === CH && !isAllowedPrimaryB2B(cand.name, CH)) continue;
    // Allow b2b for primary channels even if channel is in cycle
    if (cyc.has(ch) && !(last && String(last).toUpperCase() === CH && isAllowedPrimaryB2B(cand.name, CH))) continue;

    // (CT/Relief back-to-back now allowed — weekly caps enforce limits)

    const sc = candScore(cand);
    if (sc > bestScore) { bestScore=sc; best=cand; }
  }
  pick = best;

  // Pass 2: RELAX cycle (if staffing is too tight) – still enforce CT-bucket streak
  if (!pick) {
    best = null; bestScore = -1e9;
    for (const cand of shuffled) {
      if (usedNames.has(cand.name)) continue;

      // Training restriction: trainees can only work E, S, W, C
      if (!canTraineeWork(cand.name, CH, b.key)) continue;

      // R1/R2 restriction: In Pass 2, still skip people who work next block
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;
      // Relief weekly cap: max 2 Relief blocks per person per work week
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && (rwmap.get(cand.name) || 0) >= WEEKLY_RELIEF_CAP) continue;
    if ((CH === "DC1" || CH === "DC2") && (dwmap.get(cand.name) || 0) >= WEEKLY_DC_CAP) continue;
    if (PRIMARY_SET.has(CH) && (pcwmap.get(`${cand.name}|${CH}`) || 0) >= WEEKLY_PRIMARY_CH_CAP) continue;

      // Same-day channel restriction: don't assign same channel twice in one day
      // Exception: allow back-to-back for primary geographic channels (max 2 consecutive)
      const candDayChannels = todayChannels.get(cand.name);
      if (candDayChannels && candDayChannels.has(CH)) {
        const lastCh = lastAssign.get(cand.name);
        if (!(lastCh && String(lastCh).toUpperCase() === CH && isAllowedPrimaryB2B(cand.name, CH))) continue;
      }

      const last = lastAssign.get(cand.name);
      if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) continue;
      if (last && String(last).toUpperCase() === CH && !isAllowedPrimaryB2B(cand.name, CH)) continue;

      const sc = candScore(cand) - 15; // slight penalty vs strict
      if (sc > bestScore) { bestScore=sc; best=cand; }
    }
    pick = best;
  }

  // Pass 3: LAST RESORT – any available person (still enforce CT-bucket streak)
  if (!pick) {
    for (const cand of shuffled) {
      if (usedNames.has(cand.name)) continue;
      // Training restriction: trainees can only work E, S, W, C
      if (!canTraineeWork(cand.name, CH, b.key)) continue;
      // R1/R2 restriction: CRITICAL - still skip people who work next block even in Pass 3
      // This prevents Relief->CT back-to-back violations
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;
      // Relief weekly cap: max 2 Relief blocks per person per work week
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && (rwmap.get(cand.name) || 0) >= WEEKLY_RELIEF_CAP) continue;
    if ((CH === "DC1" || CH === "DC2") && (dwmap.get(cand.name) || 0) >= WEEKLY_DC_CAP) continue;
    if (PRIMARY_SET.has(CH) && (pcwmap.get(`${cand.name}|${CH}`) || 0) >= WEEKLY_PRIMARY_CH_CAP) continue;
      // Same-day channel restriction: don't assign same channel twice in one day
      // Exception: allow back-to-back for primary geographic channels (max 2 consecutive)
      const candDayChannels = todayChannels.get(cand.name);
      if (candDayChannels && candDayChannels.has(CH)) {
        const lastCh = lastAssign.get(cand.name);
        if (!(lastCh && String(lastCh).toUpperCase() === CH && isAllowedPrimaryB2B(cand.name, CH))) continue;
      }
      // Check forbiddenBackToBack even in Pass 3
      const last = lastAssign.get(cand.name);
      if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) continue;
      pick = cand; break;
    }
  }

  // If no pick found, skip this channel but continue with others
  // (Especially important for R1/R2 which may be skipped to prevent violations)
  if (!pick) continue;

  assignments[ch] = pick.name;
  usedNames.add(pick.name);
  lastAssign.set(pick.name, ch);

  // Track channel worked today (to prevent same channel twice in one day)
  if (!todayChannels.has(pick.name)) todayChannels.set(pick.name, new Set());
  todayChannels.get(pick.name).add(CH);

  // update cycle tracking
  if (!channelCycle.has(pick.name)) channelCycle.set(pick.name, new Set());
  const cyc = channelCycle.get(pick.name);
  if (cyc.size >= CHANNELS.length) cyc.clear();
  cyc.add(ch);

  // decrement weekly need if still owed
  const nd = getNeeds(wk, pick.name);
  if (nd[bucket] > 0) nd[bucket] -= 1;

  // update streaks
  updateStreaks(pick.name, String(ch).toUpperCase());

  // Track Relief weekly count
  if (CH === "RELIEF 1" || CH === "RELIEF 2") {
    rwmap.set(pick.name, (rwmap.get(pick.name) || 0) + 1);
  }
  // Track DC weekly count
  if (CH === "DC1" || CH === "DC2") {
    dwmap.set(pick.name, (dwmap.get(pick.name) || 0) + 1);
  }
  // Track primary channel weekly count
  if (PRIMARY_SET.has(CH)) {
    const pcKey = `${pick.name}|${CH}`;
    pcwmap.set(pcKey, (pcwmap.get(pcKey) || 0) + 1);
  }

  // update balancing counts
  if (!channelCounts.has(pick.name)) channelCounts.set(pick.name, new Map());
  const m = channelCounts.get(pick.name);
  m.set(ch, (m.get(ch)||0)+1);

  // Track SD employee channel usage (decrement remaining blocks)
  const pickUpper = String(pick.name).toUpperCase();
  if (SD_ELIGIBLE.has(pickUpper) && sdRemainingMap.has(pickUpper)) {
    const rem = sdRemainingMap.get(pickUpper) || 0;
    if (rem > 0) sdRemainingMap.set(pickUpper, rem - 1);
  }

  // Remove from must-get-channel list (they got their channel)
  mustGetChannelNextBlock.delete(pick.name);

  // If R1/R2 assigned and they work next block, they MUST get a channel next block
  // (This applies to Pass 1-3 as well, not just Pass 4)
  if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(pick)) {
    mustGetChannelNextBlock.add(pick.name);
  }
}

// ========== PASS 4: FILL ANY EMPTY CHANNELS ==========
// Multiple sub-passes with decreasing strictness to minimize violations
for (const ch of CHANNELS) {
  if (assignments[ch]) continue; // Already filled

  const CH = String(ch).toUpperCase();
  let pick = null;

  // Pass 4a: All checks - ideal candidate
  for (const cand of shuffled) {
    if (usedNames.has(cand.name)) continue;
    if (!canTraineeWork(cand.name, CH, b.key)) continue;
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(cand)) continue;
    // Relief weekly cap
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && (rwmap.get(cand.name) || 0) >= WEEKLY_RELIEF_CAP) continue;
    if ((CH === "DC1" || CH === "DC2") && (dwmap.get(cand.name) || 0) >= WEEKLY_DC_CAP) continue;
    if (PRIMARY_SET.has(CH) && (pcwmap.get(`${cand.name}|${CH}`) || 0) >= WEEKLY_PRIMARY_CH_CAP) continue;
    const last = lastAssign.get(cand.name);
    if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) continue;
    const candDayChannels = todayChannels.get(cand.name);
    if (candDayChannels && candDayChannels.has(CH)) {
      if (!(last && String(last).toUpperCase() === CH && isAllowedPrimaryB2B(cand.name, CH))) continue;
    }
    pick = cand;
    break;
  }

  // Pass 4b: Skip worksNextBlock, keep forbiddenBackToBack and same-day
  // For R1/R2, prefer people without violations (they'll likely get a Relief->CT violation)
  if (!pick) {
    const candidates4b = shuffled.filter(cand => {
      if (usedNames.has(cand.name)) return false;
      if (!canTraineeWork(cand.name, CH, b.key)) return false;
      // Relief weekly cap
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && (rwmap.get(cand.name) || 0) >= WEEKLY_RELIEF_CAP) return false;
      if ((CH === "DC1" || CH === "DC2") && (dwmap.get(cand.name) || 0) >= WEEKLY_DC_CAP) return false;
      if (PRIMARY_SET.has(CH) && (pcwmap.get(`${cand.name}|${CH}`) || 0) >= WEEKLY_PRIMARY_CH_CAP) return false;
      const last = lastAssign.get(cand.name);
      if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) return false;
      const candDayChannels = todayChannels.get(cand.name);
      if (candDayChannels && candDayChannels.has(CH)) {
        if (!(last && String(last).toUpperCase() === CH && isAllowedPrimaryB2B(cand.name, CH))) return false;
      }
      return true;
    });
    // Sort: people without violations first (for R1/R2 that may cause violation)
    if ((CH === "RELIEF 1" || CH === "RELIEF 2")) {
      candidates4b.sort((a, b) => (violationCount.get(a.name.toUpperCase())||0) - (violationCount.get(b.name.toUpperCase())||0));
    }
    if (candidates4b.length > 0) pick = candidates4b[0];
  }

  // Pass 4c: Skip worksNextBlock and same-day, KEEP forbiddenBackToBack (most important)
  if (!pick) {
    const candidates4c = shuffled.filter(cand => {
      if (usedNames.has(cand.name)) return false;
      if (!canTraineeWork(cand.name, CH, b.key)) return false;
      // Relief weekly cap
      if ((CH === "RELIEF 1" || CH === "RELIEF 2") && (rwmap.get(cand.name) || 0) >= WEEKLY_RELIEF_CAP) return false;
      if ((CH === "DC1" || CH === "DC2") && (dwmap.get(cand.name) || 0) >= WEEKLY_DC_CAP) return false;
      if (PRIMARY_SET.has(CH) && (pcwmap.get(`${cand.name}|${CH}`) || 0) >= WEEKLY_PRIMARY_CH_CAP) return false;
      const last = lastAssign.get(cand.name);
      if (last && forbiddenBackToBack(String(last).toUpperCase(), CH)) return false;
      return true;
    });
    // Sort: people without violations first
    if ((CH === "RELIEF 1" || CH === "RELIEF 2")) {
      candidates4c.sort((a, b) => (violationCount.get(a.name.toUpperCase())||0) - (violationCount.get(b.name.toUpperCase())||0));
    }
    if (candidates4c.length > 0) pick = candidates4c[0];
  }

  // Pass 4d: Last resort - anyone available (channel MUST be filled)
  // Even here, prefer people without violations
  if (!pick) {
    const candidates4d = shuffled.filter(cand => {
      if (usedNames.has(cand.name)) return false;
      if (!canTraineeWork(cand.name, CH, b.key)) return false;
      return true;
    });
    candidates4d.sort((a, b) => (violationCount.get(a.name.toUpperCase())||0) - (violationCount.get(b.name.toUpperCase())||0));
    if (candidates4d.length > 0) pick = candidates4d[0];
  }

  if (pick) {
    assignments[ch] = pick.name;
    usedNames.add(pick.name);
    lastAssign.set(pick.name, ch);

    if (!todayChannels.has(pick.name)) todayChannels.set(pick.name, new Set());
    todayChannels.get(pick.name).add(CH);

    if (!channelCycle.has(pick.name)) channelCycle.set(pick.name, new Set());
    channelCycle.get(pick.name).add(ch);

    if (!channelCounts.has(pick.name)) channelCounts.set(pick.name, new Map());
    const m = channelCounts.get(pick.name);
    m.set(ch, (m.get(ch)||0)+1);

    updateStreaks(pick.name, CH);

    // Track Relief weekly count
    if (CH === "RELIEF 1" || CH === "RELIEF 2") {
      rwmap.set(pick.name, (rwmap.get(pick.name) || 0) + 1);
    }
    // Track DC weekly count
    if (CH === "DC1" || CH === "DC2") {
      dwmap.set(pick.name, (dwmap.get(pick.name) || 0) + 1);
    }
    // Track primary channel weekly count
    if (PRIMARY_SET.has(CH)) {
      const pcKey = `${pick.name}|${CH}`;
      pcwmap.set(pcKey, (pcwmap.get(pcKey) || 0) + 1);
    }

    // Remove from must-get-channel list if they were in it (they got a channel now)
    mustGetChannelNextBlock.delete(pick.name);

    // If R1/R2 assigned to someone who works next block, they MUST get a channel next block
    if ((CH === "RELIEF 1" || CH === "RELIEF 2") && worksNextBlock(pick)) {
      mustGetChannelNextBlock.add(pick.name);
    }
  }
}
// ========== END PASS 4 ==========

const filled = Object.keys(assignments).length;

      // ========== 7TH CHANNEL (Fri/Sat nights 2200-0300) ==========
      // On Friday (day 5) and Saturday (day 6), add an additional "7th" dispatcher channel
      const dayOfWeek = dateObj.getDay(); // 0=Sun, 5=Fri, 6=Sat
      const isFriOrSat = (dayOfWeek === 5 || dayOfWeek === 6);
      const is7thBlock = SEVENTH_BLOCKS.has(b.key);

      if (isFriOrSat && is7thBlock && filled >= 10) {
        // Find someone for 7th channel from remaining available
        const remaining7th = shuffled.filter(c => !usedNames.has(c.name) && !isTrainee(c.name, dayKey, b.key));

        // Sort by fewest total assignments (fairness)
        remaining7th.sort((a,b2)=>{
          const ma = channelCounts.get(a.name) || new Map();
          const mb = channelCounts.get(b2.name) || new Map();
          const ta = Array.from(ma.values()).reduce((s,v)=>s+v,0);
          const tb = Array.from(mb.values()).reduce((s,v)=>s+v,0);
          return ta - tb;
        });

        if (remaining7th.length > 0) {
          const pick7 = remaining7th[0];
          assignments[SEVENTH_CHANNEL] = pick7.name;
          usedNames.add(pick7.name);
          lastAssign.set(pick7.name, SEVENTH_CHANNEL);

          // Track 7th channel worked today (to prevent same channel twice in one day)
          if (!todayChannels.has(pick7.name)) todayChannels.set(pick7.name, new Set());
          todayChannels.get(pick7.name).add("7TH");

          // Update balancing counts for 7th
          if (!channelCounts.has(pick7.name)) channelCounts.set(pick7.name, new Map());
          const m7 = channelCounts.get(pick7.name);
          m7.set(SEVENTH_CHANNEL, (m7.get(SEVENTH_CHANNEL)||0)+1);
        }
      }
      // ========== END 7TH CHANNEL ==========

      // SD (Special Detail): Use pre-assigned SD from earlier calculation
      // SD is now assigned FIRST (32 hrs mandatory/week) before channels are filled
      const sd = sdForBlock.slice(); // Copy pre-assigned SD for this block

      // CT overflow: show as a vertical list later; CT does NOT count as a channel in cycle tracking
      const ct = [];


if (available.length > 10) {
  // CT overflow with HARD monthly caps:
  // - We try to keep CT split as evenly as possible across the month.
  // - If CT is unavoidable after caps are hit, we allow a controlled "repeat":
  //     * MAX once per week per person
  //     * MUST be back-to-back (consecutive 4-hr blocks)
    const wmap = ctWeekCounts.get(wk) || new Map();
  const globalIdx = (day-1) * BLOCKS.length + bi;

  function capFor(name){
    // HARD CAP: nobody can be assigned to CT more than 10 times per month
    return 10;
  }
  function canTakeChannel(name, ch){
    const last = lastAssign.get(name);
    if (last && forbiddenBackToBack(last, ch)) return false;
    const lastUpper = last ? String(last).toUpperCase() : "";
    const chUpper = String(ch).toUpperCase();
    if (last && lastUpper === chUpper && !isAllowedPrimaryB2B(name, ch)) return false;
    // Also check daily same-channel restriction (with b2b exception)
    const candDayChannels = todayChannels.get(name);
    if (candDayChannels && candDayChannels.has(chUpper)) {
      if (!(last && lastUpper === chUpper && isAllowedPrimaryB2B(name, ch))) return false;
    }
    return true;
  }
  function atOrOverCap(name){
    return (ctMonthCounts.get(name) || 0) >= capFor(name);
  }

  // CRITICAL: First, ensure anyone in mustGetChannelNextBlock gets a channel (to avoid Relief->CT)
  // These people were on R1/R2 last block and MUST get a channel now
  let remaining = shuffled.filter(c => !usedNames.has(c.name));

  const mustGetPeople = remaining.filter(c => mustGetChannelNextBlock.has(c.name));
  for (const cand of mustGetPeople) {
    // Try to swap them into any channel
    for (const ch of CHANNELS) {
      const cur = assignments[ch];
      if (!cur) continue; // Empty channel - shouldn't happen but skip
      if (!canTakeChannel(cand.name, ch)) continue;
      if (!canTraineeWork(cand.name, String(ch).toUpperCase(), b.key)) continue;

      // Check if current holder can go to CT (not on CTR recently)
      const holderLast = lastAssign.get(cur);
      const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
      const ctrSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
      if (ctrSet.has(holderLastUpper)) continue; // Holder can't go to CT
      if (mustGetChannelNextBlock.has(cur)) continue; // Holder also needs a channel
      if (b2bProtected.has(cur)) continue; // Don't undo b2b pre-assignments

      // Swap: cand gets channel, cur goes to CT pool
      assignments[ch] = cand.name;
      usedNames.add(cand.name);
      usedNames.delete(cur);
      lastAssign.set(cand.name, ch);

      const chUpper = String(ch).toUpperCase();
      if (!todayChannels.has(cand.name)) todayChannels.set(cand.name, new Set());
      todayChannels.get(cand.name).add(chUpper);

      if (!channelCounts.has(cand.name)) channelCounts.set(cand.name, new Map());
      channelCounts.get(cand.name).set(ch, (channelCounts.get(cand.name).get(ch)||0)+1);

      mustGetChannelNextBlock.delete(cand.name); // They got their channel
      break;
    }
    remaining = shuffled.filter(c => !usedNames.has(c.name));
  }

  // If someone is capped, try to swap them into a channel (so they don't land in CT),
  // pushing a non-capped person into overflow instead.
  remaining = shuffled.filter(c => !usedNames.has(c.name));

  const cappedNow = remaining.filter(c => atOrOverCap(c.name));
  for (const cand of cappedNow) {
    let swapped = false;

    for (const ch of CHANNELS) {
      const cur = assignments[ch];
      if (!cur) continue;

      // only swap out someone who is NOT capped
      if (atOrOverCap(cur)) continue;
      if (b2bProtected.has(cur)) continue; // Don't undo b2b pre-assignments
      if (!canTakeChannel(cand.name, ch)) continue;
      if (!canTraineeWork(cand.name, String(ch).toUpperCase(), b.key)) continue;

      // swap
      assignments[ch] = cand.name;
      usedNames.add(cand.name);
      usedNames.delete(cur);

      // keep lastAssign consistent for cand
      lastAssign.set(cand.name, ch);

      // Track swapped-in channel worked today
      const swapCH = String(ch).toUpperCase();
      if (!todayChannels.has(cand.name)) todayChannels.set(cand.name, new Set());
      todayChannels.get(cand.name).add(swapCH);

      // update balancing counts for cand
      if (!channelCounts.has(cand.name)) channelCounts.set(cand.name, new Map());
      const mm = channelCounts.get(cand.name);
      mm.set(ch, (mm.get(ch) || 0) + 1);

      swapped = true;
      break;
    }

    if (swapped) {
      remaining = shuffled.filter(c => !usedNames.has(c.name));
    }
  }

  // Now assign CT STRICTLY under the hard cap.
  // Weekly soft cap: prefer people with fewer CT this week (spread across month)
  const CT_WEEKLY_SOFT_CAP = 3; // Soft cap: try to limit CT to 3 per person per week
  remaining = shuffled.filter(c => !usedNames.has(c.name));

  // Sort priority: under weekly soft cap > under monthly cap > lowest CT counts
  remaining.sort((a,b2)=>{
    const ca = ctMonthCounts.get(a.name)||0;
    const cb = ctMonthCounts.get(b2.name)||0;
    const oa = ca >= capFor(a.name);
    const ob = cb >= capFor(b2.name);

    // Weekly CT counts for spreading across month
    const wca = wmap.get(a.name)||0;
    const wcb = wmap.get(b2.name)||0;
    const woa = wca >= CT_WEEKLY_SOFT_CAP;
    const wob = wcb >= CT_WEEKLY_SOFT_CAP;

    // Priority: under monthly cap first
    if (oa !== ob) return oa ? 1 : -1;
    // Then prefer under weekly soft cap (spread CT across weeks)
    if (woa !== wob) return woa ? 1 : -1;
    // Then prefer lowest weekly CT (spread within week)
    if (wca !== wcb) return wca - wcb;
    // Then prefer lowest monthly CT
    if (ca !== cb) return ca - cb;
    return 0;
  });

  for (const cand of remaining) {
    const name = cand.name;
    // Training restriction: trainees should not be assigned to CT (date-only, all blocks)
    if (isTrainee(name, dayKey, b.key)) { continue; }

    // CT/Relief back-to-back is now allowed (weekly caps enforce limits)

    const needs = getNeeds(wk, name);
    // Weekly mix rule: CT counts toward the CT/R1/R2 bucket (2 blocks / 8 hrs target)
    if ((needs.ctr || 0) <= 0) { continue; }

    const cur = ctMonthCounts.get(name) || 0;
    const cap = capFor(name);

    if (cur >= cap) {
      continue;
    }

    // Hard weekly CT cap: max 2 CT blocks per person per work week
    const weekCt = wmap.get(name)||0;
    if (weekCt >= WEEKLY_CT_CAP) {
      continue; // Skip - already at weekly CT cap
    }

    ct.push(name);
    // decrement weekly CT/R bucket need
    if ((needs.ctr||0) > 0) needs.ctr -= 1;
    updateStreaks(name, "CT");
    lastAssign.set(name, "CT"); // Track CT assignment for back-to-back prevention

    // Track CT in daily channels to prevent same-day repeat
    if (!todayChannels.has(name)) todayChannels.set(name, new Set());
    todayChannels.get(name).add("CT");

    wmap.set(name, (wmap.get(name) || 0) + 1);
    ctMonthCounts.set(name, cur + 1);
    lastCTAt.set(name, {dayKey, blockIdx: bi});
    lastCTGlobalIdx.set(name, globalIdx);
  }

  ctWeekCounts.set(wk, wmap);
}

// SAFETY NET: Anyone who is available but wasn't assigned to a channel or CT
// For people who were on CT/R1/R2, we MUST get them a channel to avoid back-to-back
const unassigned = available.filter(d => !usedNames.has(d.name));
const ctrNames = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);

for (const u of unassigned) {
  if (ct.includes(u.name)) continue;

  const lastCh = lastAssign.get(u.name);
  const lastUpper = lastCh ? String(lastCh).toUpperCase() : "";
  const wasOnCTR = ctrNames.has(lastUpper);

  // Also check if they had any CTR today (not just last block)
  const uDayChans = todayChannels.get(u.name);
  const hadCTRToday = uDayChans && (uDayChans.has("CT") || uDayChans.has("RELIEF 1") || uDayChans.has("RELIEF 2"));

  if (wasOnCTR || hadCTRToday) {
    // They were on CT/R1/R2 - MUST get a channel, not CT
    // Try to find an empty channel first
    let foundChannel = false;
    for (const ch of CHANNELS) {
      if (assignments[ch]) continue; // Already filled
      const chUpper = String(ch).toUpperCase();
      if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue; // Can't do R1/R2
      // Check daily same-channel restriction
      const uDayChannels = todayChannels.get(u.name);
      if (uDayChannels && uDayChannels.has(chUpper)) continue;
      if (!canTraineeWork(u.name, chUpper, b.key)) continue;
      if (!forbiddenBackToBack(lastUpper, chUpper)) {
        assignments[ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, ch);
        // Track channel worked today
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(chUpper);
        foundChannel = true;
        break;
      }
    }

    // If no empty channel, SWAP with someone who CAN go to CT (prefer no violations)
    if (!foundChannel) {
      const swapCands1 = [];
      for (const ch of CHANNELS) {
        const currentHolder = assignments[ch];
        if (!currentHolder) continue;
        if (b2bProtected.has(currentHolder)) continue; // Don't undo b2b pre-assignments
        if (isTrainee(currentHolder, dayKey, b.key)) continue; // Don't push trainee to CT during training blocks
        const chUpper = String(ch).toUpperCase();
        if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue;
        if (traineeBlocked(u.name, dayKey, null, chUpper)) continue; // Don't put trainee in disallowed channel
        if (forbiddenBackToBack(lastUpper, chUpper)) continue;
        const uDayChannels = todayChannels.get(u.name);
        if (uDayChannels && uDayChannels.has(chUpper)) continue;
        if (!canTraineeWork(u.name, chUpper, b.key)) continue;

        const holderLast = lastAssign.get(currentHolder);
        const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
        const holderWasOnCTR = ctrNames.has(holderLastUpper);
        const holderDayChannels = todayChannels.get(currentHolder);
        const holderHadCTToday = holderDayChannels && holderDayChannels.has("CT");
        const holderCTCount = ctMonthCounts.get(currentHolder) || 0;
        const holderAtCap = holderCTCount >= 10;

        if (!holderWasOnCTR && !holderHadCTToday && !holderAtCap) {
          const holderViol = violationCount.get(currentHolder.toUpperCase()) || 0;
          const holderWeekCT = (ctWeekCounts.get(wk) || new Map()).get(currentHolder) || 0;
          if (holderWeekCT < WEEKLY_CT_CAP) { // Hard filter: only under weekly cap
            swapCands1.push({ ch, chUpper, currentHolder, holderCTCount, holderViol, holderWeekCT });
          }
        }
      }
      // Sort: no violations first, then lowest CT
      swapCands1.sort((a, b) => {
        if (a.holderViol !== b.holderViol) return a.holderViol - b.holderViol;
        return a.holderCTCount - b.holderCTCount;
      });
      if (swapCands1.length > 0) {
        const best = swapCands1[0];
        assignments[best.ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, best.ch);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(best.chUpper);

        ct.push(best.currentHolder);
        lastAssign.set(best.currentHolder, "CT");
        updateStreaks(best.currentHolder, "CT");
        if (!todayChannels.has(best.currentHolder)) todayChannels.set(best.currentHolder, new Set());
        todayChannels.get(best.currentHolder).add("CT");
        ctMonthCounts.set(best.currentHolder, best.holderCTCount + 1);
        const wkMap = ctWeekCounts.get(wk) || new Map();
        wkMap.set(best.currentHolder, (wkMap.get(best.currentHolder) || 0) + 1);
        ctWeekCounts.set(wk, wkMap);

        foundChannel = true;
      }
    }

    // If still no channel, try harder to swap - find ANY channel holder who can go to CT (prefer no violations)
    if (!foundChannel) {
      const swapCands2 = [];
      for (const ch of CHANNELS) {
        const currentHolder = assignments[ch];
        if (!currentHolder) continue;
        if (b2bProtected.has(currentHolder)) continue; // Don't undo b2b pre-assignments
        if (isTrainee(currentHolder, dayKey, b.key)) continue; // Don't push trainee to CT during training blocks
        const chUpper = String(ch).toUpperCase();
        if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue;
        if (traineeBlocked(u.name, dayKey, null, chUpper)) continue; // Don't put trainee in disallowed channel
        if (forbiddenBackToBack(lastUpper, chUpper)) continue;
        const uDayChannels = todayChannels.get(u.name);
        if (uDayChannels && uDayChannels.has(chUpper)) continue;
        if (!canTraineeWork(u.name, chUpper, b.key)) continue;

        const holderLast = lastAssign.get(currentHolder);
        const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
        const holderWasOnCTR = ctrNames.has(holderLastUpper);
        const holderDayChannels = todayChannels.get(currentHolder);
        const holderHadCTRToday = holderDayChannels && (holderDayChannels.has("CT") || holderDayChannels.has("RELIEF 1") || holderDayChannels.has("RELIEF 2"));
        const holderCTCount2 = ctMonthCounts.get(currentHolder) || 0;
        const holderAtCap2 = holderCTCount2 >= 10;

        if (!holderWasOnCTR && !holderHadCTRToday && !holderAtCap2) {
          const holderViol = violationCount.get(currentHolder.toUpperCase()) || 0;
          const holderWeekCT2 = (ctWeekCounts.get(wk) || new Map()).get(currentHolder) || 0;
          if (holderWeekCT2 < WEEKLY_CT_CAP) { // Hard filter: only under weekly cap
            swapCands2.push({ ch, chUpper, currentHolder, holderCTCount2, holderViol, holderWeekCT2 });
          }
        }
      }
      // Sort: no violations first, then lowest CT
      swapCands2.sort((a, b) => {
        if (a.holderViol !== b.holderViol) return a.holderViol - b.holderViol;
        return a.holderCTCount2 - b.holderCTCount2;
      });
      if (swapCands2.length > 0) {
        const best = swapCands2[0];
        assignments[best.ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, best.ch);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(best.chUpper);

        ct.push(best.currentHolder);
        lastAssign.set(best.currentHolder, "CT");
        updateStreaks(best.currentHolder, "CT");
        if (!todayChannels.has(best.currentHolder)) todayChannels.set(best.currentHolder, new Set());
        todayChannels.get(best.currentHolder).add("CT");
        ctMonthCounts.set(best.currentHolder, best.holderCTCount2 + 1);
        const wkMap2 = ctWeekCounts.get(wk) || new Map();
        wkMap2.set(best.currentHolder, (wkMap2.get(best.currentHolder) || 0) + 1);
        ctWeekCounts.set(wk, wkMap2);

        foundChannel = true;
      }
    }

    // THIRD ATTEMPT: Allow swapping with someone OVER cap (uneven CT is better than violation)
    // Sort by CT count to prefer swapping with lowest CT person even if over cap
    if (!foundChannel) {
      const swapCandidates = [];
      for (const ch of CHANNELS) {
        const currentHolder = assignments[ch];
        if (!currentHolder) continue;
        if (b2bProtected.has(currentHolder)) continue; // Don't undo b2b pre-assignments
        if (isTrainee(currentHolder, dayKey, b.key)) continue; // Don't push trainee to CT during training blocks
        const chUpper = String(ch).toUpperCase();
        if (chUpper === "RELIEF 1" || chUpper === "RELIEF 2") continue;
        if (traineeBlocked(u.name, dayKey, null, chUpper)) continue; // Don't put trainee in disallowed channel
        if (forbiddenBackToBack(lastUpper, chUpper)) continue;
        const uDayChannels = todayChannels.get(u.name);
        if (uDayChannels && uDayChannels.has(chUpper)) continue;

        const holderLast = lastAssign.get(currentHolder);
        const holderLastUpper = holderLast ? String(holderLast).toUpperCase() : "";
        const holderWasOnCTR = ctrNames.has(holderLastUpper);
        const holderDayChannels = todayChannels.get(currentHolder);
        const holderHadCTRToday = holderDayChannels && (holderDayChannels.has("CT") || holderDayChannels.has("RELIEF 1") || holderDayChannels.has("RELIEF 2"));

        // Allow over-cap, but skip if they were on CTR or had CTR today (would cause violation)
        if (!holderWasOnCTR && !holderHadCTRToday) {
          const holderCT = ctMonthCounts.get(currentHolder) || 0;
          const holderWeekCT3 = (ctWeekCounts.get(wk) || new Map()).get(currentHolder) || 0;
          swapCandidates.push({ ch, chUpper, currentHolder, holderCT, holderWeekCT3 });
        }
      }

      // Sort by: 1) under weekly cap first, 2) no violations, 3) lowest CT count
      swapCandidates.sort((a, b) => {
        const aOver = a.holderWeekCT3 >= WEEKLY_CT_CAP ? 1 : 0;
        const bOver = b.holderWeekCT3 >= WEEKLY_CT_CAP ? 1 : 0;
        if (aOver !== bOver) return aOver - bOver;
        const aViol = violationCount.get(a.currentHolder.toUpperCase()) || 0;
        const bViol = violationCount.get(b.currentHolder.toUpperCase()) || 0;
        if (aViol !== bViol) return aViol - bViol; // Prefer no violations
        return a.holderCT - b.holderCT;
      });

      if (swapCandidates.length > 0) {
        const best = swapCandidates[0];
        assignments[best.ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, best.ch);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(best.chUpper);

        ct.push(best.currentHolder);
        lastAssign.set(best.currentHolder, "CT");
        updateStreaks(best.currentHolder, "CT");
        if (!todayChannels.has(best.currentHolder)) todayChannels.set(best.currentHolder, new Set());
        todayChannels.get(best.currentHolder).add("CT");
        ctMonthCounts.set(best.currentHolder, best.holderCT + 1);
        const wkMap3 = ctWeekCounts.get(wk) || new Map();
        wkMap3.set(best.currentHolder, (wkMap3.get(best.currentHolder) || 0) + 1);
        ctWeekCounts.set(wk, wkMap3);

        foundChannel = true;
      }
    }

    // Last resort: if still no channel, assign CT (violation is unavoidable)
    // But skip trainees — they must stay on allowed channels, not CT
    if (!foundChannel && !isTrainee(u.name, dayKey, b.key)) {
      ct.push(u.name);
      lastAssign.set(u.name, "CT");
      updateStreaks(u.name, "CT");
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add("CT");
      // UPDATE CT COUNTS
      ctMonthCounts.set(u.name, (ctMonthCounts.get(u.name) || 0) + 1);
      const wkMapLR = ctWeekCounts.get(wk) || new Map();
      wkMapLR.set(u.name, (wkMapLR.get(u.name) || 0) + 1);
      ctWeekCounts.set(wk, wkMapLR);
      // TRACK VIOLATION (Relief->CT back-to-back)
      addViolation(u.name);
    }
  } else if (!isTrainee(u.name, dayKey, b.key)) {
    // They weren't on CT/R1/R2 - check if they already had any CTR today
    const uDayChannels = todayChannels.get(u.name);
    const uHadCTRToday = uDayChannels && (uDayChannels.has("CT") || uDayChannels.has("RELIEF 1") || uDayChannels.has("RELIEF 2"));
    // Also check if they're at or over monthly CT cap or weekly CT cap
    const uCTCount = ctMonthCounts.get(u.name) || 0;
    const uWeekCT = (ctWeekCounts.get(wk) || new Map()).get(u.name) || 0;
    if (!uHadCTRToday && uCTCount < 10 && uWeekCT < WEEKLY_CT_CAP) {
      ct.push(u.name);
      lastAssign.set(u.name, "CT");
      updateStreaks(u.name, "CT");
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add("CT");
      // UPDATE CT COUNTS
      ctMonthCounts.set(u.name, uCTCount + 1);
      const wkMapElse = ctWeekCounts.get(wk) || new Map();
      wkMapElse.set(u.name, (wkMapElse.get(u.name) || 0) + 1);
      ctWeekCounts.set(wk, wkMapElse);
    }
    // If they already had CTR today or at cap, force CT anyway — unassigned is never acceptable
    if (!ct.includes(u.name) && !usedNames.has(u.name)) {
      ct.push(u.name);
      lastAssign.set(u.name, "CT");
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add("CT");
      ctMonthCounts.set(u.name, (ctMonthCounts.get(u.name) || 0) + 1);
      const wkMapForce = ctWeekCounts.get(wk) || new Map();
      wkMapForce.set(u.name, (wkMapForce.get(u.name) || 0) + 1);
      ctWeekCounts.set(wk, wkMapForce);
    }
  }
}

// TRAINEE RESCUE: Get unassigned trainees into allowed channels (E/S/W/C) via swap
const traineeUnassigned = available.filter(d => !usedNames.has(d.name) && !ct.includes(d.name) && !sd.includes(d.name) && isTrainee(d.name, dayKey, b.key));
for (const u of traineeUnassigned) {
  const _traineeAllowed = ["East","South","West","Central"];
  let placed = false;
  // Try empty allowed channel first
  for (const ch of _traineeAllowed) {
    if (!assignments[ch]) {
      assignments[ch] = u.name;
      usedNames.add(u.name);
      lastAssign.set(u.name, ch);
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add(ch.toUpperCase());
      placed = true;
      break;
    }
  }
  // If no empty slot, swap with a non-trainee on an allowed channel
  if (!placed) {
    for (const ch of _traineeAllowed) {
      const holder = assignments[ch];
      if (!holder) continue;
      if (isTrainee(holder, dayKey, b.key)) continue;
      // Trainee placement overrides b2b protection
      assignments[ch] = u.name;
      usedNames.add(u.name);
      lastAssign.set(u.name, ch);
      if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
      todayChannels.get(u.name).add(ch.toUpperCase());
      ct.push(holder);
      lastAssign.set(holder, "CT");
      if (!todayChannels.has(holder)) todayChannels.set(holder, new Set());
      todayChannels.get(holder).add("CT");
      ctMonthCounts.set(holder, (ctMonthCounts.get(holder) || 0) + 1);
      const wkMapTR = ctWeekCounts.get(wk) || new Map();
      wkMapTR.set(holder, (wkMapTR.get(holder) || 0) + 1);
      ctWeekCounts.set(wk, wkMapTR);
      placed = true;
      break;
    }
  }
}

// FINAL SWEEP: Catch anyone still not assigned (edge cases) — force to CT
const finalUnassigned = available.filter(d => !usedNames.has(d.name) && !ct.includes(d.name) && !sd.includes(d.name));
for (const u of finalUnassigned) {
  // Trainee restriction: never push trainee to CT — try allowed channel or leave unassigned
  if (isTrainee(u.name, dayKey, b.key)) {
    const _tOk = ["East","South","West","Central"];
    let _tPlaced = false;
    // Try empty allowed channel
    for (const _tCh of _tOk) {
      if (!assignments[_tCh]) {
        assignments[_tCh] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, _tCh);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(_tCh.toUpperCase());
        _tPlaced = true;
        break;
      }
    }
    // Try swapping with a non-trainee holder in an allowed channel (prefer under weekly CT cap)
    if (!_tPlaced) {
      const _tSwapCands = [];
      for (const _tCh of _tOk) {
        const _tH = assignments[_tCh];
        if (!_tH) continue;
        if (isTrainee(_tH, dayKey, b.key)) continue;
        const _tHwk = (ctWeekCounts.get(wk) || new Map()).get(_tH) || 0;
        _tSwapCands.push({ ch: _tCh, holder: _tH, wkCT: _tHwk });
      }
      _tSwapCands.sort((a, b2) => a.wkCT - b2.wkCT);
      if (_tSwapCands.length > 0) {
        const _tPick = _tSwapCands[0];
        assignments[_tPick.ch] = u.name;
        usedNames.add(u.name);
        lastAssign.set(u.name, _tPick.ch);
        if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
        todayChannels.get(u.name).add(_tPick.ch.toUpperCase());
        ct.push(_tPick.holder);
        lastAssign.set(_tPick.holder, "CT");
        if (!todayChannels.has(_tPick.holder)) todayChannels.set(_tPick.holder, new Set());
        todayChannels.get(_tPick.holder).add("CT");
        ctMonthCounts.set(_tPick.holder, (ctMonthCounts.get(_tPick.holder) || 0) + 1);
        const _twk = ctWeekCounts.get(wk) || new Map();
        _twk.set(_tPick.holder, (_twk.get(_tPick.holder) || 0) + 1);
        ctWeekCounts.set(wk, _twk);
        _tPlaced = true;
      }
    }
    continue; // never push trainee to CT
  }
  ct.push(u.name);
  lastAssign.set(u.name, "CT");
  if (!todayChannels.has(u.name)) todayChannels.set(u.name, new Set());
  todayChannels.get(u.name).add("CT");
  ctMonthCounts.set(u.name, (ctMonthCounts.get(u.name) || 0) + 1);
  const wkMapFinal = ctWeekCounts.get(wk) || new Map();
  wkMapFinal.set(u.name, (wkMapFinal.get(u.name) || 0) + 1);
  ctWeekCounts.set(wk, wkMapFinal);
}

      plan.days[dayKey][b.key] = { assignments, sd, ct, filled, needed: 10 };
    }
  }

  savePlan(plan);

  // ========== B2B EVENING PASS (Option B) ==========
  {
    const _b2bPrimB = new Set(["NORTH","EAST","SOUTH","WEST","NORTHWEST","CENTRAL"]);
    const _b2bExclB = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2","DC1","DC2"]);

    // Build finalCounts for B2B pass (needed before the stats section builds its own)
    const _b2bFinalCounts = new Map();
    for (const dk of Object.keys(plan.days)) {
      const dayData = plan.days[dk];
      for (const bk of BLOCKS) {
        const bd = dayData[bk.key];
        if (!bd || !bd.assignments) continue;
        for (const [ch, nm] of Object.entries(bd.assignments)) {
          if (!nm) continue;
          if (!_b2bFinalCounts.has(nm)) _b2bFinalCounts.set(nm, new Map());
          const m = _b2bFinalCounts.get(nm);
          m.set(ch.toUpperCase(), (m.get(ch.toUpperCase()) || 0) + 1);
        }
      }
    }

    function _countB2B_B() {
      const b2bCounts = new Map();
      const b2bEntries = [];
      for (let day = 1; day <= daysInMonth; day++) {
        const dObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
        const dk = ymd(dObj);
        const dayData = plan.days[dk];
        if (!dayData) continue;
        const personBlocks = new Map();
        for (let bi = 0; bi < BLOCKS.length; bi++) {
          const bd = dayData[BLOCKS[bi].key];
          if (!bd || !bd.assignments) continue;
          for (const [ch, nm] of Object.entries(bd.assignments)) {
            if (!nm) continue;
            if (!personBlocks.has(nm)) personBlocks.set(nm, []);
            personBlocks.get(nm).push({ blockIdx: bi, channel: ch.toUpperCase(), blockKey: BLOCKS[bi].key, origCh: ch });
          }
        }
        for (const [nm, blocks] of personBlocks) {
          if (SD_ELIGIBLE.has(nm.toUpperCase())) continue;
          blocks.sort((a, b) => a.blockIdx - b.blockIdx);
          for (let i = 1; i < blocks.length; i++) {
            const prev = blocks[i - 1], curr = blocks[i];
            if (curr.blockIdx === prev.blockIdx + 1 && curr.channel === prev.channel && _b2bPrimB.has(curr.channel)) {
              b2bCounts.set(nm, (b2bCounts.get(nm) || 0) + 1);
              b2bEntries.push({ name: nm, dayKey: dk, blockKey: curr.blockKey, channel: curr.origCh, blockIdx: curr.blockIdx });
            }
          }
        }
      }
      for (const [nm] of _b2bFinalCounts) {
        if (SD_ELIGIBLE.has(nm.toUpperCase())) continue;
        if (!b2bCounts.has(nm)) b2bCounts.set(nm, 0);
      }
      return { b2bCounts, b2bEntries };
    }

    // Helper: would assigning personName to channel in blockKey create a B2B pair?
    function _wouldCreateB2B_B(personName, dayKey, blockKey, channel) {
      const chUp = String(channel).toUpperCase();
      if (!_b2bPrimB.has(chUp)) return false;
      const dayData = plan.days[dayKey];
      if (!dayData) return false;
      const bIdx = BLOCKS.findIndex(b => b.key === blockKey);
      if (bIdx < 0) return false;
      for (const adj of [bIdx - 1, bIdx + 1]) {
        if (adj < 0 || adj >= BLOCKS.length) continue;
        const adjBd = dayData[BLOCKS[adj].key];
        if (!adjBd || !adjBd.assignments) continue;
        for (const [ch, nm] of Object.entries(adjBd.assignments)) {
          if (nm === personName && ch.toUpperCase() === chUp) return true;
        }
      }
      return false;
    }

    // Helper: would assigning personName to channel create a same-channel non-adjacent violation?
    function _wouldViolateSameDayNonAdj_B(personName, dayKey, blockKey, channel) {
      const chUp = String(channel).toUpperCase();
      const dayData = plan.days[dayKey];
      if (!dayData) return false;
      const bIdx = BLOCKS.findIndex(b => b.key === blockKey);
      if (bIdx < 0) return false;
      for (let bi = 0; bi < BLOCKS.length; bi++) {
        if (BLOCKS[bi].key === blockKey) continue;
        const bd = dayData[BLOCKS[bi].key];
        if (!bd || !bd.assignments) continue;
        for (const [ch, nm] of Object.entries(bd.assignments)) {
          if (nm === personName && ch.toUpperCase() === chUp) {
            if (Math.abs(bi - bIdx) === 1) continue; // Adjacent is OK (B2B, handled separately)
            return true; // Non-adjacent same channel = violation
          }
        }
      }
      return false;
    }

    // Hard B2B cap: break B2B pairs until everyone has <= 1
    for (let b2bRound = 0; b2bRound < 100; b2bRound++) {
      const { b2bCounts, b2bEntries } = _countB2B_B();
      if (b2bEntries.length === 0) break;
      const vals = [...b2bCounts.values()];
      const maxB2B = Math.max(...vals);
      if (maxB2B <= 1) break; // Hard cap achieved: everyone has <= 1 B2B

      b2bEntries.sort((a, b) => (b2bCounts.get(b.name) || 0) - (b2bCounts.get(a.name) || 0));

      let swapped = false;
      for (const entry of b2bEntries) {
        const overB2B = b2bCounts.get(entry.name) || 0;
        if (overB2B <= 1) continue; // Already at or below cap
        const dk = entry.dayKey, bk = entry.blockKey;
        const bd = plan.days[dk] && plan.days[dk][bk];
        if (!bd || !bd.assignments) continue;
        if (bd.assignments[entry.channel] !== entry.name) continue;

        for (const [c2, nm2] of Object.entries(bd.assignments)) {
          if (!nm2 || nm2 === entry.name || c2 === entry.channel) continue;
          if (_b2bExclB.has(c2.toUpperCase())) continue;
          if (SD_ELIGIBLE.has(nm2.toUpperCase())) continue;

          // Don't create a new B2B for the swap partner
          if (_wouldCreateB2B_B(nm2, dk, bk, entry.channel)) continue;
          // Don't create a new B2B for the over-person with the new channel
          if (_wouldCreateB2B_B(entry.name, dk, bk, c2)) continue;

          // Safety: no same-channel non-adjacent violations
          if (_wouldViolateSameDayNonAdj_B(entry.name, dk, bk, c2)) continue;
          if (_wouldViolateSameDayNonAdj_B(nm2, dk, bk, entry.channel)) continue;

          // Safety: don't drop either person below 1 on their channel
          const donorCounts = _b2bFinalCounts.get(nm2);
          if (donorCounts && (donorCounts.get(c2.toUpperCase()) || 0) <= 1) continue;
          const overCounts = _b2bFinalCounts.get(entry.name);
          if (overCounts && (overCounts.get(entry.channel.toUpperCase()) || 0) <= 1) continue;

          // Trainee restriction
          if (traineeBlocked(nm2, dk, bk, entry.channel.toUpperCase())) continue;
          if (traineeBlocked(entry.name, dk, bk, c2.toUpperCase())) continue;

          bd.assignments[entry.channel] = nm2;
          bd.assignments[c2] = entry.name;
          if (overCounts) {
            overCounts.set(entry.channel.toUpperCase(), (overCounts.get(entry.channel.toUpperCase()) || 0) - 1);
            overCounts.set(c2.toUpperCase(), (overCounts.get(c2.toUpperCase()) || 0) + 1);
          }
          if (donorCounts) {
            donorCounts.set(c2.toUpperCase(), (donorCounts.get(c2.toUpperCase()) || 0) - 1);
            donorCounts.set(entry.channel.toUpperCase(), (donorCounts.get(entry.channel.toUpperCase()) || 0) + 1);
          }
          swapped = true;
          break;
        }
        if (swapped) break;
      }
      if (!swapped) break;
    }
  }
  // ========== END B2B EVENING PASS (Option B) ==========

  // ========== TRAINEE CORRECTION PASS (Option B) ==========
  // After ALL balancing, scan every block and fix any trainee still on a disallowed channel or CT
  {
    const _tcOkSet = new Set(["EAST","SOUTH","WEST","CENTRAL"]);
    const _tcAllowed = ["East","South","West","Central"];
    for (let _tcDay = 1; _tcDay <= daysInMonth; _tcDay++) {
      const _tcDate = new Date(year, monthIndex, _tcDay, 12, 0, 0, 0);
      const _tcDk = ymd(_tcDate);
      const _tcDayData = plan.days[_tcDk];
      if (!_tcDayData) continue;
      for (const _tcBlk of BLOCKS) {
        const _tcBd = _tcDayData[_tcBlk.key];
        if (!_tcBd) continue;

        // Fix trainees in disallowed channel assignments
        for (const [ch, nm] of Object.entries(_tcBd.assignments || {})) {
          if (!nm) continue;
          if (!isTrainee(nm, _tcDk, _tcBlk.key)) continue;
          if (_tcOkSet.has(ch.toUpperCase())) continue;
          let _tcFixed = false;
          for (const _tcCh of _tcAllowed) {
            const _tcHolder = _tcBd.assignments[_tcCh];
            if (!_tcHolder) {
              _tcBd.assignments[_tcCh] = nm;
              _tcBd.assignments[ch] = null;
              _tcFixed = true;
              break;
            }
            if (isTrainee(_tcHolder, _tcDk, _tcBlk.key)) continue;
            _tcBd.assignments[_tcCh] = nm;
            _tcBd.assignments[ch] = _tcHolder;
            _tcFixed = true;
            break;
          }
          if (!_tcFixed) {
            _tcBd.assignments[ch] = null;
            for (const _tcCh of _tcAllowed) {
              if (!_tcBd.assignments[_tcCh]) {
                _tcBd.assignments[_tcCh] = nm;
                break;
              }
            }
          }
        }

        // Fix trainees in CT
        if (_tcBd.ct && _tcBd.ct.length > 0) {
          for (let _ci = _tcBd.ct.length - 1; _ci >= 0; _ci--) {
            const _ctName = _tcBd.ct[_ci];
            if (!isTrainee(_ctName, _tcDk, _tcBlk.key)) continue;
            let _ctFixed = false;
            for (const _tcCh of _tcAllowed) {
              if (!_tcBd.assignments[_tcCh]) {
                _tcBd.assignments[_tcCh] = _ctName;
                _tcBd.ct.splice(_ci, 1);
                _ctFixed = true;
                break;
              }
            }
            if (!_ctFixed) {
              for (const _tcCh of _tcAllowed) {
                const _tcHolder = _tcBd.assignments[_tcCh];
                if (!_tcHolder) continue;
                if (isTrainee(_tcHolder, _tcDk, _tcBlk.key)) continue;
                _tcBd.assignments[_tcCh] = _ctName;
                _tcBd.ct[_ci] = _tcHolder;
                _ctFixed = true;
                break;
              }
            }
          }
        }
      }
    }
  }
  // ========== END TRAINEE CORRECTION PASS (Option B) ==========

  savePlan(plan); // Re-save after B2B pass

  // Count ALL violations by scanning the final schedule (same logic as CSV export)
  const violationsFound = new Map(); // name -> count
  const ctrSet2 = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);

  for (let day = 1; day <= daysInMonth; day++) {
    const dateObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
    const dayKey = ymd(dateObj);
    const dayData = plan.days[dayKey];
    if (!dayData) continue;

    // Track assignments per person for this day
    const personAssignments = new Map(); // name -> [{blockIdx, channel}]

    for (let bi = 0; bi < BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
      const blockData = dayData[b.key];
      if (!blockData) continue;

      // Collect all assignments for this block
      for (const [ch, name] of Object.entries(blockData.assignments || {})) {
        if (!name) continue;
        const nameUpper = String(name).toUpperCase();
        if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
        personAssignments.get(nameUpper).push({ blockIdx: bi, channel: ch.toUpperCase(), blockKey: b.key });
      }
      for (const name of (blockData.ct || [])) {
        const nameUpper = String(name).toUpperCase();
        if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
        personAssignments.get(nameUpper).push({ blockIdx: bi, channel: "CT", blockKey: b.key });
      }
    }

    // Check for violations per person
    for (const [name, assignments] of personAssignments) {
      assignments.sort((a, b) => a.blockIdx - b.blockIdx);
      const dayChannels = new Map(); // channel -> count

      for (let i = 0; i < assignments.length; i++) {
        const curr = assignments[i];
        const chUpper = curr.channel;

        // Same channel twice in day (except SD and allowed primary b2b)
        if (dayChannels.has(chUpper) && chUpper !== "SD") {
          const _primB2B = new Set(["NORTH","SOUTH","EAST","WEST","NORTHWEST","CENTRAL","CT","RELIEF 1","RELIEF 2"]);
          // Allow primary channel b2b: consecutive blocks, max 2
          const isAllowedB2B = _primB2B.has(chUpper) && i > 0 &&
            assignments[i-1].channel === chUpper && assignments[i-1].blockIdx === curr.blockIdx - 1 &&
            (dayChannels.get(chUpper) || 0) < 2;
          if (!isAllowedB2B) {
            violationsFound.set(name, (violationsFound.get(name) || 0) + 1);
          }
        }
        dayChannels.set(chUpper, (dayChannels.get(chUpper) || 0) + 1);

        // (CT/Relief back-to-back is allowed — weekly caps enforce limits)
      }
    }
  }

  let totalViolations = 0;
  for (const count of violationsFound.values()) {
    totalViolations += count;
  }
  const uniquePeopleWithViolations = violationsFound.size;

  // Compute worst-case AND sum of primary channel SPREADs (max-min per channel) for non-SD people
  const rebalanceChannels = ["North","East","South","West","Central","Northwest"];
  const _primUpper = new Set(rebalanceChannels.map(ch => ch.toUpperCase()));
  // Build finalCounts from the plan
  const finalCounts = new Map();
  for (const dk of Object.keys(plan.days)) {
    const dayData = plan.days[dk];
    for (const bk of BLOCKS) {
      const bd = dayData[bk.key];
      if (!bd || !bd.assignments) continue;
      for (const [ch, nm] of Object.entries(bd.assignments)) {
        if (!nm) continue;
        if (!finalCounts.has(nm)) finalCounts.set(nm, new Map());
        const m = finalCounts.get(nm);
        m.set(ch.toUpperCase(), (m.get(ch.toUpperCase()) || 0) + 1);
      }
    }
  }
  let _maxPrimCount = 0;
  let _sumPrimSpreads = 0;
  for (const pch of _primUpper) {
    let minC = Infinity, maxC = 0;
    for (const [name, m] of finalCounts) {
      if (SD_ELIGIBLE.has(name.toUpperCase())) continue;
      const c = m.get(pch) || 0;
      if (c < minC) minC = c;
      if (c > maxC) maxC = c;
    }
    if (minC === Infinity) minC = 0;
    const spread = maxC - minC;
    _sumPrimSpreads += spread;
    if (spread > _maxPrimCount) _maxPrimCount = spread;
  }

  // CT spread (max-min) across all non-SD people
  let _maxCTCount = 0;
  let _minCTCount = Infinity;
  const _ctMap = new Map();
  for (const dk of Object.keys(plan.days)) {
    const dayData = plan.days[dk];
    for (const bk of BLOCKS) {
      const bd = dayData[bk.key];
      if (!bd || !bd.ct) continue;
      for (const nm of bd.ct) {
        if (SD_ELIGIBLE.has(String(nm).toUpperCase())) continue;
        _ctMap.set(nm, (_ctMap.get(nm) || 0) + 1);
      }
    }
  }
  for (const [nm] of finalCounts) {
    if (SD_ELIGIBLE.has(nm.toUpperCase())) continue;
    if (!_ctMap.has(nm)) _ctMap.set(nm, 0);
  }
  for (const [, count] of _ctMap) {
    if (count > _maxCTCount) _maxCTCount = count;
    if (count < _minCTCount) _minCTCount = count;
  }
  if (_minCTCount === Infinity) _minCTCount = 0;
  const _ctSpread = _maxCTCount - _minCTCount;

  // DC spread (max-min of DC1+DC2 total) across all non-SD people
  const _dcMap = new Map();
  for (const [nm, m] of finalCounts) {
    if (SD_ELIGIBLE.has(nm.toUpperCase())) continue;
    const dc1 = m.get("DC1") || 0;
    const dc2 = m.get("DC2") || 0;
    _dcMap.set(nm, dc1 + dc2);
  }
  let _maxDC = 0, _minDC = Infinity;
  for (const [, count] of _dcMap) {
    if (count > _maxDC) _maxDC = count;
    if (count < _minDC) _minDC = count;
  }
  if (_minDC === Infinity) _minDC = 0;
  const _dcSpread = _maxDC - _minDC;

  // B2B spread (max-min of B2B pair count) across all non-SD people
  const _b2bPrimFinal = new Set(["NORTH","EAST","SOUTH","WEST","NORTHWEST","CENTRAL"]);
  const _b2bMap = new Map();
  for (let day = 1; day <= daysInMonth; day++) {
    const dObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
    const dk = ymd(dObj);
    const dayData = plan.days[dk];
    if (!dayData) continue;
    const personBlocks = new Map();
    for (let bi = 0; bi < BLOCKS.length; bi++) {
      const bd = dayData[BLOCKS[bi].key];
      if (!bd || !bd.assignments) continue;
      for (const [ch, nm] of Object.entries(bd.assignments)) {
        if (!nm) continue;
        if (!personBlocks.has(nm)) personBlocks.set(nm, []);
        personBlocks.get(nm).push({ blockIdx: bi, channel: ch.toUpperCase() });
      }
    }
    for (const [nm, blocks] of personBlocks) {
      if (SD_ELIGIBLE.has(nm.toUpperCase())) continue;
      blocks.sort((a, b) => a.blockIdx - b.blockIdx);
      for (let i = 1; i < blocks.length; i++) {
        if (blocks[i].blockIdx === blocks[i-1].blockIdx + 1 &&
            blocks[i].channel === blocks[i-1].channel &&
            _b2bPrimFinal.has(blocks[i].channel)) {
          _b2bMap.set(nm, (_b2bMap.get(nm) || 0) + 1);
        }
      }
    }
  }
  for (const [nm] of finalCounts) {
    if (SD_ELIGIBLE.has(nm.toUpperCase())) continue;
    if (!_b2bMap.has(nm)) _b2bMap.set(nm, 0);
  }
  let _maxB2B = 0, _minB2B = Infinity;
  for (const [, count] of _b2bMap) {
    if (count > _maxB2B) _maxB2B = count;
    if (count < _minB2B) _minB2B = count;
  }
  if (_minB2B === Infinity) _minB2B = 0;
  const _b2bSpread = _maxB2B - _minB2B;

  // TOTAL spread (per shift group — worst of all groups)
  const _totalCounts = new Map();
  const _totalDayBlks = new Set(["0600-1000","1000-1400","1400-1800"]);
  const _totalShift = new Map();
  for (const dk of Object.keys(plan.days)) {
    const dayData = plan.days[dk];
    for (const bk of BLOCKS) {
      const bd = dayData[bk.key];
      if (!bd) continue;
      if (bd.assignments) {
        for (const [, nm] of Object.entries(bd.assignments)) {
          if (!nm || SD_ELIGIBLE.has(nm.toUpperCase())) continue;
          _totalCounts.set(nm, (_totalCounts.get(nm) || 0) + 1);
          if (!_totalShift.has(nm)) _totalShift.set(nm, { day: false, night: false });
          const s = _totalShift.get(nm);
          if (_totalDayBlks.has(bk.key)) s.day = true; else s.night = true;
        }
      }
      if (bd.ct) {
        for (const nm of bd.ct) {
          if (!nm || SD_ELIGIBLE.has(nm.toUpperCase())) continue;
          _totalCounts.set(nm, (_totalCounts.get(nm) || 0) + 1);
        }
      }
    }
  }
  const _totByShift = { day: [], night: [], split: [] };
  for (const [nm, t] of _totalCounts) {
    const s = _totalShift.get(nm);
    if (!s) { _totByShift.day.push(t); continue; }
    if (s.day && s.night) _totByShift.split.push(t);
    else if (s.day) _totByShift.day.push(t);
    else _totByShift.night.push(t);
  }
  let _totalSpread = 0;
  for (const arr of [_totByShift.day, _totByShift.night, _totByShift.split]) {
    if (arr.length < 2) continue;
    const sp = Math.max(...arr) - Math.min(...arr);
    if (sp > _totalSpread) _totalSpread = sp;
  }

  // Store violation stats for display
  window.lastRandomizeStats = {
    totalViolations,
    uniquePeopleWithViolations,
    violationsByPerson: Object.fromEntries(violationsFound),
    maxPrimaryCount: _maxPrimCount,
    maxCTCount: _maxCTCount,
    sumPrimarySpreads: _sumPrimSpreads,
    ctSpread: _ctSpread,
    dcSpread: _dcSpread,
    b2bSpread: _b2bSpread,
    totalSpread: _totalSpread
  };

  return plan;
}
*/

const channelColor = (()=>{
  const pal = [
    "rgba(245, 158, 11, .25)",
    "rgba(16, 185, 129, .25)",
    "rgba(59, 130, 246, .25)",
    "rgba(239, 68, 68, .25)",
    "rgba(168, 85, 247, .25)",
    "rgba(14, 165, 233, .25)",
    "rgba(244, 63, 94, .25)",
    "rgba(34, 197, 94, .25)",
    "rgba(250, 204, 21, .25)",
    "rgba(99, 102, 241, .25)",
  ];
  const map={};
  CHANNELS.forEach((c,i)=>map[c]=pal[i%pal.length]);
  // 7th channel color (distinct cyan)
  map[SEVENTH_CHANNEL] = "rgba(6, 182, 212, .35)";
  return map;
})();

function renderDay(dayKey) {
  const plan = loadPlan();
  const dayTitle = document.getElementById("dayTitle");
  const wrap = document.getElementById("dayTableWrap");
  if (!plan || !plan.days || !plan.days[dayKey]) {
    dayTitle.textContent = "No month plan yet – click Randomize Month";
    wrap.innerHTML = "";
    return;
  }
  const d = parseYMD(dayKey);
  dayTitle.textContent = d ? `${monthName(d.getMonth())} ${d.getDate()}, ${d.getFullYear()}` : dayKey;

  // ========== VIOLATION DETECTION FOR DAY ==========
  const ctrSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
  const personAssignments = new Map();
  const violationCells = new Set();

  // Get previous day's last block for cross-day detection
  const prevDate = d ? new Date(d.getFullYear(), d.getMonth(), d.getDate() - 1) : null;
  const prevDayKey = prevDate ? ymd(prevDate) : null;
  const prevDayBlocks = prevDayKey && plan.days[prevDayKey] ? plan.days[prevDayKey] : null;
  const prevLastBlockEntry = prevDayBlocks ? prevDayBlocks[BLOCKS[BLOCKS.length - 1].key] : null;

  // Collect assignments for today
  BLOCKS.forEach((b, bi) => {
    const entry = plan.days[dayKey][b.key];
    if (!entry) return;
    if (entry.assignments) {
      for (const [ch, nm] of Object.entries(entry.assignments)) {
        if (!nm) continue;
        const nameUpper = String(nm).toUpperCase();
        if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
        personAssignments.get(nameUpper).push({blockKey: b.key, blockIdx: bi, channel: ch});
      }
    }
    if (entry.ct && entry.ct.length) {
      for (const nm of entry.ct) {
        const nameUpper = String(nm).toUpperCase();
        if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
        personAssignments.get(nameUpper).push({blockKey: b.key, blockIdx: bi, channel: "CT"});
      }
    }
  });

  // Detect violations
  for (const [name, assignments] of personAssignments) {
    assignments.sort((a, b) => a.blockIdx - b.blockIdx);
    const dayChannels = new Map();

    for (let i = 0; i < assignments.length; i++) {
      const curr = assignments[i];
      const chUpper = String(curr.channel).toUpperCase();
      // Same channel twice in day is a violation (except SD, weekly-capped channels, and allowed primary b2b)
      const _weeklyCappedV = new Set(["CT","RELIEF 1","RELIEF 2","DC1","DC2"]);
      if (dayChannels.has(chUpper) && chUpper !== "SD" && !_weeklyCappedV.has(chUpper)) {
        const _primB2B = new Set(["NORTH","SOUTH","EAST","WEST","NORTHWEST","CENTRAL","CT","RELIEF 1","RELIEF 2"]);
        const isAllowedB2B = _primB2B.has(chUpper) && i > 0 &&
          String(assignments[i-1].channel).toUpperCase() === chUpper &&
          assignments[i-1].blockIdx === curr.blockIdx - 1 &&
          (dayChannels.get(chUpper) || 0) < 2;
        if (!isAllowedB2B) {
          violationCells.add(`${dayKey}|${curr.blockKey}|${name}`);
        }
      }
      dayChannels.set(chUpper, (dayChannels.get(chUpper) || 0) + 1);
    }
  }

  // Weekly CT/Relief/DC/Primary cap violations for this day's people
  if (d) {
    const _wkKeyD = weekKeyFromDate(d);
    const _primNamesD = new Set(["NORTH","EAST","SOUTH","WEST","CENTRAL","NORTHWEST"]);
    for (const [name, todayAssigns] of personAssignments) {
      let _ctD = 0, _relD = 0, _dcD = 0;
      const _primChD = new Map();
      for (const dk2 of Object.keys(plan.days)) {
        const d2 = parseYMD(dk2);
        if (!d2 || weekKeyFromDate(d2) !== _wkKeyD) continue;
        for (const bk of BLOCKS) {
          const _be = plan.days[dk2][bk.key];
          if (!_be) continue;
          if (_be.ct && _be.ct.some(n => String(n).toUpperCase() === name)) _ctD++;
          if (_be.assignments) {
            for (const [ch, nm] of Object.entries(_be.assignments)) {
              const chUp = ch.toUpperCase();
              if ((chUp === "RELIEF 1" || chUp === "RELIEF 2") && String(nm).toUpperCase() === name) _relD++;
              if ((chUp === "DC1" || chUp === "DC2") && String(nm).toUpperCase() === name) _dcD++;
              if (_primNamesD.has(chUp) && String(nm).toUpperCase() === name) _primChD.set(chUp, (_primChD.get(chUp) || 0) + 1);
            }
          }
        }
      }
      if (_ctD > 2) {
        for (const a of todayAssigns) {
          if (String(a.channel).toUpperCase() === "CT") violationCells.add(`${dayKey}|${a.blockKey}|${name}`);
        }
      }
      if (_relD > 2) {
        for (const a of todayAssigns) {
          const aUp = String(a.channel).toUpperCase();
          if (aUp === "RELIEF 1" || aUp === "RELIEF 2") violationCells.add(`${dayKey}|${a.blockKey}|${name}`);
        }
      }
      if (_dcD > 2) {
        for (const a of todayAssigns) {
          const aUp = String(a.channel).toUpperCase();
          if (aUp === "DC1" || aUp === "DC2") violationCells.add(`${dayKey}|${a.blockKey}|${name}`);
        }
      }
      for (const [pCh, pCnt] of _primChD) {
        if (pCnt > 2) {
          for (const a of todayAssigns) {
            if (String(a.channel).toUpperCase() === pCh) violationCells.add(`${dayKey}|${a.blockKey}|${name}`);
          }
        }
      }
    }
  }
  // ========== END VIOLATION DETECTION ==========

  // Channel abbreviations for display
  const chAbbrev = {"North":"N","South":"S","East":"E","West":"W","Central":"C","Northwest":"NW","Relief 1":"R1","Relief 2":"R2","DC1":"DC1","DC2":"DC2"};

  const dayNames = ['SUNDAY','MONDAY','TUESDAY','WEDNESDAY','THURSDAY','FRIDAY','SATURDAY'];
  const dayOfWeekName = d ? dayNames[d.getDay()] : '';

  let html = "<table style='table-layout:fixed; width:100%;'><thead>";

  // Row 1: Day of the week
  html += `<tr><th colspan="${BLOCKS.length + 1}" style="text-align:center; padding:0; border:none;">
    <div style="font-size:15px; font-weight:900; letter-spacing:3px; color:var(--muted); padding:8px 0 2px;">${dayOfWeekName}</div>
  </th></tr>`;

  // Row 2: Day Shift / Night Shift banners
  html += `<tr>`;
  html += `<th style="border:none;"></th>`;
  html += `<th colspan="3" style="padding:6px 0; border:1px solid var(--line); border-bottom:none; border-right:4px solid rgba(255,255,255,.4); font-size:11px; font-weight:800; letter-spacing:1.5px; color:#e2c87a; background:rgba(250,204,21,.06);">&#9788; DAY SHIFT</th>`;
  html += `<th colspan="3" style="padding:6px 0; border:1px solid var(--line); border-bottom:none; border-left:none; font-size:11px; font-weight:800; letter-spacing:1.5px; color:#94a3c4; background:rgba(100,116,160,.06);">&#9790; NIGHT SHIFT</th>`;
  html += `</tr>`;

  // Row 3: CHANNEL + block time labels
  html += `<tr><th style='width:90px;'>CHANNEL</th>`;
  for (const b of BLOCKS) html += `<th>${b.label}</th>`;
  html += "</tr>";

  // Row 4: COPY FOR BOARD buttons
  html += "<tr><th></th>";
  for (const b of BLOCKS) html += `<th style="text-align:center;"><button class="btn-copy-block" data-day="${dayKey}" data-block="${b.key}" title="Copy names for ${b.label}" style="padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,.12); background:#0c1320; color:#e6edf7; cursor:pointer; font-weight:700; font-size:11px;">COPY FOR BOARD</button></th>`;
  html += "</tr></thead><tbody>";

  for (let ci=0; ci<CHANNELS.length; ci++) {
    const ch = CHANNELS[ci];
    html += `<tr><td class="sticky-col"><b>${ch.toUpperCase()}</b></td>`;
    for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
      const entry = plan.days[dayKey][b.key];
      const nm = (entry.assignments||{})[ch] || "";
      const bg = channelColor[ch] || "rgba(255,255,255,.08)";
      const isViolation = nm && violationCells.has(`${dayKey}|${b.key}|${nm.toUpperCase()}`);
      const abbr = chAbbrev[ch] || ch;
      const isOT = nm && (entry.ot || []).some(n => String(n).toUpperCase() === nm.toUpperCase());
      const otTag = isOT ? `<span style="background:#ef4444; color:#fff; font-size:9px; font-weight:900; padding:1px 4px; border-radius:3px; margin-left:4px; letter-spacing:0.5px;">OT</span>` : '';
      html += `<td>${ nm ? `<span class="assign-cell clickable-assign${isViolation ? ' violation' : ''}" data-day="${dayKey}" data-block="${b.key}" data-channel="${ch}" data-name="${escapeHtml(nm.toUpperCase())}" data-type="channel" style="background:${bg}; cursor:pointer;"><b>${abbr}</b> ${escapeHtml(nm.toUpperCase())}${otTag}</span>` : `<span class="assign-cell needed-badge clickable-needed" data-day="${dayKey}" data-block="${b.key}" data-channel="${ch}" data-type="channel" style="cursor:pointer;"><b>${abbr}</b> NEEDED</span>` }</td>`;
    }
    html += "</tr>";
  }

  // 7th channel row (Fri/Sat nights only)
  const dayDate = parseYMD(dayKey);
  const dayOfWeek = dayDate ? dayDate.getDay() : -1;
  const showSeventhRow = (dayOfWeek === 5 || dayOfWeek === 6);
  if (showSeventhRow) {
    html += `<tr><td class="sticky-col"><b>${SEVENTH_CHANNEL}</b></td>`;
    for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
      const entry = plan.days[dayKey][b.key];
      const nm = (entry.assignments||{})[SEVENTH_CHANNEL] || "";
      const bg = channelColor[SEVENTH_CHANNEL] || "rgba(255,255,255,.08)";
      const show7th = SEVENTH_BLOCKS.has(b.key);
      const isViolation = nm && violationCells.has(`${dayKey}|${b.key}|${nm.toUpperCase()}`);
      const isOT7 = nm && (entry.ot || []).some(n => String(n).toUpperCase() === nm.toUpperCase());
      const otTag7 = isOT7 ? `<span style="background:#ef4444; color:#fff; font-size:9px; font-weight:900; padding:1px 4px; border-radius:3px; margin-left:4px; letter-spacing:0.5px;">OT</span>` : '';
      html += `<td>${ (nm && show7th) ? `<span class="assign-cell clickable-assign${isViolation ? ' violation' : ''}" data-day="${dayKey}" data-block="${b.key}" data-channel="${SEVENTH_CHANNEL}" data-name="${escapeHtml(nm.toUpperCase())}" data-type="channel" style="background:${bg}; cursor:pointer;"><b>7th</b> ${escapeHtml(nm.toUpperCase())}${otTag7}</span>` : (show7th ? `<span class="assign-cell needed-badge clickable-needed" data-day="${dayKey}" data-block="${b.key}" data-channel="${SEVENTH_CHANNEL}" data-type="channel" style="cursor:pointer;"><b>7th</b> NEEDED</span>` : "<span class='small'>–</span>") }</td>`;
    }
    html += "</tr>";
  }

  html += `<tr><td class="sticky-col"><b>CT</b></td>`;
  let prevCT = new Set();
  for (let bi=0; bi<BLOCKS.length; bi++) {
    const b = BLOCKS[bi];
    const entry = plan.days[dayKey][b.key];
    const list = entry.ct || [];
    const curCT = new Set(list);
    const otList = entry.ot || [];
    const inner = list.length
      ? `<div class="ctlist">${list.map(n=>{
          const nameUpper = String(n).toUpperCase();
          const isRepeat = prevCT.has(n);
          const isViolation = violationCells.has(`${dayKey}|${b.key}|${nameUpper}`);
          const isCTOT = otList.some(o => String(o).toUpperCase() === nameUpper);
          const cls = (isRepeat || isViolation) ? "ctitem repeat" : "ctitem";
          const title = isRepeat ? ' title="Back-to-back CT"' : (isViolation ? ' title="Violation"' : "");
          const otBadge = isCTOT ? '<span style="background:#ef4444; color:#fff; font-size:8px; font-weight:900; padding:0px 3px; border-radius:2px; margin-left:3px;">OT</span>' : '';
          return `<div class="${cls} clickable-assign" data-day="${dayKey}" data-block="${b.key}" data-channel="CT" data-name="${escapeHtml(nameUpper)}" data-type="ct" style="cursor:pointer;"${title}>${escapeHtml(nameUpper)}${otBadge}</div>`;
        }).join("")}</div>`
      : "";
    html += `<td>${inner}</td>`;
    prevCT = curCT;
  }
  html += "</tr>";

  html += `<tr><td class="sticky-col"><b>SD</b></td>`;
  for (let bi=0; bi<BLOCKS.length; bi++) {
    const b = BLOCKS[bi];
    const entry = plan.days[dayKey][b.key];
    const list = entry.sd || [];
    const inner = list.length
      ? `<div class="ctlist">${list.map(n=>{
          return `<div class="ctitem clickable-assign" data-day="${dayKey}" data-block="${b.key}" data-channel="SD" data-name="${escapeHtml(String(n).toUpperCase())}" data-type="sd" style="background:rgba(200,170,255,.15); color:rgba(200,170,255,.8); border-color:rgba(200,170,255,.25); cursor:pointer;">${escapeHtml(String(n).toUpperCase())}</div>`;
        }).join("")}</div>`
      : "";
    html += `<td>${inner}</td>`;
  }
  html += "</tr>";

  // VACATION row: dispatchers excluded (on vacation) for this day
  {
    const allDispatchers = normalizeBase()
      .filter(r => String(r.Position||"").trim().toUpperCase() === "DISPATCHER")
      .map(r => String(r.Employee||"").trim()).filter(Boolean);
    const vacNames = allDispatchers.filter(n => isExcluded(n, d)).map(n => n.toUpperCase()).sort();
    html += `<tr><td><b style="color:#7dd3fc;">VACATION</b></td>`;
    if (vacNames.length) {
      const items = vacNames.map(n =>
        `<div style="margin:1px 0;"><span class="assign-cell clickable-vac" data-day="${dayKey}" data-name="${escapeHtml(n)}" style="background:rgba(125,211,252,.15); color:#7dd3fc; font-weight:700; font-size:10px; border:1px solid rgba(125,211,252,.3); cursor:pointer;">${escapeHtml(n)}</span></div>`
      ).join("");
      html += `<td colspan="${BLOCKS.length}">${items}</td>`;
    } else {
      html += `<td colspan="${BLOCKS.length}" style="color:var(--muted); font-size:10px;">None</td>`;
    }
    html += "</tr>";
  }

  // ABSENT row
  html += `<tr><td><b style="color:#f87171;">ABSENT</b></td>`;
  for (let bi=0; bi<BLOCKS.length; bi++) {
    const b = BLOCKS[bi];
    const entry = plan.days[dayKey][b.key];
    const absentList = (entry?.absent || []).map(n => String(n).toUpperCase()).filter(Boolean);
    if (absentList.length) {
      const items = absentList.map(n =>
        `<div style="margin:1px 0;"><span class="assign-cell clickable-absent" data-day="${dayKey}" data-block="${b.key}" data-name="${escapeHtml(n)}" style="background:rgba(248,113,113,.12); color:#f87171; font-weight:700; font-size:10px; border:1px solid rgba(248,113,113,.25); cursor:pointer;">${escapeHtml(n)}</span></div>`
      ).join("");
      html += `<td>${items}</td>`;
    } else {
      html += `<td></td>`;
    }
  }
  html += "</tr>";

  // UNASSIGNED row: people scheduled to work but not in any channel/CT/SD
  html += `<tr><td class="sticky-col"><b style="color:rgba(200,200,210,.7);">UNASSIGNED</b></td>`;
  for (let bi=0; bi<BLOCKS.length; bi++) {
    const b = BLOCKS[bi];
    const entry = plan.days[dayKey][b.key];
    const assignedNames = new Set();
    if (entry) {
      for (const nm of Object.values(entry.assignments||{})) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
      for (const nm of (entry.sd||[])) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
      for (const nm of (entry.ct||[])) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
      for (const nm of (entry.absent||[])) { assignedNames.add(String(nm).trim().toUpperCase()); }
    }
    const pool = buildDispatcherPoolForDate(d);
    const unassigned = pool.filter(p => worksBlock(p, d, b) && !assignedNames.has(String(p.name).trim().toUpperCase()));
    if (unassigned.length) {
      const items = unassigned.map(u =>
        `<div style="margin:1px 0;"><span class="assign-cell" style="background:rgba(200,200,210,.15); color:rgba(200,200,210,.7); font-weight:700; font-size:10px; border:1px solid rgba(200,200,210,.25); cursor:default;">${escapeHtml(String(u.name).toUpperCase())}</span></div>`
      ).join("");
      html += `<td>${items}</td>`;
    } else {
      html += `<td></td>`;
    }
  }
  html += "</tr>";

  html += "</tbody></table>";
  try { savePlan(plan); } catch(e) { console.warn(e); }
  wrap.innerHTML = html;

  renderInfoStats();
}

// Non-regular employees excluded from fairness stats
const EXCLUDED_FROM_STATS = new Set(["RAMIREZ","CLEMENT","MARZAHN","BROWNC","FOWLERL","GUIDRY","GROUNDS"]);

function computeTotals(plan) {
  const channelTotals = new Map(CHANNELS.map(c=>[c,0]));
  const dispatcherTotals = new Map();
  const dispatcherTop = new Map();
  const dispatcherChannelCounts = new Map();
  const shortfalls = [];

  for (const [dayKey, blocks] of Object.entries(plan.days||{})) {
    for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
      const entry = blocks[b.key];
      const filled = entry ? entry.filled : 0;
      if (filled < 10) shortfalls.push({ dayKey, block: b.label, filled });
      if (!entry) continue;
      for (const [ch, nm] of Object.entries(entry.assignments||{})) {
        const name = String(nm).trim().toUpperCase();
        if (EXCLUDED_FROM_STATS.has(name)) continue;
        channelTotals.set(ch, (channelTotals.get(ch)||0) + 1);
        dispatcherTotals.set(name, (dispatcherTotals.get(name)||0) + 1);
        if (!dispatcherTop.has(name)) dispatcherTop.set(name, new Map());
        const m = dispatcherTop.get(name);
        m.set(ch, (m.get(ch)||0)+1);
        if (!dispatcherChannelCounts.has(name)) dispatcherChannelCounts.set(name, new Map());
        const hm = dispatcherChannelCounts.get(name);
        hm.set(ch, (hm.get(ch)||0) + 1);
      }
      for (const nm of (entry.sd||[])) {
        const name = String(nm).trim().toUpperCase();
        if (EXCLUDED_FROM_STATS.has(name)) continue;
        dispatcherTotals.set(name, (dispatcherTotals.get(name)||0) + 1);
        if (!dispatcherChannelCounts.has(name)) dispatcherChannelCounts.set(name, new Map());
        const hm = dispatcherChannelCounts.get(name);
        hm.set("SD", (hm.get("SD")||0) + 1);
      }
      for (const nm of (entry.ct||[])) {
        const name = String(nm).trim().toUpperCase();
        if (EXCLUDED_FROM_STATS.has(name)) continue;
        dispatcherTotals.set(name, (dispatcherTotals.get(name)||0) + 1);
        if (!dispatcherChannelCounts.has(name)) dispatcherChannelCounts.set(name, new Map());
        const hm = dispatcherChannelCounts.get(name);
        hm.set("CT", (hm.get("CT")||0) + 1);
      }
    }
  }
  return {channelTotals, dispatcherTotals, dispatcherTop, dispatcherChannelCounts, shortfalls};
}

function renderStatsHtml(plan) {
  if (!plan || !plan.days) return '<div style="text-align:center; color:var(--muted); padding:20px;">NO DATA</div>';

  const PRIMARY = ["North","South","East","West","Central","Northwest"];
  const RELIEF_SET = new Set(["Relief 1","Relief 2"]);
  const DC_SET_S = new Set(["DC1","DC2"]);
  const DAY_BLOCKS = new Set(["0600-1000","1000-1400","1400-1800"]);
  const abbrMap = {North:"N",South:"S",East:"E",West:"W",Central:"C",Northwest:"NW"};

  function _cs(val, a) {
    const d = val - a;
    if (d <= -1.5) return 'color:#f87171; font-weight:700;';
    if (d >= 1.5) return 'color:#60a5fa; font-weight:700;';
    return '';
  }

  function _emptyRow() { return { North:0, South:0, East:0, West:0, Central:0, Northwest:0, relief:0, ct:0, dc:0, sd:0, total:0 }; }

  function _addToRow(ch, row) {
    if (PRIMARY.includes(ch)) row[ch]++;
    else if (RELIEF_SET.has(ch)) row.relief++;
    else if (DC_SET_S.has(ch)) row.dc++;
    row.total++;
  }

  // Build per-person combined totals + track which shifts each person works
  const allTotals = new Map();   // name -> row (combined across all blocks)
  const personShifts = new Map(); // name -> { day: bool, night: bool }

  for (const [dayKey, blocks] of Object.entries(plan.days || {})) {
    for (const b of BLOCKS) {
      const entry = blocks[b.key];
      if (!entry) continue;
      const isDay = DAY_BLOCKS.has(b.key);

      for (const [ch, nm] of Object.entries(entry.assignments || {})) {
        if (!nm) continue;
        const name = String(nm).trim().toUpperCase();
        if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
        if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
        _addToRow(ch, allTotals.get(name));
        if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
      }
      for (const nm of (entry.ct || [])) {
        const name = String(nm).trim().toUpperCase();
        if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
        if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
        const row = allTotals.get(name);
        row.ct++; row.total++;
        if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
      }
      // SD assignments
      for (const nm of (entry.sd || [])) {
        const name = String(nm).trim().toUpperCase();
        if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
        if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
        allTotals.get(name).sd++;
        if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
      }
    }
  }

  // Count back-to-back primary channel pairs per person
  const b2bCounts = new Map();
  const _b2bPrimary = new Set(["NORTH","SOUTH","EAST","WEST","NORTHWEST","CENTRAL"]);
  for (const [dayKey, blocks] of Object.entries(plan.days || {})) {
    for (let bi = 0; bi < BLOCKS.length - 1; bi++) {
      const currBlock = blocks[BLOCKS[bi].key];
      const nextBlock = blocks[BLOCKS[bi+1].key];
      if (!currBlock || !nextBlock) continue;
      const currMap = new Map();
      for (const [ch, nm] of Object.entries(currBlock.assignments || {})) {
        if (nm) currMap.set(String(nm).trim().toUpperCase(), ch.toUpperCase());
      }
      const nextMap = new Map();
      for (const [ch, nm] of Object.entries(nextBlock.assignments || {})) {
        if (nm) nextMap.set(String(nm).trim().toUpperCase(), ch.toUpperCase());
      }
      for (const [name, currCh] of currMap) {
        if (!_b2bPrimary.has(currCh)) continue;
        if (nextMap.get(name) === currCh) {
          b2bCounts.set(name, (b2bCounts.get(name) || 0) + 1);
        }
      }
    }
  }

  // Split into 4 groups: SD-eligible get their own table
  const sdGroup = new Map();
  const dayOnly = new Map();
  const nightOnly = new Map();
  const splitShift = new Map();
  for (const [name, row] of allTotals) {
    if (SD_ELIGIBLE.has(name)) { sdGroup.set(name, row); continue; }
    const s = personShifts.get(name);
    if (s.day && s.night) splitShift.set(name, row);
    else if (s.day) dayOnly.set(name, row);
    else nightOnly.set(name, row);
  }

  function _buildTable(title, totalsMap) {
    const names = Array.from(totalsMap.keys()).sort();
    if (names.length === 0) return '';

    const n = names.length || 1;
    const avg = _emptyRow();
    for (const [, r] of totalsMap) {
      for (const ch of PRIMARY) avg[ch] += r[ch];
      avg.relief += r.relief; avg.ct += r.ct; avg.dc += r.dc;
    }
    for (const ch of PRIMARY) avg[ch] /= n;
    avg.relief /= n; avg.ct /= n; avg.dc /= n;

    let h = `<h3 style="margin:12px 0 4px; font-size:12px; color:var(--text);">${title}</h3>`;
    h += `<table style="width:100%; border-collapse:collapse; font-size:11px; table-layout:fixed;"><thead><tr>`;
    h += `<th style="text-align:left; padding:3px 4px; width:90px;">NAME</th>`;
    for (const ch of PRIMARY) h += `<th style="text-align:center; padding:3px 2px; background:${channelColor[ch]||'transparent'};">${abbrMap[ch]}</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(168,85,247,.2);">R</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(220,220,230,.15);">CT</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(100,140,200,.15);">DC</th>`;
    h += `<th style="text-align:center; padding:3px 2px; font-weight:700;">TOT</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(34,197,94,.15);">B2B</th>`;
    h += `</tr></thead><tbody>`;

    // Compute avg b2b for this group
    let avgB2B = 0;
    for (const nm of names) avgB2B += (b2bCounts.get(nm) || 0);
    avgB2B /= n;

    for (const name of names) {
      const g = totalsMap.get(name);
      const b2b = b2bCounts.get(name) || 0;
      h += `<tr><td style="text-align:left; padding:2px 4px; font-weight:600; font-size:10px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(name)}</td>`;
      for (const ch of PRIMARY) h += `<td style="text-align:center; padding:2px; ${_cs(g[ch], avg[ch])}">${g[ch]}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(g.relief, avg.relief)}">${g.relief}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(g.ct, avg.ct)}">${g.ct}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(g.dc, avg.dc)}">${g.dc}</td>`;
      h += `<td style="text-align:center; padding:2px; font-weight:700;">${g.total}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(b2b, avgB2B)}">${b2b}</td></tr>`;
    }

    h += `<tr style="border-top:2px solid var(--border); font-style:italic; color:var(--muted);">`;
    h += `<td style="text-align:left; padding:2px 4px;">AVG</td>`;
    for (const ch of PRIMARY) h += `<td style="text-align:center; padding:2px;">${avg[ch].toFixed(1)}</td>`;
    h += `<td style="text-align:center; padding:2px;">${avg.relief.toFixed(1)}</td>`;
    h += `<td style="text-align:center; padding:2px;">${avg.ct.toFixed(1)}</td>`;
    h += `<td style="text-align:center; padding:2px;">${avg.dc.toFixed(1)}</td>`;
    h += `<td></td>`;
    h += `<td style="text-align:center; padding:2px;">${avgB2B.toFixed(1)}</td></tr>`;
    h += `</tbody></table>`;
    return h;
  }

  function _buildSDTable(title, totalsMap) {
    const names = Array.from(totalsMap.keys()).sort();
    if (names.length === 0) return '';

    const n = names.length || 1;
    const avg = _emptyRow();
    for (const [, r] of totalsMap) {
      for (const ch of PRIMARY) avg[ch] += r[ch];
      avg.relief += r.relief; avg.ct += r.ct; avg.dc += r.dc; avg.sd += r.sd;
    }
    for (const ch of PRIMARY) avg[ch] /= n;
    avg.relief /= n; avg.ct /= n; avg.dc /= n; avg.sd /= n;

    let h = `<h3 style="margin:12px 0 4px; font-size:12px; color:var(--text);">${title}</h3>`;
    h += `<table style="width:100%; border-collapse:collapse; font-size:11px; table-layout:fixed;"><thead><tr>`;
    h += `<th style="text-align:left; padding:3px 4px; width:90px;">NAME</th>`;
    for (const ch of PRIMARY) h += `<th style="text-align:center; padding:3px 2px; background:${channelColor[ch]||'transparent'};">${abbrMap[ch]}</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(168,85,247,.2);">R</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(220,220,230,.15);">CT</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(100,140,200,.15);">DC</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(200,170,255,.2);">SD</th>`;
    h += `<th style="text-align:center; padding:3px 2px; font-weight:700;">TOT</th>`;
    h += `<th style="text-align:center; padding:3px 2px; background:rgba(34,197,94,.15);">B2B</th>`;
    h += `</tr></thead><tbody>`;

    // Compute avg b2b for this group
    let avgB2B = 0;
    for (const nm of names) avgB2B += (b2bCounts.get(nm) || 0);
    avgB2B /= n;

    for (const name of names) {
      const g = totalsMap.get(name);
      const chTotal = g.total + g.sd; // total includes channels+CT, add SD
      const b2b = b2bCounts.get(name) || 0;
      h += `<tr><td style="text-align:left; padding:2px 4px; font-weight:600; font-size:10px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(name)}</td>`;
      for (const ch of PRIMARY) h += `<td style="text-align:center; padding:2px; ${_cs(g[ch], avg[ch])}">${g[ch]}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(g.relief, avg.relief)}">${g.relief}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(g.ct, avg.ct)}">${g.ct}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(g.dc, avg.dc)}">${g.dc}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(g.sd, avg.sd)}">${g.sd}</td>`;
      h += `<td style="text-align:center; padding:2px; font-weight:700;">${chTotal}</td>`;
      h += `<td style="text-align:center; padding:2px; ${_cs(b2b, avgB2B)}">${b2b}</td></tr>`;
    }

    h += `<tr style="border-top:2px solid var(--border); font-style:italic; color:var(--muted);">`;
    h += `<td style="text-align:left; padding:2px 4px;">AVG</td>`;
    for (const ch of PRIMARY) h += `<td style="text-align:center; padding:2px;">${avg[ch].toFixed(1)}</td>`;
    h += `<td style="text-align:center; padding:2px;">${avg.relief.toFixed(1)}</td>`;
    h += `<td style="text-align:center; padding:2px;">${avg.ct.toFixed(1)}</td>`;
    h += `<td style="text-align:center; padding:2px;">${avg.dc.toFixed(1)}</td>`;
    h += `<td style="text-align:center; padding:2px;">${avg.sd.toFixed(1)}</td>`;
    h += `<td></td>`;
    h += `<td style="text-align:center; padding:2px;">${avgB2B.toFixed(1)}</td></tr>`;
    h += `</tbody></table>`;
    return h;
  }

  return _buildSDTable("SD ELIGIBLE (Special Detail)", sdGroup)
       + _buildTable("DAY SHIFT (6A – 6P)", dayOnly)
       + _buildTable("NIGHT SHIFT (6P – 6A)", nightOnly)
       + _buildTable("SPLIT SHIFT (Day + Night)", splitShift);
}



function channelAbbrev(ch) {
  const map = { "North":"N","South":"S","East":"E","West":"W","Central":"C","Northwest":"NW","Relief 1":"R1","Relief 2":"R2","DC1":"DC1","DC2":"DC2","SD":"SD","CT":"CT","7th":"7th" };
  return map[ch] || ch;
}
function renderMonthRoster(mode, wrapId) {
  // cumulative counts per employee per channel for this render
  const countsByEmp = {};

  let plan = loadPlan();
  const wrap = document.getElementById(wrapId || "mRosterWrapDay");
  if (!wrap) return;

  // Ensure we have a plan for the currently selected month/year
  const selM = Number(document.getElementById("monthSel").value);
  const selY = Number(document.getElementById("yearSel").value);
  if (!plan || !plan.meta || plan.meta.year !== selY || plan.meta.monthIndex !== selM) {
    try { randomizeMonth(selY, selM); } catch(e) { console.error(e); }
    plan = loadPlan();
  }
  if (!plan || !plan.meta) { wrap.innerHTML = "<div class='small'>Click <b>Randomize Month</b> to generate a plan.</div>"; return; }

  const year = plan.meta.year;
  const monthIndex = plan.meta.monthIndex;
  const daysInMonth = new Date(year, monthIndex+1, 0).getDate();

  const modeUp = String(mode||"DAY").toUpperCase();
  const isSplit = (modeUp === "SPLIT");
  const shift = isSplit ? "ALL" : (modeUp === "NIGHT" ? "NIGHT" : "DAY");
  const SELBLOCKS = isSplit ? ["0600-1000","1000-1400","1400-1800","1800-2200","2200-0200","0200-0600"]
    : (shift==="DAY") ? ["0600-1000","1000-1400","1400-1800"] : ["1800-2200","2200-0200","0200-0600"];
  const blockLabels = {
    "0600-1000":"6A-10A","1000-1400":"10A-2P","1400-1800":"2P-6P",
    "1800-2200":"6P-10P","2200-0200":"10P-2A","0200-0600":"2A-6A"
  };

  const WEEKDAYS = ["MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY","SUNDAY"];
  function _worksInShift(rec, shf) {
    if (!rec) return false;
    for (const d of WEEKDAYS) {
      const s = rec[d];
      if (s && blocksWorkedForSchedule(s, shf).size) return true;
    }
    return false;
  }
  function _isSplitShift(rec) {
    return rec && _worksInShift(rec, "DAY") && _worksInShift(rec, "NIGHT");
  }

  const baseAll = normalizeBase();
  const dispatchers = baseAll
    .filter(r => String(r.Position||"").trim().toUpperCase()==="DISPATCHER")
    .map(r => ({ name: String(r.Employee||"").trim(), seniority: Number(r.Seniority||0), rec:r }))
    .filter(d => d.name);

  const hires = getNewHires().map(n=>String(n).trim()).filter(Boolean)
    .filter(n => dispatchers.every(d => d.name.toUpperCase() !== n.toUpperCase()))
    .map(n => ({ name:n, seniority:0, rec:null, isHire:true }));

  let people = dispatchers.concat(hires).sort((a,b)=>{
    const sa = (isFinite(a.seniority)?a.seniority:999999);
    const sb = (isFinite(b.seniority)?b.seniority:999999);
    if (sa !== sb) return sa - sb;
    return a.name.localeCompare(b.name);
  });
  if (isSplit) {
    people = people.filter(p => !p.isHire && _isSplitShift(p.rec));
  } else {
    people = people.filter(p => p.isHire || _worksInShift(p.rec, shift));
  }

  const cols = [];
  const dayAbbrs = {"SUNDAY":"SUN","MONDAY":"MON","TUESDAY":"TUE","WEDNESDAY":"WED","THURSDAY":"THU","FRIDAY":"FRI","SATURDAY":"SAT"};
  for (let day=1; day<=daysInMonth; day++) {
    const d = new Date(year, monthIndex, day, 12,0,0,0);
    const dk = ymd(d);
    const dn = dayName(d);
    SELBLOCKS.forEach((bk, bi) => {
      cols.push({ dk, dn, bk, label: blockLabels[bk], dayLabel: `${dayAbbrs[dn]} ${monthIndex+1}/${day}`, isFirstBlock: bi === 0, blockCount: SELBLOCKS.length });
    });
  }

  const assignMap = {};
  for (let day=1; day<=daysInMonth; day++) {
    const d = new Date(year, monthIndex, day, 12,0,0,0);
    const dk = ymd(d);
    assignMap[dk] = {};
    const dayBlocks = (plan.days && plan.days[dk]) ? plan.days[dk] : null;
    for (const bk of SELBLOCKS) {
      const map = new Map();
      if (dayBlocks && dayBlocks[bk]) {
        const entry = dayBlocks[bk];
        for (const [ch, nm] of Object.entries(entry.assignments||{})) {
          map.set(String(nm).trim().toUpperCase(), ch);
        }
        for (const nm of (entry.sd||[])) {
          map.set(String(nm).trim().toUpperCase(), "SD");
        }
        for (const nm of (entry.ct||[])) {
          map.set(String(nm).trim().toUpperCase(), "CT");
        }
      }
      assignMap[dk][bk] = map;
    }
  }

  const _dayBorder = "border-left:2px solid #000;";
  let html = `<div class="mroster-scroll"><table class="mroster-table"><thead>`;
  // Row 1: day-of-week headers spanning blocks
  html += `<tr><th class="sticky-left" rowspan="2">Employee</th>`;
  for (let ci = 0; ci < cols.length; ci++) {
    const c = cols[ci];
    if (c.isFirstBlock) html += `<th colspan="${c.blockCount}" style="text-align:center; font-weight:700; font-size:10px; ${_dayBorder} padding:4px 2px;">${c.dayLabel}</th>`;
  }
  html += `</tr>`;
  // Row 2: block labels
  html += `<tr>`;
  for (const c of cols) html += `<th style="${c.isFirstBlock ? _dayBorder : ''} font-size:9px; padding:3px 2px;">${c.label}</th>`;
  html += `</tr></thead><tbody>`;

  for (const p of people) {
    html += `<tr><td class="sticky-left"><b>${escapeHtml(p.name.toUpperCase())}</b></td>`;
    for (const c of cols) {
      const rec = p.rec;
      const schedVal = rec ? String(rec[c.dn]||"").trim().toUpperCase() : "";
      const worked = rec ? blocksWorkedForSchedule(schedVal, shift) : new Set();
      const workingThisBlock = worked.has(c.bk);
      const _db = c.isFirstBlock ? _dayBorder : "";
      if (!workingThisBlock) {
        html += `<td style="${_db}"><span class="cellbtn off">OFF</span></td>`;
      } else if (isExcluded(p.name, new Date(c.dk + "T12:00:00"))) {
        html += `<td style="${_db}"><span class="cellbtn" style="background:rgba(168,85,247,.25); color:#c4b5fd; font-weight:700; font-size:9px; border:1px solid rgba(168,85,247,.4);">VAC</span></td>`;
      } else {
        let ch = assignMap[c.dk][c.bk].get(String(p.name).trim().toUpperCase()) || "";

        const ab = ch ? channelAbbrev(ch) : "";
        const bg = (ch === "CT" ? "#ffffff" : (ch ? (channelColor[ch] || "rgba(255,255,255,.08)") : "rgba(255,255,255,.06)"));

        // Cumulative counts per employee per channel (increase left→right across the month)
        if (!countsByEmp[p.name]) countsByEmp[p.name] = {};
        if (ch) countsByEmp[p.name][ch] = (countsByEmp[p.name][ch] || 0) + 1;

        const cnt = ch ? (countsByEmp[p.name][ch] || 0) : 0;
        const label = ch ? `${ab} (${cnt})` : "";
        const dataType = (ch === "CT") ? "ct" : (ch === "SD") ? "sd" : "channel";
        html += `<td style="${_db}">${label ? `<span class="cellbtn clickable-assign" data-day="${c.dk}" data-block="${c.bk}" data-channel="${ch}" data-name="${escapeHtml(p.name.toUpperCase())}" data-type="${dataType}" style="background:${bg}; cursor:pointer; ${ch==="CT"?"color:#000 !important; border:2px solid #fff !important; box-shadow:none !important;":"color:var(--text);"}">${escapeHtml(label)}</span>` : `<span class="cellbtn" style="background:#facc15; color:#000; font-weight:900; font-size:10px; border:2px solid #eab308; animation:needPulse 1.2s ease-in-out infinite;">UN</span>`}</td>`;
      }
    }
    html += `</tr>`;
  }

  html += `</tbody></table></div>`;
  try { savePlan(plan); } catch(e) { console.warn(e); }
  wrap.innerHTML = html;
}

function renderWeek(anchorDayKey) {
  const plan = loadPlan();
  const wrap = document.getElementById("weekWrap");
  if (!plan) { wrap.innerHTML = "<div class='small'>Randomize a month first.</div>"; return; }

  const anchor = parseYMD(anchorDayKey) || new Date(plan.meta.year, plan.meta.monthIndex, 1, 12,0,0,0);
  const dow = anchor.getDay();
  const offsetToSat = (dow - 6 + 7) % 7;
  const start = new Date(anchor.getFullYear(), anchor.getMonth(), anchor.getDate() - offsetToSat, 12,0,0,0);

  const daysListAll = [];
  for (let i=0;i<7;i++) daysListAll.push(new Date(start.getFullYear(), start.getMonth(), start.getDate()+i, 12,0,0,0));
  // Filter to only days that have data in the plan
  const daysList = daysListAll.filter(d => plan.days[ymd(d)]);

  // ========== VIOLATION DETECTION FOR WEEK ==========
  const ctrSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
  const personAssignments = new Map();
  const violationCells = new Set();

  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    if (!blocks) continue;
    BLOCKS.forEach((b, bi) => {
      const entry = blocks[b.key];
      if (!entry) return;
      if (entry.assignments) {
        for (const [ch, nm] of Object.entries(entry.assignments)) {
          if (!nm) continue;
          const nameUpper = String(nm).toUpperCase();
          if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
          personAssignments.get(nameUpper).push({dayKey, blockKey: b.key, blockIdx: bi, channel: ch, dayNum: d.getDate(), dayIdx: daysList.indexOf(d)});
        }
      }
      if (entry.ct && entry.ct.length) {
        for (const nm of entry.ct) {
          const nameUpper = String(nm).toUpperCase();
          if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
          personAssignments.get(nameUpper).push({dayKey, blockKey: b.key, blockIdx: bi, channel: "CT", dayNum: d.getDate(), dayIdx: daysList.indexOf(d)});
        }
      }
    });
  }

  for (const [name, assignments] of personAssignments) {
    assignments.sort((a, b) => {
      if (a.dayIdx !== b.dayIdx) return a.dayIdx - b.dayIdx;
      return a.blockIdx - b.blockIdx;
    });
    const dayChannels = new Map();
    for (let i = 0; i < assignments.length; i++) {
      const curr = assignments[i];
      const chUpper = String(curr.channel).toUpperCase();
      if (!dayChannels.has(curr.dayKey)) dayChannels.set(curr.dayKey, new Map());
      const dayCh = dayChannels.get(curr.dayKey);
      // Same channel twice in day is a violation (except SD, weekly-capped channels, and allowed primary b2b)
      const _weeklyCappedD = new Set(["CT","RELIEF 1","RELIEF 2","DC1","DC2"]);
      if (dayCh.has(chUpper) && chUpper !== "SD" && !_weeklyCappedD.has(chUpper)) {
        const _primB2B = new Set(["NORTH","SOUTH","EAST","WEST","NORTHWEST","CENTRAL","CT","RELIEF 1","RELIEF 2"]);
        const isAllowedB2B = _primB2B.has(chUpper) && i > 0 &&
          String(assignments[i-1].channel).toUpperCase() === chUpper &&
          curr.dayKey === assignments[i-1].dayKey &&
          curr.blockIdx === assignments[i-1].blockIdx + 1 &&
          (dayCh.get(chUpper) || 0) < 2;
        if (!isAllowedB2B) {
          violationCells.add(`${curr.dayKey}|${curr.blockKey}|${name}`);
        }
      }
      dayCh.set(chUpper, (dayCh.get(chUpper) || 0) + 1);
    }

    // Weekly CT/Relief/DC/Primary cap violations
    const _ctW = assignments.filter(a => String(a.channel).toUpperCase() === "CT").length;
    const _relW = assignments.filter(a => { const c = String(a.channel).toUpperCase(); return c === "RELIEF 1" || c === "RELIEF 2"; }).length;
    const _dcW = assignments.filter(a => { const c = String(a.channel).toUpperCase(); return c === "DC1" || c === "DC2"; }).length;
    if (_ctW > 2) {
      for (const a of assignments) {
        if (String(a.channel).toUpperCase() === "CT") violationCells.add(`${a.dayKey}|${a.blockKey}|${name}`);
      }
    }
    if (_relW > 2) {
      for (const a of assignments) {
        const aUp = String(a.channel).toUpperCase();
        if (aUp === "RELIEF 1" || aUp === "RELIEF 2") violationCells.add(`${a.dayKey}|${a.blockKey}|${name}`);
      }
    }
    if (_dcW > 2) {
      for (const a of assignments) {
        const aUp = String(a.channel).toUpperCase();
        if (aUp === "DC1" || aUp === "DC2") violationCells.add(`${a.dayKey}|${a.blockKey}|${name}`);
      }
    }
    const _primWCh = new Map();
    const _primNamesW = new Set(["NORTH","EAST","SOUTH","WEST","CENTRAL","NORTHWEST"]);
    for (const a of assignments) {
      const aUp = String(a.channel).toUpperCase();
      if (_primNamesW.has(aUp)) _primWCh.set(aUp, (_primWCh.get(aUp) || 0) + 1);
    }
    for (const [pCh, pCnt] of _primWCh) {
      if (pCnt > 2) {
        for (const a of assignments) {
          if (String(a.channel).toUpperCase() === pCh) violationCells.add(`${a.dayKey}|${a.blockKey}|${name}`);
        }
      }
    }
  }
  // ========== END VIOLATION DETECTION ==========

  // Build a "daily-like" table: channels rows, (day x block) columns
  let html = `<div class="scroll-x"><table class="wide-table"><thead>`;

  const _dayBorderW = "border-left:2px solid #000;";
  const _dbW = (b) => b === BLOCKS[0] ? _dayBorderW : "";

  // Row 1: day headers spanning 6 blocks each
  html += `<tr><th class="sticky-col" rowspan="2">Channel</th>`;
  for (const d of daysList) {
    const key = ymd(d);
    const lbl = `${["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][d.getDay()]} ${d.getMonth()+1}/${d.getDate()}`;
    html += `<th class="dayhead" colspan="${BLOCKS.length}" data-day="${key}" style="cursor:pointer; ${_dayBorderW}" title="Click to load this day">${lbl}</th>`;
  }
  html += `</tr>`;

  // Row 2: block labels
  html += `<tr>`;
  for (let di=0; di<daysList.length; di++) {
    for (const b of BLOCKS) html += `<th class="subhead" style="${_dbW(b)}">${b.label}</th>`;
  }
  html += `</tr></thead><tbody>`;

  // Channel rows
  for (const ch of CHANNELS) {
    html += `<tr><td class="sticky-col"><b>${ch.toUpperCase()}</b></td>`;
    for (const d of daysList) {
      const dayKey = ymd(d);
      const blocks = plan.days[dayKey];
      for (const b of BLOCKS) {
        const db = _dbW(b);
        const entry = blocks ? blocks[b.key] : null;
        const nm = entry && entry.assignments ? (entry.assignments[ch] || "") : "";
        const bg = channelColor[ch] || "rgba(255,255,255,.08)";
        const short = entry && (entry.filled||0) < 10;
        const isViolation = nm && violationCells.has(`${dayKey}|${b.key}|${nm.toUpperCase()}`);
        const abbr = channelAbbrev(ch);
        const _isOTw = nm && entry && (entry.ot || []).some(o => String(o).toUpperCase() === nm.toUpperCase());
        const _otW = _isOTw ? '<span style="background:#ef4444; color:#fff; font-size:8px; font-weight:900; padding:0px 3px; border-radius:2px; margin-left:3px;">OT</span>' : '';
        html += `<td style="${db}">${nm ? `<span class="assign-cell clickable-assign${isViolation ? ' violation' : ''}" data-day="${dayKey}" data-block="${b.key}" data-channel="${ch}" data-name="${escapeHtml(nm.toUpperCase())}" data-type="channel" style="background:${bg}; cursor:pointer; ${short?'outline:2px solid rgba(217,72,72,.6); outline-offset:1px;':''}">${abbr} ${escapeHtml(nm.toUpperCase())}${_otW}</span>` : `<span class="assign-cell needed-badge clickable-needed" data-day="${dayKey}" data-block="${b.key}" data-channel="${ch}" data-type="channel" style="cursor:pointer;">${abbr} NEEDED</span>`}</td>`;
      }
    }
    html += `</tr>`;
  }

  // 7th channel row (Fri/Sat nights)
  html += `<tr><td class="sticky-col"><b>${SEVENTH_CHANNEL}</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const dow = d.getDay();
    const isFriSat = (dow === 5 || dow === 6);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const db = _dbW(b);
      const show7th = isFriSat && SEVENTH_BLOCKS.has(b.key);
      if (!show7th) { html += `<td style="${db}"><span class="small">–</span></td>`; continue; }
      const entry = blocks ? blocks[b.key] : null;
      const nm = entry && entry.assignments ? (entry.assignments[SEVENTH_CHANNEL] || "") : "";
      const bg = channelColor[SEVENTH_CHANNEL] || "rgba(255,255,255,.08)";
      const _isOT7w = nm && entry && (entry.ot || []).some(o => String(o).toUpperCase() === nm.toUpperCase());
      const _ot7w = _isOT7w ? '<span style="background:#ef4444; color:#fff; font-size:8px; font-weight:900; padding:0px 3px; border-radius:2px; margin-left:3px;">OT</span>' : '';
      html += `<td style="${db}">${nm ? `<span class="assign-cell clickable-assign" data-day="${dayKey}" data-block="${b.key}" data-channel="${SEVENTH_CHANNEL}" data-name="${escapeHtml(nm.toUpperCase())}" data-type="channel" style="background:${bg}; cursor:pointer;">7th ${escapeHtml(nm.toUpperCase())}${_ot7w}</span>` : `<span class="assign-cell needed-badge clickable-needed" data-day="${dayKey}" data-block="${b.key}" data-channel="${SEVENTH_CHANNEL}" data-type="channel" style="cursor:pointer;"><b>7th</b> NEEDED</span>`}</td>`;
    }
  }
  html += `</tr>`;

  // CT row
  html += `<tr><td class="sticky-col"><b>CT</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const db = _dbW(b);
      const entry = blocks ? blocks[b.key] : null;
      const list = entry && entry.ct ? entry.ct : [];
      const _otListW = entry ? (entry.ot || []) : [];
      if (list && list.length) {
        const items = list.map(n=>{
          const nameUpper = String(n).toUpperCase();
          const isViolation = violationCells.has(`${dayKey}|${b.key}|${nameUpper}`);
          const _isCTotW = _otListW.some(o => String(o).toUpperCase() === nameUpper);
          const _ctOtW = _isCTotW ? '<span style="background:#ef4444; color:#fff; font-size:8px; font-weight:900; padding:0px 3px; border-radius:2px; margin-left:3px;">OT</span>' : '';
          return `<div style="margin:1px 0"><span class="assign-cell clickable-assign${isViolation ? ' violation' : ''}" data-day="${dayKey}" data-block="${b.key}" data-channel="CT" data-name="${escapeHtml(nameUpper)}" data-type="ct" style="background:rgba(220,220,230,.15); color:rgba(255,255,255,.7); border-color:rgba(220,220,230,.25); box-shadow:none; cursor:pointer;">CT ${escapeHtml(nameUpper)}${_ctOtW}</span></div>`;
        }).join("");
        html += `<td style="${db}">${items}</td>`;
      } else {
        html += `<td style="${db}"></td>`;
      }
    }
  }
  html += `</tr>`;

  // SD row
  html += `<tr><td class="sticky-col"><b>SD</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const db = _dbW(b);
      const entry = blocks ? blocks[b.key] : null;
      const list = entry && entry.sd ? entry.sd : [];
      if (list && list.length) {
        const items = list.map(n=>`<div style="margin:1px 0"><span class="assign-cell clickable-assign" data-day="${dayKey}" data-block="${b.key}" data-channel="SD" data-name="${escapeHtml(n.toUpperCase())}" data-type="sd" style="background:rgba(200,170,255,.15); color:rgba(200,170,255,.8); border-color:rgba(200,170,255,.25); cursor:pointer;">SD ${escapeHtml(n.toUpperCase())}</span></div>`).join("");
        html += `<td style="${db}">${items}</td>`;
      } else {
        html += `<td style="${db}"></td>`;
      }
    }
  }
  html += `</tr>`;

  // VACATION row: dispatchers excluded (on vacation) for each day
  html += `<tr><td class="sticky-col"><b style="color:#7dd3fc;">VACATION</b></td>`;
  {
    const allDispatchers = normalizeBase()
      .filter(r => String(r.Position||"").trim().toUpperCase() === "DISPATCHER")
      .map(r => String(r.Employee||"").trim()).filter(Boolean);
    for (const d of daysList) {
      const _vacDk = ymd(d);
      const vacNames = allDispatchers.filter(n => isExcluded(n, d)).map(n => n.toUpperCase()).sort();
      if (vacNames.length) {
        const items = vacNames.map(n =>
          `<div style="margin:1px 0;"><span class="assign-cell clickable-vac" data-day="${_vacDk}" data-name="${escapeHtml(n)}" style="background:rgba(125,211,252,.15); color:#7dd3fc; font-weight:700; font-size:10px; border:1px solid rgba(125,211,252,.3); cursor:pointer;">${escapeHtml(n)}</span></div>`
        ).join("");
        html += `<td colspan="${BLOCKS.length}" style="${_dayBorderW}">${items}</td>`;
      } else {
        html += `<td colspan="${BLOCKS.length}" style="${_dayBorderW} color:var(--muted); font-size:10px;">—</td>`;
      }
    }
  }
  html += `</tr>`;

  // ABSENT row
  html += `<tr><td class="sticky-col"><b style="color:#f87171;">ABSENT</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const db = _dbW(b);
      const entry = blocks ? blocks[b.key] : null;
      const absentList = (entry?.absent || []).map(n => String(n).toUpperCase()).filter(Boolean);
      if (absentList.length) {
        const items = absentList.map(n =>
          `<div style="margin:1px 0;"><span class="assign-cell clickable-absent" data-day="${dayKey}" data-block="${b.key}" data-name="${escapeHtml(n)}" style="background:rgba(248,113,113,.12); color:#f87171; font-weight:700; font-size:10px; border:1px solid rgba(248,113,113,.25); cursor:pointer;">${escapeHtml(n)}</span></div>`
        ).join("");
        html += `<td style="${db}">${items}</td>`;
      } else {
        html += `<td style="${db}"></td>`;
      }
    }
  }
  html += `</tr>`;

  // UNASSIGNED row
  html += `<tr><td class="sticky-col"><b style="color:rgba(200,200,210,.7);">UNASSIGNED</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const db = _dbW(b);
      const entry = blocks ? blocks[b.key] : null;
      const assignedNames = new Set();
      if (entry) {
        for (const nm of Object.values(entry.assignments||{})) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
        for (const nm of (entry.sd||[])) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
        for (const nm of (entry.ct||[])) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
        for (const nm of (entry.absent||[])) { assignedNames.add(String(nm).trim().toUpperCase()); }
      }
      const pool = buildDispatcherPoolForDate(d);
      const unassigned = pool.filter(p => worksBlock(p, d, b) && !assignedNames.has(String(p.name).trim().toUpperCase()));
      if (unassigned.length) {
        const items = unassigned.map(u => `<div style="margin:1px 0"><span class="assign-cell" style="background:rgba(200,200,210,.15); color:rgba(200,200,210,.7); font-weight:700; font-size:10px; border:1px solid rgba(200,200,210,.25); cursor:default;">${escapeHtml(String(u.name).toUpperCase())}</span></div>`).join("");
        html += `<td style="${db}">${items}</td>`;
      } else {
        html += `<td style="${db}"></td>`;
      }
    }
  }
  html += `</tr>`;

  html += `</tbody></table></div>`;
  try { savePlan(plan); } catch(e) { console.warn(e); }
  wrap.innerHTML = html;

  // Click day headers to load that day in Day tab
  wrap.querySelectorAll("th.dayhead[data-day]").forEach(th=>{
    th.addEventListener("click", ()=>{
      const dk = th.getAttribute("data-day");
      document.getElementById("dayPick").value = dk;
      setActiveTab("day");
      renderDay(dk);
    });
  });
}



function renderMonth(year, monthIndex) {
  const plan = loadPlan();
  const wrap = document.getElementById("monthWrap");
  if (!plan) { wrap.innerHTML = "<div class='small'>Randomize a month first.</div>"; return; }

  const daysInMonth = new Date(year, monthIndex+1, 0).getDate();
  const daysList = [];
  for (let day=1; day<=daysInMonth; day++) {
    daysList.push(new Date(year, monthIndex, day, 12,0,0,0));
  }

  // ========== VIOLATION DETECTION ==========
  // Build person assignment sequences and detect violations
  const ctrSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
  const personAssignments = new Map(); // name -> [{dayKey, blockIdx, channel}]
  const violationCells = new Set(); // "dayKey|blockKey|name" strings

  // Collect all assignments per person
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    if (!blocks) continue;
    BLOCKS.forEach((b, bi) => {
      const entry = blocks[b.key];
      if (!entry) return;
      // Channel assignments
      if (entry.assignments) {
        for (const [ch, nm] of Object.entries(entry.assignments)) {
          if (!nm) continue;
          const nameUpper = String(nm).toUpperCase();
          if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
          personAssignments.get(nameUpper).push({dayKey, blockKey: b.key, blockIdx: bi, channel: ch, dayNum: d.getDate()});
        }
      }
      // CT assignments
      if (entry.ct && entry.ct.length) {
        for (const nm of entry.ct) {
          const nameUpper = String(nm).toUpperCase();
          if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
          personAssignments.get(nameUpper).push({dayKey, blockKey: b.key, blockIdx: bi, channel: "CT", dayNum: d.getDate()});
        }
      }
    });
  }

  // Sort each person's assignments by day and block, then detect violations
  for (const [name, assignments] of personAssignments) {
    assignments.sort((a, b) => {
      if (a.dayNum !== b.dayNum) return a.dayNum - b.dayNum;
      return a.blockIdx - b.blockIdx;
    });

    // Track channels worked per day for same-channel violation
    const dayChannels = new Map(); // dayKey -> Map(channelUpper -> count)

    for (let i = 0; i < assignments.length; i++) {
      const curr = assignments[i];
      const chUpper = String(curr.channel).toUpperCase();

      // Check same-channel-in-day violation (SD can repeat, primary b2b allowed)
      if (!dayChannels.has(curr.dayKey)) dayChannels.set(curr.dayKey, new Map());
      const dayCh = dayChannels.get(curr.dayKey);
      if (dayCh.has(chUpper) && chUpper !== "SD") {
        const _primB2B = new Set(["NORTH","SOUTH","EAST","WEST","NORTHWEST","CENTRAL","CT","RELIEF 1","RELIEF 2"]);
        const isAllowedB2B = _primB2B.has(chUpper) && i > 0 &&
          String(assignments[i-1].channel).toUpperCase() === chUpper &&
          curr.dayKey === assignments[i-1].dayKey &&
          curr.blockIdx === assignments[i-1].blockIdx + 1 &&
          (dayCh.get(chUpper) || 0) < 2;
        if (!isAllowedB2B) {
          // Violation! Same channel twice in same day
          violationCells.add(`${curr.dayKey}|${curr.blockKey}|${name}`);
        }
      }
      dayCh.set(chUpper, (dayCh.get(chUpper) || 0) + 1);
    }

    // Weekly CT/Relief/DC/Primary cap violations
    const _ctWkM = new Map(); // weekKey -> {ct:[], relief:[], dc:[], primCh: Map(ch->[])}
    const _primNamesM = new Set(["NORTH","EAST","SOUTH","WEST","CENTRAL","NORTHWEST"]);
    for (const a of assignments) {
      const _dM = new Date(year, monthIndex, a.dayNum, 12, 0, 0, 0);
      const _wkM = weekKeyFromDate(_dM);
      if (!_ctWkM.has(_wkM)) _ctWkM.set(_wkM, {ct:[], relief:[], dc:[], primCh: new Map()});
      const bucket = _ctWkM.get(_wkM);
      const aUp = String(a.channel).toUpperCase();
      if (aUp === "CT") bucket.ct.push(a);
      else if (aUp === "RELIEF 1" || aUp === "RELIEF 2") bucket.relief.push(a);
      else if (aUp === "DC1" || aUp === "DC2") bucket.dc.push(a);
      if (_primNamesM.has(aUp)) {
        if (!bucket.primCh.has(aUp)) bucket.primCh.set(aUp, []);
        bucket.primCh.get(aUp).push(a);
      }
    }
    for (const [_wk, bucket] of _ctWkM) {
      if (bucket.ct.length > 2) {
        for (const a of bucket.ct) violationCells.add(`${a.dayKey}|${a.blockKey}|${name}`);
      }
      if (bucket.relief.length > 2) {
        for (const a of bucket.relief) violationCells.add(`${a.dayKey}|${a.blockKey}|${name}`);
      }
      if (bucket.dc.length > 2) {
        for (const a of bucket.dc) violationCells.add(`${a.dayKey}|${a.blockKey}|${name}`);
      }
      for (const [pCh, pArr] of bucket.primCh) {
        if (pArr.length > 2) {
          for (const a of pArr) violationCells.add(`${a.dayKey}|${a.blockKey}|${name}`);
        }
      }
    }
  }
  // ========== END VIOLATION DETECTION ==========

  const _dayBorderM = "border-left:2px solid #000;";
  const _dbM = (b) => b === BLOCKS[0] ? _dayBorderM : "";

  let html = `<div class="scroll-x"><table class="wide-table"><thead>`;

  // Row 1: date headers spanning 6 blocks each (with day-of-week)
  html += `<tr><th class="sticky-col" rowspan="2">CHANNEL</th>`;
  for (const d of daysList) {
    const key = ymd(d);
    const dow = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][d.getDay()];
    const lbl = `${dow} ${monthIndex+1}/${d.getDate()}`;
    html += `<th class="dayhead" colspan="${BLOCKS.length}" data-day="${key}" style="cursor:pointer; ${_dayBorderM}" title="Click to load this day">${lbl}</th>`;
  }
  html += `</tr>`;

  // Row 2: block labels
  html += `<tr>`;
  for (let di=0; di<daysList.length; di++) {
    for (const b of BLOCKS) html += `<th class="subhead" style="${_dbM(b)}">${b.label}</th>`;
  }
  html += `</tr></thead><tbody>`;

  // Channel rows
  for (const ch of CHANNELS) {
    const chAbbr = channelAbbrev(ch);
    html += `<tr><td class="sticky-col"><b>${ch.toUpperCase()}</b></td>`;
    for (const d of daysList) {
      const dayKey = ymd(d);
      const blocks = plan.days[dayKey];
      for (const b of BLOCKS) {
        const db = _dbM(b);
        const entry = blocks ? blocks[b.key] : null;
        const nm = entry && entry.assignments ? (entry.assignments[ch] || "") : "";
        const bg = channelColor[ch] || "rgba(255,255,255,.08)";
        const short = entry && (entry.filled||0) < 10;
        const isViolation = nm && violationCells.has(`${dayKey}|${b.key}|${nm.toUpperCase()}`);
        const _isOTm = nm && entry && (entry.ot || []).some(o => String(o).toUpperCase() === nm.toUpperCase());
        const _otM = _isOTm ? '<span style="background:#ef4444; color:#fff; font-size:7px; font-weight:900; padding:0px 2px; border-radius:2px; margin-left:2px;">OT</span>' : '';
        html += `<td style="${db}">${nm ? `<span class="assign-cell month-cell clickable-assign${isViolation ? ' violation' : ''}" data-day="${dayKey}" data-block="${b.key}" data-channel="${ch}" data-name="${escapeHtml(nm.toUpperCase())}" data-type="channel" data-emp="${escapeHtml(nm.toUpperCase())}" style="background:${bg}; cursor:pointer; ${short?'outline:2px solid rgba(217,72,72,.6); outline-offset:1px;':''}"><b>${chAbbr}</b> ${escapeHtml(nm.toUpperCase())}${_otM}</span>` : `<span class="assign-cell month-cell needed-badge clickable-needed" data-day="${dayKey}" data-block="${b.key}" data-channel="${ch}" data-type="channel" style="cursor:pointer;"><b>${chAbbr}</b> NEEDED</span>`}</td>`;
      }
    }
    html += `</tr>`;
  }

  // 7th channel row (Fri/Sat nights)
  html += `<tr><td class="sticky-col"><b>${SEVENTH_CHANNEL}</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const dow = d.getDay();
    const isFriSat = (dow === 5 || dow === 6);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const db = _dbM(b);
      const show7th = isFriSat && SEVENTH_BLOCKS.has(b.key);
      if (!show7th) { html += `<td style="${db}"><span class="small">–</span></td>`; continue; }
      const entry = blocks ? blocks[b.key] : null;
      const nm = entry && entry.assignments ? (entry.assignments[SEVENTH_CHANNEL] || "") : "";
      const bg = channelColor[SEVENTH_CHANNEL] || "rgba(255,255,255,.08)";
      const _isOT7m = nm && entry && (entry.ot || []).some(o => String(o).toUpperCase() === nm.toUpperCase());
      const _ot7m = _isOT7m ? '<span style="background:#ef4444; color:#fff; font-size:7px; font-weight:900; padding:0px 2px; border-radius:2px; margin-left:2px;">OT</span>' : '';
      html += `<td style="${db}">${nm ? `<span class="assign-cell month-cell clickable-assign" data-day="${dayKey}" data-block="${b.key}" data-channel="${SEVENTH_CHANNEL}" data-name="${escapeHtml(nm.toUpperCase())}" data-type="channel" data-emp="${escapeHtml(nm.toUpperCase())}" style="background:${bg}; cursor:pointer;"><b>7th</b> ${escapeHtml(nm.toUpperCase())}${_ot7m}</span>` : `<span class="assign-cell month-cell needed-badge clickable-needed" data-day="${dayKey}" data-block="${b.key}" data-channel="${SEVENTH_CHANNEL}" data-type="channel" style="cursor:pointer;"><b>7th</b> NEEDED</span>`}</td>`;
    }
  }
  html += `</tr>`;

  // CT row
  html += `<tr><td class="sticky-col"><b>CT</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const db = _dbM(b);
      const entry = blocks ? blocks[b.key] : null;
      const list = entry && entry.ct ? entry.ct : [];
      const _otListM = entry ? (entry.ot || []) : [];
      if (list && list.length) {
        const items = list.map(n=>{
          const nameUpper = String(n).toUpperCase();
          const isViolation = violationCells.has(`${dayKey}|${b.key}|${nameUpper}`);
          const _isCTotM = _otListM.some(o => String(o).toUpperCase() === nameUpper);
          const _ctOtM = _isCTotM ? '<span style="background:#ef4444; color:#fff; font-size:7px; font-weight:900; padding:0px 2px; border-radius:2px; margin-left:2px;">OT</span>' : '';
          return `<div style="margin:2px 0"><span class="assign-cell month-cell clickable-assign${isViolation ? ' violation' : ''}" data-day="${dayKey}" data-block="${b.key}" data-channel="CT" data-name="${escapeHtml(nameUpper)}" data-type="ct" data-emp="${escapeHtml(nameUpper)}" style="background:rgba(220,220,230,.15); color:rgba(255,255,255,.7); border-color:rgba(220,220,230,.25); box-shadow:none; cursor:pointer;"><b>CT</b> ${escapeHtml(nameUpper)}${_ctOtM}</span></div>`;
        }).join("");
        html += `<td style="${db}">${items}</td>`;
      } else {
        html += `<td style="${db}"></td>`;
      }
    }
  }
  html += `</tr>`;

  // SD row
  html += `<tr><td class="sticky-col"><b>SD</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const db = _dbM(b);
      const entry = blocks ? blocks[b.key] : null;
      const list = entry && entry.sd ? entry.sd : [];
      if (list && list.length) {
        const items = list.map(n=>`<div style="margin:2px 0"><span class="assign-cell month-cell clickable-assign" data-day="${dayKey}" data-block="${b.key}" data-channel="SD" data-name="${escapeHtml(String(n).toUpperCase())}" data-type="sd" data-emp="${escapeHtml(String(n).toUpperCase())}" style="background:rgba(200,170,255,.15); color:rgba(200,170,255,.8); border-color:rgba(200,170,255,.25); cursor:pointer;"><b>SD</b> ${escapeHtml(String(n).toUpperCase())}</span></div>`).join("");
        html += `<td style="${db}">${items}</td>`;
      } else {
        html += `<td style="${db}"></td>`;
      }
    }
  }
  html += `</tr>`;

  // VACATION row: dispatchers excluded (on vacation) for each day
  html += `<tr><td class="sticky-col"><b style="color:#7dd3fc;">VACATION</b></td>`;
  {
    const allDispatchers = normalizeBase()
      .filter(r => String(r.Position||"").trim().toUpperCase() === "DISPATCHER")
      .map(r => String(r.Employee||"").trim()).filter(Boolean);
    for (const d of daysList) {
      const _vacDk = ymd(d);
      const vacNames = allDispatchers.filter(n => isExcluded(n, d)).map(n => n.toUpperCase()).sort();
      if (vacNames.length) {
        const items = vacNames.map(n =>
          `<div style="margin:2px 0;"><span class="assign-cell month-cell clickable-vac" data-day="${_vacDk}" data-name="${escapeHtml(n)}" style="background:rgba(125,211,252,.15); color:#7dd3fc; font-weight:700; font-size:9px; border:1px solid rgba(125,211,252,.3); cursor:pointer;">${escapeHtml(n)}</span></div>`
        ).join("");
        html += `<td colspan="${BLOCKS.length}" style="${_dayBorderM}">${items}</td>`;
      } else {
        html += `<td colspan="${BLOCKS.length}" style="${_dayBorderM} color:var(--muted); font-size:9px;">—</td>`;
      }
    }
  }
  html += `</tr>`;

  // ABSENT row
  html += `<tr><td class="sticky-col"><b style="color:#f87171;">ABSENT</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const db = _dbM(b);
      const entry = blocks ? blocks[b.key] : null;
      const absentList = (entry?.absent || []).map(n => String(n).toUpperCase()).filter(Boolean);
      if (absentList.length) {
        const items = absentList.map(n =>
          `<div style="margin:2px 0;"><span class="assign-cell month-cell clickable-absent" data-day="${dayKey}" data-block="${b.key}" data-name="${escapeHtml(n)}" style="background:rgba(248,113,113,.12); color:#f87171; font-weight:700; font-size:9px; border:1px solid rgba(248,113,113,.25); cursor:pointer;">${escapeHtml(n)}</span></div>`
        ).join("");
        html += `<td style="${db}">${items}</td>`;
      } else {
        html += `<td style="${db}"></td>`;
      }
    }
  }
  html += `</tr>`;

  // UNASSIGNED row
  html += `<tr><td class="sticky-col"><b style="color:rgba(200,200,210,.7);">UNASSIGNED</b></td>`;
  for (const d of daysList) {
    const dayKey = ymd(d);
    const blocks = plan.days[dayKey];
    for (const b of BLOCKS) {
      const db = _dbM(b);
      const entry = blocks ? blocks[b.key] : null;
      const assignedNames = new Set();
      if (entry) {
        for (const nm of Object.values(entry.assignments||{})) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
        for (const nm of (entry.sd||[])) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
        for (const nm of (entry.ct||[])) { if (nm) assignedNames.add(String(nm).trim().toUpperCase()); }
        for (const nm of (entry.absent||[])) { assignedNames.add(String(nm).trim().toUpperCase()); }
      }
      const pool = buildDispatcherPoolForDate(d);
      const unassigned = pool.filter(p => worksBlock(p, d, b) && !assignedNames.has(String(p.name).trim().toUpperCase()));
      if (unassigned.length) {
        const items = unassigned.map(u => `<div style="margin:2px 0"><span class="assign-cell month-cell" style="background:rgba(200,200,210,.15); color:rgba(200,200,210,.7); font-weight:700; font-size:9px; border:1px solid rgba(200,200,210,.25); cursor:default;">${escapeHtml(String(u.name).toUpperCase())}</span></div>`).join("");
        html += `<td style="${db}">${items}</td>`;
      } else {
        html += `<td style="${db}"></td>`;
      }
    }
  }
  html += `</tr>`;

  html += `</tbody></table></div>`;

  // ========== CHANNEL TOTALS TABLE (Day / Night / Split) ==========
  {
    const PRIMARY_CHS = ["North","South","East","West","Central","Northwest"];
    const RELIEF_CHS = new Set(["RELIEF 1","RELIEF 2","R1","R2"]);
    const DC_CHS = new Set(["DC1","DC2"]);
    const DAY_BLK = new Set(["0600-1000","1000-1400","1400-1800"]);
    const abbrMap = {North:"N",South:"S",East:"E",West:"W",Central:"C",Northwest:"NW"};

    function _emptyRow() { return { North:0, South:0, East:0, West:0, Central:0, Northwest:0, relief:0, ct:0, dc:0, sd:0, total:0 }; }

    function _addToRow(chUpper, row) {
      if (chUpper === "NORTH") row.North++;
      else if (chUpper === "SOUTH") row.South++;
      else if (chUpper === "EAST") row.East++;
      else if (chUpper === "WEST") row.West++;
      else if (chUpper === "CENTRAL") row.Central++;
      else if (chUpper === "NORTHWEST") row.Northwest++;
      else if (RELIEF_CHS.has(chUpper)) row.relief++;
      else if (chUpper === "CT") row.ct++;
      else if (DC_CHS.has(chUpper)) row.dc++;
      row.total++;
    }

    // Build combined totals per person + track which shifts they work
    const allTotals = new Map();
    const personShifts = new Map(); // name -> { day, night }

    for (const [name, assignments] of personAssignments) {
      if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
      if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
      const row = allTotals.get(name);
      const shifts = personShifts.get(name);
      for (const a of assignments) {
        _addToRow(String(a.channel).toUpperCase(), row);
        if (DAY_BLK.has(a.blockKey)) shifts.day = true; else shifts.night = true;
      }
    }

    // Count SD blocks per person
    for (const d of daysList) {
      const dayKey = ymd(d);
      const blocks = plan.days[dayKey];
      if (!blocks) continue;
      for (const b of BLOCKS) {
        const entry = blocks[b.key];
        if (!entry) continue;
        for (const nm of (entry.sd || [])) {
          const nameUpper = String(nm).trim().toUpperCase();
          if (!allTotals.has(nameUpper)) allTotals.set(nameUpper, _emptyRow());
          allTotals.get(nameUpper).sd++;
        }
      }
    }

    // Count back-to-back primary channel pairs per person
    const b2bCounts = new Map();
    const _b2bPrimary = new Set(["NORTH","SOUTH","EAST","WEST","NORTHWEST","CENTRAL"]);
    for (const [dayKey, blocks] of Object.entries(plan.days || {})) {
      for (let bi = 0; bi < BLOCKS.length - 1; bi++) {
        const currBlock = blocks[BLOCKS[bi].key];
        const nextBlock = blocks[BLOCKS[bi+1].key];
        if (!currBlock || !nextBlock) continue;
        const currMap = new Map();
        for (const [ch, nm] of Object.entries(currBlock.assignments || {})) {
          if (nm) currMap.set(String(nm).trim().toUpperCase(), ch.toUpperCase());
        }
        const nextMap = new Map();
        for (const [ch, nm] of Object.entries(nextBlock.assignments || {})) {
          if (nm) nextMap.set(String(nm).trim().toUpperCase(), ch.toUpperCase());
        }
        for (const [name, currCh] of currMap) {
          if (!_b2bPrimary.has(currCh)) continue;
          if (nextMap.get(name) === currCh) {
            b2bCounts.set(name, (b2bCounts.get(name) || 0) + 1);
          }
        }
      }
    }

    // Split into 4 groups: SD-eligible get their own table
    const sdGroup = new Map();
    const dayOnly = new Map();
    const nightOnly = new Map();
    const splitShift = new Map();
    for (const [name, row] of allTotals) {
      if (SD_ELIGIBLE.has(name)) { sdGroup.set(name, row); continue; }
      const s = personShifts.get(name);
      if (s && s.day && s.night) splitShift.set(name, row);
      else if (s && s.day) dayOnly.set(name, row);
      else nightOnly.set(name, row);
    }

    function _cellStyle(val, avg) {
      if (avg === 0) return '';
      const diff = val - avg;
      if (diff <= -1.5) return 'color:#f87171; font-weight:700;';
      if (diff >= 1.5) return 'color:#60a5fa; font-weight:700;';
      return '';
    }

    function _buildShiftTable(title, totalsMap) {
      const sortedNames = Array.from(totalsMap.keys()).sort();
      if (sortedNames.length === 0) return '';

      const count = sortedNames.length || 1;
      const avgRow = _emptyRow();
      for (const [, row] of totalsMap) {
        for (const ch of PRIMARY_CHS) avgRow[ch] += row[ch];
        avgRow.relief += row.relief; avgRow.ct += row.ct; avgRow.dc += row.dc;
      }
      for (const ch of PRIMARY_CHS) avgRow[ch] /= count;
      avgRow.relief /= count; avgRow.ct /= count; avgRow.dc /= count;

      let t = `<div style="margin-top:18px;"><h3 style="margin:0 0 4px; font-size:12px; color:var(--text);">${title}</h3>`;
      t += `<table style="width:100%; border-collapse:collapse; font-size:11px; table-layout:fixed;">`;
      t += `<thead><tr>`;
      t += `<th style="text-align:left; padding:3px 4px; width:90px;">NAME</th>`;
      for (const ch of PRIMARY_CHS) t += `<th style="text-align:center; padding:3px 2px; background:${channelColor[ch] || 'transparent'};">${abbrMap[ch]}</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(168,85,247,.2);">R</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(220,220,230,.15);">CT</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(100,140,200,.15);">DC</th>`;
      t += `<th style="text-align:center; padding:3px 2px; font-weight:700;">TOT</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(34,197,94,.15);">B2B</th>`;
      t += `</tr></thead><tbody>`;

      // Compute avg b2b for this group
      let avgB2B = 0;
      for (const nm of sortedNames) avgB2B += (b2bCounts.get(nm) || 0);
      avgB2B /= count;

      for (const name of sortedNames) {
        const row = totalsMap.get(name);
        const b2b = b2bCounts.get(name) || 0;
        t += `<tr><td style="text-align:left; padding:2px 4px; font-weight:600; font-size:10px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(name)}</td>`;
        for (const ch of PRIMARY_CHS) t += `<td style="text-align:center; padding:2px; ${_cellStyle(row[ch], avgRow[ch])}">${row[ch]}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(row.relief, avgRow.relief)}">${row.relief}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(row.ct, avgRow.ct)}">${row.ct}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(row.dc, avgRow.dc)}">${row.dc}</td>`;
        t += `<td style="text-align:center; padding:2px; font-weight:700;">${row.total}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(b2b, avgB2B)}">${b2b}</td></tr>`;
      }

      t += `<tr style="border-top:2px solid var(--border); font-style:italic; color:var(--muted);">`;
      t += `<td style="text-align:left; padding:2px 4px;">AVG</td>`;
      for (const ch of PRIMARY_CHS) t += `<td style="text-align:center; padding:2px;">${avgRow[ch].toFixed(1)}</td>`;
      t += `<td style="text-align:center; padding:2px;">${avgRow.relief.toFixed(1)}</td>`;
      t += `<td style="text-align:center; padding:2px;">${avgRow.ct.toFixed(1)}</td>`;
      t += `<td style="text-align:center; padding:2px;">${avgRow.dc.toFixed(1)}</td>`;
      t += `<td></td>`;
      t += `<td style="text-align:center; padding:2px;">${avgB2B.toFixed(1)}</td></tr>`;

      t += `</tbody></table></div>`;
      return t;
    }

    function _buildSDTable(title, totalsMap) {
      const sortedNames = Array.from(totalsMap.keys()).sort();
      if (sortedNames.length === 0) return '';

      const count = sortedNames.length || 1;
      const avgRow = _emptyRow();
      for (const [, row] of totalsMap) {
        for (const ch of PRIMARY_CHS) avgRow[ch] += row[ch];
        avgRow.relief += row.relief; avgRow.ct += row.ct; avgRow.dc += row.dc; avgRow.sd += row.sd;
      }
      for (const ch of PRIMARY_CHS) avgRow[ch] /= count;
      avgRow.relief /= count; avgRow.ct /= count; avgRow.dc /= count; avgRow.sd /= count;

      let t = `<div style="margin-top:18px;"><h3 style="margin:0 0 4px; font-size:12px; color:var(--text);">${title}</h3>`;
      t += `<table style="width:100%; border-collapse:collapse; font-size:11px; table-layout:fixed;">`;
      t += `<thead><tr>`;
      t += `<th style="text-align:left; padding:3px 4px; width:90px;">NAME</th>`;
      for (const ch of PRIMARY_CHS) t += `<th style="text-align:center; padding:3px 2px; background:${channelColor[ch] || 'transparent'};">${abbrMap[ch]}</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(168,85,247,.2);">R</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(220,220,230,.15);">CT</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(100,140,200,.15);">DC</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(200,170,255,.2);">SD</th>`;
      t += `<th style="text-align:center; padding:3px 2px; font-weight:700;">TOT</th>`;
      t += `<th style="text-align:center; padding:3px 2px; background:rgba(34,197,94,.15);">B2B</th>`;
      t += `</tr></thead><tbody>`;

      // Compute avg b2b for this group
      let avgB2B = 0;
      for (const nm of sortedNames) avgB2B += (b2bCounts.get(nm) || 0);
      avgB2B /= count;

      for (const name of sortedNames) {
        const row = totalsMap.get(name);
        const chTotal = row.total + row.sd;
        const b2b = b2bCounts.get(name) || 0;
        t += `<tr><td style="text-align:left; padding:2px 4px; font-weight:600; font-size:10px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${escapeHtml(name)}</td>`;
        for (const ch of PRIMARY_CHS) t += `<td style="text-align:center; padding:2px; ${_cellStyle(row[ch], avgRow[ch])}">${row[ch]}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(row.relief, avgRow.relief)}">${row.relief}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(row.ct, avgRow.ct)}">${row.ct}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(row.dc, avgRow.dc)}">${row.dc}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(row.sd, avgRow.sd)}">${row.sd}</td>`;
        t += `<td style="text-align:center; padding:2px; font-weight:700;">${chTotal}</td>`;
        t += `<td style="text-align:center; padding:2px; ${_cellStyle(b2b, avgB2B)}">${b2b}</td></tr>`;
      }

      t += `<tr style="border-top:2px solid var(--border); font-style:italic; color:var(--muted);">`;
      t += `<td style="text-align:left; padding:2px 4px;">AVG</td>`;
      for (const ch of PRIMARY_CHS) t += `<td style="text-align:center; padding:2px;">${avgRow[ch].toFixed(1)}</td>`;
      t += `<td style="text-align:center; padding:2px;">${avgRow.relief.toFixed(1)}</td>`;
      t += `<td style="text-align:center; padding:2px;">${avgRow.ct.toFixed(1)}</td>`;
      t += `<td style="text-align:center; padding:2px;">${avgRow.dc.toFixed(1)}</td>`;
      t += `<td style="text-align:center; padding:2px;">${avgRow.sd.toFixed(1)}</td>`;
      t += `<td></td>`;
      t += `<td style="text-align:center; padding:2px;">${avgB2B.toFixed(1)}</td></tr>`;

      t += `</tbody></table></div>`;
      return t;
    }

    html += _buildSDTable("SD ELIGIBLE (Special Detail)", sdGroup);
    html += _buildShiftTable("DAY SHIFT TOTALS (6A – 6P)", dayOnly);
    html += _buildShiftTable("NIGHT SHIFT TOTALS (6P – 6A)", nightOnly);
    html += _buildShiftTable("SPLIT SHIFT TOTALS (Day + Night)", splitShift);
  }
  // ========== END CHANNEL TOTALS TABLE ==========

  try { savePlan(plan); } catch(e) { console.warn(e); }
  wrap.innerHTML = html;

  // Click date headers to load day in Day tab
  wrap.querySelectorAll("th.dayhead[data-day]").forEach(th=>{
    th.addEventListener("click", ()=>{
      const dk = th.getAttribute("data-day");
      document.getElementById("dayPick").value = dk;
      setActiveTab("day");
      renderDay(dk);
    });
  });
}


// ========== EXPORT OPEN SHIFTS (NEEDS) TO XLSX ==========
const _blockTimeMap = {
  "0600-1000": { startTime: "06:00", endTime: "10:00", nextDay: false },
  "1000-1400": { startTime: "10:00", endTime: "14:00", nextDay: false },
  "1400-1800": { startTime: "14:00", endTime: "18:00", nextDay: false },
  "1800-2200": { startTime: "18:00", endTime: "22:00", nextDay: false },
  "2200-0200": { startTime: "22:00", endTime: "02:00", nextDay: true },
  "0200-0600": { startTime: "02:00", endTime: "06:00", nextDay: false, startNextDay: true }
};
function _fmtDateSlash(d) { return `${d.getMonth()+1}/${d.getDate()}/${d.getFullYear()}`; }

function _buildNeedsRows(dateList) {
  const plan = loadPlan();
  if (!plan || !plan.days) return [];
  const rows = [];
  for (const dateObj of dateList) {
    const dayKey = ymd(dateObj);
    const blocks = plan.days[dayKey];
    if (!blocks) continue;
    for (const b of BLOCKS) {
      const entry = blocks[b.key];
      if (!entry) continue;
      let neededCount = 0;
      for (const ch of CHANNELS) {
        const nm = entry.assignments ? (entry.assignments[ch] || "") : "";
        if (!nm) neededCount++;
      }
      const dow = dateObj.getDay();
      if ((dow === 5 || dow === 6) && SEVENTH_BLOCKS.has(b.key)) {
        const nm7 = entry.assignments ? (entry.assignments[SEVENTH_CHANNEL] || "") : "";
        if (!nm7) neededCount++;
      }
      if (neededCount <= 0) continue;
      const bt = _blockTimeMap[b.key];
      let startDate = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate());
      if (bt.startNextDay) startDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() + 1);
      let endDate = new Date(startDate);
      if (bt.nextDay) endDate = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate() + 1);
      rows.push({
        "Group": "ECC OT",
        "Start Date": _fmtDateSlash(startDate),
        "Start Time": bt.startTime,
        "End Date": _fmtDateSlash(endDate),
        "End Time": bt.endTime,
        "Open Slots": neededCount,
        "Theme Color": "9. DarkGreen",
        "Custom Label": "",
        "Unpaid Break (minutes)": "",
        "Notes": b.key + " DP",
        "Shared": "1. Shared"
      });
    }
  }
  return rows;
}

const _TEMPLATE_B64 = "UEsDBBQAAAAAAAAAAAA+HACiIAcAACAHAAAaAAAAeGwvX3JlbHMvd29ya2Jvb2sueG1sLnJlbHM8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJVVEYtOCIgc3RhbmRhbG9uZT0ieWVzIj8+DQo8UmVsYXRpb25zaGlwcyB4bWxucz0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3BhY2thZ2UvMjAwNi9yZWxhdGlvbnNoaXBzIj48UmVsYXRpb25zaGlwIElkPSJySWQxIiBUeXBlPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3dvcmtzaGVldCIgVGFyZ2V0PSJ3b3Jrc2hlZXRzL3NoZWV0MS54bWwiLz48UmVsYXRpb25zaGlwIElkPSJySWQyIiBUeXBlPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3dvcmtzaGVldCIgVGFyZ2V0PSJ3b3Jrc2hlZXRzL3NoZWV0Mi54bWwiLz48UmVsYXRpb25zaGlwIElkPSJySWQzIiBUeXBlPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3dvcmtzaGVldCIgVGFyZ2V0PSJ3b3Jrc2hlZXRzL3NoZWV0My54bWwiLz48UmVsYXRpb25zaGlwIElkPSJySWQ0IiBUeXBlPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3dvcmtzaGVldCIgVGFyZ2V0PSJ3b3Jrc2hlZXRzL3NoZWV0NC54bWwiLz48UmVsYXRpb25zaGlwIElkPSJySWQ1IiBUeXBlPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3dvcmtzaGVldCIgVGFyZ2V0PSJ3b3Jrc2hlZXRzL3NoZWV0NS54bWwiLz48UmVsYXRpb25zaGlwIElkPSJySWQ2IiBUeXBlPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3dvcmtzaGVldCIgVGFyZ2V0PSJ3b3Jrc2hlZXRzL3NoZWV0Ni54bWwiLz48UmVsYXRpb25zaGlwIElkPSJySWQ3IiBUeXBlPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3dvcmtzaGVldCIgVGFyZ2V0PSJ3b3Jrc2hlZXRzL3NoZWV0Ny54bWwiLz48UmVsYXRpb25zaGlwIElkPSJySWQ4IiBUeXBlPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3dvcmtzaGVldCIgVGFyZ2V0PSJ3b3Jrc2hlZXRzL3NoZWV0OC54bWwiLz48UmVsYXRpb25zaGlwIElkPSJySWQ5IiBUeXBlPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3dvcmtzaGVldCIgVGFyZ2V0PSJ3b3Jrc2hlZXRzL3NoZWV0OS54bWwiLz48UmVsYXRpb25zaGlwIElkPSJySWQxMCIgVHlwZT0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy90aGVtZSIgVGFyZ2V0PSJ0aGVtZS90aGVtZTEueG1sIi8+PFJlbGF0aW9uc2hpcCBJZD0icklkMTEiIFR5cGU9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvc3R5bGVzIiBUYXJnZXQ9InN0eWxlcy54bWwiLz48UmVsYXRpb25zaGlwIElkPSJySWQxMiIgVHlwZT0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9zaGVldE1ldGFkYXRhIiBUYXJnZXQ9Im1ldGFkYXRhLnhtbCIvPjwvUmVsYXRpb25zaGlwcz5QSwMEFAAAAAAAAAAAAOyRzqO5GwAAuRsAABMAAAB4bC90aGVtZS90aGVtZTEueG1sPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/Pg0KPGE6dGhlbWUgeG1sbnM6YT0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL2RyYXdpbmdtbC8yMDA2L21haW4iIG5hbWU9Ik9mZmljZSBUaGVtZSI+PGE6dGhlbWVFbGVtZW50cz48YTpjbHJTY2hlbWUgbmFtZT0iT2ZmaWNlIj48YTpkazE+PGE6c3lzQ2xyIHZhbD0id2luZG93VGV4dCIgbGFzdENscj0iMDAwMDAwIi8+PC9hOmRrMT48YTpsdDE+PGE6c3lzQ2xyIHZhbD0id2luZG93IiBsYXN0Q2xyPSJGRkZGRkYiLz48L2E6bHQxPjxhOmRrMj48YTpzcmdiQ2xyIHZhbD0iMUY0OTdEIi8+PC9hOmRrMj48YTpsdDI+PGE6c3JnYkNsciB2YWw9IkVFRUNFMSIvPjwvYTpsdDI+PGE6YWNjZW50MT48YTpzcmdiQ2xyIHZhbD0iNEY4MUJEIi8+PC9hOmFjY2VudDE+PGE6YWNjZW50Mj48YTpzcmdiQ2xyIHZhbD0iQzA1MDREIi8+PC9hOmFjY2VudDI+PGE6YWNjZW50Mz48YTpzcmdiQ2xyIHZhbD0iOUJCQjU5Ii8+PC9hOmFjY2VudDM+PGE6YWNjZW50ND48YTpzcmdiQ2xyIHZhbD0iODA2NEEyIi8+PC9hOmFjY2VudDQ+PGE6YWNjZW50NT48YTpzcmdiQ2xyIHZhbD0iNEJBQ0M2Ii8+PC9hOmFjY2VudDU+PGE6YWNjZW50Nj48YTpzcmdiQ2xyIHZhbD0iRjc5NjQ2Ii8+PC9hOmFjY2VudDY+PGE6aGxpbms+PGE6c3JnYkNsciB2YWw9IjAwMDBGRiIvPjwvYTpobGluaz48YTpmb2xIbGluaz48YTpzcmdiQ2xyIHZhbD0iODAwMDgwIi8+PC9hOmZvbEhsaW5rPjwvYTpjbHJTY2hlbWU+PGE6Zm9udFNjaGVtZSBuYW1lPSJPZmZpY2UiPjxhOm1ham9yRm9udD48YTpsYXRpbiB0eXBlZmFjZT0iQ2FtYnJpYSIvPjxhOmVhIHR5cGVmYWNlPSIiLz48YTpjcyB0eXBlZmFjZT0iIi8+PGE6Zm9udCBzY3JpcHQ9IkpwYW4iIHR5cGVmYWNlPSLDr8K8wq3Dr8K8wrMgw6/CvMKww6PCgsK0w6PCgsK3w6PCg8KDw6PCgsKvIi8+PGE6Zm9udCBzY3JpcHQ9IkhhbmciIHR5cGVmYWNlPSLDq8KnwpHDrMKdwoAgw6rCs8Kgw6vClMKVIi8+PGE6Zm9udCBzY3JpcHQ9IkhhbnMiIHR5cGVmYWNlPSLDpcKuwovDpMK9wpMiLz48YTpmb250IHNjcmlwdD0iSGFudCIgdHlwZWZhY2U9IsOmwpbCsMOnwrTCsMOmwpjCjsOpwqvClCIvPjxhOmZvbnQgc2NyaXB0PSJBcmFiIiB0eXBlZmFjZT0iVGltZXMgTmV3IFJvbWFuIi8+PGE6Zm9udCBzY3JpcHQ9IkhlYnIiIHR5cGVmYWNlPSJUaW1lcyBOZXcgUm9tYW4iLz48YTpmb250IHNjcmlwdD0iVGhhaSIgdHlwZWZhY2U9IlRhaG9tYSIvPjxhOmZvbnQgc2NyaXB0PSJFdGhpIiB0eXBlZmFjZT0iTnlhbGEiLz48YTpmb250IHNjcmlwdD0iQmVuZyIgdHlwZWZhY2U9IlZyaW5kYSIvPjxhOmZvbnQgc2NyaXB0PSJHdWpyIiB0eXBlZmFjZT0iU2hydXRpIi8+PGE6Zm9udCBzY3JpcHQ9IktobXIiIHR5cGVmYWNlPSJNb29sQm9yYW4iLz48YTpmb250IHNjcmlwdD0iS25kYSIgdHlwZWZhY2U9IlR1bmdhIi8+PGE6Zm9udCBzY3JpcHQ9Ikd1cnUiIHR5cGVmYWNlPSJSYWF2aSIvPjxhOmZvbnQgc2NyaXB0PSJDYW5zIiB0eXBlZmFjZT0iRXVwaGVtaWEiLz48YTpmb250IHNjcmlwdD0iQ2hlciIgdHlwZWZhY2U9IlBsYW50YWdlbmV0IENoZXJva2VlIi8+PGE6Zm9udCBzY3JpcHQ9IllpaWkiIHR5cGVmYWNlPSJNaWNyb3NvZnQgWWkgQmFpdGkiLz48YTpmb250IHNjcmlwdD0iVGlidCIgdHlwZWZhY2U9Ik1pY3Jvc29mdCBIaW1hbGF5YSIvPjxhOmZvbnQgc2NyaXB0PSJUaGFhIiB0eXBlZmFjZT0iTVYgQm9saSIvPjxhOmZvbnQgc2NyaXB0PSJEZXZhIiB0eXBlZmFjZT0iTWFuZ2FsIi8+PGE6Zm9udCBzY3JpcHQ9IlRlbHUiIHR5cGVmYWNlPSJHYXV0YW1pIi8+PGE6Zm9udCBzY3JpcHQ9IlRhbWwiIHR5cGVmYWNlPSJMYXRoYSIvPjxhOmZvbnQgc2NyaXB0PSJTeXJjIiB0eXBlZmFjZT0iRXN0cmFuZ2VsbyBFZGVzc2EiLz48YTpmb250IHNjcmlwdD0iT3J5YSIgdHlwZWZhY2U9IkthbGluZ2EiLz48YTpmb250IHNjcmlwdD0iTWx5bSIgdHlwZWZhY2U9IkthcnRpa2EiLz48YTpmb250IHNjcmlwdD0iTGFvbyIgdHlwZWZhY2U9IkRva0NoYW1wYSIvPjxhOmZvbnQgc2NyaXB0PSJTaW5oIiB0eXBlZmFjZT0iSXNrb29sYSBQb3RhIi8+PGE6Zm9udCBzY3JpcHQ9Ik1vbmciIHR5cGVmYWNlPSJNb25nb2xpYW4gQmFpdGkiLz48YTpmb250IHNjcmlwdD0iVmlldCIgdHlwZWZhY2U9IlRpbWVzIE5ldyBSb21hbiIvPjxhOmZvbnQgc2NyaXB0PSJVaWdoIiB0eXBlZmFjZT0iTWljcm9zb2Z0IFVpZ2h1ciIvPjwvYTptYWpvckZvbnQ+PGE6bWlub3JGb250PjxhOmxhdGluIHR5cGVmYWNlPSJDYWxpYnJpIi8+PGE6ZWEgdHlwZWZhY2U9IiIvPjxhOmNzIHR5cGVmYWNlPSIiLz48YTpmb250IHNjcmlwdD0iSnBhbiIgdHlwZWZhY2U9IsOvwrzCrcOvwrzCsyDDr8K8wrDDo8KCwrTDo8KCwrfDo8KDwoPDo8KCwq8iLz48YTpmb250IHNjcmlwdD0iSGFuZyIgdHlwZWZhY2U9IsOrwqfCkcOswp3CgCDDqsKzwqDDq8KUwpUiLz48YTpmb250IHNjcmlwdD0iSGFucyIgdHlwZWZhY2U9IsOlwq7Ci8Okwr3CkyIvPjxhOmZvbnQgc2NyaXB0PSJIYW50IiB0eXBlZmFjZT0iw6bClsKww6fCtMKww6bCmMKOw6nCq8KUIi8+PGE6Zm9udCBzY3JpcHQ9IkFyYWIiIHR5cGVmYWNlPSJBcmlhbCIvPjxhOmZvbnQgc2NyaXB0PSJIZWJyIiB0eXBlZmFjZT0iQXJpYWwiLz48YTpmb250IHNjcmlwdD0iVGhhaSIgdHlwZWZhY2U9IlRhaG9tYSIvPjxhOmZvbnQgc2NyaXB0PSJFdGhpIiB0eXBlZmFjZT0iTnlhbGEiLz48YTpmb250IHNjcmlwdD0iQmVuZyIgdHlwZWZhY2U9IlZyaW5kYSIvPjxhOmZvbnQgc2NyaXB0PSJHdWpyIiB0eXBlZmFjZT0iU2hydXRpIi8+PGE6Zm9udCBzY3JpcHQ9IktobXIiIHR5cGVmYWNlPSJEYXVuUGVuaCIvPjxhOmZvbnQgc2NyaXB0PSJLbmRhIiB0eXBlZmFjZT0iVHVuZ2EiLz48YTpmb250IHNjcmlwdD0iR3VydSIgdHlwZWZhY2U9IlJhYXZpIi8+PGE6Zm9udCBzY3JpcHQ9IkNhbnMiIHR5cGVmYWNlPSJFdXBoZW1pYSIvPjxhOmZvbnQgc2NyaXB0PSJDaGVyIiB0eXBlZmFjZT0iUGxhbnRhZ2VuZXQgQ2hlcm9rZWUiLz48YTpmb250IHNjcmlwdD0iWWlpaSIgdHlwZWZhY2U9Ik1pY3Jvc29mdCBZaSBCYWl0aSIvPjxhOmZvbnQgc2NyaXB0PSJUaWJ0IiB0eXBlZmFjZT0iTWljcm9zb2Z0IEhpbWFsYXlhIi8+PGE6Zm9udCBzY3JpcHQ9IlRoYWEiIHR5cGVmYWNlPSJNViBCb2xpIi8+PGE6Zm9udCBzY3JpcHQ9IkRldmEiIHR5cGVmYWNlPSJNYW5nYWwiLz48YTpmb250IHNjcmlwdD0iVGVsdSIgdHlwZWZhY2U9IkdhdXRhbWkiLz48YTpmb250IHNjcmlwdD0iVGFtbCIgdHlwZWZhY2U9IkxhdGhhIi8+PGE6Zm9udCBzY3JpcHQ9IlN5cmMiIHR5cGVmYWNlPSJFc3RyYW5nZWxvIEVkZXNzYSIvPjxhOmZvbnQgc2NyaXB0PSJPcnlhIiB0eXBlZmFjZT0iS2FsaW5nYSIvPjxhOmZvbnQgc2NyaXB0PSJNbHltIiB0eXBlZmFjZT0iS2FydGlrYSIvPjxhOmZvbnQgc2NyaXB0PSJMYW9vIiB0eXBlZmFjZT0iRG9rQ2hhbXBhIi8+PGE6Zm9udCBzY3JpcHQ9IlNpbmgiIHR5cGVmYWNlPSJJc2tvb2xhIFBvdGEiLz48YTpmb250IHNjcmlwdD0iTW9uZyIgdHlwZWZhY2U9Ik1vbmdvbGlhbiBCYWl0aSIvPjxhOmZvbnQgc2NyaXB0PSJWaWV0IiB0eXBlZmFjZT0iQXJpYWwiLz48YTpmb250IHNjcmlwdD0iVWlnaCIgdHlwZWZhY2U9Ik1pY3Jvc29mdCBVaWdodXIiLz48L2E6bWlub3JGb250PjwvYTpmb250U2NoZW1lPjxhOmZtdFNjaGVtZSBuYW1lPSJPZmZpY2UiPjxhOmZpbGxTdHlsZUxzdD48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiLz48L2E6c29saWRGaWxsPjxhOmdyYWRGaWxsIHJvdFdpdGhTaGFwZT0iMSI+PGE6Z3NMc3Q+PGE6Z3MgcG9zPSIwIj48YTpzY2hlbWVDbHIgdmFsPSJwaENsciI+PGE6dGludCB2YWw9IjUwMDAwIi8+PGE6c2F0TW9kIHZhbD0iMzAwMDAwIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PGE6Z3MgcG9zPSIzNTAwMCI+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnRpbnQgdmFsPSIzNzAwMCIvPjxhOnNhdE1vZCB2YWw9IjMwMDAwMCIvPjwvYTpzY2hlbWVDbHI+PC9hOmdzPjxhOmdzIHBvcz0iMTAwMDAwIj48YTpzY2hlbWVDbHIgdmFsPSJwaENsciI+PGE6dGludCB2YWw9IjE1MDAwIi8+PGE6c2F0TW9kIHZhbD0iMzUwMDAwIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PC9hOmdzTHN0PjxhOmxpbiBhbmc9IjE2MjAwMDAwIiBzY2FsZWQ9IjEiLz48L2E6Z3JhZEZpbGw+PGE6Z3JhZEZpbGwgcm90V2l0aFNoYXBlPSIxIj48YTpnc0xzdD48YTpncyBwb3M9IjAiPjxhOnNjaGVtZUNsciB2YWw9InBoQ2xyIj48YTpzaGFkZSB2YWw9IjUxMDAwIi8+PGE6c2F0TW9kIHZhbD0iMTMwMDAwIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PGE6Z3MgcG9zPSI4MDAwMCI+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnNoYWRlIHZhbD0iOTMwMDAiLz48YTpzYXRNb2QgdmFsPSIxMzAwMDAiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48YTpncyBwb3M9IjEwMDAwMCI+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnNoYWRlIHZhbD0iOTQwMDAiLz48YTpzYXRNb2QgdmFsPSIxMzUwMDAiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48L2E6Z3NMc3Q+PGE6bGluIGFuZz0iMTYyMDAwMDAiIHNjYWxlZD0iMCIvPjwvYTpncmFkRmlsbD48L2E6ZmlsbFN0eWxlTHN0PjxhOmxuU3R5bGVMc3Q+PGE6bG4gdz0iOTUyNSIgY2FwPSJmbGF0IiBjbXBkPSJzbmciIGFsZ249ImN0ciI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9InBoQ2xyIj48YTpzaGFkZSB2YWw9Ijk1MDAwIi8+PGE6c2F0TW9kIHZhbD0iMTA1MDAwIi8+PC9hOnNjaGVtZUNscj48L2E6c29saWRGaWxsPjxhOnByc3REYXNoIHZhbD0ic29saWQiLz48L2E6bG4+PGE6bG4gdz0iMjU0MDAiIGNhcD0iZmxhdCIgY21wZD0ic25nIiBhbGduPSJjdHIiPjxhOnNvbGlkRmlsbD48YTpzY2hlbWVDbHIgdmFsPSJwaENsciIvPjwvYTpzb2xpZEZpbGw+PGE6cHJzdERhc2ggdmFsPSJzb2xpZCIvPjwvYTpsbj48YTpsbiB3PSIzODEwMCIgY2FwPSJmbGF0IiBjbXBkPSJzbmciIGFsZ249ImN0ciI+PGE6c29saWRGaWxsPjxhOnNjaGVtZUNsciB2YWw9InBoQ2xyIi8+PC9hOnNvbGlkRmlsbD48YTpwcnN0RGFzaCB2YWw9InNvbGlkIi8+PC9hOmxuPjwvYTpsblN0eWxlTHN0PjxhOmVmZmVjdFN0eWxlTHN0PjxhOmVmZmVjdFN0eWxlPjxhOmVmZmVjdExzdD48YTpvdXRlclNoZHcgYmx1clJhZD0iNDAwMDAiIGRpc3Q9IjIwMDAwIiBkaXI9IjU0MDAwMDAiIHJvdFdpdGhTaGFwZT0iMCI+PGE6c3JnYkNsciB2YWw9IjAwMDAwMCI+PGE6YWxwaGEgdmFsPSIzODAwMCIvPjwvYTpzcmdiQ2xyPjwvYTpvdXRlclNoZHc+PC9hOmVmZmVjdExzdD48L2E6ZWZmZWN0U3R5bGU+PGE6ZWZmZWN0U3R5bGU+PGE6ZWZmZWN0THN0PjxhOm91dGVyU2hkdyBibHVyUmFkPSI0MDAwMCIgZGlzdD0iMjMwMDAiIGRpcj0iNTQwMDAwMCIgcm90V2l0aFNoYXBlPSIwIj48YTpzcmdiQ2xyIHZhbD0iMDAwMDAwIj48YTphbHBoYSB2YWw9IjM1MDAwIi8+PC9hOnNyZ2JDbHI+PC9hOm91dGVyU2hkdz48L2E6ZWZmZWN0THN0PjwvYTplZmZlY3RTdHlsZT48YTplZmZlY3RTdHlsZT48YTplZmZlY3RMc3Q+PGE6b3V0ZXJTaGR3IGJsdXJSYWQ9IjQwMDAwIiBkaXN0PSIyMzAwMCIgZGlyPSI1NDAwMDAwIiByb3RXaXRoU2hhcGU9IjAiPjxhOnNyZ2JDbHIgdmFsPSIwMDAwMDAiPjxhOmFscGhhIHZhbD0iMzUwMDAiLz48L2E6c3JnYkNscj48L2E6b3V0ZXJTaGR3PjwvYTplZmZlY3RMc3Q+PGE6c2NlbmUzZD48YTpjYW1lcmEgcHJzdD0ib3J0aG9ncmFwaGljRnJvbnQiPjxhOnJvdCBsYXQ9IjAiIGxvbj0iMCIgcmV2PSIwIi8+PC9hOmNhbWVyYT48YTpsaWdodFJpZyByaWc9InRocmVlUHQiIGRpcj0idCI+PGE6cm90IGxhdD0iMCIgbG9uPSIwIiByZXY9IjEyMDAwMDAiLz48L2E6bGlnaHRSaWc+PC9hOnNjZW5lM2Q+PGE6c3AzZD48YTpiZXZlbFQgdz0iNjM1MDAiIGg9IjI1NDAwIi8+PC9hOnNwM2Q+PC9hOmVmZmVjdFN0eWxlPjwvYTplZmZlY3RTdHlsZUxzdD48YTpiZ0ZpbGxTdHlsZUxzdD48YTpzb2xpZEZpbGw+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiLz48L2E6c29saWRGaWxsPjxhOmdyYWRGaWxsIHJvdFdpdGhTaGFwZT0iMSI+PGE6Z3NMc3Q+PGE6Z3MgcG9zPSIwIj48YTpzY2hlbWVDbHIgdmFsPSJwaENsciI+PGE6dGludCB2YWw9IjQwMDAwIi8+PGE6c2F0TW9kIHZhbD0iMzUwMDAwIi8+PC9hOnNjaGVtZUNscj48L2E6Z3M+PGE6Z3MgcG9zPSI0MDAwMCI+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnRpbnQgdmFsPSI0NTAwMCIvPjxhOnNoYWRlIHZhbD0iOTkwMDAiLz48YTpzYXRNb2QgdmFsPSIzNTAwMDAiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48YTpncyBwb3M9IjEwMDAwMCI+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnNoYWRlIHZhbD0iMjAwMDAiLz48YTpzYXRNb2QgdmFsPSIyNTUwMDAiLz48L2E6c2NoZW1lQ2xyPjwvYTpncz48L2E6Z3NMc3Q+PGE6cGF0aCBwYXRoPSJjaXJjbGUiPjxhOmZpbGxUb1JlY3QgbD0iNTAwMDAiIHQ9Ii04MDAwMCIgcj0iNTAwMDAiIGI9IjE4MDAwMCIvPjwvYTpwYXRoPjwvYTpncmFkRmlsbD48YTpncmFkRmlsbCByb3RXaXRoU2hhcGU9IjEiPjxhOmdzTHN0PjxhOmdzIHBvcz0iMCI+PGE6c2NoZW1lQ2xyIHZhbD0icGhDbHIiPjxhOnRpbnQgdmFsPSI4MDAwMCIvPjxhOnNhdE1vZCB2YWw9IjMwMDAwMCIvPjwvYTpzY2hlbWVDbHI+PC9hOmdzPjxhOmdzIHBvcz0iMTAwMDAwIj48YTpzY2hlbWVDbHIgdmFsPSJwaENsciI+PGE6c2hhZGUgdmFsPSIzMDAwMCIvPjxhOnNhdE1vZCB2YWw9IjIwMDAwMCIvPjwvYTpzY2hlbWVDbHI+PC9hOmdzPjwvYTpnc0xzdD48YTpwYXRoIHBhdGg9ImNpcmNsZSI+PGE6ZmlsbFRvUmVjdCBsPSI1MDAwMCIgdD0iNTAwMDAiIHI9IjUwMDAwIiBiPSI1MDAwMCIvPjwvYTpwYXRoPjwvYTpncmFkRmlsbD48L2E6YmdGaWxsU3R5bGVMc3Q+PC9hOmZtdFNjaGVtZT48L2E6dGhlbWVFbGVtZW50cz48YTpvYmplY3REZWZhdWx0cy8+PGE6ZXh0cmFDbHJTY2hlbWVMc3QvPjwvYTp0aGVtZT5QSwMEFAAAAAAAAAAAAFX0BJRaBAAAWgQAAA0AAAB4bC9zdHlsZXMueG1sPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/Pg0KPHN0eWxlU2hlZXQgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9zcHJlYWRzaGVldG1sLzIwMDYvbWFpbiIgeG1sbnM6dnQ9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L2RvY1Byb3BzVlR5cGVzIj48bnVtRm10cyBjb3VudD0iMSI+PG51bUZtdCBudW1GbXRJZD0iNTYiIGZvcm1hdENvZGU9IiZxdW90O+S4iuWNiC/kuIvljYggJnF1b3Q7aGgmcXVvdDvmmYImcXVvdDttbSZxdW90O+WIhiZxdW90O3NzJnF1b3Q756eSICZxdW90OyIvPjwvbnVtRm10cz48Zm9udHMgY291bnQ9IjEiPjxmb250PjxzeiB2YWw9IjEyIi8+PGNvbG9yIHRoZW1lPSIxIi8+PG5hbWUgdmFsPSJDYWxpYnJpIi8+PGZhbWlseSB2YWw9IjIiLz48c2NoZW1lIHZhbD0ibWlub3IiLz48L2ZvbnQ+PC9mb250cz48ZmlsbHMgY291bnQ9IjIiPjxmaWxsPjxwYXR0ZXJuRmlsbCBwYXR0ZXJuVHlwZT0ibm9uZSIvPjwvZmlsbD48ZmlsbD48cGF0dGVybkZpbGwgcGF0dGVyblR5cGU9ImdyYXkxMjUiLz48L2ZpbGw+PC9maWxscz48Ym9yZGVycyBjb3VudD0iMSI+PGJvcmRlcj48bGVmdC8+PHJpZ2h0Lz48dG9wLz48Ym90dG9tLz48ZGlhZ29uYWwvPjwvYm9yZGVyPjwvYm9yZGVycz48Y2VsbFN0eWxlWGZzIGNvdW50PSIxIj48eGYgbnVtRm10SWQ9IjAiIGZvbnRJZD0iMCIgZmlsbElkPSIwIiBib3JkZXJJZD0iMCIvPjwvY2VsbFN0eWxlWGZzPjxjZWxsWGZzIGNvdW50PSIxIj48eGYgbnVtRm10SWQ9IjAiIGZvbnRJZD0iMCIgZmlsbElkPSIwIiBib3JkZXJJZD0iMCIgeGZJZD0iMCIgYXBwbHlOdW1iZXJGb3JtYXQ9IjEiLz48L2NlbGxYZnM+PGNlbGxTdHlsZXMgY291bnQ9IjEiPjxjZWxsU3R5bGUgbmFtZT0iTm9ybWFsIiB4ZklkPSIwIiBidWlsdGluSWQ9IjAiLz48L2NlbGxTdHlsZXM+PGR4ZnMgY291bnQ9IjAiLz48dGFibGVTdHlsZXMgY291bnQ9IjAiIGRlZmF1bHRUYWJsZVN0eWxlPSJUYWJsZVN0eWxlTWVkaXVtOSIgZGVmYXVsdFBpdm90U3R5bGU9IlBpdm90U3R5bGVNZWRpdW00Ii8+PC9zdHlsZVNoZWV0PlBLAwQUAAAAAAAAAAAAp0uMyvEBAADxAQAAGAAAAHhsL3dvcmtzaGVldHMvc2hlZXQxLnhtbDw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04IiBzdGFuZGFsb25lPSJ5ZXMiPz4NCjx3b3Jrc2hlZXQgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9zcHJlYWRzaGVldG1sLzIwMDYvbWFpbiIgeG1sbnM6cj0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcyI+PGRpbWVuc2lvbiByZWY9IkExIi8+PHNoZWV0Vmlld3M+PHNoZWV0VmlldyB3b3JrYm9va1ZpZXdJZD0iMCIgcmlnaHRUb0xlZnQ9IjAiLz48L3NoZWV0Vmlld3M+PHNoZWV0RGF0YS8+PHBhZ2VNYXJnaW5zIGxlZnQ9IjAuNyIgcmlnaHQ9IjAuNyIgdG9wPSIwLjc1IiBib3R0b209IjAuNzUiIGhlYWRlcj0iMC4zIiBmb290ZXI9IjAuMyIvPjxpZ25vcmVkRXJyb3JzPjxpZ25vcmVkRXJyb3IgbnVtYmVyU3RvcmVkQXNUZXh0PSIxIiBzcXJlZj0iQTEiLz48L2lnbm9yZWRFcnJvcnM+PC93b3Jrc2hlZXQ+UEsDBBQAAAAAAAAAAABeiJu7lS0AAJUtAAAYAAAAeGwvd29ya3NoZWV0cy9zaGVldDIueG1sPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/Pg0KPHdvcmtzaGVldCB4bWxucz0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3NwcmVhZHNoZWV0bWwvMjAwNi9tYWluIiB4bWxuczpyPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzIj48ZGltZW5zaW9uIHJlZj0iQTE6QTI1NSIvPjxzaGVldFZpZXdzPjxzaGVldFZpZXcgd29ya2Jvb2tWaWV3SWQ9IjAiIHJpZ2h0VG9MZWZ0PSIwIi8+PC9zaGVldFZpZXdzPjxzaGVldERhdGE+PHJvdyByPSIxIj48YyByPSJBMSI+PHY+MTwvdj48L2M+PC9yb3c+PHJvdyByPSIyIj48YyByPSJBMiI+PHY+Mjwvdj48L2M+PC9yb3c+PHJvdyByPSIzIj48YyByPSJBMyI+PHY+Mzwvdj48L2M+PC9yb3c+PHJvdyByPSI0Ij48YyByPSJBNCI+PHY+NDwvdj48L2M+PC9yb3c+PHJvdyByPSI1Ij48YyByPSJBNSI+PHY+NTwvdj48L2M+PC9yb3c+PHJvdyByPSI2Ij48YyByPSJBNiI+PHY+Njwvdj48L2M+PC9yb3c+PHJvdyByPSI3Ij48YyByPSJBNyI+PHY+Nzwvdj48L2M+PC9yb3c+PHJvdyByPSI4Ij48YyByPSJBOCI+PHY+ODwvdj48L2M+PC9yb3c+PHJvdyByPSI5Ij48YyByPSJBOSI+PHY+OTwvdj48L2M+PC9yb3c+PHJvdyByPSIxMCI+PGMgcj0iQTEwIj48dj4xMDwvdj48L2M+PC9yb3c+PHJvdyByPSIxMSI+PGMgcj0iQTExIj48dj4xMTwvdj48L2M+PC9yb3c+PHJvdyByPSIxMiI+PGMgcj0iQTEyIj48dj4xMjwvdj48L2M+PC9yb3c+PHJvdyByPSIxMyI+PGMgcj0iQTEzIj48dj4xMzwvdj48L2M+PC9yb3c+PHJvdyByPSIxNCI+PGMgcj0iQTE0Ij48dj4xNDwvdj48L2M+PC9yb3c+PHJvdyByPSIxNSI+PGMgcj0iQTE1Ij48dj4xNTwvdj48L2M+PC9yb3c+PHJvdyByPSIxNiI+PGMgcj0iQTE2Ij48dj4xNjwvdj48L2M+PC9yb3c+PHJvdyByPSIxNyI+PGMgcj0iQTE3Ij48dj4xNzwvdj48L2M+PC9yb3c+PHJvdyByPSIxOCI+PGMgcj0iQTE4Ij48dj4xODwvdj48L2M+PC9yb3c+PHJvdyByPSIxOSI+PGMgcj0iQTE5Ij48dj4xOTwvdj48L2M+PC9yb3c+PHJvdyByPSIyMCI+PGMgcj0iQTIwIj48dj4yMDwvdj48L2M+PC9yb3c+PHJvdyByPSIyMSI+PGMgcj0iQTIxIj48dj4yMTwvdj48L2M+PC9yb3c+PHJvdyByPSIyMiI+PGMgcj0iQTIyIj48dj4yMjwvdj48L2M+PC9yb3c+PHJvdyByPSIyMyI+PGMgcj0iQTIzIj48dj4yMzwvdj48L2M+PC9yb3c+PHJvdyByPSIyNCI+PGMgcj0iQTI0Ij48dj4yNDwvdj48L2M+PC9yb3c+PHJvdyByPSIyNSI+PGMgcj0iQTI1Ij48dj4yNTwvdj48L2M+PC9yb3c+PHJvdyByPSIyNiI+PGMgcj0iQTI2Ij48dj4yNjwvdj48L2M+PC9yb3c+PHJvdyByPSIyNyI+PGMgcj0iQTI3Ij48dj4yNzwvdj48L2M+PC9yb3c+PHJvdyByPSIyOCI+PGMgcj0iQTI4Ij48dj4yODwvdj48L2M+PC9yb3c+PHJvdyByPSIyOSI+PGMgcj0iQTI5Ij48dj4yOTwvdj48L2M+PC9yb3c+PHJvdyByPSIzMCI+PGMgcj0iQTMwIj48dj4zMDwvdj48L2M+PC9yb3c+PHJvdyByPSIzMSI+PGMgcj0iQTMxIj48dj4zMTwvdj48L2M+PC9yb3c+PHJvdyByPSIzMiI+PGMgcj0iQTMyIj48dj4zMjwvdj48L2M+PC9yb3c+PHJvdyByPSIzMyI+PGMgcj0iQTMzIj48dj4zMzwvdj48L2M+PC9yb3c+PHJvdyByPSIzNCI+PGMgcj0iQTM0Ij48dj4zNDwvdj48L2M+PC9yb3c+PHJvdyByPSIzNSI+PGMgcj0iQTM1Ij48dj4zNTwvdj48L2M+PC9yb3c+PHJvdyByPSIzNiI+PGMgcj0iQTM2Ij48dj4zNjwvdj48L2M+PC9yb3c+PHJvdyByPSIzNyI+PGMgcj0iQTM3Ij48dj4zNzwvdj48L2M+PC9yb3c+PHJvdyByPSIzOCI+PGMgcj0iQTM4Ij48dj4zODwvdj48L2M+PC9yb3c+PHJvdyByPSIzOSI+PGMgcj0iQTM5Ij48dj4zOTwvdj48L2M+PC9yb3c+PHJvdyByPSI0MCI+PGMgcj0iQTQwIj48dj40MDwvdj48L2M+PC9yb3c+PHJvdyByPSI0MSI+PGMgcj0iQTQxIj48dj40MTwvdj48L2M+PC9yb3c+PHJvdyByPSI0MiI+PGMgcj0iQTQyIj48dj40Mjwvdj48L2M+PC9yb3c+PHJvdyByPSI0MyI+PGMgcj0iQTQzIj48dj40Mzwvdj48L2M+PC9yb3c+PHJvdyByPSI0NCI+PGMgcj0iQTQ0Ij48dj40NDwvdj48L2M+PC9yb3c+PHJvdyByPSI0NSI+PGMgcj0iQTQ1Ij48dj40NTwvdj48L2M+PC9yb3c+PHJvdyByPSI0NiI+PGMgcj0iQTQ2Ij48dj40Njwvdj48L2M+PC9yb3c+PHJvdyByPSI0NyI+PGMgcj0iQTQ3Ij48dj40Nzwvdj48L2M+PC9yb3c+PHJvdyByPSI0OCI+PGMgcj0iQTQ4Ij48dj40ODwvdj48L2M+PC9yb3c+PHJvdyByPSI0OSI+PGMgcj0iQTQ5Ij48dj40OTwvdj48L2M+PC9yb3c+PHJvdyByPSI1MCI+PGMgcj0iQTUwIj48dj41MDwvdj48L2M+PC9yb3c+PHJvdyByPSI1MSI+PGMgcj0iQTUxIj48dj41MTwvdj48L2M+PC9yb3c+PHJvdyByPSI1MiI+PGMgcj0iQTUyIj48dj41Mjwvdj48L2M+PC9yb3c+PHJvdyByPSI1MyI+PGMgcj0iQTUzIj48dj41Mzwvdj48L2M+PC9yb3c+PHJvdyByPSI1NCI+PGMgcj0iQTU0Ij48dj41NDwvdj48L2M+PC9yb3c+PHJvdyByPSI1NSI+PGMgcj0iQTU1Ij48dj41NTwvdj48L2M+PC9yb3c+PHJvdyByPSI1NiI+PGMgcj0iQTU2Ij48dj41Njwvdj48L2M+PC9yb3c+PHJvdyByPSI1NyI+PGMgcj0iQTU3Ij48dj41Nzwvdj48L2M+PC9yb3c+PHJvdyByPSI1OCI+PGMgcj0iQTU4Ij48dj41ODwvdj48L2M+PC9yb3c+PHJvdyByPSI1OSI+PGMgcj0iQTU5Ij48dj41OTwvdj48L2M+PC9yb3c+PHJvdyByPSI2MCI+PGMgcj0iQTYwIj48dj42MDwvdj48L2M+PC9yb3c+PHJvdyByPSI2MSI+PGMgcj0iQTYxIj48dj42MTwvdj48L2M+PC9yb3c+PHJvdyByPSI2MiI+PGMgcj0iQTYyIj48dj42Mjwvdj48L2M+PC9yb3c+PHJvdyByPSI2MyI+PGMgcj0iQTYzIj48dj42Mzwvdj48L2M+PC9yb3c+PHJvdyByPSI2NCI+PGMgcj0iQTY0Ij48dj42NDwvdj48L2M+PC9yb3c+PHJvdyByPSI2NSI+PGMgcj0iQTY1Ij48dj42NTwvdj48L2M+PC9yb3c+PHJvdyByPSI2NiI+PGMgcj0iQTY2Ij48dj42Njwvdj48L2M+PC9yb3c+PHJvdyByPSI2NyI+PGMgcj0iQTY3Ij48dj42Nzwvdj48L2M+PC9yb3c+PHJvdyByPSI2OCI+PGMgcj0iQTY4Ij48dj42ODwvdj48L2M+PC9yb3c+PHJvdyByPSI2OSI+PGMgcj0iQTY5Ij48dj42OTwvdj48L2M+PC9yb3c+PHJvdyByPSI3MCI+PGMgcj0iQTcwIj48dj43MDwvdj48L2M+PC9yb3c+PHJvdyByPSI3MSI+PGMgcj0iQTcxIj48dj43MTwvdj48L2M+PC9yb3c+PHJvdyByPSI3MiI+PGMgcj0iQTcyIj48dj43Mjwvdj48L2M+PC9yb3c+PHJvdyByPSI3MyI+PGMgcj0iQTczIj48dj43Mzwvdj48L2M+PC9yb3c+PHJvdyByPSI3NCI+PGMgcj0iQTc0Ij48dj43NDwvdj48L2M+PC9yb3c+PHJvdyByPSI3NSI+PGMgcj0iQTc1Ij48dj43NTwvdj48L2M+PC9yb3c+PHJvdyByPSI3NiI+PGMgcj0iQTc2Ij48dj43Njwvdj48L2M+PC9yb3c+PHJvdyByPSI3NyI+PGMgcj0iQTc3Ij48dj43Nzwvdj48L2M+PC9yb3c+PHJvdyByPSI3OCI+PGMgcj0iQTc4Ij48dj43ODwvdj48L2M+PC9yb3c+PHJvdyByPSI3OSI+PGMgcj0iQTc5Ij48dj43OTwvdj48L2M+PC9yb3c+PHJvdyByPSI4MCI+PGMgcj0iQTgwIj48dj44MDwvdj48L2M+PC9yb3c+PHJvdyByPSI4MSI+PGMgcj0iQTgxIj48dj44MTwvdj48L2M+PC9yb3c+PHJvdyByPSI4MiI+PGMgcj0iQTgyIj48dj44Mjwvdj48L2M+PC9yb3c+PHJvdyByPSI4MyI+PGMgcj0iQTgzIj48dj44Mzwvdj48L2M+PC9yb3c+PHJvdyByPSI4NCI+PGMgcj0iQTg0Ij48dj44NDwvdj48L2M+PC9yb3c+PHJvdyByPSI4NSI+PGMgcj0iQTg1Ij48dj44NTwvdj48L2M+PC9yb3c+PHJvdyByPSI4NiI+PGMgcj0iQTg2Ij48dj44Njwvdj48L2M+PC9yb3c+PHJvdyByPSI4NyI+PGMgcj0iQTg3Ij48dj44Nzwvdj48L2M+PC9yb3c+PHJvdyByPSI4OCI+PGMgcj0iQTg4Ij48dj44ODwvdj48L2M+PC9yb3c+PHJvdyByPSI4OSI+PGMgcj0iQTg5Ij48dj44OTwvdj48L2M+PC9yb3c+PHJvdyByPSI5MCI+PGMgcj0iQTkwIj48dj45MDwvdj48L2M+PC9yb3c+PHJvdyByPSI5MSI+PGMgcj0iQTkxIj48dj45MTwvdj48L2M+PC9yb3c+PHJvdyByPSI5MiI+PGMgcj0iQTkyIj48dj45Mjwvdj48L2M+PC9yb3c+PHJvdyByPSI5MyI+PGMgcj0iQTkzIj48dj45Mzwvdj48L2M+PC9yb3c+PHJvdyByPSI5NCI+PGMgcj0iQTk0Ij48dj45NDwvdj48L2M+PC9yb3c+PHJvdyByPSI5NSI+PGMgcj0iQTk1Ij48dj45NTwvdj48L2M+PC9yb3c+PHJvdyByPSI5NiI+PGMgcj0iQTk2Ij48dj45Njwvdj48L2M+PC9yb3c+PHJvdyByPSI5NyI+PGMgcj0iQTk3Ij48dj45Nzwvdj48L2M+PC9yb3c+PHJvdyByPSI5OCI+PGMgcj0iQTk4Ij48dj45ODwvdj48L2M+PC9yb3c+PHJvdyByPSI5OSI+PGMgcj0iQTk5Ij48dj45OTwvdj48L2M+PC9yb3c+PHJvdyByPSIxMDAiPjxjIHI9IkExMDAiPjx2PjEwMDwvdj48L2M+PC9yb3c+PHJvdyByPSIxMDEiPjxjIHI9IkExMDEiPjx2PjEwMTwvdj48L2M+PC9yb3c+PHJvdyByPSIxMDIiPjxjIHI9IkExMDIiPjx2PjEwMjwvdj48L2M+PC9yb3c+PHJvdyByPSIxMDMiPjxjIHI9IkExMDMiPjx2PjEwMzwvdj48L2M+PC9yb3c+PHJvdyByPSIxMDQiPjxjIHI9IkExMDQiPjx2PjEwNDwvdj48L2M+PC9yb3c+PHJvdyByPSIxMDUiPjxjIHI9IkExMDUiPjx2PjEwNTwvdj48L2M+PC9yb3c+PHJvdyByPSIxMDYiPjxjIHI9IkExMDYiPjx2PjEwNjwvdj48L2M+PC9yb3c+PHJvdyByPSIxMDciPjxjIHI9IkExMDciPjx2PjEwNzwvdj48L2M+PC9yb3c+PHJvdyByPSIxMDgiPjxjIHI9IkExMDgiPjx2PjEwODwvdj48L2M+PC9yb3c+PHJvdyByPSIxMDkiPjxjIHI9IkExMDkiPjx2PjEwOTwvdj48L2M+PC9yb3c+PHJvdyByPSIxMTAiPjxjIHI9IkExMTAiPjx2PjExMDwvdj48L2M+PC9yb3c+PHJvdyByPSIxMTEiPjxjIHI9IkExMTEiPjx2PjExMTwvdj48L2M+PC9yb3c+PHJvdyByPSIxMTIiPjxjIHI9IkExMTIiPjx2PjExMjwvdj48L2M+PC9yb3c+PHJvdyByPSIxMTMiPjxjIHI9IkExMTMiPjx2PjExMzwvdj48L2M+PC9yb3c+PHJvdyByPSIxMTQiPjxjIHI9IkExMTQiPjx2PjExNDwvdj48L2M+PC9yb3c+PHJvdyByPSIxMTUiPjxjIHI9IkExMTUiPjx2PjExNTwvdj48L2M+PC9yb3c+PHJvdyByPSIxMTYiPjxjIHI9IkExMTYiPjx2PjExNjwvdj48L2M+PC9yb3c+PHJvdyByPSIxMTciPjxjIHI9IkExMTciPjx2PjExNzwvdj48L2M+PC9yb3c+PHJvdyByPSIxMTgiPjxjIHI9IkExMTgiPjx2PjExODwvdj48L2M+PC9yb3c+PHJvdyByPSIxMTkiPjxjIHI9IkExMTkiPjx2PjExOTwvdj48L2M+PC9yb3c+PHJvdyByPSIxMjAiPjxjIHI9IkExMjAiPjx2PjEyMDwvdj48L2M+PC9yb3c+PHJvdyByPSIxMjEiPjxjIHI9IkExMjEiPjx2PjEyMTwvdj48L2M+PC9yb3c+PHJvdyByPSIxMjIiPjxjIHI9IkExMjIiPjx2PjEyMjwvdj48L2M+PC9yb3c+PHJvdyByPSIxMjMiPjxjIHI9IkExMjMiPjx2PjEyMzwvdj48L2M+PC9yb3c+PHJvdyByPSIxMjQiPjxjIHI9IkExMjQiPjx2PjEyNDwvdj48L2M+PC9yb3c+PHJvdyByPSIxMjUiPjxjIHI9IkExMjUiPjx2PjEyNTwvdj48L2M+PC9yb3c+PHJvdyByPSIxMjYiPjxjIHI9IkExMjYiPjx2PjEyNjwvdj48L2M+PC9yb3c+PHJvdyByPSIxMjciPjxjIHI9IkExMjciPjx2PjEyNzwvdj48L2M+PC9yb3c+PHJvdyByPSIxMjgiPjxjIHI9IkExMjgiPjx2PjEyODwvdj48L2M+PC9yb3c+PHJvdyByPSIxMjkiPjxjIHI9IkExMjkiPjx2PjEyOTwvdj48L2M+PC9yb3c+PHJvdyByPSIxMzAiPjxjIHI9IkExMzAiPjx2PjEzMDwvdj48L2M+PC9yb3c+PHJvdyByPSIxMzEiPjxjIHI9IkExMzEiPjx2PjEzMTwvdj48L2M+PC9yb3c+PHJvdyByPSIxMzIiPjxjIHI9IkExMzIiPjx2PjEzMjwvdj48L2M+PC9yb3c+PHJvdyByPSIxMzMiPjxjIHI9IkExMzMiPjx2PjEzMzwvdj48L2M+PC9yb3c+PHJvdyByPSIxMzQiPjxjIHI9IkExMzQiPjx2PjEzNDwvdj48L2M+PC9yb3c+PHJvdyByPSIxMzUiPjxjIHI9IkExMzUiPjx2PjEzNTwvdj48L2M+PC9yb3c+PHJvdyByPSIxMzYiPjxjIHI9IkExMzYiPjx2PjEzNjwvdj48L2M+PC9yb3c+PHJvdyByPSIxMzciPjxjIHI9IkExMzciPjx2PjEzNzwvdj48L2M+PC9yb3c+PHJvdyByPSIxMzgiPjxjIHI9IkExMzgiPjx2PjEzODwvdj48L2M+PC9yb3c+PHJvdyByPSIxMzkiPjxjIHI9IkExMzkiPjx2PjEzOTwvdj48L2M+PC9yb3c+PHJvdyByPSIxNDAiPjxjIHI9IkExNDAiPjx2PjE0MDwvdj48L2M+PC9yb3c+PHJvdyByPSIxNDEiPjxjIHI9IkExNDEiPjx2PjE0MTwvdj48L2M+PC9yb3c+PHJvdyByPSIxNDIiPjxjIHI9IkExNDIiPjx2PjE0Mjwvdj48L2M+PC9yb3c+PHJvdyByPSIxNDMiPjxjIHI9IkExNDMiPjx2PjE0Mzwvdj48L2M+PC9yb3c+PHJvdyByPSIxNDQiPjxjIHI9IkExNDQiPjx2PjE0NDwvdj48L2M+PC9yb3c+PHJvdyByPSIxNDUiPjxjIHI9IkExNDUiPjx2PjE0NTwvdj48L2M+PC9yb3c+PHJvdyByPSIxNDYiPjxjIHI9IkExNDYiPjx2PjE0Njwvdj48L2M+PC9yb3c+PHJvdyByPSIxNDciPjxjIHI9IkExNDciPjx2PjE0Nzwvdj48L2M+PC9yb3c+PHJvdyByPSIxNDgiPjxjIHI9IkExNDgiPjx2PjE0ODwvdj48L2M+PC9yb3c+PHJvdyByPSIxNDkiPjxjIHI9IkExNDkiPjx2PjE0OTwvdj48L2M+PC9yb3c+PHJvdyByPSIxNTAiPjxjIHI9IkExNTAiPjx2PjE1MDwvdj48L2M+PC9yb3c+PHJvdyByPSIxNTEiPjxjIHI9IkExNTEiPjx2PjE1MTwvdj48L2M+PC9yb3c+PHJvdyByPSIxNTIiPjxjIHI9IkExNTIiPjx2PjE1Mjwvdj48L2M+PC9yb3c+PHJvdyByPSIxNTMiPjxjIHI9IkExNTMiPjx2PjE1Mzwvdj48L2M+PC9yb3c+PHJvdyByPSIxNTQiPjxjIHI9IkExNTQiPjx2PjE1NDwvdj48L2M+PC9yb3c+PHJvdyByPSIxNTUiPjxjIHI9IkExNTUiPjx2PjE1NTwvdj48L2M+PC9yb3c+PHJvdyByPSIxNTYiPjxjIHI9IkExNTYiPjx2PjE1Njwvdj48L2M+PC9yb3c+PHJvdyByPSIxNTciPjxjIHI9IkExNTciPjx2PjE1Nzwvdj48L2M+PC9yb3c+PHJvdyByPSIxNTgiPjxjIHI9IkExNTgiPjx2PjE1ODwvdj48L2M+PC9yb3c+PHJvdyByPSIxNTkiPjxjIHI9IkExNTkiPjx2PjE1OTwvdj48L2M+PC9yb3c+PHJvdyByPSIxNjAiPjxjIHI9IkExNjAiPjx2PjE2MDwvdj48L2M+PC9yb3c+PHJvdyByPSIxNjEiPjxjIHI9IkExNjEiPjx2PjE2MTwvdj48L2M+PC9yb3c+PHJvdyByPSIxNjIiPjxjIHI9IkExNjIiPjx2PjE2Mjwvdj48L2M+PC9yb3c+PHJvdyByPSIxNjMiPjxjIHI9IkExNjMiPjx2PjE2Mzwvdj48L2M+PC9yb3c+PHJvdyByPSIxNjQiPjxjIHI9IkExNjQiPjx2PjE2NDwvdj48L2M+PC9yb3c+PHJvdyByPSIxNjUiPjxjIHI9IkExNjUiPjx2PjE2NTwvdj48L2M+PC9yb3c+PHJvdyByPSIxNjYiPjxjIHI9IkExNjYiPjx2PjE2Njwvdj48L2M+PC9yb3c+PHJvdyByPSIxNjciPjxjIHI9IkExNjciPjx2PjE2Nzwvdj48L2M+PC9yb3c+PHJvdyByPSIxNjgiPjxjIHI9IkExNjgiPjx2PjE2ODwvdj48L2M+PC9yb3c+PHJvdyByPSIxNjkiPjxjIHI9IkExNjkiPjx2PjE2OTwvdj48L2M+PC9yb3c+PHJvdyByPSIxNzAiPjxjIHI9IkExNzAiPjx2PjE3MDwvdj48L2M+PC9yb3c+PHJvdyByPSIxNzEiPjxjIHI9IkExNzEiPjx2PjE3MTwvdj48L2M+PC9yb3c+PHJvdyByPSIxNzIiPjxjIHI9IkExNzIiPjx2PjE3Mjwvdj48L2M+PC9yb3c+PHJvdyByPSIxNzMiPjxjIHI9IkExNzMiPjx2PjE3Mzwvdj48L2M+PC9yb3c+PHJvdyByPSIxNzQiPjxjIHI9IkExNzQiPjx2PjE3NDwvdj48L2M+PC9yb3c+PHJvdyByPSIxNzUiPjxjIHI9IkExNzUiPjx2PjE3NTwvdj48L2M+PC9yb3c+PHJvdyByPSIxNzYiPjxjIHI9IkExNzYiPjx2PjE3Njwvdj48L2M+PC9yb3c+PHJvdyByPSIxNzciPjxjIHI9IkExNzciPjx2PjE3Nzwvdj48L2M+PC9yb3c+PHJvdyByPSIxNzgiPjxjIHI9IkExNzgiPjx2PjE3ODwvdj48L2M+PC9yb3c+PHJvdyByPSIxNzkiPjxjIHI9IkExNzkiPjx2PjE3OTwvdj48L2M+PC9yb3c+PHJvdyByPSIxODAiPjxjIHI9IkExODAiPjx2PjE4MDwvdj48L2M+PC9yb3c+PHJvdyByPSIxODEiPjxjIHI9IkExODEiPjx2PjE4MTwvdj48L2M+PC9yb3c+PHJvdyByPSIxODIiPjxjIHI9IkExODIiPjx2PjE4Mjwvdj48L2M+PC9yb3c+PHJvdyByPSIxODMiPjxjIHI9IkExODMiPjx2PjE4Mzwvdj48L2M+PC9yb3c+PHJvdyByPSIxODQiPjxjIHI9IkExODQiPjx2PjE4NDwvdj48L2M+PC9yb3c+PHJvdyByPSIxODUiPjxjIHI9IkExODUiPjx2PjE4NTwvdj48L2M+PC9yb3c+PHJvdyByPSIxODYiPjxjIHI9IkExODYiPjx2PjE4Njwvdj48L2M+PC9yb3c+PHJvdyByPSIxODciPjxjIHI9IkExODciPjx2PjE4Nzwvdj48L2M+PC9yb3c+PHJvdyByPSIxODgiPjxjIHI9IkExODgiPjx2PjE4ODwvdj48L2M+PC9yb3c+PHJvdyByPSIxODkiPjxjIHI9IkExODkiPjx2PjE4OTwvdj48L2M+PC9yb3c+PHJvdyByPSIxOTAiPjxjIHI9IkExOTAiPjx2PjE5MDwvdj48L2M+PC9yb3c+PHJvdyByPSIxOTEiPjxjIHI9IkExOTEiPjx2PjE5MTwvdj48L2M+PC9yb3c+PHJvdyByPSIxOTIiPjxjIHI9IkExOTIiPjx2PjE5Mjwvdj48L2M+PC9yb3c+PHJvdyByPSIxOTMiPjxjIHI9IkExOTMiPjx2PjE5Mzwvdj48L2M+PC9yb3c+PHJvdyByPSIxOTQiPjxjIHI9IkExOTQiPjx2PjE5NDwvdj48L2M+PC9yb3c+PHJvdyByPSIxOTUiPjxjIHI9IkExOTUiPjx2PjE5NTwvdj48L2M+PC9yb3c+PHJvdyByPSIxOTYiPjxjIHI9IkExOTYiPjx2PjE5Njwvdj48L2M+PC9yb3c+PHJvdyByPSIxOTciPjxjIHI9IkExOTciPjx2PjE5Nzwvdj48L2M+PC9yb3c+PHJvdyByPSIxOTgiPjxjIHI9IkExOTgiPjx2PjE5ODwvdj48L2M+PC9yb3c+PHJvdyByPSIxOTkiPjxjIHI9IkExOTkiPjx2PjE5OTwvdj48L2M+PC9yb3c+PHJvdyByPSIyMDAiPjxjIHI9IkEyMDAiPjx2PjIwMDwvdj48L2M+PC9yb3c+PHJvdyByPSIyMDEiPjxjIHI9IkEyMDEiPjx2PjIwMTwvdj48L2M+PC9yb3c+PHJvdyByPSIyMDIiPjxjIHI9IkEyMDIiPjx2PjIwMjwvdj48L2M+PC9yb3c+PHJvdyByPSIyMDMiPjxjIHI9IkEyMDMiPjx2PjIwMzwvdj48L2M+PC9yb3c+PHJvdyByPSIyMDQiPjxjIHI9IkEyMDQiPjx2PjIwNDwvdj48L2M+PC9yb3c+PHJvdyByPSIyMDUiPjxjIHI9IkEyMDUiPjx2PjIwNTwvdj48L2M+PC9yb3c+PHJvdyByPSIyMDYiPjxjIHI9IkEyMDYiPjx2PjIwNjwvdj48L2M+PC9yb3c+PHJvdyByPSIyMDciPjxjIHI9IkEyMDciPjx2PjIwNzwvdj48L2M+PC9yb3c+PHJvdyByPSIyMDgiPjxjIHI9IkEyMDgiPjx2PjIwODwvdj48L2M+PC9yb3c+PHJvdyByPSIyMDkiPjxjIHI9IkEyMDkiPjx2PjIwOTwvdj48L2M+PC9yb3c+PHJvdyByPSIyMTAiPjxjIHI9IkEyMTAiPjx2PjIxMDwvdj48L2M+PC9yb3c+PHJvdyByPSIyMTEiPjxjIHI9IkEyMTEiPjx2PjIxMTwvdj48L2M+PC9yb3c+PHJvdyByPSIyMTIiPjxjIHI9IkEyMTIiPjx2PjIxMjwvdj48L2M+PC9yb3c+PHJvdyByPSIyMTMiPjxjIHI9IkEyMTMiPjx2PjIxMzwvdj48L2M+PC9yb3c+PHJvdyByPSIyMTQiPjxjIHI9IkEyMTQiPjx2PjIxNDwvdj48L2M+PC9yb3c+PHJvdyByPSIyMTUiPjxjIHI9IkEyMTUiPjx2PjIxNTwvdj48L2M+PC9yb3c+PHJvdyByPSIyMTYiPjxjIHI9IkEyMTYiPjx2PjIxNjwvdj48L2M+PC9yb3c+PHJvdyByPSIyMTciPjxjIHI9IkEyMTciPjx2PjIxNzwvdj48L2M+PC9yb3c+PHJvdyByPSIyMTgiPjxjIHI9IkEyMTgiPjx2PjIxODwvdj48L2M+PC9yb3c+PHJvdyByPSIyMTkiPjxjIHI9IkEyMTkiPjx2PjIxOTwvdj48L2M+PC9yb3c+PHJvdyByPSIyMjAiPjxjIHI9IkEyMjAiPjx2PjIyMDwvdj48L2M+PC9yb3c+PHJvdyByPSIyMjEiPjxjIHI9IkEyMjEiPjx2PjIyMTwvdj48L2M+PC9yb3c+PHJvdyByPSIyMjIiPjxjIHI9IkEyMjIiPjx2PjIyMjwvdj48L2M+PC9yb3c+PHJvdyByPSIyMjMiPjxjIHI9IkEyMjMiPjx2PjIyMzwvdj48L2M+PC9yb3c+PHJvdyByPSIyMjQiPjxjIHI9IkEyMjQiPjx2PjIyNDwvdj48L2M+PC9yb3c+PHJvdyByPSIyMjUiPjxjIHI9IkEyMjUiPjx2PjIyNTwvdj48L2M+PC9yb3c+PHJvdyByPSIyMjYiPjxjIHI9IkEyMjYiPjx2PjIyNjwvdj48L2M+PC9yb3c+PHJvdyByPSIyMjciPjxjIHI9IkEyMjciPjx2PjIyNzwvdj48L2M+PC9yb3c+PHJvdyByPSIyMjgiPjxjIHI9IkEyMjgiPjx2PjIyODwvdj48L2M+PC9yb3c+PHJvdyByPSIyMjkiPjxjIHI9IkEyMjkiPjx2PjIyOTwvdj48L2M+PC9yb3c+PHJvdyByPSIyMzAiPjxjIHI9IkEyMzAiPjx2PjIzMDwvdj48L2M+PC9yb3c+PHJvdyByPSIyMzEiPjxjIHI9IkEyMzEiPjx2PjIzMTwvdj48L2M+PC9yb3c+PHJvdyByPSIyMzIiPjxjIHI9IkEyMzIiPjx2PjIzMjwvdj48L2M+PC9yb3c+PHJvdyByPSIyMzMiPjxjIHI9IkEyMzMiPjx2PjIzMzwvdj48L2M+PC9yb3c+PHJvdyByPSIyMzQiPjxjIHI9IkEyMzQiPjx2PjIzNDwvdj48L2M+PC9yb3c+PHJvdyByPSIyMzUiPjxjIHI9IkEyMzUiPjx2PjIzNTwvdj48L2M+PC9yb3c+PHJvdyByPSIyMzYiPjxjIHI9IkEyMzYiPjx2PjIzNjwvdj48L2M+PC9yb3c+PHJvdyByPSIyMzciPjxjIHI9IkEyMzciPjx2PjIzNzwvdj48L2M+PC9yb3c+PHJvdyByPSIyMzgiPjxjIHI9IkEyMzgiPjx2PjIzODwvdj48L2M+PC9yb3c+PHJvdyByPSIyMzkiPjxjIHI9IkEyMzkiPjx2PjIzOTwvdj48L2M+PC9yb3c+PHJvdyByPSIyNDAiPjxjIHI9IkEyNDAiPjx2PjI0MDwvdj48L2M+PC9yb3c+PHJvdyByPSIyNDEiPjxjIHI9IkEyNDEiPjx2PjI0MTwvdj48L2M+PC9yb3c+PHJvdyByPSIyNDIiPjxjIHI9IkEyNDIiPjx2PjI0Mjwvdj48L2M+PC9yb3c+PHJvdyByPSIyNDMiPjxjIHI9IkEyNDMiPjx2PjI0Mzwvdj48L2M+PC9yb3c+PHJvdyByPSIyNDQiPjxjIHI9IkEyNDQiPjx2PjI0NDwvdj48L2M+PC9yb3c+PHJvdyByPSIyNDUiPjxjIHI9IkEyNDUiPjx2PjI0NTwvdj48L2M+PC9yb3c+PHJvdyByPSIyNDYiPjxjIHI9IkEyNDYiPjx2PjI0Njwvdj48L2M+PC9yb3c+PHJvdyByPSIyNDciPjxjIHI9IkEyNDciPjx2PjI0Nzwvdj48L2M+PC9yb3c+PHJvdyByPSIyNDgiPjxjIHI9IkEyNDgiPjx2PjI0ODwvdj48L2M+PC9yb3c+PHJvdyByPSIyNDkiPjxjIHI9IkEyNDkiPjx2PjI0OTwvdj48L2M+PC9yb3c+PHJvdyByPSIyNTAiPjxjIHI9IkEyNTAiPjx2PjI1MDwvdj48L2M+PC9yb3c+PHJvdyByPSIyNTEiPjxjIHI9IkEyNTEiPjx2PjI1MTwvdj48L2M+PC9yb3c+PHJvdyByPSIyNTIiPjxjIHI9IkEyNTIiPjx2PjI1Mjwvdj48L2M+PC9yb3c+PHJvdyByPSIyNTMiPjxjIHI9IkEyNTMiPjx2PjI1Mzwvdj48L2M+PC9yb3c+PHJvdyByPSIyNTQiPjxjIHI9IkEyNTQiPjx2PjI1NDwvdj48L2M+PC9yb3c+PHJvdyByPSIyNTUiPjxjIHI9IkEyNTUiPjx2PjI1NTwvdj48L2M+PC9yb3c+PC9zaGVldERhdGE+PHBhZ2VNYXJnaW5zIGxlZnQ9IjAuNyIgcmlnaHQ9IjAuNyIgdG9wPSIwLjc1IiBib3R0b209IjAuNzUiIGhlYWRlcj0iMC4zIiBmb290ZXI9IjAuMyIvPjxpZ25vcmVkRXJyb3JzPjxpZ25vcmVkRXJyb3IgbnVtYmVyU3RvcmVkQXNUZXh0PSIxIiBzcXJlZj0iQTE6QTI1NSIvPjwvaWdub3JlZEVycm9ycz48L3dvcmtzaGVldD5QSwMEFAAAAAAAAAAAAFvm9kjwAwAA8AMAABgAAAB4bC93b3Jrc2hlZXRzL3NoZWV0My54bWw8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJVVEYtOCIgc3RhbmRhbG9uZT0ieWVzIj8+DQo8d29ya3NoZWV0IHhtbG5zPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvc3ByZWFkc2hlZXRtbC8yMDA2L21haW4iIHhtbG5zOnI9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMiPjxkaW1lbnNpb24gcmVmPSJBMTpBOSIvPjxzaGVldFZpZXdzPjxzaGVldFZpZXcgd29ya2Jvb2tWaWV3SWQ9IjAiIHJpZ2h0VG9MZWZ0PSIwIi8+PC9zaGVldFZpZXdzPjxzaGVldERhdGE+PHJvdyByPSIxIj48YyByPSJBMSIgdD0ic3RyIj48dj5QYXJlbnRhbCBMZWF2ZTwvdj48L2M+PC9yb3c+PHJvdyByPSIyIj48YyByPSJBMiIgdD0ic3RyIj48dj5TaWNrIERheTwvdj48L2M+PC9yb3c+PHJvdyByPSIzIj48YyByPSJBMyIgdD0ic3RyIj48dj5WYWNhdGlvbjwvdj48L2M+PC9yb3c+PHJvdyByPSI0Ij48YyByPSJBNCIgdD0ic3RyIj48dj5PZmY8L3Y+PC9jPjwvcm93Pjxyb3cgcj0iNSI+PGMgcj0iQTUiIHQ9InN0ciI+PHY+T1QgQ2FuY2VsbGVkIGJ5IFN1cHY8L3Y+PC9jPjwvcm93Pjxyb3cgcj0iNiI+PGMgcj0iQTYiIHQ9InN0ciI+PHY+VW5mdWxmaWxsZWQ8L3Y+PC9jPjwvcm93Pjxyb3cgcj0iNyI+PGMgcj0iQTciIHQ9InN0ciI+PHY+TkNOUzwvdj48L2M+PC9yb3c+PHJvdyByPSI4Ij48YyByPSJBOCIgdD0ic3RyIj48dj5WQTwvdj48L2M+PC9yb3c+PHJvdyByPSI5Ij48YyByPSJBOSIgdD0ic3RyIj48dj5DYWxsZWQgT2ZmPC92PjwvYz48L3Jvdz48L3NoZWV0RGF0YT48cGFnZU1hcmdpbnMgbGVmdD0iMC43IiByaWdodD0iMC43IiB0b3A9IjAuNzUiIGJvdHRvbT0iMC43NSIgaGVhZGVyPSIwLjMiIGZvb3Rlcj0iMC4zIi8+PGlnbm9yZWRFcnJvcnM+PGlnbm9yZWRFcnJvciBudW1iZXJTdG9yZWRBc1RleHQ9IjEiIHNxcmVmPSJBMTpBOSIvPjwvaWdub3JlZEVycm9ycz48L3dvcmtzaGVldD5QSwMEFAAAAAAAAAAAALgZvix8BwAAfAcAABgAAAB4bC93b3Jrc2hlZXRzL3NoZWV0NC54bWw8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJVVEYtOCIgc3RhbmRhbG9uZT0ieWVzIj8+DQo8d29ya3NoZWV0IHhtbG5zPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvc3ByZWFkc2hlZXRtbC8yMDA2L21haW4iIHhtbG5zOnI9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMiPjxkaW1lbnNpb24gcmVmPSJBMTpBMiIvPjxzaGVldFZpZXdzPjxzaGVldFZpZXcgd29ya2Jvb2tWaWV3SWQ9IjAiIHJpZ2h0VG9MZWZ0PSIwIi8+PC9zaGVldFZpZXdzPjxjb2xzPjxjb2wgbWluPSIxIiBtYXg9IjEiIGN1c3RvbVdpZHRoPSIxIiB3aWR0aD0iMjAwIi8+PC9jb2xzPjxzaGVldERhdGE+PHJvdyByPSIxIj48YyByPSJBMSIgdD0ic3RyIj48dj5JbnN0cnVjdGlvbnM8L3Y+PC9jPjwvcm93Pjxyb3cgcj0iMiIgaHQ9IjE2NSIgY3VzdG9tSGVpZ2h0PSIxIiB4bWw6c3BhY2U9InByZXNlcnZlIj48YyByPSJBMiIgdD0ic3RyIiB4bWw6c3BhY2U9InByZXNlcnZlIj48diB4bWw6c3BhY2U9InByZXNlcnZlIj5feDAwMGRfCiAgICAgIC0JVXNlIHRoZSBzYW1wbGUgY29sdW1ucyBhbmQgZGF0YSBwcm92aWRlZCBpbiB0aGVzZSB3b3Jrc2hlZXRzIGFzIGEgZ3VpZGUgZm9yIGVudGVyaW5nIHlvdXIgc2NoZWR1bGUgaW5mbyBpbnRvIGFuIGltcG9ydCBmaWxlLl94MDAwZF8KICAgICAgLQlZb3UgY2FuIGVpdGhlciBjcmVhdGUgYSBuZXcgZmlsZSBvciBhZGQgeW91ciBzY2hlZHVsZSBpbmZvIHRvIHRoaXMgb25lIGFuZCBkZWxldGUgdGhlIHNhbXBsZSBkYXRhIGJlZm9yZSB5b3UgdXBsb2FkIGl0Ll94MDAwZF8KICAgICAgLQlFbnRlciBzaGlmdHMgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgdGltZSBmb3JtYXRzOiAxODowMCwgb3IgNnBtLl94MDAwZF8KICAgICAgLQlBbGwgY29sdW1ucyBtYXJrZWQgaW4gYm9sZCBhcmUgcmVxdWlyZWQgZmllbGRzIGFuZCBjYW4gbm90IGJlIGxlZnQgZW1wdHkuX3gwMDBkXwogICAgICAtCVRoZSBpbXBvcnQgcHJvY2VzcyB3aWxsIHNraXAgYWRkaW5nIGEgc2NoZWR1bGUgZW50aXR5IChzaGlmdCwgdGltZSBvZmYsIG9wZW4gc2hpZnQpIG9yIG1lbWJlciBpZiB0aGF0IGV4YWN0IHNhbWUgZW50aXR5IG9yIG1lbWJlciBhbHJlYWR5IGV4aXN0cy5feDAwMGRfCiAgICAgIC0JVXNlIHRoZSBEYXkgTm90ZXMgdGFiIHRvIGFkZCBub3RlcyBmb3IgYSBzcGVjaWZpYyBkYXkuIFNoaWZ0IG5vdGVzIGFuZCBEYXkgbm90ZXMgY2Fu4oCZdCBleGNlZWQgNTAwIGNoYXJhY3RlcnMuX3gwMDBkXwogICAgICAtCVRvIGF2b2lkIGltcG9ydCBlcnJvcnMsIHVzZSB0aGUgZXhpc3RpbmcgY29sdW1ucyBhbmQgdGFicy4gRG9uJmFwb3M7dCBhZGQsIHJlbW92ZSwgbW92ZSwgb3IgcmVuYW1lIHRoZW0uX3gwMDBkXwogICAgICAtCVRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0aGF0IGNhbiBiZSBpbXBvcnRlZCBmb3IgZWFjaCBzY2hlZHVsZSBlbnRpdHkgaW4gb25lIGZpbGUgaXMgMTAwMDAuIFlvdSBjYW4gY3JlYXRlIGFub3RoZXIgZmlsZSB0byBpbXBvcnQgbW9yZSBpdGVtcy5feDAwMGRfCiAgICAgIC0JMjQgaG91ciBzaGlmdHMgY2FuIG5vdyBiZSBhc3NpZ25lZC4gVG8gYXZvaWQgaW1wb3J0IGVycm9ycywgZG8gbm90IHNjaGVkdWxlIHNoaWZ0cyB0aGF0IGV4Y2VlZCAyNCBob3Vycy5feDAwMGRfCiAgICA8L3Y+PC9jPjwvcm93Pjwvc2hlZXREYXRhPjxwYWdlTWFyZ2lucyBsZWZ0PSIwLjciIHJpZ2h0PSIwLjciIHRvcD0iMC43NSIgYm90dG9tPSIwLjc1IiBoZWFkZXI9IjAuMyIgZm9vdGVyPSIwLjMiLz48aWdub3JlZEVycm9ycz48aWdub3JlZEVycm9yIG51bWJlclN0b3JlZEFzVGV4dD0iMSIgc3FyZWY9IkExOkEyIi8+PC9pZ25vcmVkRXJyb3JzPjwvd29ya3NoZWV0PlBLAwQUAAAAAAAAAAAAB8IQHpUGAACVBgAAGAAAAHhsL3dvcmtzaGVldHMvc2hlZXQ1LnhtbDw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04IiBzdGFuZGFsb25lPSJ5ZXMiPz4NCjx3b3Jrc2hlZXQgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9zcHJlYWRzaGVldG1sLzIwMDYvbWFpbiIgeG1sbnM6cj0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcyI+PGRpbWVuc2lvbiByZWY9IkExOkwxIi8+PHNoZWV0Vmlld3M+PHNoZWV0VmlldyB3b3JrYm9va1ZpZXdJZD0iMCIgcmlnaHRUb0xlZnQ9IjAiLz48L3NoZWV0Vmlld3M+PGNvbHM+PGNvbCBtaW49IjEiIG1heD0iMSIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSI5LjE0MDYyNSIvPjxjb2wgbWluPSIyIiBtYXg9IjIiIGN1c3RvbVdpZHRoPSIxIiB3aWR0aD0iMTEuNzEwOTM3NSIvPjxjb2wgbWluPSIzIiBtYXg9IjMiIGN1c3RvbVdpZHRoPSIxIiB3aWR0aD0iOS4xNDA2MjUiLz48Y29sIG1pbj0iNCIgbWF4PSI0IiBjdXN0b21XaWR0aD0iMSIgd2lkdGg9IjEwLjU3MDMxMjUiLz48Y29sIG1pbj0iNSIgbWF4PSI1IiBjdXN0b21XaWR0aD0iMSIgd2lkdGg9IjEwLjcxMDkzNzUiLz48Y29sIG1pbj0iNiIgbWF4PSI2IiBjdXN0b21XaWR0aD0iMSIgd2lkdGg9IjkuNTcwMzEyNSIvPjxjb2wgbWluPSI3IiBtYXg9IjciIGN1c3RvbVdpZHRoPSIxIiB3aWR0aD0iOS43MTA5Mzc1Ii8+PGNvbCBtaW49IjgiIG1heD0iOCIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSIxMi41NzAzMTI1Ii8+PGNvbCBtaW49IjkiIG1heD0iOSIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSIxMy4yODUxNTYyNSIvPjxjb2wgbWluPSIxMCIgbWF4PSIxMCIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSIyMi4xNDA2MjUiLz48Y29sIG1pbj0iMTEiIG1heD0iMTEiIGN1c3RvbVdpZHRoPSIxIiB3aWR0aD0iOS4xNDA2MjUiLz48Y29sIG1pbj0iMTIiIG1heD0iMTIiIGN1c3RvbVdpZHRoPSIxIiB3aWR0aD0iOS4xNDA2MjUiLz48L2NvbHM+PHNoZWV0RGF0YT48cm93IHI9IjEiPjxjIHI9IkExIiB0PSJzdHIiPjx2Pk1lbWJlcjwvdj48L2M+PGMgcj0iQjEiIHQ9InN0ciI+PHY+V29yayBFbWFpbDwvdj48L2M+PGMgcj0iQzEiIHQ9InN0ciI+PHY+R3JvdXA8L3Y+PC9jPjxjIHI9IkQxIiB0PSJzdHIiPjx2PlN0YXJ0IERhdGU8L3Y+PC9jPjxjIHI9IkUxIiB0PSJzdHIiPjx2PlN0YXJ0IFRpbWU8L3Y+PC9jPjxjIHI9IkYxIiB0PSJzdHIiPjx2PkVuZCBEYXRlPC92PjwvYz48YyByPSJHMSIgdD0ic3RyIj48dj5FbmQgVGltZTwvdj48L2M+PGMgcj0iSDEiIHQ9InN0ciI+PHY+VGhlbWUgQ29sb3I8L3Y+PC9jPjxjIHI9IkkxIiB0PSJzdHIiPjx2PkN1c3RvbSBMYWJlbDwvdj48L2M+PGMgcj0iSjEiIHQ9InN0ciI+PHY+VW5wYWlkIEJyZWFrIChtaW51dGVzKTwvdj48L2M+PGMgcj0iSzEiIHQ9InN0ciI+PHY+Tm90ZXM8L3Y+PC9jPjxjIHI9IkwxIiB0PSJzdHIiPjx2PlNoYXJlZDwvdj48L2M+PC9yb3c+PC9zaGVldERhdGE+PHBhZ2VNYXJnaW5zIGxlZnQ9IjAuNyIgcmlnaHQ9IjAuNyIgdG9wPSIwLjc1IiBib3R0b209IjAuNzUiIGhlYWRlcj0iMC4zIiBmb290ZXI9IjAuMyIvPjxpZ25vcmVkRXJyb3JzPjxpZ25vcmVkRXJyb3IgbnVtYmVyU3RvcmVkQXNUZXh0PSIxIiBzcXJlZj0iQTE6TDEiLz48L2lnbm9yZWRFcnJvcnM+PC93b3Jrc2hlZXQ+UEsDBBQAAAAAAAAAAABBDyWazgUAAM4FAAAYAAAAeGwvd29ya3NoZWV0cy9zaGVldDYueG1sPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/Pg0KPHdvcmtzaGVldCB4bWxucz0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3NwcmVhZHNoZWV0bWwvMjAwNi9tYWluIiB4bWxuczpyPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzIj48ZGltZW5zaW9uIHJlZj0iQTE6SjEiLz48c2hlZXRWaWV3cz48c2hlZXRWaWV3IHdvcmtib29rVmlld0lkPSIwIiByaWdodFRvTGVmdD0iMCIvPjwvc2hlZXRWaWV3cz48Y29scz48Y29sIG1pbj0iMSIgbWF4PSIxIiBjdXN0b21XaWR0aD0iMSIgd2lkdGg9IjkuMTQwNjI1Ii8+PGNvbCBtaW49IjIiIG1heD0iMiIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSIxMS43MTA5Mzc1Ii8+PGNvbCBtaW49IjMiIG1heD0iMyIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSIxMC41NzAzMTI1Ii8+PGNvbCBtaW49IjQiIG1heD0iNCIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSIxMC43MTA5Mzc1Ii8+PGNvbCBtaW49IjUiIG1heD0iNSIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSI5LjU3MDMxMjUiLz48Y29sIG1pbj0iNiIgbWF4PSI2IiBjdXN0b21XaWR0aD0iMSIgd2lkdGg9IjkuNzEwOTM3NSIvPjxjb2wgbWluPSI3IiBtYXg9IjciIGN1c3RvbVdpZHRoPSIxIiB3aWR0aD0iMTYuMTQwNjI1Ii8+PGNvbCBtaW49IjgiIG1heD0iOCIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSIxMi41NzAzMTI1Ii8+PGNvbCBtaW49IjkiIG1heD0iOSIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSI5LjE0MDYyNSIvPjxjb2wgbWluPSIxMCIgbWF4PSIxMCIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSI5LjE0MDYyNSIvPjwvY29scz48c2hlZXREYXRhPjxyb3cgcj0iMSI+PGMgcj0iQTEiIHQ9InN0ciI+PHY+TWVtYmVyPC92PjwvYz48YyByPSJCMSIgdD0ic3RyIj48dj5Xb3JrIEVtYWlsPC92PjwvYz48YyByPSJDMSIgdD0ic3RyIj48dj5TdGFydCBEYXRlPC92PjwvYz48YyByPSJEMSIgdD0ic3RyIj48dj5TdGFydCBUaW1lPC92PjwvYz48YyByPSJFMSIgdD0ic3RyIj48dj5FbmQgRGF0ZTwvdj48L2M+PGMgcj0iRjEiIHQ9InN0ciI+PHY+RW5kIFRpbWU8L3Y+PC9jPjxjIHI9IkcxIiB0PSJzdHIiPjx2PlRpbWUgT2ZmIFJlYXNvbjwvdj48L2M+PGMgcj0iSDEiIHQ9InN0ciI+PHY+VGhlbWUgQ29sb3I8L3Y+PC9jPjxjIHI9IkkxIiB0PSJzdHIiPjx2Pk5vdGVzPC92PjwvYz48YyByPSJKMSIgdD0ic3RyIj48dj5TaGFyZWQ8L3Y+PC9jPjwvcm93Pjwvc2hlZXREYXRhPjxwYWdlTWFyZ2lucyBsZWZ0PSIwLjciIHJpZ2h0PSIwLjciIHRvcD0iMC43NSIgYm90dG9tPSIwLjc1IiBoZWFkZXI9IjAuMyIgZm9vdGVyPSIwLjMiLz48aWdub3JlZEVycm9ycz48aWdub3JlZEVycm9yIG51bWJlclN0b3JlZEFzVGV4dD0iMSIgc3FyZWY9IkExOkoxIi8+PC9pZ25vcmVkRXJyb3JzPjwvd29ya3NoZWV0PlBLAwQUAAAAAAAAAAAARoHsJTwGAAA8BgAAGAAAAHhsL3dvcmtzaGVldHMvc2hlZXQ3LnhtbDw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04IiBzdGFuZGFsb25lPSJ5ZXMiPz4NCjx3b3Jrc2hlZXQgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9zcHJlYWRzaGVldG1sLzIwMDYvbWFpbiIgeG1sbnM6cj0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcyI+PGRpbWVuc2lvbiByZWY9IkExOksxIi8+PHNoZWV0Vmlld3M+PHNoZWV0VmlldyB3b3JrYm9va1ZpZXdJZD0iMCIgcmlnaHRUb0xlZnQ9IjAiLz48L3NoZWV0Vmlld3M+PGNvbHM+PGNvbCBtaW49IjEiIG1heD0iMSIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSI5LjE0MDYyNSIvPjxjb2wgbWluPSIyIiBtYXg9IjIiIGN1c3RvbVdpZHRoPSIxIiB3aWR0aD0iMTAuNTcwMzEyNSIvPjxjb2wgbWluPSIzIiBtYXg9IjMiIGN1c3RvbVdpZHRoPSIxIiB3aWR0aD0iMTAuNzEwOTM3NSIvPjxjb2wgbWluPSI0IiBtYXg9IjQiIGN1c3RvbVdpZHRoPSIxIiB3aWR0aD0iOS41NzAzMTI1Ii8+PGNvbCBtaW49IjUiIG1heD0iNSIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSI5LjcxMDkzNzUiLz48Y29sIG1pbj0iNiIgbWF4PSI2IiBjdXN0b21XaWR0aD0iMSIgd2lkdGg9IjExLjE0MDYyNSIvPjxjb2wgbWluPSI3IiBtYXg9IjciIGN1c3RvbVdpZHRoPSIxIiB3aWR0aD0iMTIuNTcwMzEyNSIvPjxjb2wgbWluPSI4IiBtYXg9IjgiIGN1c3RvbVdpZHRoPSIxIiB3aWR0aD0iMTMuMjg1MTU2MjUiLz48Y29sIG1pbj0iOSIgbWF4PSI5IiBjdXN0b21XaWR0aD0iMSIgd2lkdGg9IjIyLjI4NTE1NjI1Ii8+PGNvbCBtaW49IjEwIiBtYXg9IjEwIiBjdXN0b21XaWR0aD0iMSIgd2lkdGg9IjE3LjU3MDMxMjUiLz48Y29sIG1pbj0iMTEiIG1heD0iMTEiIGN1c3RvbVdpZHRoPSIxIiB3aWR0aD0iOS4xNDA2MjUiLz48L2NvbHM+PHNoZWV0RGF0YT48cm93IHI9IjEiPjxjIHI9IkExIiB0PSJzdHIiPjx2Pkdyb3VwPC92PjwvYz48YyByPSJCMSIgdD0ic3RyIj48dj5TdGFydCBEYXRlPC92PjwvYz48YyByPSJDMSIgdD0ic3RyIj48dj5TdGFydCBUaW1lPC92PjwvYz48YyByPSJEMSIgdD0ic3RyIj48dj5FbmQgRGF0ZTwvdj48L2M+PGMgcj0iRTEiIHQ9InN0ciI+PHY+RW5kIFRpbWU8L3Y+PC9jPjxjIHI9IkYxIiB0PSJzdHIiPjx2Pk9wZW4gU2xvdHM8L3Y+PC9jPjxjIHI9IkcxIiB0PSJzdHIiPjx2PlRoZW1lIENvbG9yPC92PjwvYz48YyByPSJIMSIgdD0ic3RyIj48dj5DdXN0b20gTGFiZWw8L3Y+PC9jPjxjIHI9IkkxIiB0PSJzdHIiPjx2PlVucGFpZCBCcmVhayAobWludXRlcyk8L3Y+PC9jPjxjIHI9IkoxIiB0PSJzdHIiPjx2Pk5vdGVzPC92PjwvYz48YyByPSJLMSIgdD0ic3RyIj48dj5TaGFyZWQ8L3Y+PC9jPjwvcm93Pjwvc2hlZXREYXRhPjxwYWdlTWFyZ2lucyBsZWZ0PSIwLjciIHJpZ2h0PSIwLjciIHRvcD0iMC43NSIgYm90dG9tPSIwLjc1IiBoZWFkZXI9IjAuMyIgZm9vdGVyPSIwLjMiLz48aWdub3JlZEVycm9ycz48aWdub3JlZEVycm9yIG51bWJlclN0b3JlZEFzVGV4dD0iMSIgc3FyZWY9IkExOksxIi8+PC9pZ25vcmVkRXJyb3JzPjwvd29ya3NoZWV0PlBLAwQUAAAAAAAAAAAAU0YQH9UCAADVAgAAGAAAAHhsL3dvcmtzaGVldHMvc2hlZXQ4LnhtbDw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04IiBzdGFuZGFsb25lPSJ5ZXMiPz4NCjx3b3Jrc2hlZXQgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9zcHJlYWRzaGVldG1sLzIwMDYvbWFpbiIgeG1sbnM6cj0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcyI+PGRpbWVuc2lvbiByZWY9IkExOkIxIi8+PHNoZWV0Vmlld3M+PHNoZWV0VmlldyB3b3JrYm9va1ZpZXdJZD0iMCIgcmlnaHRUb0xlZnQ9IjAiLz48L3NoZWV0Vmlld3M+PGNvbHM+PGNvbCBtaW49IjEiIG1heD0iMSIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSIxMC43MTA5Mzc1Ii8+PGNvbCBtaW49IjIiIG1heD0iMiIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSIyMy4yODUxNTYyNSIvPjwvY29scz48c2hlZXREYXRhPjxyb3cgcj0iMSI+PGMgcj0iQTEiIHQ9InN0ciI+PHY+RGF0ZTwvdj48L2M+PGMgcj0iQjEiIHQ9InN0ciI+PHY+Tm90ZTwvdj48L2M+PC9yb3c+PC9zaGVldERhdGE+PHBhZ2VNYXJnaW5zIGxlZnQ9IjAuNyIgcmlnaHQ9IjAuNyIgdG9wPSIwLjc1IiBib3R0b209IjAuNzUiIGhlYWRlcj0iMC4zIiBmb290ZXI9IjAuMyIvPjxpZ25vcmVkRXJyb3JzPjxpZ25vcmVkRXJyb3IgbnVtYmVyU3RvcmVkQXNUZXh0PSIxIiBzcXJlZj0iQTE6QjEiLz48L2lnbm9yZWRFcnJvcnM+PC93b3Jrc2hlZXQ+UEsDBBQAAAAAAAAAAABFA/xCOQMAADkDAAAYAAAAeGwvd29ya3NoZWV0cy9zaGVldDkueG1sPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/Pg0KPHdvcmtzaGVldCB4bWxucz0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3NwcmVhZHNoZWV0bWwvMjAwNi9tYWluIiB4bWxuczpyPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzIj48ZGltZW5zaW9uIHJlZj0iQTE6QzEiLz48c2hlZXRWaWV3cz48c2hlZXRWaWV3IHdvcmtib29rVmlld0lkPSIwIiByaWdodFRvTGVmdD0iMCIvPjwvc2hlZXRWaWV3cz48Y29scz48Y29sIG1pbj0iMSIgbWF4PSIxIiBjdXN0b21XaWR0aD0iMSIgd2lkdGg9IjM3Ljg1NTQ2ODc1Ii8+PGNvbCBtaW49IjIiIG1heD0iMiIgY3VzdG9tV2lkdGg9IjEiIHdpZHRoPSI1My4yODUxNTYyNSIvPjxjb2wgbWluPSIzIiBtYXg9IjMiIGN1c3RvbVdpZHRoPSIxIiB3aWR0aD0iMzAuODU1NDY4NzUiLz48L2NvbHM+PHNoZWV0RGF0YT48cm93IHI9IjEiPjxjIHI9IkExIiB0PSJzdHIiPjx2Pk5hbWU8L3Y+PC9jPjxjIHI9IkIxIiB0PSJzdHIiPjx2PkVtYWlsPC92PjwvYz48YyByPSJDMSIgdD0ic3RyIj48dj5BbGlhcyBFbWFpbDwvdj48L2M+PC9yb3c+PC9zaGVldERhdGE+PHBhZ2VNYXJnaW5zIGxlZnQ9IjAuNyIgcmlnaHQ9IjAuNyIgdG9wPSIwLjc1IiBib3R0b209IjAuNzUiIGhlYWRlcj0iMC4zIiBmb290ZXI9IjAuMyIvPjxpZ25vcmVkRXJyb3JzPjxpZ25vcmVkRXJyb3IgbnVtYmVyU3RvcmVkQXNUZXh0PSIxIiBzcXJlZj0iQTE6QzEiLz48L2lnbm9yZWRFcnJvcnM+PC93b3Jrc2hlZXQ+UEsDBBQAAAAAAAAAAABggACBiAMAAIgDAAAPAAAAeGwvbWV0YWRhdGEueG1sPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/Pg0KPG1ldGFkYXRhIHhtbG5zPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvc3ByZWFkc2hlZXRtbC8yMDA2L21haW4iIHhtbG5zOnhscmQ9Imh0dHA6Ly9zY2hlbWFzLm1pY3Jvc29mdC5jb20vb2ZmaWNlL3NwcmVhZHNoZWV0bWwvMjAxNy9yaWNoZGF0YSIgeG1sbnM6eGRhPSJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9zcHJlYWRzaGVldG1sLzIwMTcvZHluYW1pY2FycmF5Ij4KICA8bWV0YWRhdGFUeXBlcyBjb3VudD0iMSI+CiAgICA8bWV0YWRhdGFUeXBlIG5hbWU9IlhMREFQUiIgbWluU3VwcG9ydGVkVmVyc2lvbj0iMTIwMDAwIiBjb3B5PSIxIiBwYXN0ZUFsbD0iMSIgcGFzdGVWYWx1ZXM9IjEiIG1lcmdlPSIxIiBzcGxpdEZpcnN0PSIxIiByb3dDb2xTaGlmdD0iMSIgY2xlYXJGb3JtYXRzPSIxIiBjbGVhckNvbW1lbnRzPSIxIiBhc3NpZ249IjEiIGNvZXJjZT0iMSIgY2VsbE1ldGE9IjEiLz4KICA8L21ldGFkYXRhVHlwZXM+CiAgPGZ1dHVyZU1ldGFkYXRhIG5hbWU9IlhMREFQUiIgY291bnQ9IjEiPgogICAgPGJrPgogICAgICA8ZXh0THN0PgogICAgICAgIDxleHQgdXJpPSJ7YmRiYjhjZGMtZmExZS00OTZlLWE4NTctM2MzZjMwYzAyOWMzfSI+CiAgICAgICAgICA8eGRhOmR5bmFtaWNBcnJheVByb3BlcnRpZXMgZkR5bmFtaWM9IjEiIGZDb2xsYXBzZWQ9IjAiLz4KICAgICAgICA8L2V4dD4KICAgICAgPC9leHRMc3Q+CiAgICA8L2JrPgogIDwvZnV0dXJlTWV0YWRhdGE+CiAgPGNlbGxNZXRhZGF0YSBjb3VudD0iMSI+CiAgICA8Yms+CiAgICAgIDxyYyB0PSIxIiB2PSIwIi8+CiAgICA8L2JrPgogIDwvY2VsbE1ldGFkYXRhPgo8L21ldGFkYXRhPlBLAwQUAAAAAAAAAAAA0x5+DWUDAABlAwAADwAAAHhsL3dvcmtib29rLnhtbDw/eG1sIHZlcnNpb249IjEuMCIgZW5jb2Rpbmc9IlVURi04IiBzdGFuZGFsb25lPSJ5ZXMiPz4NCjx3b3JrYm9vayB4bWxucz0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3NwcmVhZHNoZWV0bWwvMjAwNi9tYWluIiB4bWxuczpyPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzIj48d29ya2Jvb2tQciBjb2RlTmFtZT0iVGhpc1dvcmtib29rIiBkZWZhdWx0VGhlbWVWZXJzaW9uPSIxMjQyMjYiLz48Ym9va1ZpZXdzPjx3b3JrYm9va1ZpZXcgZmlyc3RTaGVldD0iMyIgYWN0aXZlVGFiPSIzIi8+PC9ib29rVmlld3M+PHNoZWV0cz48c2hlZXQgbmFtZT0iRW1haWwiIHNoZWV0SWQ9IjEiIHI6aWQ9InJJZDEiIHN0YXRlPSJ2ZXJ5SGlkZGVuIi8+PHNoZWV0IG5hbWU9Ik9wZW5TbG90cyIgc2hlZXRJZD0iMiIgcjppZD0icklkMiIgc3RhdGU9InZlcnlIaWRkZW4iLz48c2hlZXQgbmFtZT0iVGltZU9mZlJlYXNvbiIgc2hlZXRJZD0iMyIgcjppZD0icklkMyIgc3RhdGU9InZlcnlIaWRkZW4iLz48c2hlZXQgbmFtZT0iSW5zdHJ1Y3Rpb25zIiBzaGVldElkPSI0IiByOmlkPSJySWQ0Ii8+PHNoZWV0IG5hbWU9IlNoaWZ0cyIgc2hlZXRJZD0iNSIgcjppZD0icklkNSIvPjxzaGVldCBuYW1lPSJUaW1lIE9mZiIgc2hlZXRJZD0iNiIgcjppZD0icklkNiIvPjxzaGVldCBuYW1lPSJPcGVuIFNoaWZ0cyIgc2hlZXRJZD0iNyIgcjppZD0icklkNyIvPjxzaGVldCBuYW1lPSJEYXkgTm90ZXMiIHNoZWV0SWQ9IjgiIHI6aWQ9InJJZDgiLz48c2hlZXQgbmFtZT0iTWVtYmVycyIgc2hlZXRJZD0iOSIgcjppZD0icklkOSIvPjwvc2hlZXRzPjwvd29ya2Jvb2s+UEsDBBQAAAAAAAAAAABKahH5TAIAAEwCAAALAAAAX3JlbHMvLnJlbHM8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJVVEYtOCIgc3RhbmRhbG9uZT0ieWVzIj8+DQo8UmVsYXRpb25zaGlwcyB4bWxucz0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3BhY2thZ2UvMjAwNi9yZWxhdGlvbnNoaXBzIj48UmVsYXRpb25zaGlwIElkPSJySWQyIiBUeXBlPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvcGFja2FnZS8yMDA2L3JlbGF0aW9uc2hpcHMvbWV0YWRhdGEvY29yZS1wcm9wZXJ0aWVzIiBUYXJnZXQ9ImRvY1Byb3BzL2NvcmUueG1sIi8+PFJlbGF0aW9uc2hpcCBJZD0icklkMyIgVHlwZT0iaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9leHRlbmRlZC1wcm9wZXJ0aWVzIiBUYXJnZXQ9ImRvY1Byb3BzL2FwcC54bWwiLz48UmVsYXRpb25zaGlwIElkPSJySWQxIiBUeXBlPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL29mZmljZURvY3VtZW50IiBUYXJnZXQ9InhsL3dvcmtib29rLnhtbCIvPjwvUmVsYXRpb25zaGlwcz5QSwMEFAAAAAAAAAAAAIkuYgboAwAA6AMAABAAAABkb2NQcm9wcy9hcHAueG1sPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/Pg0KPFByb3BlcnRpZXMgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L2V4dGVuZGVkLXByb3BlcnRpZXMiIHhtbG5zOnZ0PSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9kb2NQcm9wc1ZUeXBlcyI+PEFwcGxpY2F0aW9uPlNoZWV0SlM8L0FwcGxpY2F0aW9uPjxBcHBWZXJzaW9uPjEyLjAwMDA8L0FwcFZlcnNpb24+PERvY1NlY3VyaXR5PjA8L0RvY1NlY3VyaXR5PjxIeXBlcmxpbmtzQ2hhbmdlZD5mYWxzZTwvSHlwZXJsaW5rc0NoYW5nZWQ+PFNoYXJlZERvYz5mYWxzZTwvU2hhcmVkRG9jPjxMaW5rc1VwVG9EYXRlPmZhbHNlPC9MaW5rc1VwVG9EYXRlPjxTY2FsZUNyb3A+ZmFsc2U8L1NjYWxlQ3JvcD48SGVhZGluZ1BhaXJzPjx2dDp2ZWN0b3Igc2l6ZT0iMiIgYmFzZVR5cGU9InZhcmlhbnQiPjx2dDp2YXJpYW50Pjx2dDpscHN0cj5Xb3Jrc2hlZXRzPC92dDpscHN0cj48L3Z0OnZhcmlhbnQ+PHZ0OnZhcmlhbnQ+PHZ0Omk0Pjk8L3Z0Omk0PjwvdnQ6dmFyaWFudD48L3Z0OnZlY3Rvcj48L0hlYWRpbmdQYWlycz48VGl0bGVzT2ZQYXJ0cz48dnQ6dmVjdG9yIHNpemU9IjkiIGJhc2VUeXBlPSJscHN0ciI+PHZ0Omxwc3RyPkVtYWlsPC92dDpscHN0cj48dnQ6bHBzdHI+T3BlblNsb3RzPC92dDpscHN0cj48dnQ6bHBzdHI+VGltZU9mZlJlYXNvbjwvdnQ6bHBzdHI+PHZ0Omxwc3RyPkluc3RydWN0aW9uczwvdnQ6bHBzdHI+PHZ0Omxwc3RyPlNoaWZ0czwvdnQ6bHBzdHI+PHZ0Omxwc3RyPlRpbWUgT2ZmPC92dDpscHN0cj48dnQ6bHBzdHI+T3BlbiBTaGlmdHM8L3Z0Omxwc3RyPjx2dDpscHN0cj5EYXkgTm90ZXM8L3Z0Omxwc3RyPjx2dDpscHN0cj5NZW1iZXJzPC92dDpscHN0cj48L3Z0OnZlY3Rvcj48L1RpdGxlc09mUGFydHM+PC9Qcm9wZXJ0aWVzPlBLAwQUAAAAAAAAAAAAd/aK/2UCAABlAgAAEQAAAGRvY1Byb3BzL2NvcmUueG1sPD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9InllcyI/Pg0KPGNwOmNvcmVQcm9wZXJ0aWVzIHhtbG5zOmNwPSJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvcGFja2FnZS8yMDA2L21ldGFkYXRhL2NvcmUtcHJvcGVydGllcyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpkY3Rlcm1zPSJodHRwOi8vcHVybC5vcmcvZGMvdGVybXMvIiB4bWxuczpkY21pdHlwZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlLyIgeG1sbnM6eHNpPSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZSI+PGRjdGVybXM6Y3JlYXRlZCB4c2k6dHlwZT0iZGN0ZXJtczpXM0NEVEYiPjIwMjYtMDItMTJUMjM6MDE6NThaPC9kY3Rlcm1zOmNyZWF0ZWQ+PGRjdGVybXM6bW9kaWZpZWQgeHNpOnR5cGU9ImRjdGVybXM6VzNDRFRGIj4yMDI2LTAyLTEyVDIzOjAxOjU5WjwvZGN0ZXJtczptb2RpZmllZD48Y3A6bGFzdE1vZGlmaWVkQnk+UVVBUkFOVElORTwvY3A6bGFzdE1vZGlmaWVkQnk+PGRjOmNyZWF0b3I+UVVBUkFOVElORTwvZGM6Y3JlYXRvcj48L2NwOmNvcmVQcm9wZXJ0aWVzPlBLAwQUAAAAAAAAAAAAVAR/0lUMAABVDAAAEwAAAFtDb250ZW50X1R5cGVzXS54bWw8P3htbCB2ZXJzaW9uPSIxLjAiIGVuY29kaW5nPSJVVEYtOCIgc3RhbmRhbG9uZT0ieWVzIj8+DQo8VHlwZXMgeG1sbnM9Imh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wYWNrYWdlLzIwMDYvY29udGVudC10eXBlcyIgeG1sbnM6eHNkPSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSIgeG1sbnM6eHNpPSJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYS1pbnN0YW5jZSI+PERlZmF1bHQgRXh0ZW5zaW9uPSJ4bWwiIENvbnRlbnRUeXBlPSJhcHBsaWNhdGlvbi94bWwiLz48RGVmYXVsdCBFeHRlbnNpb249ImJpbiIgQ29udGVudFR5cGU9ImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5iaW5hcnkubWFjcm9FbmFibGVkLm1haW4iLz48RGVmYXVsdCBFeHRlbnNpb249InZtbCIgQ29udGVudFR5cGU9ImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC52bWxEcmF3aW5nIi8+PERlZmF1bHQgRXh0ZW5zaW9uPSJkYXRhIiBDb250ZW50VHlwZT0iYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50Lm1vZGVsK2RhdGEiLz48RGVmYXVsdCBFeHRlbnNpb249ImJtcCIgQ29udGVudFR5cGU9ImltYWdlL2JtcCIvPjxEZWZhdWx0IEV4dGVuc2lvbj0icG5nIiBDb250ZW50VHlwZT0iaW1hZ2UvcG5nIi8+PERlZmF1bHQgRXh0ZW5zaW9uPSJnaWYiIENvbnRlbnRUeXBlPSJpbWFnZS9naWYiLz48RGVmYXVsdCBFeHRlbnNpb249ImVtZiIgQ29udGVudFR5cGU9ImltYWdlL3gtZW1mIi8+PERlZmF1bHQgRXh0ZW5zaW9uPSJ3bWYiIENvbnRlbnRUeXBlPSJpbWFnZS94LXdtZiIvPjxEZWZhdWx0IEV4dGVuc2lvbj0ianBnIiBDb250ZW50VHlwZT0iaW1hZ2UvanBlZyIvPjxEZWZhdWx0IEV4dGVuc2lvbj0ianBlZyIgQ29udGVudFR5cGU9ImltYWdlL2pwZWciLz48RGVmYXVsdCBFeHRlbnNpb249InRpZiIgQ29udGVudFR5cGU9ImltYWdlL3RpZmYiLz48RGVmYXVsdCBFeHRlbnNpb249InRpZmYiIENvbnRlbnRUeXBlPSJpbWFnZS90aWZmIi8+PERlZmF1bHQgRXh0ZW5zaW9uPSJwZGYiIENvbnRlbnRUeXBlPSJhcHBsaWNhdGlvbi9wZGYiLz48RGVmYXVsdCBFeHRlbnNpb249InJlbHMiIENvbnRlbnRUeXBlPSJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtcGFja2FnZS5yZWxhdGlvbnNoaXBzK3htbCIvPjxPdmVycmlkZSBQYXJ0TmFtZT0iL3hsL3dvcmtib29rLnhtbCIgQ29udGVudFR5cGU9ImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0Lm1haW4reG1sIi8+PE92ZXJyaWRlIFBhcnROYW1lPSIveGwvd29ya3NoZWV0cy9zaGVldDEueG1sIiBDb250ZW50VHlwZT0iYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwud29ya3NoZWV0K3htbCIvPjxPdmVycmlkZSBQYXJ0TmFtZT0iL3hsL3dvcmtzaGVldHMvc2hlZXQyLnhtbCIgQ29udGVudFR5cGU9ImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLndvcmtzaGVldCt4bWwiLz48T3ZlcnJpZGUgUGFydE5hbWU9Ii94bC93b3Jrc2hlZXRzL3NoZWV0My54bWwiIENvbnRlbnRUeXBlPSJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC53b3Jrc2hlZXQreG1sIi8+PE92ZXJyaWRlIFBhcnROYW1lPSIveGwvd29ya3NoZWV0cy9zaGVldDQueG1sIiBDb250ZW50VHlwZT0iYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwud29ya3NoZWV0K3htbCIvPjxPdmVycmlkZSBQYXJ0TmFtZT0iL3hsL3dvcmtzaGVldHMvc2hlZXQ1LnhtbCIgQ29udGVudFR5cGU9ImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLndvcmtzaGVldCt4bWwiLz48T3ZlcnJpZGUgUGFydE5hbWU9Ii94bC93b3Jrc2hlZXRzL3NoZWV0Ni54bWwiIENvbnRlbnRUeXBlPSJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC53b3Jrc2hlZXQreG1sIi8+PE92ZXJyaWRlIFBhcnROYW1lPSIveGwvd29ya3NoZWV0cy9zaGVldDcueG1sIiBDb250ZW50VHlwZT0iYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwud29ya3NoZWV0K3htbCIvPjxPdmVycmlkZSBQYXJ0TmFtZT0iL3hsL3dvcmtzaGVldHMvc2hlZXQ4LnhtbCIgQ29udGVudFR5cGU9ImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLndvcmtzaGVldCt4bWwiLz48T3ZlcnJpZGUgUGFydE5hbWU9Ii94bC93b3Jrc2hlZXRzL3NoZWV0OS54bWwiIENvbnRlbnRUeXBlPSJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC53b3Jrc2hlZXQreG1sIi8+PE92ZXJyaWRlIFBhcnROYW1lPSIveGwvdGhlbWUvdGhlbWUxLnhtbCIgQ29udGVudFR5cGU9ImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC50aGVtZSt4bWwiLz48T3ZlcnJpZGUgUGFydE5hbWU9Ii94bC9zdHlsZXMueG1sIiBDb250ZW50VHlwZT0iYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc3R5bGVzK3htbCIvPjxPdmVycmlkZSBQYXJ0TmFtZT0iL2RvY1Byb3BzL2NvcmUueG1sIiBDb250ZW50VHlwZT0iYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLXBhY2thZ2UuY29yZS1wcm9wZXJ0aWVzK3htbCIvPjxPdmVycmlkZSBQYXJ0TmFtZT0iL2RvY1Byb3BzL2FwcC54bWwiIENvbnRlbnRUeXBlPSJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuZXh0ZW5kZWQtcHJvcGVydGllcyt4bWwiLz48T3ZlcnJpZGUgUGFydE5hbWU9Ii94bC9tZXRhZGF0YS54bWwiIENvbnRlbnRUeXBlPSJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldE1ldGFkYXRhK3htbCIvPjwvVHlwZXM+UEsBAgAAFAAAAAAAAAAAAD4cAKIgBwAAIAcAABoAAAAAAAAAAAAAAAAAAAAAAHhsL19yZWxzL3dvcmtib29rLnhtbC5yZWxzUEsBAgAAFAAAAAAAAAAAAOyRzqO5GwAAuRsAABMAAAAAAAAAAAAAAAAAWAcAAHhsL3RoZW1lL3RoZW1lMS54bWxQSwECAAAUAAAAAAAAAAAAVfQElFoEAABaBAAADQAAAAAAAAAAAAAAAABCIwAAeGwvc3R5bGVzLnhtbFBLAQIAABQAAAAAAAAAAACnS4zK8QEAAPEBAAAYAAAAAAAAAAAAAAAAAMcnAAB4bC93b3Jrc2hlZXRzL3NoZWV0MS54bWxQSwECAAAUAAAAAAAAAAAAXoibu5UtAACVLQAAGAAAAAAAAAAAAAAAAADuKQAAeGwvd29ya3NoZWV0cy9zaGVldDIueG1sUEsBAgAAFAAAAAAAAAAAAFvm9kjwAwAA8AMAABgAAAAAAAAAAAAAAAAAuVcAAHhsL3dvcmtzaGVldHMvc2hlZXQzLnhtbFBLAQIAABQAAAAAAAAAAAC4Gb4sfAcAAHwHAAAYAAAAAAAAAAAAAAAAAN9bAAB4bC93b3Jrc2hlZXRzL3NoZWV0NC54bWxQSwECAAAUAAAAAAAAAAAAB8IQHpUGAACVBgAAGAAAAAAAAAAAAAAAAACRYwAAeGwvd29ya3NoZWV0cy9zaGVldDUueG1sUEsBAgAAFAAAAAAAAAAAAEEPJZrOBQAAzgUAABgAAAAAAAAAAAAAAAAAXGoAAHhsL3dvcmtzaGVldHMvc2hlZXQ2LnhtbFBLAQIAABQAAAAAAAAAAABGgewlPAYAADwGAAAYAAAAAAAAAAAAAAAAAGBwAAB4bC93b3Jrc2hlZXRzL3NoZWV0Ny54bWxQSwECAAAUAAAAAAAAAAAAU0YQH9UCAADVAgAAGAAAAAAAAAAAAAAAAADSdgAAeGwvd29ya3NoZWV0cy9zaGVldDgueG1sUEsBAgAAFAAAAAAAAAAAAEUD/EI5AwAAOQMAABgAAAAAAAAAAAAAAAAA3XkAAHhsL3dvcmtzaGVldHMvc2hlZXQ5LnhtbFBLAQIAABQAAAAAAAAAAABggACBiAMAAIgDAAAPAAAAAAAAAAAAAAAAAEx9AAB4bC9tZXRhZGF0YS54bWxQSwECAAAUAAAAAAAAAAAA0x5+DWUDAABlAwAADwAAAAAAAAAAAAAAAAABgQAAeGwvd29ya2Jvb2sueG1sUEsBAgAAFAAAAAAAAAAAAEpqEflMAgAATAIAAAsAAAAAAAAAAAAAAAAAk4QAAF9yZWxzLy5yZWxzUEsBAgAAFAAAAAAAAAAAAIkuYgboAwAA6AMAABAAAAAAAAAAAAAAAAAACIcAAGRvY1Byb3BzL2FwcC54bWxQSwECAAAUAAAAAAAAAAAAd/aK/2UCAABlAgAAEQAAAAAAAAAAAAAAAAAeiwAAZG9jUHJvcHMvY29yZS54bWxQSwECAAAUAAAAAAAAAAAAVAR/0lUMAABVDAAAEwAAAAAAAAAAAAAAAACyjQAAW0NvbnRlbnRfVHlwZXNdLnhtbFBLBQYAAAAAEgASAKsEAAA4mgAAAAA=";

function _downloadNeedsXlsx(rows, fileName) {
  if (!rows.length) { showToast("No open shifts found — all channels are filled."); return; }
  // Parse the embedded Teams import template (headers preserved from original)
  const templateBytes = Uint8Array.from(atob(_TEMPLATE_B64), c => c.charCodeAt(0));
  const wb = XLSX.read(templateBytes, { type: "array" });
  // Append data rows below the existing header (row 0) — don't touch the header
  const header = ["Group","Start Date","Start Time","End Date","End Time","Open Slots","Theme Color","Custom Label","Unpaid Break (minutes)","Notes","Shared"];
  const dataOnly = rows.map(r => header.map(h => r[h] !== undefined ? r[h] : ""));
  XLSX.utils.sheet_add_aoa(wb.Sheets["Open Shifts"], dataOnly, { origin: "A2" });
  XLSX.writeFile(wb, fileName);
  showToast(`Exported ${rows.length} open shift(s) to ${fileName}`);
}

// Month export
function exportNeedsXlsx() {
  const plan = loadPlan();
  if (!plan || !plan.days) { showToast("No plan data. Randomize a month first."); return; }
  const year = Number(document.getElementById("yearSel").value);
  const monthIndex = Number(document.getElementById("monthSel").value);
  const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();
  const dateList = [];
  for (let d = 1; d <= daysInMonth; d++) dateList.push(new Date(year, monthIndex, d, 12, 0, 0, 0));
  _downloadNeedsXlsx(_buildNeedsRows(dateList), `Open_Shifts_${year}-${String(monthIndex+1).padStart(2,"0")}.xlsx`);
}

// Week export
function exportNeedsWeekXlsx() {
  const plan = loadPlan();
  if (!plan || !plan.days) { showToast("No plan data. Randomize a month first."); return; }
  const dk = document.getElementById("dayPick").value;
  if (!dk) { showToast("Select a day first."); return; }
  const anchor = parseYMD(dk);
  if (!anchor) { showToast("Invalid date."); return; }
  const dow = anchor.getDay();
  const offsetToSat = (dow - 6 + 7) % 7;
  const start = new Date(anchor.getFullYear(), anchor.getMonth(), anchor.getDate() - offsetToSat, 12, 0, 0, 0);
  const dateList = [];
  for (let i = 0; i < 7; i++) dateList.push(new Date(start.getFullYear(), start.getMonth(), start.getDate() + i, 12, 0, 0, 0));
  const label = `${start.getMonth()+1}-${start.getDate()}`;
  _downloadNeedsXlsx(_buildNeedsRows(dateList), `Open_Shifts_Week_${label}.xlsx`);
}

// Day export
function exportNeedsDayXlsx() {
  const plan = loadPlan();
  if (!plan || !plan.days) { showToast("No plan data. Randomize a month first."); return; }
  const dk = document.getElementById("dayPick").value;
  if (!dk) { showToast("Select a day first."); return; }
  const dateObj = parseYMD(dk);
  if (!dateObj) { showToast("Invalid date."); return; }
  const dateList = [new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate(), 12, 0, 0, 0)];
  _downloadNeedsXlsx(_buildNeedsRows(dateList), `Open_Shifts_${dk}.xlsx`);
}

async function copyText(text) {
  try { await navigator.clipboard.writeText(text); showToast("Copied to clipboard."); }
  catch(e) { showToast("Copy failed. Try selecting and copying manually."); }
}
function buildDayText(dayKey) {
  const plan = loadPlan();
  if (!plan || !plan.days[dayKey]) return "NO PLAN YET.";
  const lines = [];
  lines.push(`DISPATCHER ROTATION – ${dayKey}`);
  for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
    lines.push("");
    lines.push(b.label.toUpperCase());
    const entry = plan.days[dayKey][b.key];
    // Main channels
    for (const ch of CHANNELS) {
      const nm = (entry.assignments[ch]||"");
      lines.push(`${ch.toUpperCase()}: ${nm ? nm.toUpperCase() : "NEEDED"}`);
    }
    // 7th channel (Fri/Sat 2200-0200 only)
    const dtxt = new Date(dayKey + "T12:00:00");
    const dowTxt = dtxt.getDay();
    if ((dowTxt === 5 || dowTxt === 6) && SEVENTH_BLOCKS.has(b.key)) {
      const nm7 = (entry.assignments[SEVENTH_CHANNEL]||"");
      lines.push(`7TH: ${nm7 ? nm7.toUpperCase() : "NEEDED"}`);
    }
    // SD
    for (const nm of (entry.sd||[])) lines.push(`SD: ${nm.toUpperCase()}`);
    // CT
    for (const nm of (entry.ct||[])) lines.push(`CT: ${nm.toUpperCase()}`);
  }
  return lines.join("\n");
}
function buildDayCSV(dayKey) {
  const plan = loadPlan();
  if (!plan || !plan.days[dayKey]) return "";
  const rows = [["DATE","BLOCK","CHANNEL","NAME"]];
  for (let bi=0; bi<BLOCKS.length; bi++) {
      const b = BLOCKS[bi];
    const entry = plan.days[dayKey][b.key];
    for (const ch of CHANNELS) {
      const nm = entry.assignments[ch]||"";
      rows.push([dayKey, b.label.toUpperCase(), ch.toUpperCase(), nm ? nm.toUpperCase() : "NEEDED"]);
    }
    // 7th channel (Fri/Sat 2200-0200 only)
    const dcsv = new Date(dayKey + "T12:00:00");
    const dowCsv = dcsv.getDay();
    if ((dowCsv === 5 || dowCsv === 6) && SEVENTH_BLOCKS.has(b.key)) {
      const nm7 = entry.assignments[SEVENTH_CHANNEL]||"";
      rows.push([dayKey, b.label.toUpperCase(), "7TH", nm7 ? nm7.toUpperCase() : "NEEDED"]);
    }
    for (const nm of (entry.sd||[])) rows.push([dayKey, b.label.toUpperCase(), "SD", nm.toUpperCase()]);
    for (const nm of (entry.ct||[])) rows.push([dayKey, b.label.toUpperCase(), "CT", nm.toUpperCase()]);
  }
  return rows.map(r => r.map(x=>`"${String(x).replaceAll('"','""')}"`).join(",")).join("\n");
}

function renderMonthRostersIfActive(){
  const active = loadJSON(STORAGE.ui, {}).tab || "day";
  if (active !== "mroster") return;
  renderMonthRoster("DAY", "mRosterWrapDay");
  renderMonthRoster("NIGHT", "mRosterWrapNight");
  renderMonthRoster("SPLIT", "mRosterWrapSplit");
}

function setActiveTab(tab) {
  document.querySelectorAll(".tab").forEach(t=>t.classList.toggle("active", t.getAttribute("data-tab")===tab));
  ["day","week","month","mroster","exceptions"].forEach(k => document.getElementById("tab_"+k).style.display = (k===tab) ? "" : "none");
  if (tab === "exceptions") renderExceptions();
  if (tab === "mroster") try { renderMonthRostersIfActive(); } catch(e) {}
  saveJSON(STORAGE.ui, {...loadJSON(STORAGE.ui, {}), tab});
}

function initSelectors() {
  const monthSel = document.getElementById("monthSel");
  const yearSel = document.getElementById("yearSel");
  monthSel.innerHTML = "";
  for (let i=0;i<12;i++) {
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = monthName(i);
    monthSel.appendChild(opt);
  }
  yearSel.innerHTML = "";
  const now = new Date();
  const y0 = now.getFullYear()-1;
  for (let y=y0; y<=y0+4; y++) {
    const opt = document.createElement("option");
    opt.value = String(y);
    opt.textContent = String(y);
    yearSel.appendChild(opt);
  }
  monthSel.value = String(now.getMonth());
  yearSel.value = String(now.getFullYear());
}

function renderExceptions() {
  const wrap = document.getElementById("exceptionsWrap");
  if (!wrap) return;
  const names = normalizeBase()
    .filter(r => String(r.Position||"").trim().toUpperCase() === "DISPATCHER")
    .map(r => String(r.Employee||"").trim()).filter(Boolean).sort();
  const opts = '<option value="">— SELECT —</option>' + names.map(n =>
    `<option value="${escapeHtml(n)}">${escapeHtml(n.toUpperCase())}</option>`
  ).join("");
  const vacRanges = getVacRanges();
  const trainerRanges = getTrainerRanges();

  let html = '<div style="display:grid; grid-template-columns:1fr 1fr; gap:16px;">';

  // --- Vacation / Exclusion table ---
  html += '<div>';
  html += '<h2 style="margin:0 0 10px; font-size:13px; letter-spacing:.5px;">VACATION / EXCLUSION</h2>';
  html += '<div style="display:flex; gap:6px; margin-bottom:10px; flex-wrap:wrap; align-items:end;">';
  html += `<div style="flex:1; min-width:120px;"><div style="font-size:9px; color:var(--muted); margin-bottom:2px;">EMPLOYEE</div><select id="vacName" style="width:100%; font-size:12px; padding:6px; border-radius:6px; box-sizing:border-box; background:var(--panel2); border:1px solid var(--line); color:var(--text);">${opts}</select></div>`;
  html += '<div style="min-width:110px;"><div style="font-size:9px; color:var(--muted); margin-bottom:2px;">FROM</div><input id="vacFrom" type="date" style="width:100%; font-size:12px; padding:6px; border-radius:6px; box-sizing:border-box;" /></div>';
  html += '<div style="min-width:110px;"><div style="font-size:9px; color:var(--muted); margin-bottom:2px;">TO (blank = rest of month)</div><input id="vacTo" type="date" style="width:100%; font-size:12px; padding:6px; border-radius:6px; box-sizing:border-box;" /></div>';
  html += '<button class="btn secondary" id="btnAddVac" style="font-size:11px; padding:6px 12px; border-radius:6px; white-space:nowrap;">ADD</button>';
  html += '</div>';
  html += '<table style="width:100%; table-layout:fixed;"><thead><tr><th style="text-align:left; width:35%;">NAME</th><th style="width:25%;">FROM</th><th style="width:25%;">TO</th><th style="width:15%;"></th></tr></thead><tbody>';
  if (vacRanges.length) {
    vacRanges.forEach((r, idx) => {
      html += `<tr><td style="text-align:left; font-weight:700;">${escapeHtml((r.name||"").toUpperCase())}</td><td>${r.from||"—"}</td><td>${r.to||"rest of month"}</td><td><button class="btn danger exc-del-vac" data-i="${idx}" style="font-size:10px; padding:3px 8px;">X</button></td></tr>`;
    });
  } else {
    html += '<tr><td colspan="4" style="color:var(--muted); font-size:11px;">No exclusions.</td></tr>';
  }
  html += '</tbody></table></div>';

  // --- Trainers table ---
  html += '<div>';
  html += '<h2 style="margin:0 0 10px; font-size:13px; letter-spacing:.5px;">TRAINERS</h2>';
  html += '<div style="display:flex; gap:6px; margin-bottom:10px; flex-wrap:wrap; align-items:end;">';
  html += `<div style="flex:1; min-width:120px;"><div style="font-size:9px; color:var(--muted); margin-bottom:2px;">EMPLOYEE</div><select id="traineeName" style="width:100%; font-size:12px; padding:6px; border-radius:6px; box-sizing:border-box; background:var(--panel2); border:1px solid var(--line); color:var(--text);">${opts}</select></div>`;
  html += '<div style="min-width:110px;"><div style="font-size:9px; color:var(--muted); margin-bottom:2px;">FROM</div><input id="traineeFrom" type="date" style="width:100%; font-size:12px; padding:6px; border-radius:6px; box-sizing:border-box;" /></div>';
  html += '<div style="min-width:110px;"><div style="font-size:9px; color:var(--muted); margin-bottom:2px;">TO (blank = rest of month)</div><input id="traineeTo" type="date" style="width:100%; font-size:12px; padding:6px; border-radius:6px; box-sizing:border-box;" /></div>';
  html += '<button class="btn secondary" id="btnAddTrainee" style="font-size:11px; padding:6px 12px; border-radius:6px; white-space:nowrap;">ADD</button>';
  html += '</div>';
  // Block picker checkboxes
  const _blockOpts = [
    {key:"0600-1000", label:"6A-10A"}, {key:"1000-1400", label:"10A-2P"}, {key:"1400-1800", label:"2P-6P"},
    {key:"1800-2200", label:"6P-10P"}, {key:"2200-0200", label:"10P-2A"}, {key:"0200-0600", label:"2A-6A"}
  ];
  html += '<div style="margin-bottom:10px;"><div style="font-size:9px; color:var(--muted); margin-bottom:4px;">TRAINING BLOCKS (none = all blocks)</div>';
  html += '<div id="traineeBlockPicker" style="display:flex; gap:4px; flex-wrap:wrap;">';
  _blockOpts.forEach(bo => {
    html += `<label data-block-key="${bo.key}" style="display:inline-flex; align-items:center; gap:3px; font-size:11px; padding:3px 8px; border-radius:5px; border:1px solid var(--line); cursor:pointer; user-select:none;"><input type="checkbox" class="trainee-block-cb" value="${bo.key}" style="margin:0;" />${bo.label}</label>`;
  });
  html += '</div></div>';
  // Helper: collect all blocks an employee works on any day of the week
  // Uses the same shift-to-hours map as worksBlock() so all shift types are handled
  const _allDays = ["SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"];
  const _shiftMap = {"6A-2P":[6,14],"6A-6P":[6,18],"10A-6P":[10,18],"10A-10P":[10,22],"2P-10P":[14,22],"6P-2A":[18,26],"6P-6A":[18,30],"10P-6A":[22,30],"2A-10A":[2,10]};
  function _getEmployeeBlocks(empName) {
    const nm = String(empName||"").trim().toUpperCase();
    const base = normalizeBase();
    const row = base.find(r => String(r.Employee||"").trim().toUpperCase() === nm);
    if (!row) return new Set(BLOCKS.map(b=>b.key)); // fallback: show all
    const out = new Set();
    for (const dn of _allDays) {
      const shift = String(row[dn]||"").trim().toUpperCase();
      if (!shift || shift === "OFF") continue;
      const rng = _shiftMap[shift];
      if (!rng) continue; // unknown shift — skip rather than showing all
      const [s, e] = rng;
      for (const blk of BLOCKS) {
        if (blk.start >= s && blk.end <= e) out.add(blk.key);
      }
    }
    return out.size ? out : new Set(BLOCKS.map(b=>b.key)); // fallback if nothing found
  }

  html += '<table style="width:100%; table-layout:fixed;"><thead><tr><th style="text-align:left; width:22%;">NAME</th><th style="width:14%;">FROM</th><th style="width:14%;">TO</th><th style="width:34%;">BLOCKS</th><th style="width:16%;"></th></tr></thead><tbody>';
  if (trainerRanges.length) {
    trainerRanges.forEach((r, idx) => {
      const blocksLabel = (r.blocks && r.blocks.length > 0) ? r.blocks.map(k => { const m = _blockOpts.find(o=>o.key===k); return m ? m.label : k; }).join(', ') : 'ALL';
      // Normal display row
      html += `<tr id="tr-row-${idx}"><td style="text-align:left; font-weight:700;">${escapeHtml((r.name||"").toUpperCase())}</td><td>${r.from||"—"}</td><td>${r.to||"rest of month"}</td><td style="font-size:10px;">${blocksLabel}</td><td style="white-space:nowrap;"><button class="btn secondary exc-edit-tr" data-ti="${idx}" style="font-size:10px; padding:3px 8px; margin-right:2px;">EDIT</button><button class="btn danger exc-del-tr" data-ti="${idx}" style="font-size:10px; padding:3px 8px;">X</button></td></tr>`;
      // Inline edit row — all 6 checkboxes rendered; filtered at click time via data-emp
      let editCbs = '';
      _blockOpts.forEach(bo => {
        const chk = (r.blocks && r.blocks.includes(bo.key)) ? 'checked' : '';
        editCbs += `<label data-block-key="${bo.key}" style="display:inline-flex; align-items:center; gap:2px; font-size:10px; padding:2px 5px; border-radius:4px; border:1px solid var(--line); cursor:pointer; user-select:none;"><input type="checkbox" class="edit-block-cb-${idx}" value="${bo.key}" ${chk} style="margin:0;" />${bo.label}</label> `;
      });
      html += `<tr id="tr-edit-${idx}" style="display:none;"><td colspan="3" style="text-align:left; font-size:9px; color:var(--muted); padding:6px 0;">EDITING BLOCKS FOR <b>${escapeHtml((r.name||"").toUpperCase())}</b></td><td style="padding:6px 0;"><div style="display:flex; gap:3px; flex-wrap:wrap;">${editCbs}</div></td><td style="white-space:nowrap; padding:6px 0;"><button class="btn secondary exc-save-tr" data-ti="${idx}" style="font-size:10px; padding:3px 8px; margin-right:2px;">SAVE</button><button class="btn secondary exc-cancel-tr" data-ti="${idx}" style="font-size:10px; padding:3px 8px;">CANCEL</button></td></tr>`;
    });
  } else {
    html += '<tr><td colspan="5" style="color:var(--muted); font-size:11px;">No trainers.</td></tr>';
  }
  html += '</tbody></table></div>';

  html += '</div>';
  wrap.innerHTML = html;

  // Wire delete buttons for vacations
  wrap.querySelectorAll(".exc-del-vac").forEach(btn => {
    btn.addEventListener("click", () => {
      const i = Number(btn.getAttribute("data-i"));
      const v = getVacRanges(); v.splice(i,1); saveJSON(STORAGE.vac, v);
      renderExceptions(); renderInfoStats();
      const dk = document.getElementById("dayPick").value;
      if (dk) renderDay(dk);
    });
  });
  // Wire delete buttons for trainers
  wrap.querySelectorAll(".exc-del-tr").forEach(btn => {
    btn.addEventListener("click", () => {
      const i = Number(btn.getAttribute("data-ti"));
      const t = getTrainerRanges(); t.splice(i,1); saveJSON(STORAGE.training, t);
      renderExceptions(); renderInfoStats();
    });
  });
  // Wire edit buttons for trainers — toggles inline edit row, filters blocks at click time
  wrap.querySelectorAll(".exc-edit-tr").forEach(btn => {
    btn.addEventListener("click", () => {
      const i = btn.getAttribute("data-ti");
      const row = document.getElementById("tr-row-" + i);
      const edit = document.getElementById("tr-edit-" + i);
      if (row) row.style.display = "none";
      if (edit) {
        edit.style.display = "";
        // Filter checkboxes to only blocks this employee actually works
        const empName = trainerRanges[Number(i)] ? trainerRanges[Number(i)].name : "";
        const empBlocks = _getEmployeeBlocks(empName);
        edit.querySelectorAll("label[data-block-key]").forEach(lbl => {
          const bk = lbl.getAttribute("data-block-key");
          if (empBlocks.has(bk)) {
            lbl.style.display = "";
          } else {
            lbl.style.display = "none";
            const cb = lbl.querySelector("input[type=checkbox]");
            if (cb) cb.checked = false;
          }
        });
      }
    });
  });
  // Wire cancel buttons — hides edit row, shows normal row
  wrap.querySelectorAll(".exc-cancel-tr").forEach(btn => {
    btn.addEventListener("click", () => {
      const i = btn.getAttribute("data-ti");
      const row = document.getElementById("tr-row-" + i);
      const edit = document.getElementById("tr-edit-" + i);
      if (row) row.style.display = "";
      if (edit) edit.style.display = "none";
    });
  });
  // Wire save buttons — reads checkboxes, updates trainer entry, re-renders
  wrap.querySelectorAll(".exc-save-tr").forEach(btn => {
    btn.addEventListener("click", () => {
      const i = Number(btn.getAttribute("data-ti"));
      const cbs = document.querySelectorAll(".edit-block-cb-" + i + ":checked");
      const blocks = Array.from(cbs).map(cb => cb.value);
      const t = getTrainerRanges();
      if (t[i]) { t[i].blocks = blocks; saveJSON(STORAGE.training, t); }
      renderExceptions(); renderInfoStats();
      showToast("Updated training blocks.");
    });
  });
  // Wire trainee employee dropdown to filter ADD form block picker
  const _traineeNameSel = document.getElementById("traineeName");
  const _blockPickerDiv = document.getElementById("traineeBlockPicker");
  function _updateAddBlockPicker() {
    if (!_traineeNameSel || !_blockPickerDiv) return;
    const nm = _traineeNameSel.value.trim().toUpperCase();
    const empBlocks = nm ? _getEmployeeBlocks(nm) : new Set(BLOCKS.map(b=>b.key));
    _blockPickerDiv.querySelectorAll("label[data-block-key]").forEach(lbl => {
      const bk = lbl.getAttribute("data-block-key");
      if (empBlocks.has(bk)) {
        lbl.style.display = "";
      } else {
        lbl.style.display = "none";
        const cb = lbl.querySelector("input[type=checkbox]");
        if (cb) cb.checked = false; // uncheck hidden blocks
      }
    });
  }
  if (_traineeNameSel) {
    _traineeNameSel.addEventListener("change", _updateAddBlockPicker);
    _updateAddBlockPicker(); // run once on render for initial selection
  }
}

function renderVacList() {
  const list = document.getElementById("vacList");
  if (!list) return;
  const ranges = getVacRanges();
  if (!ranges.length) { list.innerHTML = "<div class='small'>NO EXCLUSIONS.</div>"; return; }
  list.innerHTML = ranges.map((r, idx)=>{
    const from = r.from ? r.from : "–";
    const to = r.to ? r.to : "–";
    return `<div class="pill">
      <div><b>${escapeHtml((r.name||"").toUpperCase())}</b><div class="meta">FROM: ${from} &nbsp; TO: ${to}</div></div>
      <button data-i="${idx}">X</button>
    </div>`;
  }).join("");
  list.querySelectorAll("button[data-i]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const i = Number(btn.getAttribute("data-i"));
      const v = getVacRanges(); v.splice(i,1); saveJSON(STORAGE.vac, v);
      renderVacList();
      const dk = document.getElementById("dayPick").value;
      if (dk) renderDay(dk);
    });
  });
}

function renderTraineeList() {
  const list = document.getElementById("traineeList");
  if (!list) return;
  const ranges = getTrainerRanges();
  if (!ranges.length) { list.innerHTML = "<div class='small'>NO TRAINERS.</div>"; return; }
  list.innerHTML = ranges.map((r, idx)=>{
    const from = r.from ? r.from : "–";
    const to = r.to ? r.to : "–";
    const blks = (r.blocks && r.blocks.length) ? r.blocks.join(', ') : 'ALL';
    return `<div class="pill">
      <div><b>${escapeHtml(r.name.toUpperCase())}</b><div class="meta">FROM: ${from} TO: ${to} BLOCKS: ${blks}</div></div>
      <button data-ti="${idx}">X</button>
    </div>`;
  }).join("");
  list.querySelectorAll("button[data-ti]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const i = Number(btn.getAttribute("data-ti"));
      const t = getTrainerRanges(); t.splice(i,1); saveJSON(STORAGE.training, t);
      renderTraineeList();
    });
  });
}

// ========== FAIRNESS STATS ==========
function calculateFairnessStats() {
  const plan = loadPlan();
  if (!plan || !plan.days) return null;

  const empStats = new Map();
  const channelCounts = {};
  let totalAssignments = 0;

  // Count eligible blocks per employee across the month (accounts for vacation/exclusion)
  const eligibleBlocks = new Map(); // name -> count of blocks they could have worked
  for (const dayKey of Object.keys(plan.days)) {
    const dateObj = parseYMD(dayKey);
    if (!dateObj) continue;
    const pool = buildDispatcherPoolForDate(dateObj);
    for (const disp of pool) {
      const nm = String(disp.name).trim().toUpperCase();
      if (EXCLUDED_FROM_STATS.has(nm)) continue;
      let blocksThisDay = 0;
      for (const b of BLOCKS) {
        if (worksBlock(disp, dateObj, b)) blocksThisDay++;
      }
      eligibleBlocks.set(nm, (eligibleBlocks.get(nm) || 0) + blocksThisDay);
    }
  }

  for (const [dayKey, dayData] of Object.entries(plan.days)) {
    const dateObj2 = parseYMD(dayKey);
    for (const [blockKey, blockData] of Object.entries(dayData)) {
      if (!blockData || typeof blockData !== 'object') continue;

      for (const [ch, name] of Object.entries(blockData.assignments || {})) {
        if (!name) continue;
        const nm = name.toUpperCase();
        if (EXCLUDED_FROM_STATS.has(nm)) continue;
        // Skip assignments on days the person is on vacation
        if (dateObj2 && isExcluded(name, dateObj2)) continue;
        totalAssignments++;
        if (!empStats.has(nm)) empStats.set(nm, { total: 0, channels: {}, ct: 0, sd: 0 });
        empStats.get(nm).total++;
        empStats.get(nm).channels[ch] = (empStats.get(nm).channels[ch] || 0) + 1;
        channelCounts[ch] = (channelCounts[ch] || 0) + 1;
      }

      for (const name of (blockData.ct || [])) {
        if (!name) continue;
        const nm = name.toUpperCase();
        if (EXCLUDED_FROM_STATS.has(nm)) continue;
        if (dateObj2 && isExcluded(name, dateObj2)) continue;
        if (!empStats.has(nm)) empStats.set(nm, { total: 0, channels: {}, ct: 0, sd: 0 });
        empStats.get(nm).ct++;
      }

      for (const name of (blockData.sd || [])) {
        if (!name) continue;
        const nm = name.toUpperCase();
        if (EXCLUDED_FROM_STATS.has(nm)) continue;
        if (dateObj2 && isExcluded(name, dateObj2)) continue;
        if (!empStats.has(nm)) empStats.set(nm, { total: 0, channels: {}, ct: 0, sd: 0 });
        empStats.get(nm).sd++;
      }
    }
  }

  // Identify vacation employees — anyone with at least one vacation day this month
  const vacRanges = getVacRanges();
  const vacNames = new Set();
  for (const dayKey of Object.keys(plan.days)) {
    const dateObj = parseYMD(dayKey);
    if (!dateObj) continue;
    for (const r of vacRanges) {
      if (!r || !r.name) continue;
      const nm = String(r.name).trim().toUpperCase();
      if (isExcluded(nm, dateObj)) vacNames.add(nm);
    }
  }

  // Identify trainees — anyone who is a trainee on any day this month
  const traineeNames = new Set();
  for (const dayKey of Object.keys(plan.days)) {
    for (const [nm] of empStats) {
      if (isTrainee(nm, dayKey, null)) traineeNames.add(nm);
    }
  }

  // Compute expected assignments per person proportional to their eligible blocks
  const totalEligible = Array.from(eligibleBlocks.values()).reduce((a, b) => a + b, 0);
  // Store expected on each empStats entry
  for (const [nm, s] of empStats) {
    const eb = eligibleBlocks.get(nm) || 0;
    s.eligibleBlocks = eb;
    s.expected = totalEligible > 0 ? totalAssignments * (eb / totalEligible) : 0;
    s.isVacation = vacNames.has(nm);
    s.isTrainee = traineeNames.has(nm);
  }

  const totals = Array.from(empStats.values()).map(s => s.total);
  const avg = totals.length ? totals.reduce((a,b) => a+b, 0) / totals.length : 0;

  // Spread is based on adjusted diff (actual - expected) — exclude vacation & trainee employees from score
  const nonVacDiffs = Array.from(empStats.entries()).filter(([nm, s]) => !s.isVacation && !s.isTrainee).map(([nm, s]) => s.total - s.expected);
  const maxDiff = nonVacDiffs.length ? Math.max(...nonVacDiffs, 0) : 0;
  const minDiff = nonVacDiffs.length ? Math.min(...nonVacDiffs, 0) : 0;
  const spread = Math.round((maxDiff - minDiff) * 10) / 10;

  return {
    empStats,
    eligibleBlocks,
    channelCounts,
    totalAssignments,
    avgPerPerson: avg,
    maxDiff,
    minDiff,
    spread,
    vacNames,
    fairnessScore: spread <= 5 ? 'EXCELLENT' : spread <= 10 ? 'GOOD' : spread <= 20 ? 'FAIR' : 'POOR'
  };
}

// ========== PRINT: HOW IT WORKS (one page) ==========
function printHowItWorks() {
  const monthNames = ["January","February","March","April","May","June","July","August","September","October","November","December"];
  const selM = Number(document.getElementById("monthSel").value);
  const selY = Number(document.getElementById("yearSel").value);
  const monthLabel = monthNames[selM] + " " + selY;

  // Build fairness table data — separated by shift
  const stats = calculateFairnessStats();
  let fairnessTable = '';
  if (stats && stats.empStats && stats.empStats.size > 0) {
    const baseAll = normalizeBase();
    const WEEKDAYS = ["MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY","SUNDAY"];

    // Classify each person into a shift group
    function getShiftGroup(name) {
      const nm = String(name).trim().toUpperCase();
      if (SD_ELIGIBLE.has(nm)) return "SD";
      const rec = baseAll.find(r => String(r.Employee||"").trim().toUpperCase() === nm);
      if (!rec) return "DAY"; // fallback
      let hasDay = false, hasNight = false;
      for (const d of WEEKDAYS) {
        const s = rec[d];
        if (s && blocksWorkedForSchedule(s, "DAY").size) hasDay = true;
        if (s && blocksWorkedForSchedule(s, "NIGHT").size) hasNight = true;
      }
      if (hasDay && hasNight) return "SPLIT";
      if (hasNight) return "NIGHT";
      return "DAY";
    }

    const groups = { DAY: [], NIGHT: [], SPLIT: [], SD: [] };
    for (const [name, s] of stats.empStats.entries()) {
      const grp = getShiftGroup(name);
      groups[grp].push([name, s]);
    }
    // Sort each group by total descending
    for (const g of Object.values(groups)) g.sort((a,b) => b[1].total - a[1].total);

    function buildRows(arr) {
      let rows = '';
      for (const [name, s] of arr) {
        const fairPct = s.expected > 0 ? Math.round(100 - (Math.abs(s.total - s.expected) / s.expected) * 100) : 100;
        const clamped = Math.max(0, Math.min(100, fairPct));
        const color = clamped >= 90 ? '#16a34a' : clamped >= 80 ? '#ca8a04' : '#dc2626';
        const vacTag = s.isVacation ? ' <span style="color:#ca8a04; font-size:6px; font-weight:700;">VAC</span>' : '';
        const trnTag = s.isTrainee ? ' <span style="color:#38bdf8; font-size:6px; font-weight:700;">TRN</span>' : '';
        const rowOpacity = (s.isVacation || s.isTrainee) ? ' opacity:0.6;' : '';
        rows += '<tr style="' + rowOpacity + '"><td style="text-align:left; font-weight:600; padding:2px 6px;">' + name + vacTag + trnTag + '</td><td style="padding:2px 6px; text-align:center;">' + s.total + '</td><td style="padding:2px 6px; text-align:center;">' + s.ct + '</td><td style="padding:2px 6px; text-align:center; color:' + color + '; font-weight:700;">' + clamped + '%</td></tr>';
      }
      return rows;
    }

    function buildGroupTable(label, arr, color) {
      if (!arr.length) return '';
      const half = Math.ceil(arr.length / 2);
      const col1 = arr.slice(0, half);
      const col2 = arr.slice(half);
      let html = '<div class="grp-label" style="color:' + color + '; border-bottom-color:' + color + ';">' + label + ' (' + arr.length + ')</div>';
      html += '<div style="display:flex; gap:12px; margin-top:2px;">';
      html += '<div style="flex:1;"><table class="ftable"><thead><tr><th style="text-align:left;">Name</th><th>Total</th><th>CT</th><th>Fair %</th></tr></thead><tbody>' + buildRows(col1) + '</tbody></table></div>';
      if (col2.length) {
        html += '<div style="flex:1;"><table class="ftable"><thead><tr><th style="text-align:left;">Name</th><th>Total</th><th>CT</th><th>Fair %</th></tr></thead><tbody>' + buildRows(col2) + '</tbody></table></div>';
      }
      html += '</div>';
      return html;
    }

    fairnessTable = buildGroupTable("Day Shift (6A\u20136P)", groups.DAY, "#2563eb")
                  + buildGroupTable("Night Shift (6P\u20136A)", groups.NIGHT, "#1e293b")
                  + buildGroupTable("Split Shift", groups.SPLIT, "#d97706")
                  + buildGroupTable("Shift Differential (SD)", groups.SD, "#7c3aed");
  } else {
    fairnessTable = '<div style="color:#999; text-align:center; padding:12px;">No data \u2014 randomize a month first.</div>';
  }

  const w = window.open("", "_blank");
  w.document.write(`<!DOCTYPE html><html><head><meta charset="UTF-8"><title>RotationOps - ${monthLabel}</title>
<style>
@media print { @page { margin: 0.3in 0.4in; size: portrait; } }
* { margin:0; padding:0; box-sizing:border-box; }
body { font-family: Arial, sans-serif; font-size: 11.5px; color: #1a1a1a; padding: 0.3in 0.4in; line-height: 1.55; }
.month-header { text-align: center; margin-bottom: 10px; border-bottom: 3px solid #1e293b; padding-bottom: 8px; }
.month-header h1 { font-size: 34px; font-weight: 900; letter-spacing: 1px; margin-bottom: 1px; }
.month-header .sub { font-size: 13px; color: #475569; font-weight: 600; }
.section-title { font-weight: 800; font-size: 12px; margin-top: 8px; margin-bottom: 2px; color: #1e293b; text-transform: uppercase; letter-spacing: 0.5px; }
.section-body { margin-bottom: 4px; font-size: 11.5px; }
ul { margin: 2px 0 4px 18px; }
ul li { margin-bottom: 1px; font-size: 11.5px; }
b { color: #111; }
.ftable { width: 100%; border-collapse: collapse; font-size: 7.5px; }
.ftable th { background: #1e293b; color: #fff; padding: 1px 4px; font-size: 6.5px; text-transform: uppercase; letter-spacing: 0.3px; }
.ftable td { border-bottom: 1px solid #e2e8f0; font-size: 7.5px; padding: 1px 4px; }
.ftable tr:nth-child(even) td { background: #f8fafc; }
.grp-label { margin-top: 6px; margin-bottom: 1px; font-weight: 800; font-size: 8.5px; text-transform: uppercase; letter-spacing: 0.5px; padding-bottom: 1px; border-bottom-width: 2px; border-bottom-style: solid; }
.footer { margin-top: 8px; font-size: 7.5px; color: #999; text-align: center; border-top: 1px solid #ddd; padding-top: 4px; }
@media print { .no-print { display: none; } }
</style></head><body>

<div class="month-header">
  <h1>${monthLabel.toUpperCase()}</h1>
  <div class="sub">RotationOps \u2014 Dispatch Rotation System</div>
</div>

<div class="section-body" style="margin-bottom:6px;">
<b>1.</b> The system generates hundreds of complete monthly schedules and keeps the fairest one.<br>
<b>2.</b> It then fine-tunes by swapping assignments between people to even out the distribution.
</div>

<div class="section-title">What the System Balances</div>
<ul>
<li><b>Primary channels</b> \u2014 North, East, South, West, Northwest, and Central are distributed as evenly as possible across everyone on the same shift.</li>
<li><b>DC Desk &amp; Relief</b> \u2014 DC1, DC2, Relief 1, and Relief 2 are included in the rotation and balanced alongside primary channels.</li>
<li><b>Call-Taker</b> \u2014 CT assignments are spread evenly so no one gets stuck on phones more than anyone else.</li>
<li><b>7th Channel</b> \u2014 Added on Friday and Saturday nights and distributed evenly.</li>
<li><b>Vacations</b> \u2014 Employees on vacation are excluded from those days. Their fairness is measured only against the days they actually work.</li>
<li><b>Trainees</b> \u2014 Limited to East, South, West, and Central during training blocks.</li>
</ul>

<div class="section-title" style="margin-bottom:0;">Fairness % by Employee</div>
<div style="font-size:7.5px; color:#555; margin-bottom:2px;">100% = perfectly even. <span style="color:#16a34a; font-weight:700;">Green 90%+</span> = fair. <span style="color:#ca8a04; font-weight:700;">Yellow 80\u201389%</span> = slightly off. <span style="color:#dc2626; font-weight:700;">Red &lt;80%</span> = noticeably off. Employees on vacation are excluded from the overall score.</div>
${fairnessTable}

<div class="footer">RotationOps \u2014 Dispatch Rotation System</div>

<script>window.onload = function(){ window.print(); };<\/script>
</body></html>`);
  w.document.close();
}

// ========== PRINT: MONTHLY ROSTER (landscape, legal paper) ==========
function printMonthRoster(mode) {
  const plan = loadPlan();
  if (!plan || !plan.days) { showToast("No plan loaded. Randomize a month first."); return; }

  const year = plan.meta.year;
  const monthIndex = plan.meta.monthIndex;
  const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();
  const monthNames = ["January","February","March","April","May","June","July","August","September","October","November","December"];
  const dayAbbr = ["SUN","MON","TUE","WED","THU","FRI","SAT"];
  const monthLabel = monthNames[monthIndex] + " " + year;
  const DAY_BLOCKS = ["0600-1000","1000-1400","1400-1800"];
  const NIGHT_BLOCKS = ["1800-2200","2200-0200","0200-0600"];
  const ALL_BLOCKS = DAY_BLOCKS.concat(NIGHT_BLOCKS);
  const chAbbrMap = { "North":"N","South":"S","East":"E","West":"W","Central":"C","Northwest":"NW","Relief 1":"R1","Relief 2":"R2","DC1":"DC1","DC2":"DC2","SD":"SD","CT":"CT","7th":"7th" };

  const modeUp = String(mode || "DAY").toUpperCase();

  // Determine which blocks to show per mode
  let SELBLOCKS, blockShort, shiftLabel;
  if (modeUp === "SPLIT") {
    SELBLOCKS = ALL_BLOCKS;
    blockShort = ["6A","10A","2P","6P","10P","2A"];
    shiftLabel = "Split Shift";
  } else if (modeUp === "SD") {
    SELBLOCKS = ALL_BLOCKS;
    blockShort = ["6A","10A","2P","6P","10P","2A"];
    shiftLabel = "SD (Shift Differential)";
  } else if (modeUp === "NIGHT") {
    SELBLOCKS = NIGHT_BLOCKS;
    blockShort = ["6P","10P","2A"];
    shiftLabel = "Night Shift (6P-6A)";
  } else {
    SELBLOCKS = DAY_BLOCKS;
    blockShort = ["6A","10A","2P"];
    shiftLabel = "Day Shift (6A-6P)";
  }

  // Build people list
  const baseAll = normalizeBase();
  const WEEKDAYS = ["MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY","SUNDAY"];

  // Helper: does this person work blocks in a given shift on any day?
  function worksInShift(rec, shf) {
    if (!rec) return false;
    for (const d of WEEKDAYS) {
      const s = rec[d];
      if (s && blocksWorkedForSchedule(s, shf).size) return true;
    }
    return false;
  }

  // Helper: is this person a split-shift worker (blocks in BOTH day AND night)?
  function isSplitShift(rec) {
    if (!rec) return false;
    return worksInShift(rec, "DAY") && worksInShift(rec, "NIGHT");
  }

  const dispatchers = baseAll
    .filter(r => String(r.Position || "").trim().toUpperCase() === "DISPATCHER")
    .map(r => ({ name: String(r.Employee || "").trim(), seniority: Number(r.Seniority || 0), rec: r }))
    .filter(d => d.name);
  const hires = getNewHires().map(n => String(n).trim()).filter(Boolean)
    .filter(n => dispatchers.every(d => d.name.toUpperCase() !== n.toUpperCase()))
    .map(n => ({ name: n, seniority: 0, rec: null, isHire: true }));
  let people = dispatchers.concat(hires).sort((a, b) => {
    const sa = (isFinite(a.seniority) ? a.seniority : 999999);
    const sb = (isFinite(b.seniority) ? b.seniority : 999999);
    if (sa !== sb) return sa - sb;
    return a.name.localeCompare(b.name);
  });

  // Filter people based on mode
  if (modeUp === "SD") {
    // Only SD_ELIGIBLE people
    people = people.filter(p => SD_ELIGIBLE.has(p.name.toUpperCase()));
  } else if (modeUp === "SPLIT") {
    // Only people who work blocks in both day AND night shifts
    people = people.filter(p => !p.isHire && isSplitShift(p.rec));
  } else if (modeUp === "DAY") {
    // Day-only: exclude split-shift people and SD-only people
    people = people.filter(p => {
      if (SD_ELIGIBLE.has(p.name.toUpperCase())) return false;
      if (!p.isHire && isSplitShift(p.rec)) return false;
      return p.isHire || worksInShift(p.rec, "DAY");
    });
  } else {
    // Night-only: exclude split-shift people and SD-only people
    people = people.filter(p => {
      if (SD_ELIGIBLE.has(p.name.toUpperCase())) return false;
      if (!p.isHire && isSplitShift(p.rec)) return false;
      return p.isHire || worksInShift(p.rec, "NIGHT");
    });
  }

  if (!people.length) { showToast("No people found for " + shiftLabel + " roster."); return; }

  // Build assignment map: assignMap[dk][bk] = Map(NAME -> channel)
  const assignMap = {};
  for (let day = 1; day <= daysInMonth; day++) {
    const d = new Date(year, monthIndex, day, 12, 0, 0, 0);
    const dk = ymd(d);
    assignMap[dk] = {};
    const dayBlocks = (plan.days && plan.days[dk]) ? plan.days[dk] : null;
    for (const bk of SELBLOCKS) {
      const map = new Map();
      if (dayBlocks && dayBlocks[bk]) {
        const entry = dayBlocks[bk];
        for (const [ch, nm] of Object.entries(entry.assignments || {})) map.set(String(nm).trim().toUpperCase(), ch);
        for (const nm of (entry.sd || [])) map.set(String(nm).trim().toUpperCase(), "SD");
        for (const nm of (entry.ct || [])) map.set(String(nm).trim().toUpperCase(), "CT");
      }
      assignMap[dk][bk] = map;
    }
  }

  // For split/SD (6 blocks), use smaller font to fit
  const isSixBlock = (modeUp === "SPLIT" || modeUp === "SD");
  const cellFs = isSixBlock ? "7px" : "9px";
  const cellLh = isSixBlock ? "1.15" : "1.3";
  const nameFs = isSixBlock ? "8px" : "9px";
  const headFs = isSixBlock ? "7px" : "8px";

  // Build table: 1 column per day, cell shows blocks stacked
  let tbl = '<table><thead><tr><th class="name-col">NAME</th>';
  for (let day = 1; day <= daysInMonth; day++) {
    const d = new Date(year, monthIndex, day, 12, 0, 0, 0);
    const dow = d.getDay();
    const isWkend = (dow === 0 || dow === 6);
    tbl += '<th class="day-col' + (isWkend ? ' wkend' : '') + '">' + dayAbbr[dow] + '<br>' + (monthIndex + 1) + '/' + day + '</th>';
  }
  tbl += '</tr></thead><tbody>';

  for (const p of people) {
    tbl += '<tr><td class="name-col">' + p.name.toUpperCase() + '</td>';
    for (let day = 1; day <= daysInMonth; day++) {
      const d = new Date(year, monthIndex, day, 12, 0, 0, 0);
      const dk = ymd(d);
      const dow = d.getDay();
      const dn = ["SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"][dow];
      const rec = p.rec;
      const schedVal = rec ? String(rec[dn] || "").trim().toUpperCase() : "";
      // For split/SD, check all blocks; for day/night, check only that shift's blocks
      const allWorked = rec ? parseShiftToBlocks(schedVal) : new Set();
      const isVac = isExcluded(p.name, new Date(dk + "T12:00:00"));
      const isWkend = (dow === 0 || dow === 6);

      // Check if person works any of the selected blocks this day
      let worksAny = false;
      for (const bk of SELBLOCKS) { if (allWorked.has(bk)) { worksAny = true; break; } }

      if (!worksAny) {
        tbl += '<td class="off' + (isWkend ? ' wkend' : '') + '">OFF</td>';
      } else if (isVac) {
        tbl += '<td class="vac' + (isWkend ? ' wkend' : '') + '">VAC</td>';
      } else {
        let lines = [];
        for (let bi = 0; bi < SELBLOCKS.length; bi++) {
          const bk = SELBLOCKS[bi];
          if (!allWorked.has(bk)) {
            lines.push('<span class="blk-off">-</span>');
          } else {
            const ch = (assignMap[dk] && assignMap[dk][bk]) ? (assignMap[dk][bk].get(p.name.toUpperCase()) || "") : "";
            const ab = ch ? (chAbbrMap[ch] || ch) : "?";
            lines.push('<span class="ch-' + ab.replace(/\s/g,'').toLowerCase() + '">' + ab + '</span>');
          }
        }
        tbl += '<td class="assign' + (isWkend ? ' wkend' : '') + '">' + lines.join('<br>') + '</td>';
      }
    }
    tbl += '</tr>';
  }
  tbl += '</tbody></table>';

  // Block time legend
  let legend = '<div class="legend"><b>Block times:</b> ';
  for (let i = 0; i < SELBLOCKS.length; i++) {
    legend += (i > 0 ? ' &nbsp;|&nbsp; ' : '') + '<b>Line ' + (i+1) + '</b> = ' + blockShort[i];
  }
  legend += ' &nbsp;&nbsp;&bull;&nbsp;&nbsp; <b>N</b>=North <b>E</b>=East <b>S</b>=South <b>W</b>=West <b>NW</b>=Northwest <b>C</b>=Central <b>CT</b>=Call-Taker <b>R1</b>=Relief 1 <b>R2</b>=Relief 2 <b>DC1</b>=Dispatch 1 <b>DC2</b>=Dispatch 2</div>';

  const w = window.open("", "_blank");
  w.document.write(`<!DOCTYPE html><html><head><meta charset="UTF-8"><title>${monthLabel} ${shiftLabel} Roster</title>
<style>
@media print { @page { margin: 0.25in 0.3in; size: 14in 8.5in; } }
* { margin:0; padding:0; box-sizing:border-box; }
body { font-family: Arial, sans-serif; padding: 8px; }
h1 { font-size: 18px; margin-bottom: 2px; font-weight: 900; text-align: center; }
.subtitle { font-size: 10px; color: #555; margin-bottom: 8px; text-align: center; }
table { border-collapse: collapse; width: 100%; table-layout: fixed; }
th, td { border: 1px solid #94a3b8; padding: 3px 2px; text-align: center; vertical-align: middle; }
th { background: #1e293b; color: #fff; font-size: 9px; font-weight: 700; line-height: 1.25; }
th.wkend { background: #334155; }
.name-col { width: 110px; min-width: 110px; max-width: 110px; text-align: left !important; padding-left: 5px !important; font-size: ${nameFs}; font-weight: 700; white-space: nowrap; overflow: hidden; }
th.name-col { background: #1e293b; color: #fff; }
.day-col { font-size: ${headFs}; padding: 3px 0; }
td.off { background: #f1f5f9; color: #b0b8c4; font-size: ${cellFs}; font-weight: 600; }
td.vac { background: #ede9fe; color: #7c3aed; font-size: ${cellFs}; font-weight: 800; }
td.assign { font-size: ${cellFs}; font-weight: 700; line-height: ${cellLh}; padding: 2px 1px; background: #fff; }
td.wkend { background: #f8fafc; }
td.off.wkend { background: #e8ecf1; }
.blk-off { color: #cbd5e1; font-size: ${isSixBlock ? "6px" : "8px"}; }
tr:nth-child(even) td.assign { background: #f9fafb; }
tr:nth-child(even) td.assign.wkend { background: #f1f4f8; }
/* Channel colors */
.ch-n { color: #b45309; }
.ch-e { color: #047857; }
.ch-s { color: #1d4ed8; }
.ch-w { color: #dc2626; }
.ch-nw { color: #7c3aed; }
.ch-c { color: #0369a1; }
.ch-ct { color: #111; background: #e5e7eb; padding: 0 2px; border-radius: 2px; }
.ch-r1 { color: #a16207; }
.ch-r2 { color: #4338ca; }
.ch-dc1 { color: #be185d; }
.ch-dc2 { color: #15803d; }
.ch-sd { color: #6d28d9; }
.ch-7th { color: #0e7490; }
.legend { font-size: 9px; color: #444; margin-top: 6px; line-height: 1.6; text-align: center; }
@media print { .no-print { display: none; } }
</style></head><body>
<h1>${monthLabel} \u2014 ${shiftLabel} Rotation Roster</h1>
<div class="subtitle">Each cell shows ${SELBLOCKS.length} blocks top-to-bottom (${blockShort.join(' / ')}) \u2022 Generated ${new Date().toLocaleDateString()}</div>
${tbl}
${legend}
<script>window.onload = function(){ window.print(); };<\/script>
</body></html>`);
  w.document.close();
}

function renderInfoStats() {
  const plan = loadPlan();
  const stats = calculateFairnessStats();

  // FAIRNESS STATS popup content (includes HOW IT WORKS at top)
  let fairHtml = '';

  fairHtml += `<div class="how-it-works-box" style="padding:10px 14px; margin-bottom:10px; background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.1); border-radius:8px; font-size:11px; line-height:1.7; color:var(--muted);">
    <div style="font-weight:800; font-size:12px; color:var(--text); margin-bottom:6px;">HOW IT WORKS</div>

    <div style="margin-bottom:8px;">
      <b style="color:var(--text);">1.</b> The system generates hundreds of complete monthly schedules and keeps the fairest one.<br>
      <b style="color:var(--text);">2.</b> It then fine-tunes by swapping assignments between people to even out the distribution.
    </div>

    <div style="font-weight:700; font-size:11px; color:var(--text); margin-top:8px; margin-bottom:4px;">WHAT THE SYSTEM BALANCES</div>
    <div style="margin-bottom:6px;">
      \u2022 <b style="color:var(--text);">Primary channels</b> \u2014 North, East, South, West, Northwest, and Central are distributed as evenly as possible across everyone on the same shift.<br>
      \u2022 <b style="color:var(--text);">DC Desk &amp; Relief</b> \u2014 DC1, DC2, Relief 1, and Relief 2 are included in the rotation and balanced alongside primary channels.<br>
      \u2022 <b style="color:var(--text);">Call-Taker</b> \u2014 CT assignments are spread evenly so no one gets stuck on phones more than anyone else.<br>
      \u2022 <b style="color:var(--text);">7th Channel</b> \u2014 Added on Friday and Saturday nights and distributed evenly.<br>
      \u2022 <b style="color:var(--text);">Vacations</b> \u2014 Employees on vacation are excluded from those days. Their fairness is measured only against the days they actually work.<br>
      \u2022 <b style="color:var(--text);">Trainees</b> \u2014 Limited to East, South, West, and Central. Excluded from the fairness score since they can\u2019t rotate through all channels.
    </div>

    <div style="font-weight:700; font-size:11px; color:var(--text); margin-top:8px; margin-bottom:4px;">FAIRNESS %</div>
    <div style="margin-bottom:6px;">Shows how close each person\u2019s assignments are to what they should have gotten based on their availability. 100% = perfectly even. <span style="color:#22c55e">Green 90%+</span> = fair. <span style="color:#f59e0b">Yellow 80\u201389%</span> = slightly off. <span style="color:#ef4444">Red &lt;80%</span> = noticeably off. Employees on vacation and trainees are excluded from the overall fairness score since they can\u2019t rotate through all channels.</div>

    <div style="margin-top:12px; text-align:center;"><button onclick="printHowItWorks()" style="background:#4aa3ff; color:#fff; border:none; border-radius:6px; padding:8px 20px; font-size:12px; font-weight:700; cursor:pointer;">PRINT THIS PAGE</button></div>
  </div>`;

  if (stats) {
    const scoreClass = stats.fairnessScore === 'EXCELLENT' ? 'good' : stats.fairnessScore === 'GOOD' ? 'good' : stats.fairnessScore === 'FAIR' ? 'warn' : 'bad';
    const sorted = Array.from(stats.empStats.entries()).sort((a,b) => b[1].total - a[1].total);

    fairHtml += `<div style="display:flex; gap:8px; margin-bottom:10px;">
      <div class="stat-card" style="flex:1; padding:6px 8px;">
        <div class="stat-value" style="font-size:16px;">${stats.totalAssignments}</div>
        <div class="stat-label" style="font-size:9px;">TOTAL</div>
      </div>
      <div class="stat-card" style="flex:1; padding:6px 8px;">
        <div class="stat-value" style="font-size:16px;">${stats.empStats.size}</div>
        <div class="stat-label" style="font-size:9px;">EMPLOYEES</div>
      </div>
      <div class="stat-card" style="flex:1; padding:6px 8px;">
        <div class="stat-value" style="font-size:16px;">${stats.avgPerPerson.toFixed(1)}</div>
        <div class="stat-label" style="font-size:9px;">AVG/PERSON</div>
      </div>
      <div class="stat-card ${scoreClass}" style="flex:1; padding:6px 8px;">
        <div class="stat-value" style="font-size:16px;">${stats.fairnessScore}</div>
        <div class="stat-label" style="font-size:9px;">SPREAD: ${stats.spread}</div>
      </div>
    </div>`;

    fairHtml += '<div style="overflow:auto; max-height:360px;">';
    fairHtml += '<table style="width:100%; font-size:11px;"><thead><tr><th>NAME</th><th>TOTAL</th><th>EXPECTED</th><th>7TH</th><th>CT</th><th>FAIRNESS %</th></tr></thead><tbody>';
    sorted.forEach(([name, s]) => {
      const fairPct = s.expected > 0 ? Math.round(100 - (Math.abs(s.total - s.expected) / s.expected) * 100) : 100;
      const clampedPct = Math.max(0, Math.min(100, fairPct));
      const pctClass = clampedPct >= 90 ? 'color:#22c55e' : clampedPct >= 80 ? 'color:#f59e0b' : 'color:#ef4444';
      const seventh = s.channels[SEVENTH_CHANNEL] || 0;
      const vacLabel = s.isVacation ? ' <span style="color:#f59e0b; font-size:9px; font-weight:700;">VAC</span>' : '';
      const trnLabel = s.isTrainee ? ' <span style="color:#38bdf8; font-size:9px; font-weight:700;">TRN</span>' : '';
      const dimRow = s.isVacation || s.isTrainee;
      fairHtml += `<tr style="${dimRow ? 'opacity:0.6;' : ''}">
        <td style="text-align:left; font-weight:600;">${escapeHtml(name)}${vacLabel}${trnLabel}</td>
        <td>${s.total}</td>
        <td>${s.expected.toFixed(1)}</td>
        <td>${seventh}</td>
        <td>${s.ct}</td>
        <td style="${pctClass}; font-weight:700;">${clampedPct}%</td>
      </tr>`;
    });
    fairHtml += '</tbody></table></div>';
  } else {
    fairHtml = '<div style="text-align:center; color:var(--muted); padding:20px;">NO DATA — RANDOMIZE A MONTH FIRST</div>';
  }

  // CHANNEL TOTALS popup content
  let chTotalsHtml = '';
  if (plan && plan.days) {
    chTotalsHtml = renderStatsHtml(plan);
  } else {
    chTotalsHtml = '<div style="text-align:center; color:var(--muted); padding:20px;">NO DATA — RANDOMIZE A MONTH FIRST</div>';
  }

  // Write to popups
  const fairEl = document.getElementById("fairnessPopupContent");
  if (fairEl) fairEl.innerHTML = fairHtml;
  const chEl = document.getElementById("channelTotalsPopupContent");
  if (chEl) chEl.innerHTML = chTotalsHtml;
}

function boot() {
  normalizeBase();
  initSelectors();
  const ui = loadJSON(STORAGE.ui, {});
  if (ui && ui.tab) setActiveTab(ui.tab);

  // ===== Channel Flash Text =====
  const channelInner = document.getElementById("channelInner");
  if (channelInner) {
    const channels = ["N","E","S","W","NW","C","DC1","DC2","R1","R2","CT"];
    let ci = 0;
    channelInner.textContent = channels[0];
    channelInner.style.transition = "transform .2s ease-in";
    setInterval(() => {
      channelInner.style.transform = "rotateX(90deg)";
      setTimeout(() => {
        ci = (ci + 1) % channels.length;
        channelInner.textContent = channels[ci];
        channelInner.style.transition = "none";
        channelInner.style.transform = "rotateX(-90deg)";
        requestAnimationFrame(() => {
          channelInner.style.transition = "transform .2s ease-out";
          channelInner.style.transform = "rotateX(0deg)";
        });
      }, 200);
    }, 500);
  }

  document.getElementById("dayPick").value = operationalToday();

  // Pill popup toggles (HOW IT WORKS, FAIRNESS STATS, CHANNEL TOTALS)
  const popups = [
    { btn: "btnFairnessStats", popup: "fairnessPopup" },
    { btn: "btnChannelTotals", popup: "channelTotalsPopup" },
    { btn: "btnTechInfo", popup: "techInfoPopup" }
  ];
  popups.forEach(({ btn: btnId, popup: popupId }) => {
    const btn = document.getElementById(btnId);
    const popup = document.getElementById(popupId);
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      // Close other popups first
      popups.forEach(p => {
        if (p.popup !== popupId) document.getElementById(p.popup).style.display = "none";
      });
      popup.style.display = popup.style.display === "none" ? "block" : "none";
      // Re-populate stats when opening
      if (popup.style.display === "block") renderInfoStats();
    });
  });
  document.addEventListener("click", (e) => {
    popups.forEach(({ btn: btnId, popup: popupId }) => {
      const btn = document.getElementById(btnId);
      const popup = document.getElementById(popupId);
      if (!popup.contains(e.target) && e.target !== btn) {
        popup.style.display = "none";
      }
    });
  });

  // EXPORT OPEN SHIFTS button
  document.getElementById("btnExportNeeds").addEventListener("click", () => { exportNeedsXlsx(); });
  document.getElementById("btnExportNeedsDay").addEventListener("click", () => { exportNeedsDayXlsx(); });
  document.getElementById("btnExportNeedsWeek").addEventListener("click", () => { exportNeedsWeekXlsx(); });

  // PRINT ROSTER dropdown
  document.getElementById("btnPrintRoster").addEventListener("click", (e) => {
    e.stopPropagation();
    const menu = document.getElementById("printRosterMenu");
    menu.style.display = menu.style.display === "none" ? "block" : "none";
  });
  document.querySelectorAll(".print-roster-opt").forEach(opt => {
    opt.addEventListener("mouseenter", () => { opt.style.background = "rgba(255,255,255,.1)"; });
    opt.addEventListener("mouseleave", () => { opt.style.background = ""; });
    opt.addEventListener("click", () => {
      document.getElementById("printRosterMenu").style.display = "none";
      const mode = opt.getAttribute("data-mode");
      if (mode === "ALL") {
        ["DAY","NIGHT","SPLIT","SD"].forEach(m => printMonthRoster(m));
      } else {
        printMonthRoster(mode);
      }
    });
  });
  document.addEventListener("click", (e) => {
    const menu = document.getElementById("printRosterMenu");
    const btn = document.getElementById("btnPrintRoster");
    if (menu && btn && !menu.contains(e.target) && e.target !== btn) menu.style.display = "none";
  });

  // EXPORT dropdown toggle
  document.getElementById("btnExportMenu").addEventListener("click", (e) => {
    e.stopPropagation();
    const dd = document.getElementById("exportDropdown");
    dd.style.display = dd.style.display === "none" ? "block" : "none";
  });
  document.addEventListener("click", (e) => {
    const wrap = document.getElementById("exportDropdownWrap");
    if (wrap && !wrap.contains(e.target)) {
      document.getElementById("exportDropdown").style.display = "none";
    }
  });
  // Close dropdown when any export option is clicked (use setTimeout so click fires first)
  ["btnExportTotals","btnExportCSV","btnExportMonthCSV","btnPushShiftOps"].forEach(id => {
    document.getElementById(id).addEventListener("click", () => {
      setTimeout(() => { document.getElementById("exportDropdown").style.display = "none"; }, 50);
    });
  });

  // EXPORT TOTALS button
  document.getElementById("btnExportTotals").addEventListener("click", () => {
    const plan = loadPlan();
    if (!plan || !plan.days) { showToast("No plan to export. Randomize first."); return; }

    const PRIMARY = ["North","South","East","West","Central","Northwest"];
    const RELIEF_SET = new Set(["Relief 1","Relief 2"]);
    const DC_SET_E = new Set(["DC1","DC2"]);
    const DAY_BLOCKS_E = new Set(["0600-1000","1000-1400","1400-1800"]);

    function _emptyRow() { return { North:0, South:0, East:0, West:0, Central:0, Northwest:0, r1:0, r2:0, ct:0, dc1:0, dc2:0, sd:0, total:0 }; }

    const allTotals = new Map();
    const personShifts = new Map();

    for (const [dayKey, blocks] of Object.entries(plan.days || {})) {
      for (const b of BLOCKS) {
        const entry = blocks[b.key];
        if (!entry) continue;
        const isDay = DAY_BLOCKS_E.has(b.key);

        for (const [ch, nm] of Object.entries(entry.assignments || {})) {
          if (!nm) continue;
          const name = String(nm).trim().toUpperCase();
          if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
          if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
          const row = allTotals.get(name);
          if (PRIMARY.includes(ch)) row[ch]++;
          else if (ch === "Relief 1") row.r1++;
          else if (ch === "Relief 2") row.r2++;
          else if (ch === "DC1") row.dc1++;
          else if (ch === "DC2") row.dc2++;
          row.total++;
          if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
        }
        for (const nm of (entry.ct || [])) {
          const name = String(nm).trim().toUpperCase();
          if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
          if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
          allTotals.get(name).ct++; allTotals.get(name).total++;
          if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
        }
        for (const nm of (entry.sd || [])) {
          const name = String(nm).trim().toUpperCase();
          if (!allTotals.has(name)) allTotals.set(name, _emptyRow());
          if (!personShifts.has(name)) personShifts.set(name, { day: false, night: false });
          allTotals.get(name).sd++;
          if (isDay) personShifts.get(name).day = true; else personShifts.get(name).night = true;
        }
      }
    }

    // Count back-to-back primary channel pairs per person
    const b2bCounts = new Map(); // name -> count of b2b pairs
    const _b2bPrimary = new Set(["NORTH","SOUTH","EAST","WEST","NORTHWEST","CENTRAL"]);
    for (const [dayKey, blocks] of Object.entries(plan.days || {})) {
      for (let bi = 0; bi < BLOCKS.length - 1; bi++) {
        const currBlock = blocks[BLOCKS[bi].key];
        const nextBlock = blocks[BLOCKS[bi+1].key];
        if (!currBlock || !nextBlock) continue;
        // Build person -> channel for each block
        const currMap = new Map();
        for (const [ch, nm] of Object.entries(currBlock.assignments || {})) {
          if (nm) currMap.set(String(nm).trim().toUpperCase(), ch.toUpperCase());
        }
        const nextMap = new Map();
        for (const [ch, nm] of Object.entries(nextBlock.assignments || {})) {
          if (nm) nextMap.set(String(nm).trim().toUpperCase(), ch.toUpperCase());
        }
        for (const [name, currCh] of currMap) {
          if (!_b2bPrimary.has(currCh)) continue;
          if (nextMap.get(name) === currCh) {
            b2bCounts.set(name, (b2bCounts.get(name) || 0) + 1);
          }
        }
      }
    }

    // Group into 4 categories
    const groups = { "SD ELIGIBLE": new Map(), "DAY SHIFT": new Map(), "NIGHT SHIFT": new Map(), "SPLIT SHIFT": new Map() };
    for (const [name, row] of allTotals) {
      if (SD_ELIGIBLE.has(name)) groups["SD ELIGIBLE"].set(name, row);
      else {
        const s = personShifts.get(name);
        if (s.day && s.night) groups["SPLIT SHIFT"].set(name, row);
        else if (s.day) groups["DAY SHIFT"].set(name, row);
        else groups["NIGHT SHIFT"].set(name, row);
      }
    }

    const meta = plan.meta || {};
    const hdr = "NAME\tN\tS\tE\tW\tC\tNW\tR1\tR2\tR_TOT\tCT\tDC1\tDC2\tDC_TOT\tSD\tTOTAL\tB2B";
    let txt = `ROTATION EXPORT — ${monthName(meta.monthIndex || 0)} ${meta.year || ""}\n`;
    txt += `Generated: ${new Date().toLocaleString()}\n`;
    txt += `Violations: ${window.lastRandomizeStats?.totalViolations ?? "?"}\n\n`;

    for (const [groupName, map] of Object.entries(groups)) {
      const names = Array.from(map.keys()).sort();
      if (names.length === 0) continue;

      txt += `=== ${groupName} (${names.length} people) ===\n`;
      txt += hdr + "\n";

      let avgRow = _emptyRow(); avgRow.r1 = 0; avgRow.r2 = 0; avgRow.dc1 = 0; avgRow.dc2 = 0;
      for (const name of names) {
        const r = map.get(name);
        const rTot = r.r1 + r.r2;
        const dcTot = r.dc1 + r.dc2;
        const grand = r.total + r.sd;
        const b2b = b2bCounts.get(name) || 0;
        txt += `${name}\t${r.North}\t${r.South}\t${r.East}\t${r.West}\t${r.Central}\t${r.Northwest}\t${r.r1}\t${r.r2}\t${rTot}\t${r.ct}\t${r.dc1}\t${r.dc2}\t${dcTot}\t${r.sd}\t${grand}\t${b2b}\n`;
        for (const ch of PRIMARY) avgRow[ch] += r[ch];
        avgRow.r1 += r.r1; avgRow.r2 += r.r2; avgRow.ct += r.ct; avgRow.dc1 += r.dc1; avgRow.dc2 += r.dc2; avgRow.sd += r.sd; avgRow.total += r.total; avgRow.b2b = (avgRow.b2b || 0) + b2b;
      }
      const n = names.length;
      const aR = (avgRow.r1 + avgRow.r2) / n;
      const aDC = (avgRow.dc1 + avgRow.dc2) / n;
      const aB2B = (avgRow.b2b || 0) / n;
      txt += `AVG\t${(avgRow.North/n).toFixed(1)}\t${(avgRow.South/n).toFixed(1)}\t${(avgRow.East/n).toFixed(1)}\t${(avgRow.West/n).toFixed(1)}\t${(avgRow.Central/n).toFixed(1)}\t${(avgRow.Northwest/n).toFixed(1)}\t${(avgRow.r1/n).toFixed(1)}\t${(avgRow.r2/n).toFixed(1)}\t${aR.toFixed(1)}\t${(avgRow.ct/n).toFixed(1)}\t${(avgRow.dc1/n).toFixed(1)}\t${(avgRow.dc2/n).toFixed(1)}\t${aDC.toFixed(1)}\t${(avgRow.sd/n).toFixed(1)}\t${((avgRow.total+avgRow.sd)/n).toFixed(1)}\t${aB2B.toFixed(1)}\n`;

      // Min/Max row
      let mins = _emptyRow(), maxs = _emptyRow();
      for (const ch of PRIMARY) { mins[ch] = Infinity; maxs[ch] = 0; }
      mins.r1 = Infinity; mins.r2 = Infinity; mins.ct = Infinity; mins.dc1 = Infinity; mins.dc2 = Infinity; mins.sd = Infinity;
      maxs.r1 = 0; maxs.r2 = 0; maxs.ct = 0; maxs.dc1 = 0; maxs.dc2 = 0; maxs.sd = 0;
      let minRTot = Infinity, maxRTot = 0, minDCTot = Infinity, maxDCTot = 0, minGrand = Infinity, maxGrand = 0;
      let minB2B = Infinity, maxB2B = 0;
      for (const name of names) {
        const r = map.get(name);
        for (const ch of PRIMARY) { mins[ch] = Math.min(mins[ch], r[ch]); maxs[ch] = Math.max(maxs[ch], r[ch]); }
        mins.r1 = Math.min(mins.r1, r.r1); maxs.r1 = Math.max(maxs.r1, r.r1);
        mins.r2 = Math.min(mins.r2, r.r2); maxs.r2 = Math.max(maxs.r2, r.r2);
        mins.ct = Math.min(mins.ct, r.ct); maxs.ct = Math.max(maxs.ct, r.ct);
        mins.dc1 = Math.min(mins.dc1, r.dc1); maxs.dc1 = Math.max(maxs.dc1, r.dc1);
        mins.dc2 = Math.min(mins.dc2, r.dc2); maxs.dc2 = Math.max(maxs.dc2, r.dc2);
        mins.sd = Math.min(mins.sd, r.sd); maxs.sd = Math.max(maxs.sd, r.sd);
        const rT = r.r1+r.r2, dT = r.dc1+r.dc2, g = r.total+r.sd;
        minRTot = Math.min(minRTot, rT); maxRTot = Math.max(maxRTot, rT);
        minDCTot = Math.min(minDCTot, dT); maxDCTot = Math.max(maxDCTot, dT);
        minGrand = Math.min(minGrand, g); maxGrand = Math.max(maxGrand, g);
        const b2b = b2bCounts.get(name) || 0;
        minB2B = Math.min(minB2B, b2b); maxB2B = Math.max(maxB2B, b2b);
      }
      txt += `MIN\t${mins.North}\t${mins.South}\t${mins.East}\t${mins.West}\t${mins.Central}\t${mins.Northwest}\t${mins.r1}\t${mins.r2}\t${minRTot}\t${mins.ct}\t${mins.dc1}\t${mins.dc2}\t${minDCTot}\t${mins.sd}\t${minGrand}\t${minB2B}\n`;
      txt += `MAX\t${maxs.North}\t${maxs.South}\t${maxs.East}\t${maxs.West}\t${maxs.Central}\t${maxs.Northwest}\t${maxs.r1}\t${maxs.r2}\t${maxRTot}\t${maxs.ct}\t${maxs.dc1}\t${maxs.dc2}\t${maxDCTot}\t${maxs.sd}\t${maxGrand}\t${maxB2B}\n`;
      txt += `SPREAD\t${maxs.North-mins.North}\t${maxs.South-mins.South}\t${maxs.East-mins.East}\t${maxs.West-mins.West}\t${maxs.Central-mins.Central}\t${maxs.Northwest-mins.Northwest}\t${maxs.r1-mins.r1}\t${maxs.r2-mins.r2}\t${maxRTot-minRTot}\t${maxs.ct-mins.ct}\t${maxs.dc1-mins.dc1}\t${maxs.dc2-mins.dc2}\t${maxDCTot-minDCTot}\t${maxs.sd-mins.sd}\t${maxGrand-minGrand}\t${maxB2B-minB2B}\n`;
      txt += "\n";
    }

    // Copy to clipboard and download
    navigator.clipboard.writeText(txt).then(() => showToast("Exported & copied to clipboard!")).catch(() => {});
    const blob = new Blob([txt], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `rotation_totals_${meta.year || ""}_${String((meta.monthIndex||0)+1).padStart(2,"0")}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  });

  // EXPORT CSV button — formatted Excel document (HTML table → .xls, Excel 2007 compatible)
  document.getElementById("btnExportCSV").addEventListener("click", () => {
    const plan = loadPlan();
    if (!plan || !plan.days) { showToast("No plan to export. Randomize first."); return; }

    const meta = plan.meta || {};
    const year = meta.year || new Date().getFullYear();
    const monthIndex = meta.monthIndex ?? new Date().getMonth();
    const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();
    const dayAbbr = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
    const chAbbrMap = { "North":"N","South":"S","East":"E","West":"W","Central":"C","Northwest":"NW","Relief 1":"R1","Relief 2":"R2","DC1":"DC1","DC2":"DC2","SD":"SD","CT":"CT","7th":"7th" };
    const chColor = {
      "N":"#fef3c7","E":"#d1fae5","S":"#dbeafe","W":"#fee2e2","NW":"#ede9fe","C":"#e0f2fe",
      "CT":"#f3f4f6","R1":"#fef9c3","R2":"#e0e7ff","DC1":"#fce7f3","DC2":"#dcfce7","SD":"#f5f3ff","7th":"#cffafe"
    };

    function exportShift(shiftName, selBlocks, blockShort) {
      const shift = shiftName;
      // Build people list
      const baseAll = normalizeBase();
      function worksAnyInShift(rec) {
        if (!rec) return false;
        const days = ["MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY","SUNDAY"];
        for (const d of days) {
          const s = rec[d];
          if (s && blocksWorkedForSchedule(s, shift).size) return true;
        }
        return false;
      }
      const dispatchers = baseAll
        .filter(r => String(r.Position || "").trim().toUpperCase() === "DISPATCHER")
        .map(r => ({ name: String(r.Employee || "").trim(), seniority: Number(r.Seniority || 0), rec: r }))
        .filter(d => d.name);
      const hires = getNewHires().map(n => String(n).trim()).filter(Boolean)
        .filter(n => dispatchers.every(d => d.name.toUpperCase() !== n.toUpperCase()))
        .map(n => ({ name: n, seniority: 0, rec: null, isHire: true }));
      let people = dispatchers.concat(hires).sort((a, b) => {
        const sa = (isFinite(a.seniority) ? a.seniority : 999999);
        const sb = (isFinite(b.seniority) ? b.seniority : 999999);
        if (sa !== sb) return sa - sb;
        return a.name.localeCompare(b.name);
      });
      people = people.filter(p => p.isHire || worksAnyInShift(p.rec));

      // Build assignment map
      const assignMap = {};
      for (let day = 1; day <= daysInMonth; day++) {
        const d = new Date(year, monthIndex, day, 12, 0, 0, 0);
        const dk = ymd(d);
        assignMap[dk] = {};
        const dayBlocks = (plan.days && plan.days[dk]) ? plan.days[dk] : null;
        for (const bk of selBlocks) {
          const map = new Map();
          if (dayBlocks && dayBlocks[bk]) {
            const entry = dayBlocks[bk];
            for (const [ch, nm] of Object.entries(entry.assignments || {})) map.set(String(nm).trim().toUpperCase(), ch);
            for (const nm of (entry.sd || [])) map.set(String(nm).trim().toUpperCase(), "SD");
            for (const nm of (entry.ct || [])) map.set(String(nm).trim().toUpperCase(), "CT");
          }
          assignMap[dk][bk] = map;
        }
      }

      const numCols = 1 + daysInMonth;

      // Header row 1: day names
      let h = '<tr><td class="name-hdr" rowspan="2">' + shiftName + ' SHIFT</td>';
      for (let day = 1; day <= daysInMonth; day++) {
        const d = new Date(year, monthIndex, day, 12, 0, 0, 0);
        const dow = d.getDay();
        const isWkend = (dow === 0 || dow === 6);
        h += '<td class="day-hdr" style="' + (isWkend ? 'background:#CBD5E1;' : '') + '">' + dayAbbr[dow] + '<br>' + (monthIndex+1) + '/' + day + '</td>';
      }
      h += '</tr>';

      // Header row 2: block labels
      h += '<tr>';
      for (let day = 1; day <= daysInMonth; day++) {
        h += '<td class="blk-hdr">' + blockShort.join(' / ') + '</td>';
      }
      h += '</tr>';

      // Person rows
      for (let pi = 0; pi < people.length; pi++) {
        const p = people[pi];
        const cls = (pi % 2 === 0) ? 'row-even' : 'row-odd';
        h += '<tr><td class="name-col ' + cls + '">' + p.name.toUpperCase() + '</td>';
        for (let day = 1; day <= daysInMonth; day++) {
          const d = new Date(year, monthIndex, day, 12, 0, 0, 0);
          const dk = ymd(d);
          const dow = d.getDay();
          const dn = ["SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"][dow];
          const rec = p.rec;
          const schedVal = rec ? String(rec[dn] || "").trim().toUpperCase() : "";
          const worked = rec ? blocksWorkedForSchedule(schedVal, shift) : new Set();
          const isVac = isExcluded(p.name, new Date(dk + "T12:00:00"));

          let worksAny = false;
          for (const bk of selBlocks) { if (worked.has(bk)) { worksAny = true; break; } }

          if (!worksAny) {
            h += '<td class="cell-off ' + cls + '">OFF</td>';
          } else if (isVac) {
            h += '<td class="cell-vac ' + cls + '">VAC</td>';
          } else {
            const lines = [];
            for (const bk of selBlocks) {
              if (!worked.has(bk)) { lines.push('-'); continue; }
              const ch = (assignMap[dk] && assignMap[dk][bk]) ? (assignMap[dk][bk].get(p.name.toUpperCase()) || "") : "";
              const ab = ch ? (chAbbrMap[ch] || ch) : "?";
              const otEntry = plan.days[dk] && plan.days[dk][bk];
              const isOT = ch && otEntry && (otEntry.ot || []).some(n => String(n).toUpperCase() === p.name.toUpperCase());
              lines.push(ab + (isOT ? ' OT' : ''));
            }
            // Color based on first non-dash assignment
            const firstCh = lines.find(l => l !== '-' && l !== '?') || '';
            const baseAb = firstCh.replace(' OT', '');
            const bg = chColor[baseAb] || '#FFFFFF';
            h += '<td class="' + cls + '" style="background:' + bg + '; font-size:9pt; font-weight:600; white-space:nowrap;">' + lines.join('<br>') + '</td>';
          }
        }
        h += '</tr>';
      }
      return h;
    }

    const dayBlocks = ["0600-1000","1000-1400","1400-1800"];
    const nightBlocks = ["1800-2200","2200-0200","0200-0600"];

    let h = `<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">
<head><meta charset="utf-8">
<!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet>
<x:Name>Roster</x:Name>
<x:WorksheetOptions><x:FitToPage/><x:Print><x:FitWidth>1</x:FitWidth><x:Orientation>Landscape</x:Orientation></x:Print></x:WorksheetOptions>
</x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]-->
<style>
  td, th { font-family: Calibri, Arial, sans-serif; font-size: 10pt; padding: 3px 4px; border: 1px solid #CBD5E1; text-align: center; vertical-align: middle; }
  .title { font-size: 16pt; font-weight: 900; color: #1E293B; border: none; text-align: left; padding: 6px 4px 2px; }
  .subtitle { font-size: 10pt; color: #64748B; border: none; text-align: left; padding: 2px 4px 6px; }
  .name-hdr { background: #1E293B; color: #FFFFFF; font-size: 11pt; font-weight: 800; text-align: left; padding: 4px 8px; }
  .day-hdr { background: #374151; color: #FFFFFF; font-size: 8pt; font-weight: 700; }
  .blk-hdr { background: #4B5563; color: #D1D5DB; font-size: 7pt; }
  .name-col { text-align: left; font-weight: 700; font-size: 10pt; padding-left: 6px; white-space: nowrap; }
  .row-even { background: #FFFFFF; }
  .row-odd { background: #F8FAFC; }
  .cell-off { color: #94A3B8; font-size: 8pt; }
  .cell-vac { background: #EDE9FE !important; color: #7C3AED; font-weight: 700; font-size: 9pt; }
</style>
</head><body>
<table cellspacing="0" cellpadding="0">`;

    const numCols = 1 + daysInMonth;
    h += `<tr><td class="title" colspan="${numCols}">${monthName(monthIndex)} ${year} &mdash; Rotation Roster</td></tr>`;
    h += `<tr><td class="subtitle" colspan="${numCols}">Generated: ${new Date().toLocaleString()} &nbsp;&nbsp;|&nbsp;&nbsp; Each cell: 3 blocks top-to-bottom</td></tr>`;
    h += `<tr><td colspan="${numCols}" style="border:none; height:8px;">&nbsp;</td></tr>`;

    // Day shift
    h += exportShift("DAY", dayBlocks, ["6A","10A","2P"]);
    h += `<tr><td colspan="${numCols}" style="border:none; height:12px;">&nbsp;</td></tr>`;
    // Night shift
    h += exportShift("NIGHT", nightBlocks, ["6P","10P","2A"]);

    h += `</table></body></html>`;

    const blob = new Blob(["\uFEFF" + h], { type: "application/vnd.ms-excel;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `rotation_roster_${year}_${String(monthIndex+1).padStart(2,"0")}.xls`;
    a.click();
    URL.revokeObjectURL(url);
    showToast("Excel roster exported!");
  });

  // EXPORT CSV button — full month assignments as CSV for Excel 2007+
  document.getElementById("btnExportMonthCSV").addEventListener("click", () => {
    const plan = loadPlan();
    if (!plan || !plan.days) { showToast("No plan to export. Randomize first."); return; }
    const meta = plan.meta || {};
    const year = meta.year || new Date().getFullYear();
    const monthIndex = meta.monthIndex ?? new Date().getMonth();
    const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();
    const dayNames = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
    const ctrSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);

    // Build person assignment sequences for violation detection (same as renderMonth)
    const personAssignments = new Map();
    const daysList = [];
    for (let day = 1; day <= daysInMonth; day++) daysList.push(new Date(year, monthIndex, day, 12, 0, 0, 0));

    for (const d of daysList) {
      const dayKey = ymd(d);
      const blocks = plan.days[dayKey];
      if (!blocks) continue;
      BLOCKS.forEach((b, bi) => {
        const entry = blocks[b.key];
        if (!entry) return;
        if (entry.assignments) {
          for (const [ch, nm] of Object.entries(entry.assignments)) {
            if (!nm) continue;
            const nameUpper = String(nm).toUpperCase();
            if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
            personAssignments.get(nameUpper).push({ dayKey, blockKey: b.key, blockIdx: bi, channel: ch, dayNum: d.getDate() });
          }
        }
        if (entry.ct && entry.ct.length) {
          for (const nm of entry.ct) {
            const nameUpper = String(nm).toUpperCase();
            if (!personAssignments.has(nameUpper)) personAssignments.set(nameUpper, []);
            personAssignments.get(nameUpper).push({ dayKey, blockKey: b.key, blockIdx: bi, channel: "CT", dayNum: d.getDate() });
          }
        }
      });
    }

    // Detect violations
    const violationCells = new Map(); // "dayKey|blockKey|name" -> violationType
    for (const [name, assignments] of personAssignments) {
      assignments.sort((a, b) => a.dayNum !== b.dayNum ? a.dayNum - b.dayNum : a.blockIdx - b.blockIdx);
      const dayChannels = new Map();
      for (let i = 0; i < assignments.length; i++) {
        const curr = assignments[i];
        const chUpper = String(curr.channel).toUpperCase();
        if (!dayChannels.has(curr.dayKey)) dayChannels.set(curr.dayKey, new Map());
        const dayCh = dayChannels.get(curr.dayKey);
        if (dayCh.has(chUpper) && chUpper !== "SD") {
          const _primB2B = new Set(["NORTH","SOUTH","EAST","WEST","NORTHWEST","CENTRAL","CT","RELIEF 1","RELIEF 2"]);
          const isAllowedB2B = _primB2B.has(chUpper) && i > 0 &&
            String(assignments[i-1].channel).toUpperCase() === chUpper &&
            curr.dayKey === assignments[i-1].dayKey &&
            curr.blockIdx === assignments[i-1].blockIdx + 1 &&
            (dayCh.get(chUpper) || 0) < 2;
          if (!isAllowedB2B) {
            violationCells.set(`${curr.dayKey}|${curr.blockKey}|${name}`, "Same channel repeated");
          }
        }
        dayCh.set(chUpper, (dayCh.get(chUpper) || 0) + 1);
      }

      // Weekly CT/Relief/DC cap violations
      const _ctWkX = new Map(); // weekKey -> {ct:[], relief:[], dc:[]}
      for (const a of assignments) {
        const _dX = new Date(year, monthIndex, a.dayNum, 12, 0, 0, 0);
        const _wkX = weekKeyFromDate(_dX);
        if (!_ctWkX.has(_wkX)) _ctWkX.set(_wkX, {ct:[], relief:[], dc:[]});
        const bucket = _ctWkX.get(_wkX);
        const aUp = String(a.channel).toUpperCase();
        if (aUp === "CT") bucket.ct.push(a);
        else if (aUp === "RELIEF 1" || aUp === "RELIEF 2") bucket.relief.push(a);
        else if (aUp === "DC1" || aUp === "DC2") bucket.dc.push(a);
      }
      for (const [_wk, bucket] of _ctWkX) {
        if (bucket.ct.length > 2) {
          for (const a of bucket.ct) violationCells.set(`${a.dayKey}|${a.blockKey}|${name}`, "CT over 8hr weekly max");
        }
        if (bucket.relief.length > 2) {
          for (const a of bucket.relief) violationCells.set(`${a.dayKey}|${a.blockKey}|${name}`, "Relief over 8hr weekly max");
        }
        if (bucket.dc.length > 2) {
          for (const a of bucket.dc) violationCells.set(`${a.dayKey}|${a.blockKey}|${name}`, "DC over 8hr weekly max");
        }
      }
    }

    // Build previous assignment lookup: for each person, track their last channel per block
    const prevAssignLookup = new Map(); // "dayKey|blockKey|name" -> prevChannel
    for (const [name, assignments] of personAssignments) {
      for (let i = 0; i < assignments.length; i++) {
        if (i > 0) {
          prevAssignLookup.set(`${assignments[i].dayKey}|${assignments[i].blockKey}|${name}`, assignments[i - 1].channel);
        }
      }
    }

    // Build CSV rows
    const esc = (v) => { const s = String(v ?? ""); return /[,"\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s; };
    const rows = [["Date","Day","Block","Employee","Assignment","PrevAssignment","Violation","ViolationType"]];

    for (const d of daysList) {
      const dayKey = ymd(d);
      const dow = dayNames[d.getDay()];
      const dateStr = `${monthIndex + 1}/${d.getDate()}/${year}`;
      const blocks = plan.days[dayKey];
      if (!blocks) continue;

      for (const b of BLOCKS) {
        const entry = blocks[b.key];
        if (!entry) continue;
        const blockLabel = b.label.replace(/—/g, "–");

        // Collect all assignments for this block into an array, then sort by employee
        const blockRows = [];

        // Channel assignments
        for (const ch of CHANNELS) {
          const nm = (entry.assignments || {})[ch] || "";
          if (nm) {
            const nameUpper = String(nm).toUpperCase();
            const vKey = `${dayKey}|${b.key}|${nameUpper}`;
            const prev = prevAssignLookup.get(vKey) || "";
            const viol = violationCells.has(vKey) ? "YES" : "";
            const violType = violationCells.get(vKey) || "";
            blockRows.push([dateStr, dow, blockLabel, nameUpper, ch, prev, viol, violType]);
          }
        }

        // 7th channel (Fri/Sat night blocks)
        const isFriSat = (d.getDay() === 5 || d.getDay() === 6);
        if (isFriSat && SEVENTH_BLOCKS.has(b.key)) {
          const nm7 = (entry.assignments || {})[SEVENTH_CHANNEL] || "";
          if (nm7) {
            const nameUpper = String(nm7).toUpperCase();
            const vKey = `${dayKey}|${b.key}|${nameUpper}`;
            const prev = prevAssignLookup.get(vKey) || "";
            const viol = violationCells.has(vKey) ? "YES" : "";
            const violType = violationCells.get(vKey) || "";
            blockRows.push([dateStr, dow, blockLabel, nameUpper, "7th", prev, viol, violType]);
          }
        }

        // CT assignments
        for (const nm of (entry.ct || [])) {
          const nameUpper = String(nm).toUpperCase();
          const vKey = `${dayKey}|${b.key}|${nameUpper}`;
          const prev = prevAssignLookup.get(vKey) || "";
          const viol = violationCells.has(vKey) ? "YES" : "";
          const violType = violationCells.get(vKey) || "";
          blockRows.push([dateStr, dow, blockLabel, nameUpper, "CT", prev, viol, violType]);
        }

        // SD assignments
        for (const nm of (entry.sd || [])) {
          const nameUpper = String(nm).toUpperCase();
          const vKey = `${dayKey}|${b.key}|${nameUpper}`;
          const prev = prevAssignLookup.get(vKey) || "";
          blockRows.push([dateStr, dow, blockLabel, nameUpper, "SD", prev, "", ""]);
        }

        // Sort by employee name within each block
        blockRows.sort((a, b) => a[3].localeCompare(b[3]));
        for (const r of blockRows) rows.push(r);
      }
    }

    const csv = rows.map(r => r.map(esc).join(",")).join("\n");
    const blob = new Blob(["\uFEFF" + csv], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `rotation_${year}_${String(monthIndex + 1).padStart(2, "0")}.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    showToast("CSV file exported!");
  });

  // PUSH TO SHIFTOPS — write current day's rotation assignments to ShiftOPS daily_edits Firestore
  document.getElementById("btnPushShiftOps").addEventListener("click", async () => {
    const plan = loadPlan();
    if (!plan || !plan.days) { showToast("No plan to push. Randomize first."); return; }

    const iso = document.getElementById("dayPick").value;
    if (!iso) { showToast("No day selected."); return; }
    const dayBlocks = plan.days[iso];
    if (!dayBlocks) { showToast("No assignments for " + iso); return; }

    const DAY_BLK = ["0600-1000","1000-1400","1400-1800"];
    const NIGHT_BLK = ["1800-2200","2200-0200","0200-0600"];

    // Build name-casing map: UPPER -> original Firestore casing
    const nameCaseMap = new Map();
    try {
      const empSnap = await db.collection('employees').get();
      empSnap.docs.forEach(doc => {
        const raw = (doc.data().Employee || doc.id).toString().trim();
        nameCaseMap.set(raw.toUpperCase(), raw);
      });
    } catch (e) {
      console.warn("Could not load employee casing from Firestore:", e);
    }
    function toShiftOpsName(nm) {
      const upper = String(nm).trim().toUpperCase();
      return nameCaseMap.get(upper) || upper;
    }

    function channelToRole(ch) {
      const u = String(ch).toUpperCase();
      if (u === "CT") return "CALLTAKER";
      return "DISPATCHER";
    }
    function channelToSeat(ch) {
      const map = {
        "North":"North","South":"South","East":"East","West":"West",
        "Central":"Central","Northwest":"Northwest",
        "DC1":"DC1","DC2":"DC2","Relief 1":"Relief 1","Relief 2":"Relief 2"
      };
      return map[ch] || ch || "";
    }

    let docCount = 0;
    let assignCount = 0;
    const btn = document.getElementById("btnPushShiftOps");
    const origText = btn.textContent;
    btn.textContent = "Pushing...";
    btn.disabled = true;

    try {
      for (const [shiftName, shiftBlocks] of [["DAY", DAY_BLK], ["NIGHT", NIGHT_BLK]]) {
        const edits = {};
        let hasAny = false;

        for (const bk of shiftBlocks) {
          const entry = dayBlocks[bk];
          if (!entry) continue;

          if (entry.assignments) {
            for (const [ch, nm] of Object.entries(entry.assignments)) {
              if (!nm) continue;
              const emp = toShiftOpsName(nm);
              if (!edits[emp]) edits[emp] = {};
              edits[emp][bk] = {
                Present: "YES", Hours: "", Role: channelToRole(ch),
                Assignment: channelToSeat(ch), AbsenceReason: "",
                PartialReason: "", WorkedStart: "", WorkedEnd: "", OthType: ""
              };
              hasAny = true; assignCount++;
            }
          }

          if (entry.ct && entry.ct.length) {
            for (const nm of entry.ct) {
              if (!nm) continue;
              const emp = toShiftOpsName(nm);
              if (!edits[emp]) edits[emp] = {};
              edits[emp][bk] = {
                Present: "YES", Hours: "", Role: "CALLTAKER",
                Assignment: "", AbsenceReason: "",
                PartialReason: "", WorkedStart: "", WorkedEnd: "", OthType: ""
              };
              hasAny = true; assignCount++;
            }
          }

          if (entry.sd && entry.sd.length) {
            for (const nm of entry.sd) {
              if (!nm) continue;
              const emp = toShiftOpsName(nm);
              if (!edits[emp]) edits[emp] = {};
              edits[emp][bk] = {
                Present: "YES", Hours: "", Role: "DISPATCHER",
                Assignment: "SD", AbsenceReason: "",
                PartialReason: "", WorkedStart: "", WorkedEnd: "", OthType: ""
              };
              hasAny = true; assignCount++;
            }
          }
        }

        if (hasAny) {
          const docId = iso + "_" + shiftName;
          await db.collection('daily_edits').doc(docId).set({
            date: iso, shift: shiftName, edits: edits, ot: [],
            savedAt: new Date().toISOString(), source: "RotationOps"
          }, { merge: true });
          docCount++;
        }
      }

      showToast("Pushed " + iso + " to ShiftOps! " + assignCount + " assignments (" + docCount + " shifts).");
    } catch (err) {
      console.error("Push to ShiftOps failed:", err);
      showToast("ERROR: " + (err.message || err));
    } finally {
      btn.textContent = origText;
      btn.disabled = false;
    }
  });

  // Event delegation for btnAddVac and btnAddTrainee
  document.addEventListener("click", (e)=>{
    if (e.target && e.target.id === "btnAddVac") {
      const sel = document.getElementById("vacName");
      const name = sel.value.trim();
      const from = document.getElementById("vacFrom").value || "";
      const to = document.getElementById("vacTo").value || "";
      if (!name) return showToast("Select a name first.");
      const v = getVacRanges(); v.push({name, from, to}); saveJSON(STORAGE.vac, v);
      sel.selectedIndex = 0;
      document.getElementById("vacFrom").value = "";
      document.getElementById("vacTo").value = "";
      renderExceptions(); renderInfoStats(); showToast("Added exclusion.");
    }
    if (e.target && e.target.id === "btnAddTrainee") {
      const sel = document.getElementById("traineeName");
      const name = sel.value.trim().toUpperCase();
      const from = document.getElementById("traineeFrom").value || "";
      const to = document.getElementById("traineeTo").value || "";
      if (!name) return showToast("Select a trainer first.");
      const blocks = Array.from(document.querySelectorAll('.trainee-block-cb:checked')).map(cb => cb.value);
      const ranges = getTrainerRanges();
      ranges.push({name, from, to, blocks});
      saveJSON(STORAGE.training, ranges);
      sel.selectedIndex = 0;
      document.getElementById("traineeFrom").value = "";
      document.getElementById("traineeTo").value = "";
      document.querySelectorAll('.trainee-block-cb').forEach(cb => cb.checked = false);
      renderExceptions(); renderInfoStats();
      const blkMsg = blocks.length ? ` during ${blocks.length} block(s)` : ' (all blocks)';
      showToast("Added trainer" + blkMsg + ". They will only be assigned E, S, W, C.");
    }
  });

  // ========== SWAP TIP BUBBLE ==========
  function showSwapTip() {
    const tip = document.getElementById("swapTip");
    if (!tip) return;
    tip.style.display = "block";
    tip.onclick = () => { tip.style.display = "none"; };
    setTimeout(() => { tip.style.display = "none"; }, 10000);
  }

  // ========== SHIFTOPS SYNC HELPER ==========
  // Push a single person's assignment for one block to ShiftOps Firestore
  async function syncToShiftOps(dayKey, blockKey, personName, role, seat) {
    try {
      const nameCaseMap = new Map();
      const empSnap = await db.collection('employees').get();
      empSnap.docs.forEach(doc => {
        const raw = (doc.data().Employee || doc.id).toString().trim();
        nameCaseMap.set(raw.toUpperCase(), raw);
      });
      const soName = nameCaseMap.get(personName.toUpperCase()) || personName;

      const DAY_SET = new Set(["0600-1000","1000-1400","1400-1800"]);
      const shiftName = DAY_SET.has(blockKey) ? "DAY" : "NIGHT";
      const docId = dayKey + "_" + shiftName;
      const docRef = db.collection('daily_edits').doc(docId);

      const update = {};
      update["edits." + soName + "." + blockKey] = {
        Present: "YES", Hours: "", Role: role,
        Assignment: seat, AbsenceReason: "",
        PartialReason: "", WorkedStart: "", WorkedEnd: "", OthType: ""
      };
      update["savedAt"] = new Date().toISOString();

      const existing = await docRef.get();
      if (existing.exists) {
        await docRef.update(update);
      } else {
        const edits = {};
        edits[soName] = {};
        edits[soName][blockKey] = update["edits." + soName + "." + blockKey];
        await docRef.set({ date: dayKey, shift: shiftName, edits, ot: [], savedAt: new Date().toISOString() });
      }
    } catch (err) {
      console.warn("ShiftOps sync failed for " + personName + ":", err);
    }
  }

  // Push two people's assignments for one block (swap) to ShiftOps
  async function syncSwapToShiftOps(dayKey, blockKey, nameA, roleA, seatA, nameB, roleB, seatB) {
    await syncToShiftOps(dayKey, blockKey, nameA, roleA, seatA);
    await syncToShiftOps(dayKey, blockKey, nameB, roleB, seatB);
  }

  // ========== CLICK-TO-CHANGE MODAL ==========
  let currentCallOffData = null;

  function showCallOffModal(dayKey, blockKey, channel, name, type) {
    currentCallOffData = { dayKey, blockKey, channel, name, type };
    const blockLabel = BLOCKS.find(b => b.key === blockKey)?.label || blockKey;
    document.getElementById("callOffModalTitle").textContent = `SWAP: ${name}`;
    document.getElementById("callOffModalInfo").innerHTML = `
      <strong>DATE:</strong> ${dayKey}<br>
      <strong>BLOCK:</strong> ${blockLabel}<br>
      <strong>CURRENT:</strong> ${channel}
    `;

    // Show REMOVE OT button only for OT channel assignments
    const removeOTBtn = document.getElementById("btnRemoveOT");
    const planCheck = loadPlan();
    const bdCheck = planCheck.days[dayKey]?.[blockKey];
    const isOTChannel = type === "channel" && bdCheck && Array.isArray(bdCheck.ot) && bdCheck.ot.some(n => String(n).toUpperCase() === name.toUpperCase());
    removeOTBtn.style.display = isOTChannel ? "inline-block" : "none";
    document.getElementById("btnMarkAbsent").style.display = isOTChannel ? "none" : "inline-block";

    // Show MOVE section only for SD assignments
    const moveSection = document.getElementById("moveToSection");
    const moveBtn = document.getElementById("btnMoveTo");
    if (type === "sd") {
      moveSection.style.display = "block";
      moveBtn.style.display = "inline-block";
      const moveSel = document.getElementById("moveToSelect");
      moveSel.innerHTML = "";
      // CT option
      const ctOpt = document.createElement("option");
      ctOpt.value = "ct";
      ctOpt.textContent = "CT (CALLTAKING)";
      moveSel.appendChild(ctOpt);
      // Empty channel slots
      const plan2 = loadPlan();
      const bd = plan2.days[dayKey]?.[blockKey];
      if (bd) {
        for (const ch of CHANNELS) {
          const assigned = bd.assignments?.[ch];
          if (!assigned || String(assigned).trim() === "") {
            const opt = document.createElement("option");
            opt.value = `channel|${ch}`;
            opt.textContent = ch.toUpperCase();
            moveSel.appendChild(opt);
          }
        }
      }
    } else {
      moveSection.style.display = "none";
      moveBtn.style.display = "none";
    }

    // Populate swap dropdown with all assignments in this block
    const plan = loadPlan();
    const blockData = plan.days[dayKey]?.[blockKey];
    const swapSelect = document.getElementById("swapSelect");
    swapSelect.innerHTML = "";

    if (blockData) {
      // Add channel assignments
      for (const [ch, nm] of Object.entries(blockData.assignments || {})) {
        if (nm && nm.toUpperCase() !== name.toUpperCase()) {
          const opt = document.createElement("option");
          opt.value = `channel|${ch}|${nm}`;
          opt.textContent = `${channelAbbrev(ch)}: ${nm.toUpperCase()}`;
          swapSelect.appendChild(opt);
        }
      }
      // Add CT assignments
      for (const nm of (blockData.ct || [])) {
        if (nm && nm.toUpperCase() !== name.toUpperCase()) {
          const opt = document.createElement("option");
          opt.value = `ct|CT|${nm}`;
          opt.textContent = `CT: ${nm.toUpperCase()}`;
          swapSelect.appendChild(opt);
        }
      }
      // Add SD assignments
      for (const nm of (blockData.sd || [])) {
        if (nm && nm.toUpperCase() !== name.toUpperCase()) {
          const opt = document.createElement("option");
          opt.value = `sd|SD|${nm}`;
          opt.textContent = `SD: ${nm.toUpperCase()}`;
          swapSelect.appendChild(opt);
        }
      }
    }

    if (swapSelect.options.length === 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "-- NO OTHER ASSIGNMENTS --";
      swapSelect.appendChild(opt);
    }

    document.getElementById("callOffModalResult").innerHTML = "";
    document.getElementById("callOffModal").style.display = "flex";
  }

  function hideCallOffModal() {
    document.getElementById("callOffModal").style.display = "none";
    currentCallOffData = null;
  }

  // Event delegation for clickable assignments
  document.addEventListener("click", (e) => {
    const target = e.target.closest(".clickable-assign");
    if (!target) return;

    const dayKey = target.getAttribute("data-day");
    const blockKey = target.getAttribute("data-block");
    const channel = target.getAttribute("data-channel");
    const name = target.getAttribute("data-name");
    const type = target.getAttribute("data-type");

    if (dayKey && blockKey && name) {
      showCallOffModal(dayKey, blockKey, channel, name, type);
    }
  });

  // Modal buttons
  document.getElementById("btnModalCancel").addEventListener("click", hideCallOffModal);

  document.getElementById("btnRemoveOT").addEventListener("click", () => {
    if (!currentCallOffData) return;
    const { dayKey, blockKey, channel, name } = currentCallOffData;
    const plan = loadPlan();
    const bd = plan.days[dayKey]?.[blockKey];
    if (!bd) return hideCallOffModal();
    const nameUp = name.toUpperCase();

    // Remove from channel assignment
    if (bd.assignments && String(bd.assignments[channel] || "").toUpperCase() === nameUp) {
      bd.assignments[channel] = "";
    }
    // Remove from CT if they were placed there
    if (bd.ct) {
      const idx = bd.ct.findIndex(n => String(n).toUpperCase() === nameUp);
      if (idx !== -1) bd.ct.splice(idx, 1);
    }
    // Remove from OT array
    if (bd.ot) {
      const idx = bd.ot.findIndex(n => String(n).toUpperCase() === nameUp);
      if (idx !== -1) bd.ot.splice(idx, 1);
    }

    savePlan(plan);
    hideCallOffModal();

    const dk = document.getElementById("dayPick").value;
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    renderDay(dk); renderWeek(dk); renderMonth(y, m);
    showToast(`Removed ${name.toUpperCase()} (OT) from ${channel}`);
  });
  document.getElementById("callOffModal").addEventListener("click", (e) => {
    if (e.target.id === "callOffModal") hideCallOffModal(); // Click outside to close
  });

  document.getElementById("btnModalSwap").addEventListener("click", () => {
    if (!currentCallOffData) return;
    const { dayKey, blockKey, channel, name, type } = currentCallOffData;

    const swapSelect = document.getElementById("swapSelect");
    const swapValue = swapSelect.value;
    if (!swapValue) { showToast("NO ASSIGNMENT SELECTED TO SWAP."); return; }

    const [swapType, swapChannel, swapName] = swapValue.split("|");

    const plan = loadPlan();
    const blockData = plan.days[dayKey]?.[blockKey];
    if (!blockData) return hideCallOffModal();

    // Get current person's name and swap target's name
    const personA = name.toUpperCase();
    const personB = swapName.toUpperCase();

    // Trainee restriction: block swaps that put a trainee on a restricted channel or CT
    const _swapBlockedA = (swapType === "channel" && traineeBlocked(personA, dayKey, blockKey, swapChannel.toUpperCase()))
                       || (swapType === "ct" && isTrainee(personA, dayKey, blockKey));
    const _swapBlockedB = (type === "channel" && traineeBlocked(personB, dayKey, blockKey, channel.toUpperCase()))
                       || (type === "ct" && isTrainee(personB, dayKey, blockKey));
    if (_swapBlockedA || _swapBlockedB) {
      showToast("TRAINEE CANNOT BE ASSIGNED TO THAT POSITION.");
      return;
    }

    // Perform the swap based on types
    // Remove personA from their current position
    if (type === "channel") {
      blockData.assignments[channel] = personB;
    } else if (type === "ct") {
      const idx = blockData.ct.findIndex(n => String(n).toUpperCase() === personA);
      if (idx !== -1) blockData.ct[idx] = personB;
    } else if (type === "sd") {
      const idx = blockData.sd.findIndex(n => String(n).toUpperCase() === personA);
      if (idx !== -1) blockData.sd[idx] = personB;
    }

    // Put personA in personB's position
    if (swapType === "channel") {
      blockData.assignments[swapChannel] = personA;
    } else if (swapType === "ct") {
      const idx = blockData.ct.findIndex(n => String(n).toUpperCase() === personB);
      if (idx !== -1) blockData.ct[idx] = personA;
    } else if (swapType === "sd") {
      const idx = blockData.sd.findIndex(n => String(n).toUpperCase() === personB);
      if (idx !== -1) blockData.sd[idx] = personA;
    }

    savePlan(plan);

    // Record swap in history
    const blockLabel = BLOCKS.find(b => b.key === blockKey)?.label || blockKey;
    addSwapHistory({
      name1: personA,
      name2: personB,
      date: dayKey,
      block: blockLabel
    });

    hideCallOffModal();

    // Refresh views
    const dk = document.getElementById("dayPick").value;
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    renderDay(dk); renderWeek(dk); renderMonth(y, m);
    showToast(`SWAPPED ${personA} ↔ ${personB}`);

    // Sync both to ShiftOps
    const seatMap = {"North":"North","South":"South","East":"East","West":"West","Central":"Central","Northwest":"Northwest","DC1":"DC1","DC2":"DC2","Relief 1":"Relief 1","Relief 2":"Relief 2"};
    // personA is now in swapType/swapChannel position
    const roleA = (swapType === "ct") ? "CALLTAKER" : "DISPATCHER";
    const seatA = (swapType === "channel") ? (seatMap[swapChannel] || swapChannel) : "";
    // personB is now in type/channel position
    const roleB = (type === "ct") ? "CALLTAKER" : "DISPATCHER";
    const seatB = (type === "channel") ? (seatMap[channel] || channel) : "";
    syncSwapToShiftOps(dayKey, blockKey, personA, roleA, seatA, personB, roleB, seatB);
  });

  // ========== MARK ABSENT (entire shift for the day + push to ShiftOps) ==========
  document.getElementById("btnMarkAbsent").addEventListener("click", async () => {
    if (!currentCallOffData) return;
    const { dayKey, name } = currentCallOffData;

    const plan = loadPlan();
    if (!plan.days[dayKey]) return hideCallOffModal();

    const personName = name.toUpperCase();

    // Find which blocks this person is scheduled for on this day
    const base = normalizeBase();
    const rec = base.find(r => String(r.Employee||"").trim().toUpperCase() === personName);
    const dateObj = parseYMD(dayKey);
    const dn = dateObj ? dayName(dateObj) : "";
    const schedVal = rec ? String(rec[dn] || "").trim().toUpperCase() : "";
    const workedBlocks = rec ? parseShiftToBlocks(schedVal) : new Set();

    // Remove person from ALL their blocks for the day and mark absent
    let removedCount = 0;
    for (const b of BLOCKS) {
      if (!workedBlocks.has(b.key)) continue;
      const bd = plan.days[dayKey]?.[b.key];
      if (!bd) continue;

      // Remove from channel assignments
      if (bd.assignments) {
        for (const [ch, nm] of Object.entries(bd.assignments)) {
          if (String(nm).toUpperCase() === personName) {
            bd.assignments[ch] = "";
            removedCount++;
          }
        }
      }
      // Remove from CT
      if (bd.ct) {
        const idx = bd.ct.findIndex(n => String(n).toUpperCase() === personName);
        if (idx !== -1) { bd.ct.splice(idx, 1); removedCount++; }
      }
      // Remove from SD
      if (bd.sd) {
        const idx = bd.sd.findIndex(n => String(n).toUpperCase() === personName);
        if (idx !== -1) { bd.sd.splice(idx, 1); removedCount++; }
      }
      // Remove from OT
      if (bd.ot) {
        const idx = bd.ot.findIndex(n => String(n).toUpperCase() === personName);
        if (idx !== -1) { bd.ot.splice(idx, 1); removedCount++; }
      }

      // Track as absent in each block
      if (!bd.absent) bd.absent = [];
      if (!bd.absent.some(n => String(n).toUpperCase() === personName)) {
        bd.absent.push(personName);
      }
    }

    savePlan(plan);
    hideCallOffModal();

    // Refresh views
    const dk = document.getElementById("dayPick").value;
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    renderDay(dk); renderWeek(dk); renderMonth(y, m);

    // Push absence to ShiftOps (ShiftOPS) Firestore
    try {
      const nameCaseMap = new Map();
      const empSnap = await db.collection('employees').get();
      empSnap.docs.forEach(doc => {
        const raw = (doc.data().Employee || doc.id).toString().trim();
        nameCaseMap.set(raw.toUpperCase(), raw);
      });
      const shiftOpsName = nameCaseMap.get(personName) || personName;

      // Determine which shifts are affected (DAY, NIGHT, or both)
      const DAY_SET = new Set(["0600-1000","1000-1400","1400-1800"]);
      const NIGHT_SET = new Set(["1800-2200","2200-0200","0200-0600"]);
      const affectedShifts = new Set();
      for (const bk of workedBlocks) {
        if (DAY_SET.has(bk)) affectedShifts.add("DAY");
        if (NIGHT_SET.has(bk)) affectedShifts.add("NIGHT");
      }

      for (const shiftName of affectedShifts) {
        const docId = dayKey + "_" + shiftName;
        const shiftBlocks = shiftName === "DAY" ? [...DAY_SET] : [...NIGHT_SET];
        const editsUpdate = {};

        for (const bk of shiftBlocks) {
          if (!workedBlocks.has(bk)) continue;
          editsUpdate[shiftOpsName + "." + bk] = {
            Present: "NO",
            Hours: "0",
            Role: "",
            Assignment: "",
            AbsenceReason: "",
            PartialReason: "",
            WorkedStart: "",
            WorkedEnd: "",
            OthType: ""
          };
        }

        // Use dot-notation update so we only change this person's blocks
        const flatUpdate = {};
        for (const [dotPath, val] of Object.entries(editsUpdate)) {
          flatUpdate["edits." + dotPath] = val;
        }
        flatUpdate["savedAt"] = new Date().toISOString();

        const docRef = db.collection('daily_edits').doc(docId);
        const existing = await docRef.get();
        if (existing.exists) {
          await docRef.update(flatUpdate);
        } else {
          // Doc doesn't exist yet — build full edits object
          const edits = {};
          edits[shiftOpsName] = {};
          for (const bk of shiftBlocks) {
            if (!workedBlocks.has(bk)) continue;
            edits[shiftOpsName][bk] = editsUpdate[shiftOpsName + "." + bk];
          }
          await docRef.set({ date: dayKey, shift: shiftName, edits, ot: [], savedAt: new Date().toISOString() });
        }
      }
      showToast(`${personName} MARKED ABSENT for entire shift (${removedCount} slots) — synced to ShiftOps`);
    } catch (err) {
      console.warn("ShiftOps sync failed:", err);
      showToast(`${personName} MARKED ABSENT (${removedCount} slots) — ShiftOps sync failed`);
    }
  });

  // ========== MOVE SD TO CT / CHANNEL ==========
  document.getElementById("btnMoveTo").addEventListener("click", () => {
    if (!currentCallOffData) return;
    const { dayKey, blockKey, name, type } = currentCallOffData;
    if (type !== "sd") return;

    const moveSel = document.getElementById("moveToSelect");
    const moveValue = moveSel.value;
    if (!moveValue) { showToast("SELECT A DESTINATION."); return; }

    const plan = loadPlan();
    const blockData = plan.days[dayKey]?.[blockKey];
    if (!blockData) return hideCallOffModal();

    const personName = name.toUpperCase();

    // Remove from SD
    const idx = blockData.sd.findIndex(n => String(n).toUpperCase() === personName);
    if (idx !== -1) blockData.sd.splice(idx, 1);

    // Trainee restriction: block SD move to disallowed destinations
    if (moveValue === "ct" && isTrainee(personName, dayKey, blockKey)) {
      showToast("TRAINEE CANNOT BE MOVED TO CT.");
      return;
    }
    if (moveValue.startsWith("channel|")) {
      const chCheck = moveValue.split("|")[1];
      if (traineeBlocked(personName, dayKey, blockKey, chCheck.toUpperCase())) {
        showToast("TRAINEE CANNOT BE MOVED TO " + chCheck.toUpperCase() + ".");
        return;
      }
    }

    let dest;
    if (moveValue === "ct") {
      // Add to CT
      if (!blockData.ct) blockData.ct = [];
      blockData.ct.push(personName);
      dest = "CT";
    } else if (moveValue.startsWith("channel|")) {
      // Add to channel
      const ch = moveValue.split("|")[1];
      blockData.assignments[ch] = personName;
      dest = ch.toUpperCase();
    }

    savePlan(plan);
    hideCallOffModal();

    const dk = document.getElementById("dayPick").value;
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    renderDay(dk); renderWeek(dk); renderMonth(y, m);
    showToast(`${personName} MOVED FROM SD → ${dest}`);
  });

  // ========== ASSIGN TO EMPTY SLOT MODAL ==========
  let currentAssignSlotData = null;

  function showAssignSlotModal(dayKey, blockKey, channel) {
    const plan = loadPlan();
    const blockData = plan.days[dayKey]?.[blockKey];
    if (!blockData) return;

    currentAssignSlotData = { dayKey, blockKey, channel };

    const blockLabel = BLOCKS.find(b => b.key === blockKey)?.label || blockKey;
    document.getElementById("assignSlotModalTitle").textContent = `ASSIGN TO: ${channel}`;
    document.getElementById("assignSlotModalInfo").innerHTML = `
      <strong>DATE:</strong> ${dayKey}<br>
      <strong>BLOCK:</strong> ${blockLabel}<br>
      <strong>CHANNEL:</strong> ${channel}<br>
      <span style="font-size:12px; opacity:.7;">Select someone from CT or overtime to fill this slot.</span>
    `;

    const sel = document.getElementById("assignSlotSelect");
    sel.innerHTML = "";

    // CT people first
    const ctList = (blockData.ct || []).filter(n => n && String(n).trim() !== "");
    for (const nm of ctList) {
      const opt = document.createElement("option");
      opt.value = nm;
      opt.textContent = nm.toUpperCase();
      sel.appendChild(opt);
    }

    // OT candidates: all dispatchers NOT already assigned/CT/SD in this block AND not scheduled for this block
    const dateObj = parseYMD(dayKey);
    if (dateObj) {
      const block = BLOCKS.find(b => b.key === blockKey);
      const allDispatchers = buildDispatcherPoolForDate(dateObj);
      // Names already in this block (assigned, CT, SD)
      const usedNames = new Set();
      for (const nm of Object.values(blockData.assignments || {})) { if (nm) usedNames.add(String(nm).toUpperCase()); }
      for (const nm of (blockData.ct || [])) { if (nm) usedNames.add(String(nm).toUpperCase()); }
      for (const nm of (blockData.sd || [])) { if (nm) usedNames.add(String(nm).toUpperCase()); }

      // Also get ALL base dispatchers (including those excluded/off) for OT
      const base = normalizeBase();
      const allNames = base.filter(r => String(r.Position||"").toUpperCase() === "DISPATCHER")
        .map(r => ({ name: String(r.Employee||"").trim(), sched: r }))
        .filter(r => r.name);
      const hires = getNewHires().map(n => String(n).trim()).filter(Boolean)
        .filter(n => allNames.every(d => d.name.toUpperCase() !== n.toUpperCase()))
        .map(n => ({ name: n, sched: null }));
      const everyone = allNames.concat(hires);

      // Find people NOT working this block (OT candidates)
      const otCandidates = [];
      for (const d of everyone) {
        const nameUp = d.name.toUpperCase();
        if (usedNames.has(nameUp)) continue; // already in this block
        // Check if they normally work this block
        const sched = d.sched || {};
        const dn = dateObj ? ["SUNDAY","MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY"][dateObj.getDay()] : "";
        const schedVal = String(sched[dn] || "").toUpperCase().trim();
        let worksThisBlock = false;
        if (block && schedVal && schedVal !== "OFF") {
          worksThisBlock = blocksWorkedForSchedule(schedVal, null).has(blockKey);
        }
        if (!worksThisBlock) {
          otCandidates.push(d.name);
        }
      }

      if (otCandidates.length > 0) {
        // Add separator
        const sep = document.createElement("option");
        sep.disabled = true;
        sep.textContent = "\u2500\u2500\u2500 OVERTIME \u2500\u2500\u2500";
        sel.appendChild(sep);

        otCandidates.sort((a, b) => a.localeCompare(b));
        for (const nm of otCandidates) {
          const opt = document.createElement("option");
          opt.value = "OT|" + nm;
          opt.textContent = nm.toUpperCase() + "  (OT)";
          opt.style.fontWeight = "700";
          sel.appendChild(opt);
        }
      }
    }

    if (sel.options.length === 0 || (sel.options.length === 1 && sel.options[0].disabled)) {
      showToast("NO ONE AVAILABLE FOR THIS BLOCK");
      return;
    }

    document.getElementById("assignSlotModal").style.display = "flex";
  }

  function hideAssignSlotModal() {
    document.getElementById("assignSlotModal").style.display = "none";
    currentAssignSlotData = null;
  }

  // Click on NEEDED badge → open assign modal
  document.addEventListener("click", (e) => {
    const target = e.target.closest(".clickable-needed");
    if (!target) return;

    const dayKey = target.getAttribute("data-day");
    const blockKey = target.getAttribute("data-block");
    const channel = target.getAttribute("data-channel");

    if (dayKey && blockKey && channel) {
      showAssignSlotModal(dayKey, blockKey, channel);
    }
  });

  // ASSIGN button
  document.getElementById("btnAssignSlot").addEventListener("click", () => {
    if (!currentAssignSlotData) return;
    const { dayKey, blockKey, channel } = currentAssignSlotData;

    const sel = document.getElementById("assignSlotSelect");
    const rawValue = sel.value;
    if (!rawValue) { showToast("SELECT SOMEONE TO ASSIGN."); return; }

    // Check if OT selection
    const isOT = rawValue.startsWith("OT|");
    const selectedName = isOT ? rawValue.substring(3) : rawValue;

    const plan = loadPlan();
    const blockData = plan.days[dayKey]?.[blockKey];
    if (!blockData) return hideAssignSlotModal();

    // Trainee restriction: block assignment to disallowed channels
    if (traineeBlocked(selectedName, dayKey, blockKey, channel.toUpperCase())) {
      showToast("TRAINEE CANNOT BE ASSIGNED TO " + channel.toUpperCase() + ".");
      return;
    }

    // Assign person to channel
    blockData.assignments[channel] = selectedName;

    // Track OT
    if (isOT) {
      if (!blockData.ot) blockData.ot = [];
      const nameUp = selectedName.toUpperCase();
      if (!blockData.ot.some(n => String(n).toUpperCase() === nameUp)) {
        blockData.ot.push(selectedName);
      }
    }

    // Remove person from CT if they were there
    if (blockData.ct) {
      const idx = blockData.ct.findIndex(n => String(n).toUpperCase() === selectedName.toUpperCase());
      if (idx !== -1) blockData.ct.splice(idx, 1);
    }

    savePlan(plan);
    hideAssignSlotModal();

    // Refresh views
    const dk = document.getElementById("dayPick").value;
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    renderDay(dk); renderWeek(dk); renderMonth(y, m);
    const otTag = isOT ? " (OT)" : "";
    showToast(`${selectedName.toUpperCase()}${otTag} ASSIGNED TO ${channel}`);

    // Sync to ShiftOps
    const chUp = String(channel).toUpperCase();
    const soRole = (chUp === "CT") ? "CALLTAKER" : "DISPATCHER";
    const seatMap = {"North":"North","South":"South","East":"East","West":"West","Central":"Central","Northwest":"Northwest","DC1":"DC1","DC2":"DC2","Relief 1":"Relief 1","Relief 2":"Relief 2"};
    const soSeat = seatMap[channel] || channel || "";
    syncToShiftOps(dayKey, blockKey, selectedName, soRole, soSeat);
  });

  // Cancel & close assign modal
  document.getElementById("btnAssignSlotCancel").addEventListener("click", hideAssignSlotModal);
  document.getElementById("assignSlotModal").addEventListener("click", (e) => {
    if (e.target.id === "assignSlotModal") hideAssignSlotModal();
  });

  // ========== VACATION → ASSIGN TO EMPTY SLOT ==========
  let currentVacAssignData = null;

  function showVacAssignModal(dayKey, name) {
    const plan = loadPlan();
    const dayData = plan.days[dayKey];
    if (!dayData) { showToast("NO PLAN DATA FOR THIS DAY"); return; }

    const sel = document.getElementById("vacAssignSelect");
    sel.innerHTML = "";

    // Scan blocks split by day/night shift
    const dayBlocks = BLOCKS.filter(b => b.start < 18);
    const nightBlocks = BLOCKS.filter(b => b.start >= 18);

    for (const group of [{label: "DAY SHIFT (6 AM \u2014 6 PM)", blocks: dayBlocks}, {label: "NIGHT SHIFT (6 PM \u2014 6 AM)", blocks: nightBlocks}]) {
      let groupHasOptions = false;
      const groupStart = sel.options.length;

      // Placeholder for separator — inserted only if group has options
      const sep = document.createElement("option");
      sep.disabled = true;
      sep.textContent = "\u2500\u2500\u2500 " + group.label + " \u2500\u2500\u2500";
      sel.appendChild(sep);

      for (const b of group.blocks) {
        const blockData = dayData[b.key];
        if (!blockData) continue;

        // CT option
        const ctOpt = document.createElement("option");
        ctOpt.value = b.key + "|CT";
        ctOpt.textContent = "    " + b.label + ":  CT (CALLTAKING)";
        sel.appendChild(ctOpt);
        groupHasOptions = true;

        // Empty channel slots
        if (blockData.assignments) {
          for (const ch of CHANNELS) {
            const assigned = blockData.assignments[ch];
            if (!assigned || String(assigned).trim() === "") {
              const opt = document.createElement("option");
              opt.value = b.key + "|" + ch;
              opt.textContent = "    " + b.label + ":  " + ch;
              sel.appendChild(opt);
              groupHasOptions = true;
            }
          }
        }
      }

      // Remove separator if group had no options
      if (!groupHasOptions) {
        sel.removeChild(sep);
      }
    }

    const hasSelectable = [...sel.options].some(o => !o.disabled);
    if (!hasSelectable) {
      sel.innerHTML = "";
      showToast("NO SLOTS AVAILABLE FOR " + dayKey);
      return;
    }

    currentVacAssignData = { dayKey, name };
    document.getElementById("vacAssignModalTitle").textContent = "ASSIGN: " + name.toUpperCase();
    document.getElementById("vacAssignModalInfo").innerHTML =
      `<strong>DATE:</strong> ${dayKey}<br>` +
      `<strong>EMPLOYEE:</strong> ${name.toUpperCase()}<br>` +
      `<span style="font-size:12px; opacity:.7;">This person is on vacation. Assigning them will mark them as OT.</span>`;
    document.getElementById("vacAssignModal").style.display = "flex";
  }

  function hideVacAssignModal() {
    document.getElementById("vacAssignModal").style.display = "none";
    currentVacAssignData = null;
  }

  // Click on vacation name → open vacation assign modal
  document.addEventListener("click", (e) => {
    const target = e.target.closest(".clickable-vac");
    if (!target) return;
    const dayKey = target.getAttribute("data-day");
    const name = target.getAttribute("data-name");
    if (dayKey && name) showVacAssignModal(dayKey, name);
  });

  // ASSIGN button
  document.getElementById("btnVacAssign").addEventListener("click", () => {
    if (!currentVacAssignData) return;
    const { dayKey, name } = currentVacAssignData;

    const sel = document.getElementById("vacAssignSelect");
    const rawValue = sel.value;
    if (!rawValue) { showToast("SELECT A SLOT TO ASSIGN."); return; }

    const [blockKey, channel] = rawValue.split("|");
    const plan = loadPlan();
    const blockData = plan.days[dayKey]?.[blockKey];
    if (!blockData) return hideVacAssignModal();

    // Trainee restriction: block assignment to disallowed channels or CT
    if (channel === "CT" && isTrainee(name, dayKey, blockKey)) {
      showToast("TRAINEE CANNOT BE ASSIGNED TO CT.");
      return;
    }
    if (channel !== "CT" && traineeBlocked(name, dayKey, blockKey, channel.toUpperCase())) {
      showToast("TRAINEE CANNOT BE ASSIGNED TO " + channel.toUpperCase() + ".");
      return;
    }

    // Assign to CT or to a channel slot
    if (channel === "CT") {
      if (!blockData.ct) blockData.ct = [];
      blockData.ct.push(name);
    } else {
      blockData.assignments[channel] = name;
    }

    // Mark as OT (vacation person coming in = overtime)
    if (!blockData.ot) blockData.ot = [];
    const nameUp = name.toUpperCase();
    if (!blockData.ot.some(n => String(n).toUpperCase() === nameUp)) {
      blockData.ot.push(name);
    }

    savePlan(plan);
    hideVacAssignModal();

    const dk = document.getElementById("dayPick").value;
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    renderDay(dk); renderWeek(dk); renderMonth(y, m);

    const blockLabel = BLOCKS.find(b => b.key === blockKey)?.label || blockKey;
    showToast(`${name.toUpperCase()} (VAC/OT) ASSIGNED TO ${channel} — ${blockLabel}`);

    // Sync to ShiftOps
    const soRole = (channel === "CT") ? "CALLTAKER" : "DISPATCHER";
    const seatMap = {"North":"North","South":"South","East":"East","West":"West","Central":"Central","Northwest":"Northwest","DC1":"DC1","DC2":"DC2","Relief 1":"Relief 1","Relief 2":"Relief 2"};
    const soSeat = (channel === "CT") ? "" : (seatMap[channel] || channel || "");
    syncToShiftOps(dayKey, blockKey, name, soRole, soSeat);
  });

  // Cancel & close vacation assign modal
  document.getElementById("btnVacAssignCancel").addEventListener("click", hideVacAssignModal);
  document.getElementById("vacAssignModal").addEventListener("click", (e) => {
    if (e.target.id === "vacAssignModal") hideVacAssignModal();
  });

  // ========== UNDO ABSENT (click absent name → return to CT) ==========
  document.addEventListener("click", async (e) => {
    const target = e.target.closest(".clickable-absent");
    if (!target) return;

    const dayKey = target.getAttribute("data-day");
    const blockKey = target.getAttribute("data-block");
    const absentName = target.getAttribute("data-name");
    if (!dayKey || !blockKey || !absentName) return;

    const blockLabel = BLOCKS.find(b => b.key === blockKey)?.label || blockKey;
    if (!confirm(`Return ${absentName} to CT for ${dayKey} ${blockLabel}?`)) return;

    const plan = loadPlan();
    const blockData = plan.days[dayKey]?.[blockKey];
    if (!blockData) return;

    // Remove from absent list
    if (blockData.absent) {
      const idx = blockData.absent.findIndex(n => String(n).toUpperCase() === absentName.toUpperCase());
      if (idx !== -1) blockData.absent.splice(idx, 1);
    }

    // Trainee restriction: don't add trainee back to CT
    if (isTrainee(absentName, dayKey, blockKey)) {
      // Try to place trainee in an empty allowed channel instead
      const _tAllowed = ["East","South","West","Central"];
      let _tPlaced = false;
      for (const _tCh of _tAllowed) {
        if (!blockData.assignments[_tCh]) {
          blockData.assignments[_tCh] = absentName;
          _tPlaced = true;
          break;
        }
      }
      if (!_tPlaced) {
        showToast("NO ALLOWED CHANNEL OPEN FOR TRAINEE — CANNOT RETURN TO CT.");
        return;
      }
    } else {
      // Add back to CT
      if (!blockData.ct) blockData.ct = [];
      blockData.ct.push(absentName);
    }

    savePlan(plan);

    // Refresh views
    const dk = document.getElementById("dayPick").value;
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    renderDay(dk); renderWeek(dk); renderMonth(y, m);

    // Check if person is still absent in ANY other block for this day
    let stillAbsentThisDay = false;
    for (const b of BLOCKS) {
      const bd = plan.days[dayKey]?.[b.key];
      if (bd && bd.absent && bd.absent.some(n => String(n).toUpperCase() === absentName.toUpperCase())) {
        stillAbsentThisDay = true;
        break;
      }
    }

    // Push return-to-present to ShiftOps if no longer absent in any block
    if (!stillAbsentThisDay) {
      try {
        const nameCaseMap = new Map();
        const empSnap = await db.collection('employees').get();
        empSnap.docs.forEach(doc => {
          const raw = (doc.data().Employee || doc.id).toString().trim();
          nameCaseMap.set(raw.toUpperCase(), raw);
        });
        const shiftOpsName = nameCaseMap.get(absentName.toUpperCase()) || absentName;

        const base = normalizeBase();
        const rec = base.find(r => String(r.Employee||"").trim().toUpperCase() === absentName.toUpperCase());
        const dateObj = parseYMD(dayKey);
        const dn = dateObj ? dayName(dateObj) : "";
        const schedVal = rec ? String(rec[dn] || "").trim().toUpperCase() : "";
        const workedBlocks = rec ? parseShiftToBlocks(schedVal) : new Set();

        const DAY_SET = new Set(["0600-1000","1000-1400","1400-1800"]);
        const NIGHT_SET = new Set(["1800-2200","2200-0200","0200-0600"]);
        const affectedShifts = new Set();
        for (const bk of workedBlocks) {
          if (DAY_SET.has(bk)) affectedShifts.add("DAY");
          if (NIGHT_SET.has(bk)) affectedShifts.add("NIGHT");
        }

        for (const shiftName of affectedShifts) {
          const docId = dayKey + "_" + shiftName;
          const shiftBlocks = shiftName === "DAY" ? [...DAY_SET] : [...NIGHT_SET];
          const flatUpdate = {};

          for (const bk of shiftBlocks) {
            if (!workedBlocks.has(bk)) continue;
            flatUpdate["edits." + shiftOpsName + "." + bk + ".Present"] = "YES";
            flatUpdate["edits." + shiftOpsName + "." + bk + ".Hours"] = "";
            flatUpdate["edits." + shiftOpsName + "." + bk + ".Role"] = "";
            flatUpdate["edits." + shiftOpsName + "." + bk + ".Assignment"] = "";
          }
          flatUpdate["savedAt"] = new Date().toISOString();

          const docRef = db.collection('daily_edits').doc(docId);
          const existing = await docRef.get();
          if (existing.exists) {
            await docRef.update(flatUpdate);
          }
        }
        showToast(`${absentName} RETURNED TO CT — synced to ShiftOps (Present: YES)`);
      } catch (err) {
        console.error("Failed to sync return-to-present to ShiftOps:", err);
        showToast(`${absentName} RETURNED TO CT — ShiftOps sync failed`);
      }
    } else {
      showToast(`${absentName} RETURNED TO CT for this block`);
    }
  });

  // ========== END CLICK-TO-CHANGE MODAL ==========

  // Track best violation count for this session
  let bestViolationCount = Infinity;

  function updateViolationDisplay() {
    const stats = window.lastRandomizeStats;
    if (!stats) return;

    document.getElementById("violationStats").style.display = "inline-flex";
    document.getElementById("violationCount").textContent = stats.totalViolations;
    document.getElementById("violationPeople").textContent = stats.uniquePeopleWithViolations;

    if (stats.totalViolations < bestViolationCount) {
      bestViolationCount = stats.totalViolations;
      document.getElementById("violationBest").style.display = "inline";
      document.getElementById("violationStats").style.background = "rgba(34,197,94,0.15)";
      document.getElementById("violationStats").style.borderColor = "rgba(34,197,94,0.4)";
    } else {
      document.getElementById("violationBest").style.display = "none";
      document.getElementById("violationStats").style.background = "rgba(239,68,68,0.15)";
      document.getElementById("violationStats").style.borderColor = "rgba(239,68,68,0.4)";
    }
  }

  // ========== POST-OPTIMIZER BALANCE ==========
  function balanceMonth() {
    const plan = loadPlan();
    if (!plan || !plan.days) { showToast("No plan to balance."); return; }

    const PRIMARY = new Set(["North","South","East","West","Central","Northwest"]);
    const dayKeys = Object.keys(plan.days);

    function buildCounts() {
      const counts = new Map();
      for (const dk of dayKeys) {
        const dayData = plan.days[dk];
        for (const bk of BLOCKS) {
          const bd = dayData[bk.key];
          if (!bd || !bd.assignments) continue;
          for (const [ch, nm] of Object.entries(bd.assignments)) {
            if (!nm || !PRIMARY.has(ch)) continue;
            if (SD_ELIGIBLE.has(nm.toUpperCase())) continue;
            if (!counts.has(nm)) counts.set(nm, new Map());
            const m = counts.get(nm);
            m.set(ch, (m.get(ch) || 0) + 1);
          }
        }
      }
      return counts;
    }

    function buildCTCounts() {
      const ct = new Map();
      for (const dk of dayKeys) {
        const dayData = plan.days[dk];
        for (const bk of BLOCKS) {
          const bd = dayData[bk.key];
          if (!bd || !bd.ct) continue;
          for (const nm of bd.ct) {
            if (!nm || SD_ELIGIBLE.has(nm.toUpperCase())) continue;
            ct.set(nm, (ct.get(nm) || 0) + 1);
          }
        }
      }
      return ct;
    }

    // Weekly CT/Relief/DC/Primary cap helpers for balance
    function countWeeklyBlocks(personName, dayKey, type) {
      // type: "CT", "RELIEF", "DC", or a specific primary channel name (e.g. "NORTH")
      const nmUp = personName.toUpperCase();
      const d = new Date(dayKey + "T12:00:00");
      const wkStart = weekKeyFromDate(d);
      let count = 0;
      for (const dk of dayKeys) {
        const dkDate = new Date(dk + "T12:00:00");
        if (weekKeyFromDate(dkDate) !== wkStart) continue;
        const dayData = plan.days[dk];
        if (!dayData) continue;
        for (const bk of BLOCKS) {
          const bd = dayData[bk.key];
          if (!bd) continue;
          if (type === "CT") {
            if (bd.ct && bd.ct.some(n => String(n).toUpperCase() === nmUp)) count++;
          } else if (bd.assignments) {
            for (const [ch, nm] of Object.entries(bd.assignments)) {
              const chUp = ch.toUpperCase();
              if (type === "RELIEF" && (chUp === "RELIEF 1" || chUp === "RELIEF 2") && String(nm).toUpperCase() === nmUp) count++;
              if (type === "DC" && (chUp === "DC1" || chUp === "DC2") && String(nm).toUpperCase() === nmUp) count++;
              if (type !== "RELIEF" && type !== "DC" && chUp === type && String(nm).toUpperCase() === nmUp) count++;
            }
          }
        }
      }
      return count;
    }

    const CTR_SET_BAL = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
    function wouldViolate(personName, dayKey, blockKey, newChannel) {
      const chUp = newChannel.toUpperCase();
      const nmUp = personName.toUpperCase();
      const dayData = plan.days[dayKey];
      if (!dayData) return false;
      const bIdx = BLOCKS.findIndex(b => b.key === blockKey);
      const newIsCTR = CTR_SET_BAL.has(chUp);

      for (let bi = 0; bi < BLOCKS.length; bi++) {
        if (BLOCKS[bi].key === blockKey) continue;
        const bd2 = dayData[BLOCKS[bi].key];
        if (!bd2) continue;
        const isAdjacent = Math.abs(bi - bIdx) === 1;

        let personChHere = null;
        for (const [ch2, nm2] of Object.entries(bd2.assignments || {})) {
          if (String(nm2).toUpperCase() === nmUp) { personChHere = ch2.toUpperCase(); break; }
        }
        if (!personChHere && bd2.ct) {
          for (const ctNm of bd2.ct) {
            if (String(ctNm).toUpperCase() === nmUp) { personChHere = "CT"; break; }
          }
        }
        if (!personChHere) continue;

        if (personChHere === chUp && !isAdjacent) return true;
      }
      return false;
    }

    // Classify people by shift
    const dayBlks = new Set(["0600-1000","1000-1400","1400-1800"]);
    const shiftMap = new Map();
    for (const dk of dayKeys) {
      const dayData = plan.days[dk];
      for (const bk of BLOCKS) {
        const bd = dayData[bk.key];
        if (!bd || !bd.assignments) continue;
        for (const [, nm] of Object.entries(bd.assignments)) {
          if (!nm || SD_ELIGIBLE.has(nm.toUpperCase())) continue;
          if (!shiftMap.has(nm)) shiftMap.set(nm, { day: false, night: false });
          const s = shiftMap.get(nm);
          if (dayBlks.has(bk.key)) s.day = true; else s.night = true;
        }
      }
    }
    const shiftGroups = { day: new Set(), night: new Set(), split: new Set() };
    for (const [nm, s] of shiftMap) {
      if (s.day && s.night) shiftGroups.split.add(nm);
      else if (s.day) shiftGroups.day.add(nm);
      else shiftGroups.night.add(nm);
    }

    let totalSwaps = 0;

    // Phase 1: Channel-Channel Swaps
    for (let pass = 0; pass < 100; pass++) {
      const counts = buildCounts();
      let bestGain = 0, bestSwap = null;

      for (const dk of dayKeys) {
        const dayData = plan.days[dk];
        for (const bk of BLOCKS) {
          const bd = dayData[bk.key];
          if (!bd || !bd.assignments) continue;

          const blockPairs = [];
          for (const [ch, nm] of Object.entries(bd.assignments)) {
            if (!nm || !PRIMARY.has(ch) || SD_ELIGIBLE.has(nm.toUpperCase())) continue;
            blockPairs.push({ ch, nm });
          }

          for (let i = 0; i < blockPairs.length; i++) {
            for (let j = i + 1; j < blockPairs.length; j++) {
              const a = blockPairs[i], b = blockPairs[j];
              if (a.ch === b.ch) continue;

              let sameGroup = false;
              for (const grp of [shiftGroups.day, shiftGroups.night, shiftGroups.split]) {
                if (grp.has(a.nm) && grp.has(b.nm)) { sameGroup = true; break; }
              }
              if (!sameGroup) continue;

              const mA = counts.get(a.nm) || new Map();
              const mB = counts.get(b.nm) || new Map();
              const aOnX = mA.get(a.ch) || 0, aOnY = mA.get(b.ch) || 0;
              const bOnX = mB.get(a.ch) || 0, bOnY = mB.get(b.ch) || 0;

              const before = Math.abs(aOnX - aOnY) + Math.abs(bOnY - bOnX);
              const after = Math.abs(aOnX - 1 - aOnY - 1) + Math.abs(bOnY - 1 - bOnX - 1);
              const gain = before - after;

              if (gain <= bestGain) continue;
              if (wouldViolate(a.nm, dk, bk.key, b.ch)) continue;
              if (wouldViolate(b.nm, dk, bk.key, a.ch)) continue;
              if (traineeBlocked(a.nm, dk, bk.key, b.ch.toUpperCase())) continue;
              if (traineeBlocked(b.nm, dk, bk.key, a.ch.toUpperCase())) continue;
              // Primary channel weekly cap: don't swap if it would push either person over 2 for that channel
              if (countWeeklyBlocks(a.nm, dk, b.ch.toUpperCase()) >= 2) continue;
              if (countWeeklyBlocks(b.nm, dk, a.ch.toUpperCase()) >= 2) continue;

              bestGain = gain;
              bestSwap = { dk, bk: bk.key, chA: a.ch, chB: b.ch, nmA: a.nm, nmB: b.nm };
            }
          }
        }
      }

      if (!bestSwap || bestGain <= 0) break;

      const bd = plan.days[bestSwap.dk][bestSwap.bk];
      bd.assignments[bestSwap.chA] = bestSwap.nmB;
      bd.assignments[bestSwap.chB] = bestSwap.nmA;
      totalSwaps++;
    }

    // Phase 2: CT Balancing Swaps
    for (let pass = 0; pass < 100; pass++) {
      const ctCounts = buildCTCounts();
      const allCT = [...ctCounts.values()];
      if (allCT.length < 2) break;

      let bestGain = 0, bestSwap = null;

      for (const dk of dayKeys) {
        const dayData = plan.days[dk];
        for (const bk of BLOCKS) {
          const bd = dayData[bk.key];
          if (!bd || !bd.ct || !bd.assignments) continue;

          for (let ci = 0; ci < bd.ct.length; ci++) {
            const ctPerson = bd.ct[ci];
            if (!ctPerson || SD_ELIGIBLE.has(ctPerson.toUpperCase())) continue;
            const ctPersonCount = ctCounts.get(ctPerson) || 0;

            for (const [ch, chPerson] of Object.entries(bd.assignments)) {
              if (!chPerson || !PRIMARY.has(ch)) continue;
              if (SD_ELIGIBLE.has(chPerson.toUpperCase())) continue;
              if (chPerson === ctPerson) continue;

              let sameGroup = false;
              for (const grp of [shiftGroups.day, shiftGroups.night, shiftGroups.split]) {
                if (grp.has(ctPerson) && grp.has(chPerson)) { sameGroup = true; break; }
              }
              if (!sameGroup) continue;

              const chPersonCT = ctCounts.get(chPerson) || 0;
              const gain = ctPersonCount - chPersonCT - 1;
              if (gain <= bestGain) continue;

              if (wouldViolate(ctPerson, dk, bk.key, ch)) continue;
              if (wouldViolate(chPerson, dk, bk.key, "CT")) continue;
              if (traineeBlocked(ctPerson, dk, bk.key, ch.toUpperCase())) continue;
              if (isTrainee(chPerson, dk, bk.key)) continue; // Trainee can't go to CT during training blocks
              // Weekly CT cap: don't move chPerson into CT if they're already at cap this week
              if (countWeeklyBlocks(chPerson, dk, "CT") >= 2) continue;
              // Primary channel cap: don't move ctPerson onto primary ch if they're at cap for that channel
              if (countWeeklyBlocks(ctPerson, dk, ch.toUpperCase()) >= 2) continue;

              bestGain = gain;
              bestSwap = { dk, bk: bk.key, ch, ctIdx: ci, ctPerson, chPerson };
            }
          }
        }
      }

      if (!bestSwap || bestGain <= 0) break;

      const bd = plan.days[bestSwap.dk][bestSwap.bk];
      bd.ct[bestSwap.ctIdx] = bestSwap.chPerson;
      bd.assignments[bestSwap.ch] = bestSwap.ctPerson;
      totalSwaps++;
    }

    // Phase 3: Weekly Cap Repair — fix any remaining CT/Relief weekly violations
    for (let wcPass = 0; wcPass < 200; wcPass++) {
      let fixed = false;

      // Find a person with > 2 CT in some week
      for (const dk of dayKeys) {
        const dayData = plan.days[dk];
        for (const bk of BLOCKS) {
          const bd = dayData[bk.key];
          if (!bd || !bd.ct) continue;
          for (let ci = 0; ci < bd.ct.length; ci++) {
            const overPerson = bd.ct[ci];
            if (!overPerson) continue;
            const overWeekCT = countWeeklyBlocks(overPerson, dk, "CT");
            if (overWeekCT <= 2) continue;

            // overPerson has > 2 CT this week — try to swap with someone under cap
            for (const [ch, chPerson] of Object.entries(bd.assignments || {})) {
              if (!chPerson || !PRIMARY.has(ch)) continue;
              if (chPerson === overPerson) continue;
              if (SD_ELIGIBLE.has(chPerson.toUpperCase())) continue;
              if (isTrainee(chPerson, dk, bk.key)) continue;
              if (countWeeklyBlocks(chPerson, dk, "CT") >= 2) continue;
              if (wouldViolate(overPerson, dk, bk.key, ch)) continue;
              if (wouldViolate(chPerson, dk, bk.key, "CT")) continue;
              if (traineeBlocked(overPerson, dk, bk.key, ch.toUpperCase())) continue;
              if (countWeeklyBlocks(overPerson, dk, ch.toUpperCase()) >= 2) continue;

              // Swap: overPerson gets channel, chPerson gets CT
              bd.ct[ci] = chPerson;
              bd.assignments[ch] = overPerson;
              totalSwaps++;
              fixed = true;
              break;
            }
            if (fixed) break;
          }
          if (fixed) break;
        }
        if (fixed) break;
      }
      if (!fixed) break;
    }

    // Phase 3b: Weekly Relief Cap Repair
    for (let wrPass = 0; wrPass < 200; wrPass++) {
      let fixed = false;

      for (const dk of dayKeys) {
        const dayData = plan.days[dk];
        for (const bk of BLOCKS) {
          const bd = dayData[bk.key];
          if (!bd || !bd.assignments) continue;

          for (const [rCh, overPerson] of Object.entries(bd.assignments)) {
            if (!overPerson) continue;
            const rUp = rCh.toUpperCase();
            if (rUp !== "RELIEF 1" && rUp !== "RELIEF 2") continue;
            const overWeekR = countWeeklyBlocks(overPerson, dk, "RELIEF");
            if (overWeekR <= 2) continue;

            // overPerson has > 2 Relief this week — try to swap with someone under cap
            for (const [ch2, underPerson] of Object.entries(bd.assignments)) {
              if (!underPerson || ch2 === rCh) continue;
              if (!PRIMARY.has(ch2)) continue;
              if (underPerson === overPerson) continue;
              if (SD_ELIGIBLE.has(underPerson.toUpperCase())) continue;
              if (countWeeklyBlocks(underPerson, dk, "RELIEF") >= 2) continue;
              if (wouldViolate(overPerson, dk, bk.key, ch2)) continue;
              if (wouldViolate(underPerson, dk, bk.key, rCh)) continue;
              if (traineeBlocked(overPerson, dk, bk.key, ch2.toUpperCase())) continue;
              if (traineeBlocked(underPerson, dk, bk.key, rUp)) continue;
              if (countWeeklyBlocks(overPerson, dk, ch2.toUpperCase()) >= 2) continue;

              // Swap: overPerson gets primary channel, underPerson gets relief
              bd.assignments[rCh] = underPerson;
              bd.assignments[ch2] = overPerson;
              totalSwaps++;
              fixed = true;
              break;
            }
            if (fixed) break;
          }
          if (fixed) break;
        }
        if (fixed) break;
      }
      if (!fixed) break;
    }

    // Phase 3c: Weekly DC Cap Repair
    for (let wdPass = 0; wdPass < 200; wdPass++) {
      let fixed = false;

      for (const dk of dayKeys) {
        const dayData = plan.days[dk];
        for (const bk of BLOCKS) {
          const bd = dayData[bk.key];
          if (!bd || !bd.assignments) continue;

          for (const [dCh, overPerson] of Object.entries(bd.assignments)) {
            if (!overPerson) continue;
            const dUp = dCh.toUpperCase();
            if (dUp !== "DC1" && dUp !== "DC2") continue;
            const overWeekD = countWeeklyBlocks(overPerson, dk, "DC");
            if (overWeekD <= 2) continue;

            // overPerson has > 2 DC this week — try to swap with someone under cap
            for (const [ch2, underPerson] of Object.entries(bd.assignments)) {
              if (!underPerson || ch2 === dCh) continue;
              if (!PRIMARY.has(ch2)) continue;
              if (underPerson === overPerson) continue;
              if (SD_ELIGIBLE.has(underPerson.toUpperCase())) continue;
              if (countWeeklyBlocks(underPerson, dk, "DC") >= 2) continue;
              if (wouldViolate(overPerson, dk, bk.key, ch2)) continue;
              if (wouldViolate(underPerson, dk, bk.key, dCh)) continue;
              if (traineeBlocked(overPerson, dk, bk.key, ch2.toUpperCase())) continue;
              if (traineeBlocked(underPerson, dk, bk.key, dUp)) continue;
              if (countWeeklyBlocks(overPerson, dk, ch2.toUpperCase()) >= 2) continue;

              // Swap: overPerson gets primary channel, underPerson gets DC
              bd.assignments[dCh] = underPerson;
              bd.assignments[ch2] = overPerson;
              totalSwaps++;
              fixed = true;
              break;
            }
            if (fixed) break;
          }
          if (fixed) break;
        }
        if (fixed) break;
      }
      if (!fixed) break;
    }

    // Phase 3d: Weekly Primary Channel Cap Repair (max 2 of any specific primary per week)
    const PRIMARY_ARR = [...PRIMARY]; // ["North","South","East","West","Central","Northwest"]
    for (let wpPass = 0; wpPass < 200; wpPass++) {
      let fixed = false;

      for (const dk of dayKeys) {
        const dayData = plan.days[dk];
        for (const bk of BLOCKS) {
          const bd = dayData[bk.key];
          if (!bd || !bd.assignments) continue;

          for (const [pCh, overPerson] of Object.entries(bd.assignments)) {
            if (!overPerson) continue;
            if (!PRIMARY.has(pCh)) continue;
            const pUp = pCh.toUpperCase();
            const overWeekP = countWeeklyBlocks(overPerson, dk, pUp);
            if (overWeekP <= 2) continue;

            // overPerson has > 2 of this specific primary channel this week
            // Try to swap with someone on a DIFFERENT primary who has < 2 of pCh this week
            for (const [ch2, underPerson] of Object.entries(bd.assignments)) {
              if (!underPerson || ch2 === pCh) continue;
              if (!PRIMARY.has(ch2)) continue;
              if (underPerson === overPerson) continue;
              if (SD_ELIGIBLE.has(underPerson.toUpperCase())) continue;
              // underPerson must be under cap for the channel they'd receive (pCh)
              if (countWeeklyBlocks(underPerson, dk, pUp) >= 2) continue;
              // overPerson must be under cap for the channel they'd receive (ch2)
              if (countWeeklyBlocks(overPerson, dk, ch2.toUpperCase()) >= 2) continue;
              if (wouldViolate(overPerson, dk, bk.key, ch2)) continue;
              if (wouldViolate(underPerson, dk, bk.key, pCh)) continue;
              if (traineeBlocked(overPerson, dk, bk.key, ch2.toUpperCase())) continue;
              if (traineeBlocked(underPerson, dk, bk.key, pUp)) continue;

              // Swap: overPerson gets ch2, underPerson gets pCh
              bd.assignments[pCh] = underPerson;
              bd.assignments[ch2] = overPerson;
              totalSwaps++;
              fixed = true;
              break;
            }
            if (fixed) break;
          }
          if (fixed) break;
        }
        if (fixed) break;
      }
      if (!fixed) break;
    }

    savePlan(plan);

    const counts = buildCounts();
    const ctCounts = buildCTCounts();
    let maxChSpread = 0;
    for (const ch of PRIMARY) {
      let mn = Infinity, mx = 0;
      for (const [nm, m] of counts) {
        const c = m.get(ch) || 0;
        if (c < mn) mn = c;
        if (c > mx) mx = c;
      }
      const sp = mx - (mn === Infinity ? 0 : mn);
      if (sp > maxChSpread) maxChSpread = sp;
    }
    const ctVals = [...ctCounts.values()];
    const ctSpread = ctVals.length > 1 ? Math.max(...ctVals) - Math.min(...ctVals) : 0;

    const m2 = Number(document.getElementById("monthSel").value);
    const y2 = Number(document.getElementById("yearSel").value);
    const dk2 = ymd(new Date());
    renderDay(dk2); renderWeek(dk2); renderMonth(y2, m2);
    if (loadJSON(STORAGE.ui, {}).tab === "mroster") renderMonthRostersIfActive();

    showToast(`BALANCE: ${totalSwaps} swaps made. Worst channel spread: ${maxChSpread}, CT spread: ${ctSpread}.`);
  }

  // ========== RANDOMIZE & SAVE ==========
  let _lastRandomizeFn = randomizeMonth; // Track which randomizer was last used

  async function _doRandomize(randomFn, btnEl) {
    const pwd = prompt("ENTER PASSWORD TO RANDOMIZE:");
    if (pwd !== "911911") { showToast("INCORRECT PASSWORD."); return; }
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);

    // Ask how long to search
    const minutesInput = prompt("How many MINUTES should the optimizer run?\n\n• 1 = quick (~200 attempts)\n• 5 = solid (~1000 attempts)\n• 30 = thorough\n• 480 = overnight (8 hours)\n\nEnter minutes (or blank for 1):", "1");
    if (minutesInput === null) return; // cancelled
    const timeLimitMin = Math.max(0.25, Number(minutesInput) || 1);
    const timeLimitMs = timeLimitMin * 60 * 1000;

    const btnLabel = btnEl.textContent;
    bestViolationCount = Infinity;
    _lastRandomizeFn = randomFn;

    btnEl.disabled = true;
    btnEl.textContent = "RANDOMIZING...";

    let attempts = 0;
    let viol = Infinity;
    let bestPlan = null;
    let bestViol = Infinity;
    let bestSpread = Infinity;
    let bestCT = Infinity;
    let bestScore = Infinity;
    let bestSumSpreads = Infinity;
    let bestCtSpread = Infinity;
    let bestB2bSpread = Infinity;
    let bestDcSpread = Infinity;
    let bestTotalSpread = Infinity;
    let lastImprovedAt = 0;

    // Composite score: violations use threshold (under 10 is acceptable, focus on balance)
    const VIOL_THRESHOLD = 10;
    function _qualityScore(v, sumSpreads, worstSpread, ctSpread, b2bSpread, dcSpread, totalSpread) {
      const vv = v || 0;
      return Math.max(0, vv - VIOL_THRESHOLD) * 10000
        + vv * 100
        + (totalSpread || 0) * 600
        + (sumSpreads || 0) * 200
        + (worstSpread || 0) * 300
        + (ctSpread || 0) * 250
        + (b2bSpread || 0) * 100
        + (dcSpread || 0) * 50;
    }

    function _formatElapsed(ms) {
      const sec = Math.floor(ms / 1000);
      if (sec < 60) return `${sec}s`;
      const min = Math.floor(sec / 60);
      const remSec = sec % 60;
      if (min < 60) return `${min}m ${remSec}s`;
      const hr = Math.floor(min / 60);
      const remMin = min % 60;
      return `${hr}h ${remMin}m`;
    }

    const startTime = Date.now();

    // Use async loop with yielding so the browser stays responsive
    async function _runBatch() {
      const BATCH_SIZE = 5; // run 5 attempts then yield to UI
      for (let i = 0; i < BATCH_SIZE; i++) {
        const elapsed = Date.now() - startTime;
        if (elapsed >= timeLimitMs) return true; // time's up

        try {
          randomFn(y, m);
          viol = window.lastRandomizeStats?.totalViolations ?? Infinity;
        } catch (err) {
          console.error("randomize error on attempt " + attempts + ":", err);
          viol = Infinity;
        }
        attempts++;

        const stats = window.lastRandomizeStats || {};
        const spread = stats.maxPrimaryCount || 0;
        const sumSpreads = stats.sumPrimarySpreads || 0;
        const ctSpread = stats.ctSpread || 0;
        const b2bSpread = stats.b2bSpread || 0;
        const dcSpread = stats.dcSpread || 0;
        const totalSpread = stats.totalSpread || 0;
        const score = _qualityScore(viol, sumSpreads, spread, ctSpread, b2bSpread, dcSpread, totalSpread);

        if (score < bestScore) {
          bestScore = score;
          bestViol = viol;
          bestSpread = spread;
          bestCT = stats.maxCTCount || 0;
          bestSumSpreads = sumSpreads;
          bestCtSpread = ctSpread;
          bestB2bSpread = b2bSpread;
          bestDcSpread = dcSpread;
          bestTotalSpread = totalSpread;
          bestPlan = JSON.parse(JSON.stringify(loadPlan()));
          lastImprovedAt = attempts;
        }

        // Only stop early if we hit a near-perfect result
        if (bestViol <= 5 && bestSpread <= 2 && bestCtSpread <= 4 && bestB2bSpread <= 2 && bestTotalSpread <= 1) return true;
      }
      return false; // not done yet
    }

    // Main async loop — yields every batch so UI updates
    let done = false;
    while (!done) {
      done = await new Promise(resolve => {
        setTimeout(async () => {
          const finished = await _runBatch();
          const elapsed = Date.now() - startTime;
          const elapsedStr = _formatElapsed(elapsed);
          const remainStr = _formatElapsed(Math.max(0, timeLimitMs - elapsed));
          btnEl.textContent = `OPTIMIZING... ${elapsedStr} (${attempts} runs, best: ${bestViol}v/Σ${bestSumSpreads}sp/tot${bestTotalSpread}) — ${remainStr} left`;
          resolve(finished);
        }, 0); // yield to browser
      });
    }

    const totalElapsed = _formatElapsed(Date.now() - startTime);
    console.log(`RANDOMIZE: ${attempts} attempts in ${totalElapsed}. Best: ${bestViol}v / worst-ch ${bestSpread} / Σspreads ${bestSumSpreads} / ct-spread ${bestCtSpread} / b2b-spread ${bestB2bSpread} / dc-spread ${bestDcSpread} / total-spread ${bestTotalSpread} (improved at attempt #${lastImprovedAt})`);

    // Always restore best plan and update stats
    if (bestPlan) {
      savePlan(bestPlan);
      viol = bestViol;
    }
    window.lastRandomizeStats = window.lastRandomizeStats || {};
    window.lastRandomizeStats.totalViolations = bestViol === Infinity ? 0 : bestViol;
    window.lastRandomizeStats.maxPrimaryCount = bestSpread === Infinity ? 0 : bestSpread;
    window.lastRandomizeStats.maxCTCount = bestCT === Infinity ? 0 : bestCT;
    window.lastRandomizeStats.sumPrimarySpreads = bestSumSpreads === Infinity ? 0 : bestSumSpreads;
    window.lastRandomizeStats.ctSpread = bestCtSpread === Infinity ? 0 : bestCtSpread;
    window.lastRandomizeStats.b2bSpread = bestB2bSpread === Infinity ? 0 : bestB2bSpread;
    window.lastRandomizeStats.dcSpread = bestDcSpread === Infinity ? 0 : bestDcSpread;
    window.lastRandomizeStats.totalSpread = bestTotalSpread === Infinity ? 0 : bestTotalSpread;

    updateViolationDisplay();
    const dk = ymd(new Date());
    document.getElementById("dayPick").value = dk;
    renderDay(dk); renderWeek(dk); renderMonth(y,m); if (loadJSON(STORAGE.ui, {}).tab==="mroster") renderMonthRostersIfActive();
    showSwapTip();
    showToast(`Done! ${attempts} attempts in ${totalElapsed}. Best: ${bestViol}v, worst-ch ${bestSpread}, Σspreads ${bestSumSpreads}, ct-sp ${bestCtSpread}, b2b-sp ${bestB2bSpread}, tot-sp ${bestTotalSpread}. Improved at #${lastImprovedAt}.`);

    // Log what we're about to save
    const savePlanCheck = loadPlan();
    const saveFirstDay = savePlanCheck ? Object.keys(savePlanCheck.days || {})[0] : null;
    const saveFirstBlock = saveFirstDay ? savePlanCheck.days[saveFirstDay] : null;
    const saveFirstBlockKey = saveFirstBlock ? Object.keys(saveFirstBlock)[0] : null;
    const saveFirstAssign = saveFirstBlockKey && saveFirstBlock[saveFirstBlockKey]?.assignments
      ? Object.values(saveFirstBlock[saveFirstBlockKey].assignments).slice(0,3).join(", ")
      : "none";
    console.log("RANDOMIZE: About to save. First day assignments:", saveFirstDay, "→", saveFirstAssign);

    // Save to Firebase immediately — block everything until done
    btnEl.textContent = "SAVING TO FIREBASE...";
    if (autoSaveTimer) clearTimeout(autoSaveTimer);
    if (realtimeUnsubscribe) { realtimeUnsubscribe(); realtimeUnsubscribe = null; }
    isSyncing = true;
    setSyncStatus("SAVING...", "pending");

    let ok = false;
    try {
      ok = await saveRotationToFirebase();
    } catch (err) {
      console.error("Save after randomize failed:", err);
    }

    isSyncing = false;
    btnEl.disabled = false;
    btnEl.textContent = btnLabel;

    if (ok) {
      lastSavedAt = Date.now();
      setSyncStatus("SYNCED", "good");
      const plan = loadPlan();
      const docId = plan && plan.meta ? `rotation_${plan.meta.year}_${plan.meta.monthIndex}` : "unknown";
      showToast(`SAVED & VERIFIED! Doc: ${docId} — ${viol} violations (${attempts} attempts)`);
    } else {
      setSyncStatus("SAVE FAILED", "bad");
      alert("FAILED TO SAVE TO FIREBASE. Your rotation was NOT saved. Check your internet and try again.");
    }

    // Reconnect realtime sync now that Firebase has the new data
    startRealtimeSync(y, m);
  }

  document.getElementById("btnRandomizeA").addEventListener("click", async () => {
    await _doRandomize(randomizeMonth, document.getElementById("btnRandomizeA"));
  });
  document.getElementById("btnCheckViol").addEventListener("click", () => {
    const plan = loadPlan();
    if (!plan || !plan.days) { showToast("No plan loaded."); return; }

    const year = plan.meta.year;
    const monthIndex = plan.meta.monthIndex;
    const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();

    const ctrSet = new Set(["CT","RELIEF 1","RELIEF 2","R1","R2"]);
    const _primB2B = new Set(["NORTH","SOUTH","EAST","WEST","NORTHWEST","CENTRAL","CT","RELIEF 1","RELIEF 2"]);
    const allViolations = []; // {name, type, dayKey, blockKey, detail}

    // === 1) Same-channel-twice violations (per day) ===
    for (let day = 1; day <= daysInMonth; day++) {
      const dateObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
      const dk = ymd(dateObj);
      const dayData = plan.days[dk];
      if (!dayData) continue;

      const personAssignments = new Map();
      for (let bi = 0; bi < BLOCKS.length; bi++) {
        const bd = dayData[BLOCKS[bi].key];
        if (!bd) continue;
        for (const [ch, nm] of Object.entries(bd.assignments || {})) {
          if (!nm) continue;
          const key = nm.toUpperCase();
          if (!personAssignments.has(key)) personAssignments.set(key, []);
          personAssignments.get(key).push({ blockIdx: bi, blockKey: BLOCKS[bi].key, channel: ch.toUpperCase() });
        }
        for (const nm of (bd.ct || [])) {
          if (!nm) continue;
          const key = nm.toUpperCase();
          if (!personAssignments.has(key)) personAssignments.set(key, []);
          personAssignments.get(key).push({ blockIdx: bi, blockKey: BLOCKS[bi].key, channel: "CT" });
        }
      }

      for (const [nm, assigns] of personAssignments) {
        assigns.sort((a, b) => a.blockIdx - b.blockIdx);
        const dayChannels = new Map();
        for (let i = 0; i < assigns.length; i++) {
          const curr = assigns[i];
          const chUpper = curr.channel;
          const _weeklyCappedCV = new Set(["CT","RELIEF 1","RELIEF 2","DC1","DC2"]);
          if (dayChannels.has(chUpper) && chUpper !== "SD" && !_weeklyCappedCV.has(chUpper)) {
            const isAllowedB2B = _primB2B.has(chUpper) && i > 0 &&
              assigns[i-1].channel === chUpper && assigns[i-1].blockIdx === curr.blockIdx - 1 &&
              (dayChannels.get(chUpper) || 0) < 2;
            if (!isAllowedB2B) {
              allViolations.push({
                name: nm, type: "Same Channel", dayKey: dk, blockKey: curr.blockKey,
                detail: `${chUpper} appears ${(dayChannels.get(chUpper)||0)+1}x on ${dk}`
              });
            }
          }
          dayChannels.set(chUpper, (dayChannels.get(chUpper) || 0) + 1);
        }
      }
    }

    // === 2) Weekly CT/Relief/DC/Primary cap violations ===
    const _wkData = new Map(); // name -> Map<weekKey, {ct:[], relief:[], dc:[], primCh: Map(ch->[])}>
    const _primNamesCV = new Set(["NORTH","EAST","SOUTH","WEST","CENTRAL","NORTHWEST"]);
    for (let day = 1; day <= daysInMonth; day++) {
      const dateObj = new Date(year, monthIndex, day, 12, 0, 0, 0);
      const dk = ymd(dateObj);
      const wkKey = weekKeyFromDate(dateObj);
      const dayData = plan.days[dk];
      if (!dayData) continue;

      for (let bi = 0; bi < BLOCKS.length; bi++) {
        const bd = dayData[BLOCKS[bi].key];
        if (!bd) continue;
        const bLabel = BLOCKS[bi].label || BLOCKS[bi].key;

        for (const nm of (bd.ct || [])) {
          if (!nm) continue;
          const n = nm.toUpperCase();
          if (!_wkData.has(n)) _wkData.set(n, new Map());
          const wm = _wkData.get(n);
          if (!wm.has(wkKey)) wm.set(wkKey, {ct:[], relief:[], dc:[], primCh: new Map()});
          wm.get(wkKey).ct.push({dk, bLabel});
        }
        for (const [ch, nm] of Object.entries(bd.assignments || {})) {
          if (!nm) continue;
          const chUp = ch.toUpperCase();
          const n = nm.toUpperCase();
          if (!_wkData.has(n)) _wkData.set(n, new Map());
          const wm = _wkData.get(n);
          if (!wm.has(wkKey)) wm.set(wkKey, {ct:[], relief:[], dc:[], primCh: new Map()});
          const bucket = wm.get(wkKey);
          if (chUp === "RELIEF 1" || chUp === "RELIEF 2") {
            bucket.relief.push({dk, bLabel});
          } else if (chUp === "DC1" || chUp === "DC2") {
            bucket.dc.push({dk, bLabel});
          }
          if (_primNamesCV.has(chUp)) {
            if (!bucket.primCh.has(chUp)) bucket.primCh.set(chUp, []);
            bucket.primCh.get(chUp).push({dk, bLabel});
          }
        }
      }
    }

    for (const [name, weeks] of _wkData) {
      for (const [wk, bucket] of weeks) {
        if (bucket.ct.length > 2) {
          const wkDate = new Date(wk + "T12:00:00");
          const wkEnd = new Date(wkDate); wkEnd.setDate(wkEnd.getDate() + 6);
          const wkLabel = `${wkDate.getMonth()+1}/${wkDate.getDate()} - ${wkEnd.getMonth()+1}/${wkEnd.getDate()}`;
          const blockList = bucket.ct.map(b => `${b.dk} ${b.bLabel}`).join(", ");
          allViolations.push({
            name, type: "CT Weekly Max", dayKey: wk, blockKey: "-",
            detail: `Week ${wkLabel}: ${bucket.ct.length} CT blocks (max 2) \u2014 ${blockList}`
          });
        }
        if (bucket.relief.length > 2) {
          const wkDate = new Date(wk + "T12:00:00");
          const wkEnd = new Date(wkDate); wkEnd.setDate(wkEnd.getDate() + 6);
          const wkLabel = `${wkDate.getMonth()+1}/${wkDate.getDate()} - ${wkEnd.getMonth()+1}/${wkEnd.getDate()}`;
          const blockList = bucket.relief.map(b => `${b.dk} ${b.bLabel}`).join(", ");
          allViolations.push({
            name, type: "Relief Weekly Max", dayKey: wk, blockKey: "-",
            detail: `Week ${wkLabel}: ${bucket.relief.length} Relief blocks (max 2) \u2014 ${blockList}`
          });
        }
        if (bucket.dc.length > 2) {
          const wkDate = new Date(wk + "T12:00:00");
          const wkEnd = new Date(wkDate); wkEnd.setDate(wkEnd.getDate() + 6);
          const wkLabel = `${wkDate.getMonth()+1}/${wkDate.getDate()} - ${wkEnd.getMonth()+1}/${wkEnd.getDate()}`;
          const blockList = bucket.dc.map(b => `${b.dk} ${b.bLabel}`).join(", ");
          allViolations.push({
            name, type: "DC Weekly Max", dayKey: wk, blockKey: "-",
            detail: `Week ${wkLabel}: ${bucket.dc.length} DC blocks (max 2) \u2014 ${blockList}`
          });
        }
        for (const [pCh, pArr] of bucket.primCh) {
          if (pArr.length > 2) {
            const wkDate = new Date(wk + "T12:00:00");
            const wkEnd = new Date(wkDate); wkEnd.setDate(wkEnd.getDate() + 6);
            const wkLabel = `${wkDate.getMonth()+1}/${wkDate.getDate()} - ${wkEnd.getMonth()+1}/${wkEnd.getDate()}`;
            const blockList = pArr.map(b => `${b.dk} ${b.bLabel}`).join(", ");
            allViolations.push({
              name, type: `${pCh} Weekly Max`, dayKey: wk, blockKey: "-",
              detail: `Week ${wkLabel}: ${pArr.length} ${pCh} blocks (max 2) \u2014 ${blockList}`
            });
          }
        }
      }
    }

    // === Build report ===
    const totalViol = allViolations.length;
    const violPeople = new Map();
    for (const v of allViolations) {
      violPeople.set(v.name, (violPeople.get(v.name) || 0) + 1);
    }
    const peopleCount = violPeople.size;

    // Count by type
    const typeCounts = new Map();
    for (const v of allViolations) {
      typeCounts.set(v.type, (typeCounts.get(v.type) || 0) + 1);
    }

    // Group by person
    const byPerson = new Map();
    for (const v of allViolations) {
      if (!byPerson.has(v.name)) byPerson.set(v.name, []);
      byPerson.get(v.name).push(v);
    }

    // Build text report
    const lines = [];
    lines.push("\u2550".repeat(39));
    lines.push("         VIOLATION REPORT");
    lines.push("\u2550".repeat(39));
    lines.push("");
    lines.push(`TOTAL VIOLATIONS: ${totalViol}`);
    lines.push(`PEOPLE AFFECTED:  ${peopleCount}`);
    lines.push("");

    if (typeCounts.size > 0) {
      lines.push("\u2500\u2500 Breakdown by Type \u2500\u2500");
      for (const [type, count] of typeCounts) {
        lines.push(`  ${type}:  ${String(count).padStart(3)}`);
      }
      lines.push("");
    }

    if (byPerson.size > 0) {
      lines.push("\u2500\u2500 Violations by Person \u2500\u2500");
      lines.push("");
      const sorted = [...byPerson.entries()].sort((a, b) => b[1].length - a[1].length);
      for (const [name, viols] of sorted) {
        lines.push(`  ${name} (${viols.length} violation${viols.length > 1 ? "s" : ""}):`);
        for (const v of viols) {
          if (v.blockKey === "-") {
            lines.push(`    ${v.dayKey} | - | ${v.type} | ${v.detail}`);
          } else {
            lines.push(`    ${v.dayKey} | ${v.blockKey} | ${v.type} | ${v.detail}`);
          }
        }
        lines.push("");
      }
    }

    lines.push("\u2550".repeat(39));

    const reportText = lines.join("\n");

    // Copy to clipboard
    navigator.clipboard.writeText(reportText).then(() => {
      showToast("Violation report copied to clipboard!");
    }).catch(() => {
      showToast("Report generated (clipboard copy failed).");
    });

    // Update stats display
    window.lastRandomizeStats = window.lastRandomizeStats || {};
    window.lastRandomizeStats.totalViolations = totalViol;
    window.lastRandomizeStats.uniquePeopleWithViolations = peopleCount;
    updateViolationDisplay();
  });

  // ========== REMOVE FROM ROTATION ==========
  document.getElementById("btnRemoveRot").addEventListener("click", () => {
    const pwd = prompt("ENTER PASSWORD:");
    if (pwd !== "911911") { showToast("INCORRECT PASSWORD."); return; }
    const plan = loadPlan();
    if (!plan || !plan.days) { showToast("No plan loaded. Randomize a month first."); return; }

    const year = plan.meta.year;
    const monthIndex = plan.meta.monthIndex;
    const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();

    // Build list of all people who have assignments in this plan
    const nameSet = new Set();
    for (const dk of Object.keys(plan.days)) {
      const dayData = plan.days[dk];
      for (const bk of Object.keys(dayData)) {
        const bd = dayData[bk];
        if (!bd || typeof bd !== 'object') continue;
        for (const nm of Object.values(bd.assignments || {})) {
          if (nm) nameSet.add(String(nm).trim().toUpperCase());
        }
        for (const nm of (bd.ct || [])) { if (nm) nameSet.add(String(nm).trim().toUpperCase()); }
        for (const nm of (bd.sd || [])) { if (nm) nameSet.add(String(nm).trim().toUpperCase()); }
      }
    }

    const sel = document.getElementById("removeRotPerson");
    sel.innerHTML = "";
    const sorted = Array.from(nameSet).sort();
    for (const nm of sorted) {
      const opt = document.createElement("option");
      opt.value = nm;
      opt.textContent = nm;
      sel.appendChild(opt);
    }

    // Set date range defaults to first/last of current plan month
    const pad2 = n => String(n).padStart(2, '0');
    document.getElementById("removeRotStart").value = `${year}-${pad2(monthIndex+1)}-01`;
    document.getElementById("removeRotEnd").value = `${year}-${pad2(monthIndex+1)}-${pad2(daysInMonth)}`;
    document.getElementById("removeRotPreview").style.display = "none";

    document.getElementById("removeRotModal").style.display = "flex";
  });

  // Preview on change
  function updateRemovePreview() {
    const plan = loadPlan();
    if (!plan || !plan.days) return;
    const person = document.getElementById("removeRotPerson").value;
    const startVal = document.getElementById("removeRotStart").value;
    const endVal = document.getElementById("removeRotEnd").value;
    if (!person || !startVal || !endVal) { document.getElementById("removeRotPreview").style.display = "none"; return; }

    const startDate = new Date(startVal + "T12:00:00");
    const endDate = new Date(endVal + "T12:00:00");
    let slotCount = 0;
    const dayKeys = [];

    for (const dk of Object.keys(plan.days).sort()) {
      const d = parseYMD(dk);
      if (!d) continue;
      if (d < startDate || d > endDate) continue;
      const dayData = plan.days[dk];
      for (const bk of Object.keys(dayData)) {
        const bd = dayData[bk];
        if (!bd || typeof bd !== 'object') continue;
        for (const [ch, nm] of Object.entries(bd.assignments || {})) {
          if (nm && String(nm).toUpperCase() === person) slotCount++;
        }
        for (const nm of (bd.ct || [])) { if (String(nm).toUpperCase() === person) slotCount++; }
        for (const nm of (bd.sd || [])) { if (String(nm).toUpperCase() === person) slotCount++; }
      }
      dayKeys.push(dk);
    }

    const preview = document.getElementById("removeRotPreview");
    if (slotCount > 0) {
      preview.innerHTML = `<b style="color:#ef4444;">${person}</b> has <b>${slotCount} assignment${slotCount !== 1 ? 's' : ''}</b> across <b>${dayKeys.length} day${dayKeys.length !== 1 ? 's' : ''}</b> in this range. All will be cleared to NEEDED.`;
      preview.style.display = "block";
    } else {
      preview.innerHTML = `<b>${person}</b> has no assignments in this date range.`;
      preview.style.display = "block";
    }
  }
  document.getElementById("removeRotPerson").addEventListener("change", updateRemovePreview);
  document.getElementById("removeRotStart").addEventListener("change", updateRemovePreview);
  document.getElementById("removeRotEnd").addEventListener("change", updateRemovePreview);
  // Trigger initial preview
  setTimeout(updateRemovePreview, 100);

  // Confirm removal
  document.getElementById("btnRemoveRotConfirm").addEventListener("click", () => {
    const plan = loadPlan();
    if (!plan || !plan.days) return;
    const person = document.getElementById("removeRotPerson").value;
    const startVal = document.getElementById("removeRotStart").value;
    const endVal = document.getElementById("removeRotEnd").value;
    if (!person || !startVal || !endVal) { showToast("SELECT A PERSON AND DATE RANGE."); return; }

    const startDate = new Date(startVal + "T12:00:00");
    const endDate = new Date(endVal + "T12:00:00");
    let removed = 0;

    for (const dk of Object.keys(plan.days)) {
      const d = parseYMD(dk);
      if (!d) continue;
      if (d < startDate || d > endDate) continue;
      const dayData = plan.days[dk];
      for (const bk of Object.keys(dayData)) {
        const bd = dayData[bk];
        if (!bd || typeof bd !== 'object') continue;
        // Remove from channel assignments
        for (const [ch, nm] of Object.entries(bd.assignments || {})) {
          if (nm && String(nm).toUpperCase() === person) {
            bd.assignments[ch] = "";
            removed++;
          }
        }
        // Remove from CT
        if (bd.ct) {
          for (let i = bd.ct.length - 1; i >= 0; i--) {
            if (String(bd.ct[i]).toUpperCase() === person) {
              bd.ct.splice(i, 1);
              removed++;
            }
          }
        }
        // Remove from SD
        if (bd.sd) {
          for (let i = bd.sd.length - 1; i >= 0; i--) {
            if (String(bd.sd[i]).toUpperCase() === person) {
              bd.sd.splice(i, 1);
              removed++;
            }
          }
        }
        // Remove from OT tracking
        if (bd.ot) {
          for (let i = bd.ot.length - 1; i >= 0; i--) {
            if (String(bd.ot[i]).toUpperCase() === person) {
              bd.ot.splice(i, 1);
            }
          }
        }
      }
    }

    savePlan(plan);
    document.getElementById("removeRotModal").style.display = "none";

    // Refresh all views
    const dk = document.getElementById("dayPick").value;
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    renderDay(dk); renderWeek(dk); renderMonth(y, m);
    if (loadJSON(STORAGE.ui, {}).tab === "mroster") renderMonthRostersIfActive();

    showToast(`REMOVED ${person} — ${removed} assignment${removed !== 1 ? 's' : ''} cleared to NEEDED.`);
  });

  // Cancel
  document.getElementById("btnRemoveRotCancel").addEventListener("click", () => {
    document.getElementById("removeRotModal").style.display = "none";
  });
  document.getElementById("removeRotModal").addEventListener("click", (e) => {
    if (e.target.id === "removeRotModal") document.getElementById("removeRotModal").style.display = "none";
  });

  document.getElementById("btnBalance").addEventListener("click", () => {
    const pwd = prompt("ENTER PASSWORD TO BALANCE:");
    if (pwd !== "911911") { showToast("INCORRECT PASSWORD."); return; }
    const btn = document.getElementById("btnBalance");
    btn.disabled = true;
    btn.textContent = "BALANCING...";
    setTimeout(() => {
      balanceMonth();
      btn.disabled = false;
      btn.textContent = "BALANCE";
    }, 50);
  });

  // When month/year changes, try to load from Firebase
  const monthYearChanged = async () => {
    const m = Number(document.getElementById("monthSel").value);
    const y = Number(document.getElementById("yearSel").value);
    setSyncStatus("LOADING...", "pending");
    const loaded = await loadRotationFromFirebase(y, m);
    if (loaded) {
      setSyncStatus("SYNCED", "good");
      const plan = loadPlan();
      if (plan && plan.meta && plan.meta.year === y && plan.meta.monthIndex === m) {
        const dk = ymd(new Date(y, m, 1, 12, 0, 0, 0));
        document.getElementById("dayPick").value = dk;
        renderDay(dk); renderWeek(dk); renderMonth(y, m);
        if (loadJSON(STORAGE.ui, {}).tab === "mroster") renderMonthRostersIfActive();
      }
    } else {
      setSyncStatus("LOCAL", null);
    }
    startRealtimeSync(y, m);
  };
  document.getElementById("monthSel").addEventListener("change", monthYearChanged);
  document.getElementById("yearSel").addEventListener("change", monthYearChanged);

  const btnRandomizeAgain = document.getElementById("btnRandomizeAgain");
  if (btnRandomizeAgain) {
    btnRandomizeAgain.addEventListener("click", ()=>{
      const m = Number(document.getElementById("monthSel").value);
      const y = Number(document.getElementById("yearSel").value);
      _lastRandomizeFn(y, m);
      updateViolationDisplay();
      const viol = window.lastRandomizeStats?.totalViolations || 0;
      const isBest = viol <= bestViolationCount;
      showToast(`Re-randomized ${monthName(m)} ${y}. Violations: ${viol}${isBest ? ' (Best!)' : ''}`);
      const dk = document.getElementById("dayPick").value || ymd(new Date(y,m,1,12,0,0,0));
      renderDay(dk); renderWeek(dk); renderMonth(y,m); if (loadJSON(STORAGE.ui, {}).tab==="mroster") renderMonthRostersIfActive();
    });
  }

  const btnHardReset = document.getElementById("btnHardReset");
  if (btnHardReset) {
    btnHardReset.addEventListener("click", ()=>{
      for (const k of Object.values(STORAGE)) localStorage.removeItem(k);
      showToast("Cleared saved data. Reloading...");
      setTimeout(()=>location.reload(), 600);
    });
  }

  // ========== THEME TOGGLE ==========
  function applyTheme(isLight) {
    document.body.classList.toggle("light", isLight);
    document.getElementById("themeIcon").textContent = isLight ? "🌙" : "☀️";
    document.getElementById("themeLabel").textContent = isLight ? "DARK" : "LIGHT";
    saveJSON(STORAGE.theme, isLight ? "light" : "dark");
  }
  document.getElementById("btnThemeToggle").addEventListener("click", () => {
    applyTheme(!document.body.classList.contains("light"));
  });
  // Apply saved theme
  if (loadJSON(STORAGE.theme, "dark") === "light") applyTheme(true);

  // Employee management removed — employees are managed in the base data

  // ========== SWAP HISTORY ==========
  function getSwapHistory() {
    return loadJSON(STORAGE.swapHistory, []);
  }
  function addSwapHistory(entry) {
    const history = getSwapHistory();
    history.unshift({ ...entry, timestamp: new Date().toISOString() });
    if (history.length > 100) history.length = 100; // Keep last 100
    saveJSON(STORAGE.swapHistory, history);
  }
  function renderSwapHistory() {
    const list = document.getElementById("historyList");
    const history = getSwapHistory();

    if (history.length === 0) {
      list.innerHTML = '<div style="color:var(--muted); text-align:center; padding:20px;">NO SWAPS RECORDED YET</div>';
      return;
    }

    let html = '';
    history.forEach(h => {
      const time = new Date(h.timestamp).toLocaleString();
      html += `<div class="history-item">
        <span class="history-time">${escapeHtml(time.split(',')[0])}</span>
        <span class="history-action"><b>${escapeHtml(h.name1)}</b> ↔ <b>${escapeHtml(h.name2)}</b> (${escapeHtml(h.date)} ${escapeHtml(h.block)})</span>
      </div>`;
    });
    list.innerHTML = html;
  }

  document.getElementById("btnSwapHistory").addEventListener("click", () => {
    document.getElementById("historyModal").classList.add("show");
    renderSwapHistory();
  });
  document.getElementById("btnCloseHistoryModal").addEventListener("click", () => {
    document.getElementById("historyModal").classList.remove("show");
  });
  document.getElementById("btnClearHistory").addEventListener("click", () => {
    const pw = prompt("Enter password to clear history:");
    if (pw !== "911911") { showToast("Incorrect password."); return; }
    saveJSON(STORAGE.swapHistory, []);
    renderSwapHistory();
    showToast("HISTORY CLEARED");
  });

  // Close modals on overlay click
  document.querySelectorAll('.modal-overlay').forEach(modal => {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.classList.remove('show');
    });
  });

  document.getElementById("dayPick").addEventListener("change", ()=>{
    const dk = document.getElementById("dayPick").value;
    renderDay(dk); renderWeek(dk);
  });

  // Day arrow navigation
  function shiftDay(offset) {
    const picker = document.getElementById("dayPick");
    const current = parseYMD(picker.value);
    if (!current) return;
    current.setDate(current.getDate() + offset);
    const newKey = ymd(current);
    picker.value = newKey;
    renderDay(newKey); renderWeek(newKey);
  }
  document.getElementById("btnDayPrev").addEventListener("click", () => shiftDay(-1));
  document.getElementById("btnDayNext").addEventListener("click", () => shiftDay(1));

  document.querySelectorAll(".tab").forEach(t=>{
    t.addEventListener("click", ()=>{
      const tab = t.getAttribute("data-tab");
      setActiveTab(tab);
      const dk = document.getElementById("dayPick").value;
      const m = Number(document.getElementById("monthSel").value);
      const y = Number(document.getElementById("yearSel").value);
      if (tab==="day") renderDay(dk);
      if (tab==="week") renderWeek(dk);
      if (tab==="month") renderMonth(y,m);
      if (tab==="mroster") renderMonthRostersIfActive();
    });
  });

  // Event delegation for per-block Copy buttons (dynamically created in renderDay)
  document.addEventListener("click", (e)=>{
    if (e.target && e.target.classList.contains("btn-copy-block")) {
      const dayKey = e.target.getAttribute("data-day");
      const blockKey = e.target.getAttribute("data-block");
      const plan = loadPlan();
      if (!plan || !plan.days[dayKey] || !plan.days[dayKey][blockKey]) {
        showToast("No data for this block.");
        return;
      }
      const entry = plan.days[dayKey][blockKey];
      const names = [];
      const chAbbr = {"North":"N","South":"S","East":"E","West":"W","Central":"C","Northwest":"NW","Relief 1":"R1","Relief 2":"R2","DC1":"DC1","DC2":"DC2"};
      // Collect only main channels: North, South, East, West, Central, Northwest, Relief 1, Relief 2, DC1, DC2
      const otNames = new Set((entry.ot || []).map(n => String(n).toUpperCase()));
      for (const ch of CHANNELS) {
        const nm = (entry.assignments||{})[ch];
        const otSuffix = (nm && otNames.has(nm.toUpperCase())) ? " (OT)" : "";
        names.push(nm ? nm.toUpperCase() + otSuffix : `${chAbbr[ch]||ch}: NEEDED`);
      }
      const text = names.join("\n");
      copyText(text);
    }
  });

  // Month Timeline search functionality
  function applyMonthSearch() {
    const searchVal = document.getElementById("monthSearch").value.trim().toUpperCase();
    const wrap = document.getElementById("monthWrap");
    const cells = wrap.querySelectorAll(".month-cell");

    if (!searchVal) {
      // Clear search - remove all highlights
      wrap.classList.remove("search-active");
      cells.forEach(cell => {
        cell.classList.remove("search-match", "search-dim");
      });
      return;
    }

    // Apply search
    wrap.classList.add("search-active");
    let matchCount = 0;
    cells.forEach(cell => {
      const emp = cell.getAttribute("data-emp") || "";
      if (emp.includes(searchVal)) {
        cell.classList.add("search-match");
        cell.classList.remove("search-dim");
        matchCount++;
      } else {
        cell.classList.remove("search-match");
        cell.classList.add("search-dim");
      }
    });

    if (matchCount === 0 && searchVal) {
      showToast(`No matches found for "${searchVal}"`);
    }
  }

  document.getElementById("monthSearch").addEventListener("input", applyMonthSearch);
  document.getElementById("monthSearch").addEventListener("keyup", (e) => {
    if (e.key === "Escape") {
      document.getElementById("monthSearch").value = "";
      applyMonthSearch();
    }
  });

  // Week Timeline search functionality
  function applyWeekSearch() {
    const searchVal = document.getElementById("weekSearch").value.trim().toUpperCase();
    const wrap = document.getElementById("weekWrap");
    const cells = wrap.querySelectorAll(".assign-cell");

    if (!searchVal) {
      cells.forEach(cell => { cell.style.opacity = "1"; });
      return;
    }

    let matchCount = 0;
    cells.forEach(cell => {
      const text = cell.textContent.toUpperCase();
      if (text.includes(searchVal)) {
        cell.style.opacity = "1";
        cell.style.outline = "2px solid #4aa3ff";
        matchCount++;
      } else {
        cell.style.opacity = "0.25";
        cell.style.outline = "none";
      }
    });

    if (matchCount === 0 && searchVal) {
      showToast(`NO MATCHES FOR "${searchVal}"`);
    }
  }

  document.getElementById("weekSearch").addEventListener("input", applyWeekSearch);
  document.getElementById("weekSearch").addEventListener("keyup", (e) => {
    if (e.key === "Escape") {
      document.getElementById("weekSearch").value = "";
      applyWeekSearch();
    }
  });

  // Roster – delegate to the global function
  // (renderMonthRostersIfActive is defined globally so setActiveTab can call it on page load)

  // Always load today's operational date (before 0500 = previous day)
  const today = operationalToday();
  document.getElementById("dayPick").value = today;

  // Try loading from Firebase first, then render
  (async function initializeWithFirebase() {
    const now = new Date();
    const year = now.getFullYear();
    const month = now.getMonth();

    setSyncStatus("LOADING...", "pending");

    // Load dispatcher employees from Firestore
    const empLoaded = await loadEmployeesFromFirestore();
    if (!empLoaded) {
      console.warn("Could not load employees from Firestore — BASE is empty");
    }

    // Try to load rotation plan from Firebase
    const firebaseLoaded = await loadRotationFromFirebase(year, month);

    if (firebaseLoaded) {
      setSyncStatus("SYNCED", "good");
    } else {
      setSyncStatus("LOCAL", null);
    }

    // Now render with whatever data we have
    const plan = loadPlan();
    if (plan && plan.meta) {
      document.getElementById("monthSel").value = String(plan.meta.monthIndex);
      document.getElementById("yearSel").value = String(plan.meta.year);

      // Log first assignment so we can verify data survived
      const firstDayKey = Object.keys(plan.days || {})[0];
      const firstBlock = firstDayKey ? plan.days[firstDayKey] : null;
      const firstBlockKey = firstBlock ? Object.keys(firstBlock)[0] : null;
      const firstAssign = firstBlockKey && firstBlock[firstBlockKey]?.assignments
        ? Object.values(firstBlock[firstBlockKey].assignments).slice(0,3).join(", ")
        : "none";
      console.log("INIT: First day assignments:", firstDayKey, "→", firstAssign);

      document.getElementById("dayPick").value = today;
      renderDay(today); renderWeek(today); renderMonth(plan.meta.year, plan.meta.monthIndex);
      renderMonthRostersIfActive();
      showSwapTip();
    } else {
      renderDay(today);
    }

    // NO realtime sync on page load — only the explicit load above is trusted
    // Realtime sync will start after user interaction (randomize, month change, etc.)
    initialLoadDone = true;
    console.log("INIT: Complete. No realtime sync on load.");
  })();
}


// Global error handler (shows on screen so you can screenshot it)
window.addEventListener('error', (ev)=>{
  try{
    const msg = (ev && ev.error && ev.error.message) ? ev.error.message : (ev && ev.message) ? ev.message : 'Unknown error';
    console.error(ev.error || ev);
    const el = document.getElementById('debugBanner');
    if (el) { el.style.display='block'; el.textContent = 'ERROR: ' + msg; }
    if (typeof showToast === 'function') showToast('Error: ' + msg);
  }catch(_){}
});
document.addEventListener("DOMContentLoaded", ()=>{
  try { boot(); }
  catch(e) {
    console.error(e);
    showToast("Fatal error: <code>" + escapeHtml(e && e.stack ? e.stack : String(e)) + "</code>");
    alert(String(e && e.stack ? e.stack : e));
  }
});

</script>

<div style="text-align:center; padding:20px 10px; margin-top:20px; border-top:1px solid var(--line); color:var(--muted); font-size:11px; letter-spacing:.5px;">
  Built and Maintained by T. Martinez &middot; Version 1.0
</div>

</body>
</html>
